# app.R
# Shiny pitching report with per-player privacy + admin view + customized Stuff+ metric per pitch type

library(shiny)
library(shinyjs)
library(dplyr)
library(DT)
library(gridExtra)
library(ggplot2)
library(patchwork)
library(rsconnect)
library(hexbin)
library(ggiraph)
library(httr2)
library(MASS)  # for kde2d in heatmaps
library(digest)
library(colourpicker)  # for color picker in Custom Reports formatting
library(memoise)  # for caching expensive computations in Custom Reports
library(shinymanager)  # for custom authentication with cool login page
# --- media uploads (Cloudinary) ---
# raise upload size if needed (50 MB here)
options(shiny.maxRequestSize = 50 * 1024^2)

# Set default plotting background to transparent
options(shiny.plot.res = 96)
# Force transparent backgrounds for all plot devices
if (capabilities("cairo")) {
  options(bitmapType = "cairo")
}

# Wrapper to force transparent girafe backgrounds everywhere
girafe_transparent <- function(..., bg = "transparent") {
  args <- list(...)
  if (!"bg" %in% names(args)) args$bg <- bg
  do.call(ggiraph::girafe, args)
}

# Optional team scoping: blank = no filter
if (!exists("TEAM_CODE", inherits = TRUE)) TEAM_CODE <- ""

# School scoping helpers
GLOBAL_SCOPE <- "GLOBAL"
current_school <- function() {
  sc <- Sys.getenv("TEAM_CODE", unset = TEAM_CODE)
  if (is.null(sc) || !nzchar(sc)) sc <- TEAM_CODE
  if (is.null(sc) || !nzchar(sc)) sc <- "OSU"
  toupper(sc)
}
allowed_school_codes <- function() unique(c(current_school(), GLOBAL_SCOPE))

# Load per-school configuration overrides (keeps app.R shared).
config_path <- file.path("config", "school_config.R")
if (file.exists(config_path)) {
  source(config_path)
}
if (!exists("school_config")) school_config <- list()

school_setting <- function(name, default = NULL) {
  if (!is.null(school_config[[name]])) return(school_config[[name]])
  default
}

# School-scoped overrides
TEAM_CODE <- school_setting("team_code", TEAM_CODE)
if (!nzchar(TEAM_CODE)) TEAM_CODE <- "OSU"
TEAM_CHOICES <- c("All" = "All",
                  TEAM_CODE = TEAM_CODE,
                  "Opponents" = "Opponents",
                  "Campers" = "Campers")

default_colors <- list(
  primary = "#0a2240",
  accent = "#e35205",
  accent_secondary = "#ff8c1a",
  background = "#f5f7fa",
  background_secondary = "#e8ecf1"
)
user_colors <- school_setting("colors", list())
school_colors <- modifyList(default_colors, user_colors)
accent_color <- school_colors$accent
accent_secondary_color <- school_colors$accent_secondary
if (is.null(accent_secondary_color) || !nzchar(accent_secondary_color)) {
  accent_secondary_color <- accent_color
}
background_color <- school_colors$background
if (is.null(background_color) || !nzchar(background_color)) {
  background_color <- "#f5f7fa"
}
background_secondary_color <- school_colors$background_secondary
if (is.null(background_secondary_color) || !nzchar(background_secondary_color)) {
  background_secondary_color <- background_color
}

school_logo <- school_setting("logo", "PCUlogo.png")
school_extra <- school_setting("extra", list())
school_display_name <- school_extra$school_name
if (is.null(school_display_name) || !nzchar(school_display_name)) {
  school_display_name <- TEAM_CODE
}

coach_emails <- school_setting("coaches_emails", c("coach@example.com"))
default_notes_api <- list(base_url = "", token = "")
notes_api <- modifyList(default_notes_api, school_setting("notes_api", list()))
NOTES_API_URL <- notes_api$base_url
NOTES_API_TOKEN <- notes_api$token

# ---- Heatmap constants and functions for Player Plans ----
HEAT_BINS <- 10  # Increased from 6 for smoother gradients like TruMedia
HEAT_EV_THRESHOLD <- 90

# Zone boundaries
ZONE_LEFT <- -0.83
ZONE_RIGHT <- 0.83
ZONE_BOTTOM <- 1.5
ZONE_TOP <- 3.5

# Frequency (keep multi-color)
heat_pal_freq <- function(n = HEAT_BINS) colorRampPalette(
  c("white","pink","red")
)(n)

# All other heat maps → white→red only
heat_pal_red  <- function(n = HEAT_BINS) colorRampPalette(c("white","pink","red"))(n)

# Blue → Yellow → Red palette for rate-based stats (cold to hot)
# White at start ensures no-data areas show white background
heat_pal_bwr <- function(n = HEAT_BINS) {
  colorRampPalette(c("white", "#4575b4", "#91bfdb", "#abd9e9", "#fee090", "#fc8d59", "#d73027"))(n)
}

# Blue → Yellow → Red WITHOUT white (for rate stats like Whiff, GB, Contact, Swing)
heat_pal_bwr_no_white <- function(n = HEAT_BINS) {
  colorRampPalette(c("#4575b4", "#91bfdb", "#abd9e9", "#fee090", "#fc8d59", "#d73027"))(n)
}

# Blue → Red with minimal yellow (for RV heatmap where we need better contrast near 0)
# Order: Red (negative/good for pitcher) to Blue (positive/good for hitter)
heat_pal_br_rv <- function(n = HEAT_BINS) {
  colorRampPalette(c("#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"))(n)
}

# Reversed (for stats where lower is better)
heat_pal_rwb <- function(n = HEAT_BINS) {
  colorRampPalette(c("#d73027", "#fc8d59", "#fee090", "#abd9e9", "#91bfdb", "#4575b4", "white"))(n)
}

# Reversed without white (red to blue, for RV where we want red=good/high, blue=bad/low)
heat_pal_rbw_no_white <- function(n = HEAT_BINS) {
  colorRampPalette(c("#d73027", "#fc8d59", "#fee090", "#abd9e9", "#91bfdb", "#4575b4"))(n)
}

# Keep only terminal plate-appearance pitches for wOBA (final pitch of the PA)
terminal_for_woba <- function(df) {
  korbb <- if ("KorBB" %in% names(df)) df$KorBB else NA_character_
  play  <- if ("PlayResult" %in% names(df)) df$PlayResult else NA_character_
  pc    <- if ("PitchCall" %in% names(df)) df$PitchCall else NA_character_
  
  allowed_pr <- c(
    "Single","Double","Triple","HomeRun","Error",
    "Walk","IntentionalWalk","HitByPitch",
    "Strikeout","StrikeoutSwinging","StrikeoutLooking","Sacrifice"
  )
  
  (!is.na(play)  & play  %in% allowed_pr) |
    (!is.na(korbb) & korbb %in% c("Strikeout","Walk")) |
    (!is.na(pc)   & pc    == "HitByPitch")
}

# Draw heatmap function with optional color scale legend
draw_heat <- function(grid, bins = HEAT_BINS, pal_fun = heat_pal_red,
                      title = NULL, mark_max = TRUE, breaks = NULL,
                      show_scale = FALSE, scale_label = NULL, scale_limits = NULL,
                      scale_breaks = NULL, scale_labels = NULL) {
  if (!nrow(grid)) return(ggplot() + theme_void())
  dark_on <- FALSE
  try({
    dom <- shiny::getDefaultReactiveDomain()
    if (!is.null(dom) && !is.null(dom$input$dark_mode)) dark_on <- isTRUE(dom$input$dark_mode)
  }, silent = TRUE)
  line_col <- if (dark_on) "#ffffff" else "black"
  bg_transparent <- element_rect(fill = "transparent", color = NA)
  
  home <- data.frame(
    x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
    y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
  )
  sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
  
  peak_df <- NULL
  if (mark_max) {
    i <- which.max(grid$z)
    if (length(i) && is.finite(grid$z[i])) {
      peak_df <- data.frame(px = grid$x[i], py = grid$y[i])
    }
  }
  
  n_bins <- if (is.null(breaks)) bins else max(1, length(breaks) - 1)
  
  # Main heatmap plot
  p_heat <- ggplot(grid, aes(x, y, z = z)) +
    {
      if (is.null(breaks))
        geom_contour_filled(aes(fill = after_stat(level)), bins = bins, show.legend = FALSE)
      else
        geom_contour_filled(aes(fill = after_stat(level)), breaks = breaks, show.legend = FALSE)
    } +
    scale_fill_manual(values = pal_fun(n_bins), guide = "none") +
    geom_polygon(data = home, aes(x, y), fill = NA, color = line_col, inherit.aes = FALSE) +
    geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
              fill = NA, color = line_col, inherit.aes = FALSE) +
    { if (!is.null(peak_df))
      geom_point(data = peak_df, aes(x = px, y = py), inherit.aes = FALSE,
                 size = 3.8, shape = 21, fill = "red", color = "black", stroke = 0.5)
    } +
    coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
    theme_void() + 
    theme(legend.position = "none",
          plot.title = element_text(face = "bold", hjust = 0.5),
          plot.background = bg_transparent,
          panel.background = bg_transparent) +
    labs(title = title)
  
  # If show_scale, add gradient bar on top
  if (show_scale && !is.null(scale_limits)) {
    # Create scale bar data matching strike zone width
    sz_width <- ZONE_RIGHT - ZONE_LEFT  # ~1.66 feet
    scale_data <- data.frame(
      x = seq(scale_limits[1], scale_limits[2], length.out = 200),
      y = 1,
      z = seq(scale_limits[1], scale_limits[2], length.out = 200)
    )
    
    scale_breaks_final <- if (!is.null(scale_breaks)) {
      scale_breaks
    } else if (!is.null(scale_limits) && length(scale_limits) >= 2) {
      c(scale_limits[1], mean(scale_limits), scale_limits[length(scale_limits)])
    } else if (is.null(breaks)) {
      pretty(scale_limits, n = 5)
    } else {
      fin <- breaks[is.finite(breaks)]
      fin[c(1, round(length(fin) / 2), length(fin))]
    }
    
    scale_labels_final <- scale_labels
    if (identical(scale_label, "Pitch Frequency") && length(scale_limits) >= 2) {
      scale_breaks_final <- scale_limits[c(1, length(scale_limits))]
      scale_labels_final <- c("Least", "Most")
    }
    
    p_scale <- ggplot(scale_data, aes(x = z, y = y, fill = z)) +
      geom_tile(width = (scale_limits[2] - scale_limits[1]) / 200, height = 1) +
      scale_fill_gradientn(colors = pal_fun(100), limits = scale_limits) +
      scale_x_continuous(
        breaks = scale_breaks_final,
        labels = if (is.null(scale_labels_final)) ggplot2::waiver() else scale_labels_final,
        limits = scale_limits,
        expand = c(0, 0)
      ) +
      coord_cartesian(xlim = scale_limits, ylim = c(0.5, 1.5)) +
      theme_void() +
      theme(
        legend.position = "none",
        axis.text.x = element_text(size = 10, face = "bold", margin = margin(t = 3)),
        axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 8)),
        plot.margin = margin(5, 0, 10, 0),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.background = element_rect(fill = "transparent", color = NA),
        aspect.ratio = 0.15  # Make scale bar much narrower
      ) +
      labs(x = scale_label)
    
    # Combine scale bar on top of heatmap with tighter layout
    return(p_scale / p_heat + plot_layout(heights = c(0.08, 1), widths = c(sz_width)))
  }
  
  p_heat
}

# Draw BINNED heatmap using geom_tile (for sparse rate data like whiff rate)
# This shows actual bins where data exists instead of interpolating
draw_heat_binned <- function(grid, bin_size = 0.4, pal_fun = heat_pal_red,
                             title = NULL, breaks = NULL,
                             show_scale = FALSE, scale_label = NULL, scale_limits = NULL) {
  if (!nrow(grid)) return(ggplot() + theme_void())
  
  home <- data.frame(
    x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
    y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
  )
  sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
  
  # Use geom_tile to show actual bins
  p_heat <- ggplot(grid, aes(x = x, y = y, fill = z)) +
    geom_tile(width = bin_size, height = bin_size, color = NA) +
    scale_fill_gradientn(colors = pal_fun(100), limits = scale_limits, na.value = "white") +
    geom_polygon(data = home, aes(x, y), fill = NA, color = "black", inherit.aes = FALSE) +
    geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
              fill = NA, color = "black", inherit.aes = FALSE) +
    coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
    theme_void() + 
    theme(legend.position = "none",
          plot.title = element_text(face = "bold", hjust = 0.5),
          plot.background = element_rect(fill = "transparent", color = NA),
          panel.background = element_rect(fill = "transparent", color = NA)) +
    labs(title = title)
  
  # If show_scale, add gradient bar on top
  if (show_scale && !is.null(scale_limits)) {
    sz_width <- ZONE_RIGHT - ZONE_LEFT
    scale_data <- data.frame(
      x = seq(scale_limits[1], scale_limits[2], length.out = 200),
      y = 1,
      z = seq(scale_limits[1], scale_limits[2], length.out = 200)
    )
    
    p_scale <- ggplot(scale_data, aes(x = z, y = y, fill = z)) +
      geom_tile(width = (scale_limits[2] - scale_limits[1]) / 200, height = 1) +
      scale_fill_gradientn(colors = pal_fun(100), limits = scale_limits) +
      scale_x_continuous(
        breaks = {
          if (!is.null(scale_limits) && length(scale_limits) >= 2) {
            c(scale_limits[1], mean(scale_limits), scale_limits[length(scale_limits)])
          } else if (is.null(breaks)) {
            pretty(scale_limits, n = 5)
          } else {
            fin <- breaks[is.finite(breaks)]
            fin[c(1, round(length(fin) / 2), length(fin))]
          }
        },
        limits = scale_limits,
        expand = c(0, 0)
      ) +
      coord_cartesian(xlim = scale_limits, ylim = c(0.5, 1.5)) +
      theme_void() +
      theme(
        legend.position = "none",
        axis.text.x = element_text(size = 10, face = "bold", margin = margin(t = 3)),
        axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 8)),
        plot.margin = margin(5, 0, 10, 0),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.background = element_rect(fill = "transparent", color = NA),
        aspect.ratio = 0.15
      ) +
      labs(x = scale_label)
    
    return(p_scale / p_heat + plot_layout(heights = c(0.08, 1), widths = c(sz_width)))
  }
  
  p_heat
}

# Global helper functions for heatmap generation (used across all suites)

# Helper for 2D KDE grid
make_kde_grid <- function(x, y, lims = c(-2.5,2.5,0,4.5), n = 200, h = NULL) {
  ok <- is.finite(x) & is.finite(y)
  x <- x[ok]; y <- y[ok]
  if (length(x) < 2 || length(unique(x)) < 2 || length(unique(y)) < 2) {
    return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
  }
  
  # Use adaptive bandwidth based on sample size and spread
  if (is.null(h)) {
    n_pts <- length(x)
    x_sd <- sd(x)
    y_sd <- sd(y)
    h_x <- x_sd * (n_pts^(-1/6)) * 1.2
    h_y <- y_sd * (n_pts^(-1/6)) * 1.2
    h <- c(h_x, h_y)
  }
  
  d <- MASS::kde2d(x, y, n = n, lims = lims, h = h)
  expand.grid(x = d$x, y = d$y) |> transform(z = as.vector(d$z))
}

# Helper for RV heatmap - uses same KDE as Frequency but overlays run values
# This ensures every pitch is plotted just like Frequency, with colors based on RV
make_kde_rv_grid <- function(x, y, rv_values,
                             lims = c(-2.5, 2.5, 0, 4.5),
                             n = 200, h = NULL) {
  ok <- is.finite(x) & is.finite(y) & is.finite(rv_values)
  x <- x[ok]; y <- y[ok]; rv_values <- rv_values[ok]
  
  # Handle no data case
  if (length(x) == 0) {
    return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
  }
  
  # Handle single pitch case - show a small blob
  if (length(x) == 1) {
    grid <- expand.grid(
      x = seq(lims[1], lims[2], length.out = n),
      y = seq(lims[3], lims[4], length.out = n)
    )
    # Calculate distance from the single point
    dx <- grid$x - x[1]
    dy <- grid$y - y[1]
    dist <- sqrt(dx^2 + dy^2)
    # Create a small blob around the single pitch
    grid$z <- ifelse(dist < 0.3, rv_values[1], 0)
    return(grid[grid$z != 0, c("x", "y", "z")])
  }
  
  # Check for variance - if all x or y are nearly identical, use minimum bandwidth
  x_sd <- sd(x)
  y_sd <- sd(y)
  
  if (x_sd < 0.01) x_sd <- 0.1  # Minimum bandwidth for x
  if (y_sd < 0.01) y_sd <- 0.1  # Minimum bandwidth for y
  
  # Match frequency bandwidth behavior
  if (is.null(h)) {
    n_pts <- length(x)
    h_x <- x_sd * (n_pts^(-1/6)) * 0.6
    h_y <- y_sd * (n_pts^(-1/6)) * 0.6
    h <- c(h_x, h_y)
  }
  
  # Use MASS::kde2d for the density surface (same as Frequency)
  d <- MASS::kde2d(x, y, n = n, lims = lims, h = h)
  grid <- expand.grid(x = d$x, y = d$y)
  grid$density <- as.vector(d$z)
  
  # For each grid point, calculate weighted average RV based on nearby pitches
  # This preserves the frequency-like coverage while showing RV values
  grid$z <- vapply(seq_len(nrow(grid)), function(i) {
    dx <- (x - grid$x[i]) / h[1]
    dy <- (y - grid$y[i]) / h[2]
    dist_sq <- dx^2 + dy^2
    weights <- exp(-0.5 * dist_sq)
    w_sum <- sum(weights)
    if (!is.finite(w_sum) || w_sum < 1e-8) {
      return(0)
    }
    weighted.mean(rv_values, weights, na.rm = TRUE)
  }, numeric(1))
  
  # Only keep grid points where there's actual density (like Frequency does)
  # This ensures the shape matches Frequency exactly
  max_density <- max(grid$density, na.rm = TRUE)
  if (max_density > 0) {
    # Keep points with at least 0.1% of max density
    grid <- grid[grid$density > (max_density * 0.001), ]
  }
  
  # Clean up and return just x, y, z
  grid <- grid[, c("x", "y", "z")]
  grid$z[!is.finite(grid$z)] <- 0
  
  grid
}

# KDE weighted-mean grid (matches Frequency KDE style)
make_kde_mean_grid <- function(x, y, values,
                               lims = c(-2.5, 2.5, 0, 4.5),
                               n = 200, h = NULL) {
  ok <- is.finite(x) & is.finite(y) & is.finite(values)
  x <- x[ok]; y <- y[ok]; values <- values[ok]
  if (length(x) < 2 || length(unique(x)) < 2 || length(unique(y)) < 2) {
    return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
  }
  
  # Adaptive bandwidth (same approach as make_kde_grid)
  if (is.null(h)) {
    n_pts <- length(x)
    x_sd <- sd(x); y_sd <- sd(y)
    h_x <- x_sd * (n_pts^(-1/6)) * 1.2
    h_y <- y_sd * (n_pts^(-1/6)) * 1.2
    h <- c(h_x, h_y)
  }
  
  d <- MASS::kde2d(x, y, n = n, lims = lims, h = h)
  grid <- expand.grid(x = d$x, y = d$y)
  grid$density <- as.vector(d$z)
  
  # Weighted mean at each grid point
  grid$z <- vapply(seq_len(nrow(grid)), function(i) {
    dx <- (x - grid$x[i]) / h[1]
    dy <- (y - grid$y[i]) / h[2]
    w  <- exp(-0.5 * (dx^2 + dy^2))
    ws <- sum(w)
    if (!is.finite(ws) || ws < 1e-8) return(NA_real_)
    sum(w * values, na.rm = TRUE) / ws
  }, numeric(1))
  
  # Density mask (same threshold as RV grid)
  max_den <- max(grid$density, na.rm = TRUE)
  if (max_den > 0) {
    grid <- grid[grid$density > (max_den * 0.001), ]
  }
  
  grid <- grid[, c("x", "y", "z")]
  grid$z[!is.finite(grid$z)] <- 0
  grid
}

# Shared heatmap stat renderer (Pitching-style) used across suites
render_heatmap_stat <- function(df, stat) {
  if (!nrow(df)) return(ggplot() + theme_void())
  if (identical(stat, "Exit Velocity")) stat <- "EV"
  
  if (stat == "Frequency") {
    grid <- make_kde_grid(df$PlateLocSide, df$PlateLocHeight, n = 200)
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
    return(draw_heat(
      grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
      show_scale = TRUE, scale_label = "Pitch Frequency",
      scale_limits = c(0, 80)
    ))
  }
  
  df <- df %>% dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
  if (!nrow(df)) return(ggplot() + theme_void())
  
  if (stat == "Whiff Rate") {
    swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                      "FoulBallNotFieldable", "InPlay")
    swing_mask  <- df$PitchCall %in% swing_events
    val <- ifelse(swing_mask, ifelse(df$PitchCall == "StrikeSwinging", 1, 0), NA_real_)
    grid <- make_kde_mean_grid(df$PlateLocSide, df$PlateLocHeight, val)
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- pmax(grid$z * 100, 0)
    breaks <- c(seq(0, 50, length.out = HEAT_BINS + 1), Inf)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "Whiff Rate %",
                     scale_limits = c(0, 50)))
  }
  
  if (stat == "GB Rate") {
    df_bip <- df %>%
      dplyr::filter(SessionType == "Live",
                    PitchCall == "InPlay",
                    !is.na(TaggedHitType))
    if (nrow(df_bip) < 3) return(ggplot() + theme_void() + 
                                   labs(title = "Insufficient Live BIP data"))
    val <- ifelse(df_bip$TaggedHitType == "GroundBall", 1, 0)
    grid <- make_kde_mean_grid(df_bip$PlateLocSide, df_bip$PlateLocHeight, val)
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- pmax(grid$z * 100, 0)
    breaks <- c(-Inf, seq(0, 70, length.out = HEAT_BINS + 1), Inf)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "GB Rate %",
                     scale_limits = c(0, 70)))
  }
  
  if (stat == "Contact Rate") {
    swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                      "FoulBallNotFieldable", "InPlay")
    swing_mask  <- df$PitchCall %in% swing_events
    val <- ifelse(swing_mask, ifelse(df$PitchCall == "StrikeSwinging", 0, 1), NA_real_)
    grid <- make_kde_mean_grid(df$PlateLocSide, df$PlateLocHeight, val)
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- pmin(pmax(grid$z * 100, 50), 100)
    breaks <- seq(50, 100, length.out = HEAT_BINS + 1)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "Contact Rate %",
                     scale_limits = c(50, 100)))
  }
  
  if (stat == "Swing Rate") {
    swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                      "FoulBallNotFieldable", "InPlay")
    val <- ifelse(df$PitchCall %in% swing_events, 1, 0)
    grid <- make_kde_mean_grid(df$PlateLocSide, df$PlateLocHeight, val)
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- pmax(grid$z * 100, 0)
    breaks <- c(-Inf, seq(20, 80, length.out = HEAT_BINS + 1), Inf)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "Swing Rate %",
                     scale_limits = c(20, 80)))
  }
  
  if (stat == "EV") {
    df_bip <- df %>%
      dplyr::filter(
        SessionType == "Live",
        PitchCall == "InPlay",
        is.finite(ExitSpeed)
      )
    if (!nrow(df_bip)) return(ggplot() + theme_void())
    grid <- make_kde_mean_grid(df_bip$PlateLocSide, df_bip$PlateLocHeight, df_bip$ExitSpeed)
    if (!nrow(grid)) return(ggplot() + theme_void())
    breaks <- seq(60, 110, length.out = HEAT_BINS + 1)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "Exit Velocity (mph)",
                     scale_limits = c(60, 110)))
  }
  
  if (stat == "Run Values") {
    calculate_run_value <- function(pitch_call, play_result, korbb = NA) {
      pitch_call <- as.character(pitch_call)
      play_result <- as.character(play_result)
      korbb <- as.character(korbb)
      
      if (!is.na(korbb) && nzchar(korbb) && korbb != "NA") {
        if (korbb == "Strikeout") return(-0.27)
        if (korbb == "Walk")     return(0.33)
      }
      if (pitch_call %in% c("BallCalled", "BallIntentional", "BallinDirt")) return(0.03)
      if (pitch_call %in% c("StrikeCalled", "StrikeSwinging", "FoulBall",
                            "FoulBallFieldable", "FoulBallNotFieldable"))  return(-0.03)
      if (pitch_call == "HitByPitch" || play_result %in% c("Walk","IntentionalWalk","HitByPitch")) return(0.33)
      if (pitch_call == "InPlay") {
        if (play_result == "Single")   return(0.47)
        if (play_result == "Double")   return(0.78)
        if (play_result == "Triple")   return(1.09)
        if (play_result == "HomeRun")  return(1.40)
        if (play_result == "Error")    return(0.33)
        return(-0.27)
      }
      0
    }
    
    df_rv <- df %>%
      dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight)) %>%
      dplyr::mutate(RunValue = mapply(calculate_run_value, PitchCall, PlayResult, 
                                      if("KorBB" %in% names(.)) KorBB else NA))
    if (!nrow(df_rv)) return(ggplot() + theme_void())
    
    grid <- make_kde_rv_grid(
      x = df_rv$PlateLocSide,
      y = df_rv$PlateLocHeight,
      rv_values = df_rv$RunValue,
      lims = c(-2.5, 2.5, 0, 4.5),
      n = 200
    )
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- pmin(pmax(grid$z, -0.2), 0.2)
    grid$z[!is.finite(grid$z)] <- 0
    rng <- range(grid$z, na.rm = TRUE)
    if (is.finite(rng[1]) && diff(rng) == 0) grid$z <- grid$z + 1e-6
    breaks <- c(-0.2, -0.15, -0.10, -0.05, 0, 0.05, 0.10, 0.15, 0.20)
    return(draw_heat(grid, bins = length(breaks) - 1, pal_fun = heat_pal_br_rv, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "RV",
                     scale_limits = c(-0.2, 0.2)))
  }
  
  ggplot() + theme_void()
}

# Helper to create binned rate heatmap data
make_rate_grid <- function(df, numerator_condition, denominator_condition = NULL, 
                           bin_size = 0.4, x_range = c(-2.5, 2.5), y_range = c(0, 4.5),
                           min_sample = 1) {
  # If no denominator condition provided, use all data
  if (is.null(denominator_condition)) {
    df_denom <- df
  } else {
    df_denom <- df[denominator_condition, ]
  }
  df_numer <- df[numerator_condition, ]
  
  # Create bins
  x_breaks <- seq(x_range[1], x_range[2], by = bin_size)
  y_breaks <- seq(y_range[1], y_range[2], by = bin_size)
  
  # Bin the denominator data
  df_denom$x_bin <- cut(df_denom$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
  df_denom$y_bin <- cut(df_denom$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
  
  # Count denominator
  denom_counts <- df_denom %>%
    filter(!is.na(x_bin) & !is.na(y_bin)) %>%
    group_by(x_bin, y_bin) %>%
    summarise(denom = n(), .groups = 'drop')
  
  # Bin the numerator data
  df_numer$x_bin <- cut(df_numer$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
  df_numer$y_bin <- cut(df_numer$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
  
  # Count numerator
  numer_counts <- df_numer %>%
    filter(!is.na(x_bin) & !is.na(y_bin)) %>%
    group_by(x_bin, y_bin) %>%
    summarise(numer = n(), .groups = 'drop')
  
  # Merge and calculate rate
  rate_data <- denom_counts %>%
    left_join(numer_counts, by = c("x_bin", "y_bin")) %>%
    mutate(
      numer = ifelse(is.na(numer), 0, numer),
      rate = (numer / denom) * 100
    ) %>%
    filter(denom >= min_sample)
  
  # Get bin centers for plotting
  rate_data <- rate_data %>%
    mutate(
      x = (as.numeric(sub("\\((.+),.*", "\\1", x_bin)) + 
             as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", x_bin))) / 2,
      y = (as.numeric(sub("\\((.+),.*", "\\1", y_bin)) + 
             as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", y_bin))) / 2
    ) %>%
    dplyr::select(x, y, z = rate)
  
  return(rate_data)
}

# Helper to smooth binned data using interpolation
smooth_grid <- function(grid_data, n = 120, x_range = c(-2.5, 2.5), y_range = c(0, 4.5)) {
  if (nrow(grid_data) < 4) return(grid_data)  # Need minimum points to interpolate
  
  # Remove any rows with NA or Inf values
  grid_data <- grid_data %>%
    filter(is.finite(x) & is.finite(y) & is.finite(z))
  
  if (nrow(grid_data) < 4) return(grid_data)
  
  # Use akima for smooth interpolation
  if (!requireNamespace("akima", quietly = TRUE)) {
    return(grid_data)  # Fall back to binned data if akima not available
  }
  
  # Wrap in tryCatch to handle any interpolation errors
  smooth_data <- tryCatch({
    # Allow limited extrapolation so sparse areas don't leave holes
    interp_result <- akima::interp(
      x = grid_data$x,
      y = grid_data$y,
      z = grid_data$z,
      xo = seq(x_range[1], x_range[2], length.out = n),
      yo = seq(y_range[1], y_range[2], length.out = n),
      linear = FALSE,  # Use non-linear for smoother appearance
      extrap = TRUE,  # Allow light extrapolation to avoid white holes
      duplicate = "mean"
    )
    
    result <- expand.grid(x = interp_result$x, y = interp_result$y) %>%
      mutate(z = as.vector(interp_result$z)) %>%
      filter(is.finite(z))
    
    # If we lost too much data (lots of gaps), add back original bins to fill
    if (nrow(result) < nrow(grid_data) * 2) {
      # Merge smoothed data with original bins to fill gaps
      result <- bind_rows(result, grid_data) %>%
        distinct(x, y, .keep_all = TRUE)
    }
    
    result
  }, error = function(e) {
    # If interpolation fails, return original binned data
    grid_data
  })
  
  return(smooth_data)
}

# Helper to create binned average heatmap data (for EV)
make_avg_grid <- function(df, value_col, bin_size = 0.4, 
                          x_range = c(-2.5, 2.5), y_range = c(0, 4.5), min_sample = 1) {
  # Filter to valid values
  df <- df[is.finite(df[[value_col]]), ]
  
  # Create bins
  x_breaks <- seq(x_range[1], x_range[2], by = bin_size)
  y_breaks <- seq(y_range[1], y_range[2], by = bin_size)
  
  df$x_bin <- cut(df$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
  df$y_bin <- cut(df$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
  
  # Calculate average per bin
  avg_data <- df %>%
    filter(!is.na(x_bin) & !is.na(y_bin)) %>%
    group_by(x_bin, y_bin) %>%
    summarise(
      count = n(),
      avg_value = mean(.data[[value_col]], na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    filter(count >= min_sample)
  
  # Get bin centers
  avg_data <- avg_data %>%
    mutate(
      x = (as.numeric(sub("\\((.+),.*", "\\1", x_bin)) + 
             as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", x_bin))) / 2,
      y = (as.numeric(sub("\\((.+),.*", "\\1", y_bin)) + 
             as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", y_bin))) / 2
    ) %>%
    dplyr::select(x, y, z = avg_value)
  
  return(avg_data)
}


library(curl)  # for curl::form_file
library(DBI)   # for database operations
library(RSQLite)  # for SQLite database

# Configure Cloudinary (recommended simple host for images/videos)
# Create a free account, make an *unsigned upload preset*, then set these:
# 1) Prefer environment variables in production (shinpps.io Settings → Environment Variables)
# 2) Fall back to your local defaults for dev
CLOUDINARY_CLOUD_NAME    <- Sys.getenv("CLOUDINARY_CLOUD_NAME", unset = "")
CLOUDINARY_UPLOAD_PRESET <- Sys.getenv("CLOUDINARY_UPLOAD_PRESET", unset = "")
if (!nzchar(CLOUDINARY_CLOUD_NAME))    CLOUDINARY_CLOUD_NAME    <- "pitchingcoachu"
if (!nzchar(CLOUDINARY_UPLOAD_PRESET)) CLOUDINARY_UPLOAD_PRESET <- "pcu_notes_unsigned"

# helper: coalesce for NULL
`%||%` <- function(a,b) if (is.null(a)) b else a

get_modifications_db_path <- function() {
  override <- Sys.getenv("PITCH_MOD_DB_PATH", unset = "")
  if (nzchar(override)) {
    path <- path.expand(override)
    dir.create(dirname(path), recursive = TRUE, showWarnings = FALSE)
    return(path)
  }
  
  # Check if we have write access to current directory
  if (file.access(".", 2) == 0) {
    return("pitch_modifications.db")
  }
  
  # Read-only environment (like shinyapps.io) - use /tmp which is writable
  tmp_path <- file.path("/tmp", "pitch_modifications.db")
  message("Using temporary database path: ", tmp_path)
  return(tmp_path)
}

get_modifications_export_path <- function() {
  override <- Sys.getenv("PITCH_MOD_EXPORT_PATH", unset = "")
  if (nzchar(override)) {
    path <- path.expand(override)
    dir.create(dirname(path), recursive = TRUE, showWarnings = FALSE)
    if (!file.exists(path)) {
      bundle_seed <- file.path("data", "pitch_type_modifications_export.csv")
      if (file.exists(bundle_seed)) {
        try(file.copy(bundle_seed, path, overwrite = FALSE), silent = TRUE)
      }
    }
    return(path)
  }
  file.path("data", "pitch_type_modifications_export.csv")
}

# ---- App state (custom tables/reports/targets) persistence helpers ----
state_backend <- function() {
  host <- Sys.getenv("MYSQL_HOST", "")
  db   <- Sys.getenv("MYSQL_DB", "")
  user <- Sys.getenv("MYSQL_USER", "")
  pass <- Sys.getenv("MYSQL_PASSWORD", "")
  port <- as.integer(Sys.getenv("MYSQL_PORT", "3306"))
  ssl_ca <- Sys.getenv("MYSQL_SSL_CA", "")
  has_mysql <- nzchar(host) && nzchar(db) && nzchar(user) && nzchar(pass)
  
  if (has_mysql) {
    return(list(
      type = "mysql",
      connect = function() {
        RMariaDB::dbConnect(
          RMariaDB::MariaDB(),
          host = host,
          user = user,
          password = pass,
          dbname = db,
          port = port,
          ssl.ca = if (nzchar(ssl_ca)) ssl_ca else NULL
        )
      }
    ))
  }
  
  # Fallback to local SQLite (persists locally but not across shinyapps redeploys)
  get_state_db_path <- function() {
    override <- Sys.getenv("APP_STATE_DB_PATH", unset = "")
    if (nzchar(override)) {
      path <- path.expand(override)
      dir.create(dirname(path), recursive = TRUE, showWarnings = FALSE)
      return(path)
    }
    user_dir <- tryCatch(tools::R_user_dir("pcu_pitch_dashboard", which = "data"), error = function(...) "")
    if (nzchar(user_dir)) {
      dir.create(user_dir, recursive = TRUE, showWarnings = FALSE)
      return(file.path(user_dir, "app_state.sqlite"))
    }
    "app_state.sqlite"
  }
  state_db_path <- get_state_db_path()
  list(
    type = "sqlite",
    connect = function() DBI::dbConnect(RSQLite::SQLite(), state_db_path)
  )
}

state_backend_cfg <- state_backend()

state_db_connect <- function() {
  state_backend_cfg$connect()
}

init_state_db <- function() {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  name_type <- if (identical(state_backend_cfg$type, "mysql")) "VARCHAR(191)" else "TEXT"
  text_type <- if (identical(state_backend_cfg$type, "mysql")) "LONGTEXT" else "TEXT"
  ensure_school_column <- function(tbl) {
    cols <- try(DBI::dbListFields(con, tbl), silent = TRUE)
    if (!inherits(cols, "try-error") && length(cols) && !"school_code" %in% cols) {
      try(DBI::dbExecute(con, sprintf("ALTER TABLE %s ADD COLUMN school_code %s", tbl, name_type)), silent = TRUE)
    }
  }
  DBI::dbExecute(con, sprintf(
    "CREATE TABLE IF NOT EXISTS custom_tables (name %s PRIMARY KEY, cols %s, school_code %s)",
    name_type, text_type, name_type
  ))
  DBI::dbExecute(con, sprintf(
    "CREATE TABLE IF NOT EXISTS custom_reports (name %s PRIMARY KEY, payload %s, school_code %s)",
    name_type, text_type, name_type
  ))
  DBI::dbExecute(con, sprintf(
    "CREATE TABLE IF NOT EXISTS target_shapes (
    Pitcher %s,
    PitchType %s,
    IVB_Target REAL,
    HB_Target REAL,
    IsCustom INTEGER,
    school_code %s,
    PRIMARY KEY (Pitcher, PitchType)
  )", name_type, name_type, name_type))
  DBI::dbExecute(con, sprintf(
    "CREATE TABLE IF NOT EXISTS player_plans (player %s PRIMARY KEY, payload %s, school_code %s)",
    name_type, text_type, name_type
  ))
  DBI::dbExecute(con, sprintf(
    "CREATE TABLE IF NOT EXISTS completed_goals (player %s PRIMARY KEY, payload %s, school_code %s)",
    name_type, text_type, name_type
  ))
  ensure_school_column("custom_tables")
  ensure_school_column("custom_reports")
  ensure_school_column("target_shapes")
  ensure_school_column("player_plans")
  ensure_school_column("completed_goals")
}

# load/save helpers for DB-backed state
load_custom_tables_db <- function() {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  if (!DBI::dbExistsTable(con, "custom_tables")) return(list())
  df <- DBI::dbReadTable(con, "custom_tables")
  if ("school_code" %in% names(df)) {
    df <- df[df$school_code %in% allowed_school_codes(), , drop = FALSE]
    df <- df[order(df$school_code == current_school()), , drop = FALSE]
  }
  if (!nrow(df)) return(list())
  res <- lapply(seq_len(nrow(df)), function(i) {
    item <- tryCatch(jsonlite::fromJSON(df$cols[[i]], simplifyVector = TRUE), error = function(...) list(cols = character(0)))
    item$school_code <- df$school_code[[i]] %||% current_school()
    item
  })
  names(res) <- df$name
  res
}

save_custom_tables_db <- function(x) {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  DBI::dbExecute(con, "DELETE FROM custom_tables")
  if (!length(x)) return(invisible(TRUE))
  payload <- data.frame(
    name = names(x),
    cols = vapply(x, function(v) jsonlite::toJSON(v, auto_unbox = TRUE), character(1)),
    school_code = vapply(x, function(v) v$school_code %||% current_school(), character(1)),
    stringsAsFactors = FALSE
  )
  DBI::dbWriteTable(con, "custom_tables", payload, append = TRUE, row.names = FALSE)
}

load_custom_reports_db <- function() {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  if (!DBI::dbExistsTable(con, "custom_reports")) return(list())
  df <- DBI::dbReadTable(con, "custom_reports")
  if ("school_code" %in% names(df)) {
    df <- df[df$school_code %in% allowed_school_codes(), , drop = FALSE]
    df <- df[order(df$school_code == current_school()), , drop = FALSE]
  }
  if (!nrow(df)) return(list())
  res <- lapply(seq_len(nrow(df)), function(i) {
    item <- tryCatch(jsonlite::fromJSON(df$payload[[i]], simplifyVector = TRUE), error = function(...) list())
    item$school_code <- df$school_code[[i]] %||% current_school()
    item
  })
  names(res) <- df$name
  res
}

save_custom_reports_db <- function(x) {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  DBI::dbExecute(con, "DELETE FROM custom_reports")
  if (!length(x)) return(invisible(TRUE))
  payload <- data.frame(
    name = names(x),
    payload = vapply(x, function(v) jsonlite::toJSON(v, auto_unbox = TRUE), character(1)),
    school_code = vapply(x, function(v) v$school_code %||% current_school(), character(1)),
    stringsAsFactors = FALSE
  )
  DBI::dbWriteTable(con, "custom_reports", payload, append = TRUE, row.names = FALSE)
}

load_target_shapes_db <- function() {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  if (!DBI::dbExistsTable(con, "target_shapes")) return(NULL)
  df <- DBI::dbReadTable(con, "target_shapes")
  if ("school_code" %in% names(df)) {
    df <- df[df$school_code %in% allowed_school_codes(), , drop = FALSE]
    df <- df[order(df$school_code == current_school()), , drop = FALSE]
  }
  if (!nrow(df)) return(NULL)
  df
}

save_target_shapes_db <- function(df) {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  DBI::dbExecute(con, "DELETE FROM target_shapes")
  if (!nrow(df)) return(invisible(TRUE))
  if (!"school_code" %in% names(df)) {
    df$school_code <- current_school()
  } else {
    df$school_code[is.na(df$school_code) | !nzchar(df$school_code)] <- current_school()
  }
  DBI::dbWriteTable(con, "target_shapes", df, append = TRUE, row.names = FALSE)
}

init_state_db()

compute_pitch_key <- function(df) {
  if (!nrow(df)) return(character(0))
  prefer_cols <- c("PitchUID", "PitchGuid", "PitchID", "PitchId", "PitchUIDNext", "b_pitch_guid")
  for (col in prefer_cols) {
    if (col %in% names(df)) {
      vals <- df[[col]]
      if (!is.null(vals) && any(!is.na(vals) & nzchar(as.character(vals)))) {
        return(as.character(vals))
      }
    }
  }
  safe_chr <- function(x) {
    out <- tryCatch(as.character(x), warning = function(...) "", error = function(...) "")
    if (!length(out)) return("")
    out <- out[1]
    ifelse(is.na(out), "", out)
  }
  safe_num <- function(x) {
    val <- suppressWarnings(as.numeric(x))
    if (!length(val)) return("")
    val <- val[1]
    if (is.na(val)) "" else sprintf("%.3f", round(val, 3))
  }
  safe_col <- function(row, col_name) {
    if (col_name %in% names(row)) {
      safe_chr(row[[col_name]])
    } else {
      ""
    }
  }
  vapply(seq_len(nrow(df)), function(i) {
    row <- df[i, , drop = FALSE]
    parts <- c(
      safe_col(row, "Pitcher"),
      safe_chr(as.Date(row$Date)),
      safe_col(row, "SessionType"),
      safe_col(row, "Batter"),
      safe_col(row, "PitchCall"),
      safe_col(row, "PlayResult"),
      safe_col(row, "TaggedPitchType"),
      safe_col(row, "Inning"),
      safe_col(row, "Balls"),
      safe_col(row, "Strikes"),
      safe_num(if ("RelSpeed" %in% names(row)) row$RelSpeed else NA),
      safe_num(if ("InducedVertBreak" %in% names(row)) row$InducedVertBreak else NA),
      safe_num(if ("HorzBreak" %in% names(row)) row$HorzBreak else NA),
      safe_num(if ("Extension" %in% names(row)) row$Extension else NA),
      safe_num(if ("VertApprAngle" %in% names(row)) row$VertApprAngle else NA),
      safe_num(if ("HorzApprAngle" %in% names(row)) row$HorzApprAngle else NA),
      safe_num(if ("PlateLocSide" %in% names(row)) row$PlateLocSide else NA),
      safe_num(if ("PlateLocHeight" %in% names(row)) row$PlateLocHeight else NA)
    )
    digest::digest(paste(parts, collapse = "|"), algo = "xxhash64", serialize = FALSE)
  }, character(1))
}

ensure_pitch_keys <- function(df) {
  if (!nrow(df)) {
    if (!"PitchKey" %in% names(df)) df$PitchKey <- character(0)
    return(df)
  }
  if (!"PitchKey" %in% names(df)) {
    df$PitchKey <- compute_pitch_key(df)
    return(df)
  }
  df$PitchKey <- as.character(df$PitchKey)
  missing <- is.na(df$PitchKey) | !nzchar(df$PitchKey)
  if (any(missing)) {
    df$PitchKey[missing] <- compute_pitch_key(df[missing, , drop = FALSE])
  }
  df
}

attach_pitch_keys_to_mods <- function(mods_df, base_data, tolerance = 0.5) {
  if (!nrow(mods_df)) {
    if (!"pitch_key" %in% names(mods_df)) mods_df$pitch_key <- character(0)
    return(mods_df)
  }
  if (is.null(base_data) || !nrow(base_data)) {
    if (!"pitch_key" %in% names(mods_df)) mods_df$pitch_key <- NA_character_
    return(mods_df)
  }
  mods_df$pitch_key <- as.character(mods_df[["pitch_key"]] %||% NA_character_)
  need <- is.na(mods_df$pitch_key) | !nzchar(mods_df$pitch_key)
  if (!any(need)) return(mods_df)
  base <- ensure_pitch_keys(base_data)
  tol <- ifelse(is.na(suppressWarnings(as.numeric(tolerance))), 0.5, as.numeric(tolerance))
  rel_base <- suppressWarnings(as.numeric(base$RelSpeed))
  hb_base  <- suppressWarnings(as.numeric(base$HorzBreak))
  ivb_base <- suppressWarnings(as.numeric(base$InducedVertBreak))
  for (idx in which(need)) {
    mod <- mods_df[idx, , drop = FALSE]
    rel_mod <- suppressWarnings(as.numeric(mod$rel_speed))
    hb_mod  <- suppressWarnings(as.numeric(mod$horz_break))
    ivb_mod <- suppressWarnings(as.numeric(mod$induced_vert_break))
    rel_ok <- if (is.na(rel_mod)) rep(TRUE, length(rel_base)) else abs(rel_base - rel_mod) <= tol
    hb_ok  <- if (is.na(hb_mod))  rep(TRUE, length(hb_base))  else abs(hb_base - hb_mod) <= tol
    ivb_ok <- if (is.na(ivb_mod)) rep(TRUE, length(ivb_base)) else abs(ivb_base - ivb_mod) <= tol
    matches <- which(
      base$Pitcher == mod$pitcher &
        as.character(base$Date) == as.character(mod$date) &
        rel_ok & hb_ok & ivb_ok
    )
    if (length(matches)) mods_df$pitch_key[idx] <- base$PitchKey[matches[1]]
  }
  mods_df
}

refresh_missing_pitch_keys <- function(con, mods_df, base_data) {
  if (!nrow(mods_df)) return(mods_df)
  mods_with_keys <- attach_pitch_keys_to_mods(mods_df, base_data)
  newly_filled <- which((is.na(mods_df$pitch_key) | !nzchar(mods_df$pitch_key)) & nzchar(mods_with_keys$pitch_key))
  if (length(newly_filled)) {
    for (idx in newly_filled) {
      try(dbExecute(con, "UPDATE modifications SET pitch_key = ? WHERE id = ?", list(mods_with_keys$pitch_key[idx], mods_with_keys$id[idx])), silent = TRUE)
    }
  }
  mods_with_keys
}

write_modifications_snapshot <- function(con) {
  export_path <- get_modifications_export_path()
  if (!nzchar(export_path)) return()
  
  # Get all modifications from database
  mods <- try(dbGetQuery(con, "SELECT * FROM modifications ORDER BY created_at"), silent = TRUE)
  if (inherits(mods, "try-error") || !nrow(mods)) return()
  
  # Ensure export directory exists
  dir_path <- dirname(export_path)
  if (!dir.exists(dir_path)) {
    ok <- try(dir.create(dir_path, recursive = TRUE, showWarnings = FALSE), silent = TRUE)
    if (inherits(ok, "try-error") || !dir.exists(dir_path)) return()
  }
  
  # Write to temporary file first for atomic operation
  tmp <- tempfile(fileext = ".csv")
  on.exit(unlink(tmp), add = TRUE)
  
  tryCatch({
    # Write CSV with proper formatting
    readr::write_csv(mods, tmp)
    
    # Atomic replace of export file
    success <- file.copy(tmp, export_path, overwrite = TRUE, copy.mode = TRUE)
    
    if (success) {
      cat("Successfully exported", nrow(mods), "modifications to", export_path, "\n")
    } else {
      warning("Failed to copy modifications export file")
    }
  }, error = function(e) {
    warning("Error writing modifications snapshot: ", e$message)
  })
}

import_modifications_from_export <- function(con, base_data) {
  export_path <- get_modifications_export_path()
  if (!file.exists(export_path)) return()
  
  # Read modifications from CSV export
  mods_csv <- try(readr::read_csv(export_path, show_col_types = FALSE), silent = TRUE)
  if (inherits(mods_csv, "try-error") || !nrow(mods_csv)) return()
  
  mods_csv <- as.data.frame(mods_csv, stringsAsFactors = FALSE, check.names = FALSE)
  if (!"pitch_key" %in% names(mods_csv)) mods_csv$pitch_key <- NA_character_
  
  # Attach pitch keys if missing
  mods_csv <- attach_pitch_keys_to_mods(mods_csv, base_data)
  
  # Get existing modifications from database
  existing <- try(dbGetQuery(con, "SELECT pitch_key FROM modifications"), silent = TRUE)
  existing_keys <- if (inherits(existing, "try-error")) character(0) else as.character(existing$pitch_key)
  
  # Find new rows (those not already in database)
  new_rows <- mods_csv[!(mods_csv$pitch_key %in% existing_keys), , drop = FALSE]
  if (!nrow(new_rows)) {
    cat("All modifications from export file already exist in database\n")
    return()
  }
  
  # Prepare data for database insertion
  expected_cols <- c(
    "pitcher", "date", "rel_speed", "horz_break", "induced_vert_break",
    "original_pitch_type", "new_pitch_type", "new_pitcher",
    "modified_at", "pitch_key", "created_at"
  )
  
  # Remove auto-increment id column if present
  new_rows$id <- NULL
  
  # Ensure all expected columns exist
  for (col in expected_cols) {
    if (!col %in% names(new_rows)) new_rows[[col]] <- NA
  }
  
  # Select only expected columns
  new_rows <- new_rows[, expected_cols, drop = FALSE]
  
  # Insert new modifications
  tryCatch({
    dbWriteTable(con, "modifications", new_rows, append = TRUE)
    cat("Imported", nrow(new_rows), "new modifications from export file\n")
  }, error = function(e) {
    warning("Error importing modifications: ", e$message)
  })
}

upload_media_cloudinary <- function(path) {
  if (!nzchar(CLOUDINARY_CLOUD_NAME) || !nzchar(CLOUDINARY_UPLOAD_PRESET)) {
    stop("Cloudinary not configured: set CLOUDINARY_CLOUD_NAME and CLOUDINARY_UPLOAD_PRESET.")
  }
  endpoint <- sprintf("https://api.cloudinary.com/v1_1/%s/auto/upload", CLOUDINARY_CLOUD_NAME)
  
  res <- httr2::request(endpoint) |>
    httr2::req_body_multipart(
      file = curl::form_file(path),
      upload_preset = CLOUDINARY_UPLOAD_PRESET
    ) |>
    httr2::req_timeout(30) |>
    httr2::req_error(is_error = ~ FALSE) |>
    httr2::req_perform()
  
  # Fail clearly on HTTP error
  if (httr2::resp_status(res) >= 400) {
    msg <- tryCatch(httr2::resp_body_string(res), error = function(e) paste("HTTP", httr2::resp_status(res)))
    stop(sprintf("Cloudinary upload failed: %s", msg))
  }
  
  j <- httr2::resp_body_json(res, check_type = FALSE)
  list(
    url  = j$secure_url %||% j$url,
    type = j$resource_type %||% "auto"  # "image" | "video" | "raw"
  )
}

# ---- Database functions for persistent pitch modifications ----

# Initialize modifications database
init_modifications_db <- function() {
  db_path <- get_modifications_db_path()
  
  # Wrap entire DB initialization in tryCatch to handle read-only environments
  con <- tryCatch(dbConnect(SQLite(), db_path), error = function(e) {
    warning(sprintf("Could not connect to modifications DB (%s). Pitch edits will only persist in-memory.", conditionMessage(e)))
    return(NULL)
  })
  
  if (is.null(con) || inherits(con, "error")) {
    return(db_path)
  }
  
  on.exit(dbDisconnect(con), add = TRUE)
  
  # Execute DB operations with error handling
  tryCatch({
    dbExecute(con, "
      CREATE TABLE IF NOT EXISTS modifications (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        pitcher TEXT NOT NULL,
        date TEXT NOT NULL,
        rel_speed REAL,
        horz_break REAL,
        induced_vert_break REAL,
        original_pitch_type TEXT,
        new_pitch_type TEXT NOT NULL,
        new_pitcher TEXT,
        modified_at TEXT NOT NULL,
        pitch_key TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    ")
    dbExecute(con, "
      CREATE INDEX IF NOT EXISTS idx_pitch_lookup ON modifications 
      (pitcher, date, rel_speed, horz_break, induced_vert_break)
    ")
    dbExecute(con, "
      CREATE INDEX IF NOT EXISTS idx_pitch_key ON modifications (pitch_key)
    ")
    # Ensure legacy databases get the new_pitcher column
    cols <- try(dbListFields(con, "modifications"), silent = TRUE)
    if (!inherits(cols, "try-error") && !"new_pitcher" %in% cols) {
      try(dbExecute(con, "ALTER TABLE modifications ADD COLUMN new_pitcher TEXT"), silent = TRUE)
    }
    base_data <- get0("pitch_data_pitching", ifnotfound = NULL)
    import_modifications_from_export(con, base_data)
    mods <- try(dbGetQuery(con, "SELECT * FROM modifications"), silent = TRUE)
    db_count <- if (inherits(mods, "try-error")) NA_integer_ else nrow(mods)
    message(sprintf("Mod DB path: %s | rows: %s", db_path, db_count))
    if (!inherits(mods, "try-error") && nrow(mods)) {
      refresh_missing_pitch_keys(con, mods, base_data)
      write_modifications_snapshot(con)
      # If the DB has fewer rows than the best available CSV, rebuild from CSV
      best_csv <- function() {
        candidates <- unique(c(
          get_modifications_export_path(),
          file.path("data", "pitch_type_modifications_export.csv"),
          file.path("data", "pitch_type_modifications.csv"),
          "pitch_type_modifications.csv"
        ))
        best <- NULL; best_n <- NA_integer_
        for (p in candidates) {
          if (!file.exists(p)) next
          n <- tryCatch(nrow(readr::read_csv(p, show_col_types = FALSE)), error = function(...) NA_integer_)
          if (is.finite(n) && (is.na(best_n) || n > best_n)) {
            best <- p; best_n <- n
          }
        }
        list(path = best, n = best_n)
      }
      csv_info <- best_csv()
      db_count <- nrow(mods)
      if (!is.null(csv_info$path) && is.finite(csv_info$n) && csv_info$n > db_count) {
        message(sprintf("Rebuilding modifications DB from %s (%d -> %d rows)", csv_info$path, db_count, csv_info$n))
        try(dbExecute(con, "DELETE FROM modifications"), silent = TRUE)
        mods_csv <- try(readr::read_csv(csv_info$path, show_col_types = FALSE), silent = TRUE)
        if (!inherits(mods_csv, "try-error") && nrow(mods_csv)) {
          mods_csv <- as.data.frame(mods_csv, stringsAsFactors = FALSE, check.names = FALSE)
          if (!"pitch_key" %in% names(mods_csv)) mods_csv$pitch_key <- NA_character_
          mods_csv <- attach_pitch_keys_to_mods(mods_csv, base_data)
          new_rows <- mods_csv
          new_rows$id <- NULL
          expected_cols <- c(
            "pitcher", "date", "rel_speed", "horz_break", "induced_vert_break",
            "original_pitch_type", "new_pitch_type", "new_pitcher",
            "modified_at", "pitch_key", "created_at"
          )
          for (col in expected_cols) {
            if (!col %in% names(new_rows)) new_rows[[col]] <- NA
          }
          new_rows <- new_rows[, expected_cols, drop = FALSE]
          try(dbWriteTable(con, "modifications", new_rows, append = TRUE), silent = TRUE)
        }
        mods <- try(dbGetQuery(con, "SELECT * FROM modifications"), silent = TRUE)
        if (!inherits(mods, "try-error")) {
          refresh_missing_pitch_keys(con, mods, base_data)
          write_modifications_snapshot(con)
        }
        # mod_memo is no longer memoized; nothing to forget
      }
    }
  }, error = function(e) {
    warning(sprintf("Error during DB initialization: %s", conditionMessage(e)))
  })
  
  db_path
}

# Save pitch modifications to database
save_pitch_modifications_db <- function(selected_pitches, new_type, new_pitcher = NULL) {
  db_path <- init_modifications_db()
  con <- tryCatch(dbConnect(SQLite(), db_path), error = function(e) e)
  if (inherits(con, "error")) {
    return(list(success = FALSE, error = paste("Could not open pitch modifications database:", conditionMessage(con))))
  }
  on.exit(dbDisconnect(con), add = TRUE)
  selected_pitches <- ensure_pitch_keys(selected_pitches)
  # Drop any aggregate/summary rows that lack a concrete pitch key
  selected_pitches <- selected_pitches[!is.na(selected_pitches$PitchKey) & nzchar(as.character(selected_pitches$PitchKey)), , drop = FALSE]
  if (!nrow(selected_pitches)) {
    return(list(success = FALSE, error = "No valid pitch rows selected (missing pitch key)."))
  }
  # Normalize pitcher fields to avoid NULL/NA inserts
  pitcher_vec <- as.character(selected_pitches$Pitcher)
  pitcher_vec[is.na(pitcher_vec) | pitcher_vec %in% c("NA","NaN","")] <- "Unknown"
  if (!is.null(new_pitcher) && nzchar(new_pitcher)) {
    # Fill any missing pitcher with the override and use override for new_pitcher column
    pitcher_vec[!nzchar(pitcher_vec) | is.na(pitcher_vec)] <- new_pitcher
    new_pitcher_vec <- rep(new_pitcher, nrow(selected_pitches))
  } else {
    # No override provided; still ensure we don't insert blanks
    pitcher_vec[!nzchar(pitcher_vec) | is.na(pitcher_vec) | pitcher_vec %in% c("NA","NaN")] <- "Unknown"
    new_pitcher_vec <- pitcher_vec
  }
  new_mods <- data.frame(
    pitcher = pitcher_vec,
    date = as.character(selected_pitches$Date),
    rel_speed = suppressWarnings(as.numeric(selected_pitches$RelSpeed)),
    horz_break = suppressWarnings(as.numeric(selected_pitches$HorzBreak)),
    induced_vert_break = suppressWarnings(as.numeric(selected_pitches$InducedVertBreak)),
    original_pitch_type = selected_pitches$TaggedPitchType,
    new_pitch_type = new_type,
    new_pitcher = new_pitcher_vec,
    modified_at = as.character(Sys.time()),
    pitch_key = as.character(selected_pitches$PitchKey),
    stringsAsFactors = FALSE
  )
  # Sanitize required NOT NULL fields
  new_mods$date[is.na(new_mods$date) | new_mods$date %in% c("", "NA", "NaN")] <- NA
  new_mods$pitcher[is.na(new_mods$pitcher) | new_mods$pitcher %in% c("", "NA", "NaN")] <- "Unknown"
  new_mods$new_pitcher[is.na(new_mods$new_pitcher) | new_mods$new_pitcher %in% c("", "NA", "NaN")] <- new_mods$pitcher[is.na(new_mods$new_pitcher) | new_mods$new_pitcher %in% c("", "NA", "NaN")]
  new_mods$pitch_key[is.na(new_mods$pitch_key)] <- ""
  # Keep only rows with required fields: pitch_key, pitcher, date
  new_mods <- new_mods[
    nzchar(new_mods$pitch_key) &
      nzchar(new_mods$pitcher) &
      !is.na(new_mods$date),
    , drop = FALSE
  ]
  if (!nrow(new_mods)) {
    return(list(success = FALSE, error = "No valid pitch rows available (missing key/pitcher/date)."))
  }
  res <- tryCatch({
    dbExecute(con, "BEGIN IMMEDIATE")
    for (i in seq_len(nrow(new_mods))) {
      dbExecute(con, "DELETE FROM modifications WHERE pitch_key = ?", list(new_mods$pitch_key[i]))
    }
    dbWriteTable(con, "modifications", new_mods, append = TRUE)
    dbExecute(con, "COMMIT")
    
    # ENHANCED: Always update the export CSV after successful save
    write_modifications_snapshot(con)
    
    # Additional backup: create timestamped backup
    export_path <- get_modifications_export_path()
    if (file.exists(export_path) && nzchar(export_path)) {
      backup_dir <- file.path(dirname(export_path), "backups")
      dir.create(backup_dir, recursive = TRUE, showWarnings = FALSE)
      timestamp <- format(Sys.time(), "%Y%m%d_%H%M%S")
      backup_path <- file.path(backup_dir, paste0("pitch_modifications_", timestamp, ".csv"))
      try(file.copy(export_path, backup_path), silent = TRUE)
    }
    
    list(success = TRUE, count = nrow(new_mods))
  }, error = function(e) {
    try(dbExecute(con, "ROLLBACK"), silent = TRUE)
    list(success = FALSE, error = conditionMessage(e))
  })
  res
}

# Enhanced: Load and apply modifications from database with better matching
mod_memo <- function(db_path, mtime_sig) {
  con <- tryCatch(dbConnect(SQLite(), db_path), error = function(e) e)
  if (inherits(con, "error")) return(NULL)
  on.exit(dbDisconnect(con), add = TRUE)
  mods <- dbGetQuery(con, "SELECT * FROM modifications ORDER BY created_at")
  # Normalize date/time fields to avoid parsing errors
  safe_date <- function(x) {
    tryCatch({
      v <- as.character(x)
      out <- suppressWarnings(lubridate::ymd(v))
      if (all(is.na(out))) out <- suppressWarnings(lubridate::mdy(v))
      if (all(is.na(out))) out <- suppressWarnings(lubridate::dmy(v))
      as.Date(out)
    }, error = function(...) as.Date(NA))
  }
  safe_dt <- function(x) {
    tryCatch({
      v <- as.character(x)
      out <- suppressWarnings(lubridate::parse_date_time(
        v,
        orders = c("ymd HMS", "mdy HMS", "dmy HMS", "ymd HM", "mdy HM", "dmy HM", "ymd", "mdy", "dmy"),
        tz = "UTC"
      ))
      as.POSIXct(out, tz = "UTC")
    }, error = function(...) as.POSIXct(NA))
  }
  mods$date <- safe_date(mods$date)
  mods$modified_at <- safe_dt(mods$modified_at)
  mods$created_at <- safe_dt(mods$created_at)
  mods
}

load_pitch_modifications_db <- function(pitch_data, verbose = TRUE) {
  # Ensure we ALWAYS return valid data, even if everything fails
  fallback_result <- list(
    data = pitch_data %>% mutate(original_row_id = row_number()),
    applied_count = 0,
    total_modifications = 0
  )
  
  # Wrap entire function in tryCatch to ensure we never fail to return data
  tryCatch({
    db_path <- init_modifications_db()
    
    # Check if we're in read-only mode and need to seed DB from CSV
    is_readonly <- tryCatch(file.access(".", 2) != 0, error = function(e) TRUE)
    if (is_readonly) {
      if (verbose) message("Read-only environment detected - seeding temp DB from CSV")
      
      # Load modifications from CSV and populate the temp database
      csv_path <- file.path("data", "pitch_type_modifications_export.csv")
      if (file.exists(csv_path)) {
        tryCatch({
          con <- dbConnect(SQLite(), db_path)
          on.exit(dbDisconnect(con), add = TRUE)
          
          # Check if DB is empty (needs seeding)
          existing_count <- tryCatch({
            dbGetQuery(con, "SELECT COUNT(*) as n FROM modifications")$n
          }, error = function(e) 0)
          
          if (existing_count == 0) {
            # Load and import CSV modifications
            mods_csv <- readr::read_csv(csv_path, show_col_types = FALSE)
            if (nrow(mods_csv) > 0) {
              mods_csv <- as.data.frame(mods_csv, stringsAsFactors = FALSE, check.names = FALSE)
              
              # Prepare data for insertion
              if (!"pitch_key" %in% names(mods_csv)) mods_csv$pitch_key <- NA_character_
              if (!"new_pitcher" %in% names(mods_csv)) mods_csv$new_pitcher <- NA_character_
              
              expected_cols <- c(
                "pitcher", "date", "rel_speed", "horz_break", "induced_vert_break",
                "original_pitch_type", "new_pitch_type", "new_pitcher",
                "modified_at", "pitch_key", "created_at"
              )
              
              for (col in expected_cols) {
                if (!col %in% names(mods_csv)) mods_csv[[col]] <- NA
              }
              
              import_data <- mods_csv[, expected_cols, drop = FALSE]
              dbWriteTable(con, "modifications", import_data, append = TRUE)
              
              if (verbose) {
                message(sprintf("Seeded temp DB with %d modifications from CSV", nrow(import_data)))
              }
            }
          }
        }, error = function(e) {
          warning(sprintf("Could not seed DB from CSV: %s", conditionMessage(e)))
        })
      }
    }
    
    if (!file.exists(db_path)) {
      return(fallback_result)
    }
    
    con <- tryCatch(dbConnect(SQLite(), db_path), error = function(e) e)
    if (inherits(con, "error")) {
      warning(sprintf("Could not open modifications DB while loading (%s)", conditionMessage(con)))
      return(list(
        data = ensure_pitch_keys(pitch_data) %>% mutate(original_row_id = row_number()),
        applied_count = 0,
        total_modifications = 0
      ))
    }
    on.exit(dbDisconnect(con), add = TRUE)
    
    tryCatch({
      mtime_sig <- suppressWarnings(as.character(file.info(db_path)$mtime %||% Sys.time()))
      mods <- mod_memo(db_path, mtime_sig)
      if (is.null(mods)) {
        return(list(
          data = ensure_pitch_keys(pitch_data) %>% mutate(original_row_id = row_number()),
          applied_count = 0,
          total_modifications = 0
        ))
      }
      dropped <- sum(is.na(mods$date))
      if (dropped && verbose) message(sprintf("Dropping %d modifications with unparseable dates", dropped))
      base_data <- ensure_pitch_keys(pitch_data)
      mods <- refresh_missing_pitch_keys(con, mods, base_data)
      
      if (nrow(mods) == 0) {
        return(list(
          data = base_data %>% mutate(original_row_id = row_number()),
          applied_count = 0,
          total_modifications = 0
        ))
      }
      
      temp_data <- base_data %>% mutate(original_row_id = row_number())
      
      # Apply modifications with enhanced matching
      modifications_applied <- 0
      modifications_not_found <- 0
      lookup_df <- get0("lookup_table", ifnotfound = NULL)
      fetch_email <- function(name) {
        if (is.null(lookup_df) || !"Pitcher" %in% names(lookup_df) || !"Email_lookup" %in% names(lookup_df)) {
          return(NA_character_)
        }
        idx <- which(tolower(lookup_df$Pitcher) == tolower(name))
        if (length(idx)) {
          val <- lookup_df$Email_lookup[idx[1]]
          if (is.na(val) || !nzchar(val)) return(NA_character_)
          return(val)
        }
        NA_character_
      }
      
      for (i in 1:nrow(mods)) {
        mod <- mods[i, ]
        
        # Primary matching strategy: exact match on multiple fields
        match_idx <- integer(0)
        if ("PitchKey" %in% names(temp_data) && !is.na(mod$pitch_key) && nzchar(mod$pitch_key)) {
          match_idx <- which(temp_data$PitchKey == mod$pitch_key)
        }
        if (!length(match_idx)) {
          match_idx <- which(
            temp_data$Pitcher == mod$pitcher &
              temp_data$Date == mod$date &
              abs(temp_data$RelSpeed - mod$rel_speed) < 0.1 &
              abs(temp_data$HorzBreak - mod$horz_break) < 0.1 &
              abs(temp_data$InducedVertBreak - mod$induced_vert_break) < 0.1
          )
        }
        
        # Fallback matching: if exact match fails, try looser criteria
        if (length(match_idx) == 0) {
          match_idx <- which(
            temp_data$Pitcher == mod$pitcher &
              temp_data$Date == mod$date &
              abs(temp_data$RelSpeed - mod$rel_speed) < 0.5  # Slightly looser tolerance
          )
        }
        
        if (length(match_idx) > 0) {
          # Apply modification to all matching rows (handles duplicate PitchKey entries)
          temp_data$TaggedPitchType[match_idx] <- mod$new_pitch_type
          if (!is.null(mod$new_pitcher) && nzchar(mod$new_pitcher)) {
            temp_data$Pitcher[match_idx] <- mod$new_pitcher
            new_email <- fetch_email(mod$new_pitcher)
            if (!is.na(new_email) && "Email" %in% names(temp_data)) {
              temp_data$Email[match_idx] <- new_email
            }
          }
          modifications_applied <- modifications_applied + 1
          
          if (verbose) {
            cat(sprintf("Applied: %s on %s - %s -> %s\n", 
                        mod$pitcher, mod$date, mod$original_pitch_type, mod$new_pitch_type))
          }
        } else {
          modifications_not_found <- modifications_not_found + 1
          if (verbose) {
            cat(sprintf("Could not find pitch to modify: %s on %s (%.1f mph)\n", 
                        mod$pitcher, mod$date, mod$rel_speed))
          }
        }
      }
      
      if (verbose && modifications_applied > 0) {
        message(sprintf("Applied %d of %d stored pitch type modifications", 
                        modifications_applied, nrow(mods)))
        if (modifications_not_found > 0) {
          message(sprintf("Warning: %d modifications could not be applied (pitches not found)", 
                          modifications_not_found))
        }
      }
      
      return(list(
        data = temp_data,
        applied_count = modifications_applied,
        total_modifications = nrow(mods)
      ))
      
    }, finally = {
      dbDisconnect(con)
    })
    
  }, error = function(e) {
    warning(sprintf("Error loading pitch modifications: %s", conditionMessage(e)))
    return(fallback_result)
  })
}

# Function to check if data has been updated since last modification load
check_data_freshness <- function() {
  # Check for new_data_flag.txt which gets created by automated_data_sync.R when new data arrives
  flag_file <- file.path("data", "new_data_flag.txt")
  mod_state_file <- "modification_state.txt"
  
  if (file.exists(flag_file)) {
    # New data flag exists - check if we've already processed it
    flag_time <- file.info(flag_file)$mtime
    
    if (!file.exists(mod_state_file)) {
      # First time - create state file and return TRUE
      writeLines(as.character(flag_time), mod_state_file)
      file.remove(flag_file)  # Remove the flag so we don't keep reprocessing
      return(TRUE)
    }
    
    last_processed_time <- as.POSIXct(readLines(mod_state_file)[1])
    
    if (flag_time > last_processed_time) {
      # New data has arrived since we last processed
      writeLines(as.character(flag_time), mod_state_file)
      file.remove(flag_file)  # Remove the flag
      return(TRUE)
    }
  }
  
  # Also check the traditional last_sync.txt approach as backup
  sync_file <- file.path("data", "last_sync.txt")
  if (!file.exists(sync_file)) {
    return(FALSE)  # No sync file means no data sync has occurred
  }
  
  sync_time <- file.info(sync_file)$mtime
  
  if (!file.exists(mod_state_file)) {
    # First time - create state file and return TRUE to trigger reload
    writeLines(as.character(sync_time), mod_state_file)
    return(TRUE)
  }
  
  last_mod_time <- as.POSIXct(readLines(mod_state_file)[1])
  
  if (sync_time > last_mod_time) {
    # Data has been updated since modifications were last applied
    writeLines(as.character(sync_time), mod_state_file)
    return(TRUE)
  }
  
  return(FALSE)
}

# Function to get modification statistics
get_modification_stats <- function() {
  db_path <- "pitch_modifications.db"
  
  if (!file.exists(db_path)) {
    return(list(total = 0, by_player = data.frame(), recent = data.frame()))
  }
  
  con <- dbConnect(SQLite(), db_path)
  
  tryCatch({
    # Get total count
    total <- dbGetQuery(con, "SELECT COUNT(*) as count FROM modifications")$count
    
    # Get count by player
    by_player <- dbGetQuery(con, "
      SELECT pitcher, COUNT(*) as modifications 
      FROM modifications 
      GROUP BY pitcher 
      ORDER BY modifications DESC
    ")
    
    # Get recent modifications
    recent <- dbGetQuery(con, "
      SELECT pitcher, date, original_pitch_type, new_pitch_type, modified_at 
      FROM modifications 
      ORDER BY created_at DESC 
      LIMIT 10
    ")
    
    return(list(total = total, by_player = by_player, recent = recent))
    
  }, finally = {
    dbDisconnect(con)
  })
}


have_akima <- requireNamespace("akima", quietly = TRUE)  # for smoothed means (EV/LA)

HEAT_BINS <- 6
HEAT_EV_THRESHOLD <- 90

# Frequency (keep multi-color)
heat_pal_freq <- function(n = HEAT_BINS) colorRampPalette(
  c("white","pink","red")
)(n)

# All other heat maps → white→red only
heat_pal_red  <- function(n = HEAT_BINS) colorRampPalette(c("white","pink","red"))(n)


# JS sorter: strip HTML, then try numeric (handles %, commas); fallback to lowercase text
js_sort <- 
  "function(data, type, row, meta) {\n" %>% 
  paste0("  if (type === 'sort') {\n") %>%
  paste0("    var text = String(data || '').replace(/<[^>]*>/g, '');\n") %>%
  paste0("    var num = parseFloat(text.replace(/[^0-9.+\\-eE]/g, ''));\n") %>%
  paste0("    if (!isNaN(num)) return num;\n") %>%
  paste0("    return text.toLowerCase();\n") %>%
  paste0("  }\n") %>%
  paste0("  return data;\n") %>%
  paste0("}")

# small helper
# Replace the old %or% with this scalar-safe version
`%or%` <- function(a, b) {
  if (is.null(a) || length(a) == 0) return(b)
  a1 <- a[1]
  if (is.na(a1)) return(b)
  a1c <- as.character(a1)
  if (!nzchar(a1c)) b else a1
}
fmt_mdy <- function(x) ifelse(is.na(x), "", format(as.Date(x), "%m/%d/%Y"))

get_hit_type_col <- function(df) {
  if (is.null(df)) return(character(0))
  if ("HitType" %in% names(df)) return(as.character(df$HitType))
  if ("TaggedHitType" %in% names(df)) return(as.character(df$TaggedHitType))
  rep(NA_character_, if (is.data.frame(df)) nrow(df) else 0)
}

pa_flags_from_counts <- function(df_local) {
  n <- nrow(df_local)
  res <- list(
    is_last      = rep(FALSE, n),
    is_strikeout = rep(FALSE, n),
    is_walk      = rep(FALSE, n)
  )
  if (!n) return(res)
  required <- c("Balls","Strikes","PitchCall")
  if (!all(required %in% names(df_local))) return(res)
  balls   <- suppressWarnings(as.integer(df_local$Balls))
  strikes <- suppressWarnings(as.integer(df_local$Strikes))
  pitchcall <- as.character(df_local$PitchCall)
  valid_counts <- is.finite(balls) & is.finite(strikes)
  if (!any(valid_counts)) return(res)
  prev_valid <- c(FALSE, head(valid_counts, -1))
  new_pa <- valid_counts & ((balls == 0 & strikes == 0) | !prev_valid)
  pa_id <- cumsum(ifelse(valid_counts, new_pa, FALSE))
  if (any(valid_counts) && pa_id[valid_counts][1] == 0) pa_id[valid_counts] <- pa_id[valid_counts] + 1L
  if (all(pa_id[valid_counts] == 0)) pa_id[valid_counts] <- 1L
  pa_id[!valid_counts] <- NA_integer_
  last_idx <- rep(NA_integer_, n)
  if (any(!is.na(pa_id))) {
    last_idx <- ave(seq_len(n), pa_id, FUN = function(idx) rep(max(idx), length(idx)))
  }
  is_last <- seq_len(n) == last_idx
  is_last[is.na(pa_id)] <- FALSE
  strikeout_calls <- c("StrikeSwinging","StrikeCalled","StrikeSwingingBlocked","StrikeSwingingPitchout","StrikeSwingingChecked","StrikeCalledPitchout")
  walk_calls      <- c("BallCalled","BallInDirt","PitchoutBall","IntentBall")
  res$is_last      <- is_last
  res$is_strikeout <- is_last & (strikes == 2) & pitchcall %in% strikeout_calls
  res$is_walk      <- is_last & (balls == 3)   & pitchcall %in% walk_calls
  res
}

compute_pa_flags <- function(df_local) {
  if (!("PlayResult" %in% names(df_local))) df_local$PlayResult <- NA_character_
  if (!("KorBB" %in% names(df_local))) df_local$KorBB <- NA_character_
  if (!("PitchCall" %in% names(df_local))) df_local$PitchCall <- NA_character_
  if (!("Balls" %in% names(df_local))) df_local$Balls <- NA_real_
  if (!("Strikes" %in% names(df_local))) df_local$Strikes <- NA_real_
  
  flags <- pa_flags_from_counts(df_local)
  df_play_result <- as.character(df_local$PlayResult)
  df_korbb       <- as.character(df_local$KorBB)
  df_hit_type    <- as.character(df_local$TaggedHitType %||% NA_character_)
  strikeout_results <- c("Strikeout","StrikeoutSwinging","StrikeoutLooking")
  is_strikeout <- flags$is_strikeout |
    (!is.na(df_play_result) & df_play_result %in% strikeout_results) |
    (!is.na(df_korbb) & df_korbb == "Strikeout")
  is_walk <- flags$is_walk |
    (!is.na(df_play_result) & df_play_result == "Walk") |
    (!is.na(df_korbb) & df_korbb == "Walk")
  is_terminal <- flags$is_last |
    (!is.na(df_play_result) & df_play_result != "Undefined") |
    (!is.na(df_korbb) & df_korbb %in% c("Strikeout","Walk")) |
    (!is.na(df_hit_type) & nzchar(df_hit_type))
  list(df = df_local, is_strikeout = is_strikeout, is_walk = is_walk, is_terminal = is_terminal)
}

default_swing_levels <- function() {
  c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","FoulBall","InPlay")
}

parse_utc_datetime <- function(x) {
  if (is.null(x)) return(as.POSIXct(rep(NA_real_, length(x)), origin = "1970-01-01", tz = "UTC"))
  suppressWarnings({
    a <- as.POSIXct(x, tz = "UTC")  # handles "YYYY-MM-DD HH:MM:SS"
    na <- is.na(a)
    if (any(na)) {
      a2 <- as.POSIXct(strptime(x[na], "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC"))  # ISO-8601
      a[na] <- a2
    }
    na <- is.na(a)
    if (any(na)) {
      a2 <- as.POSIXct(strptime(x[na], "%m/%d/%Y %H:%M:%OS", tz = "UTC"))  # fallback
      a[na] <- a2
    }
    a
  })
}

notes_api_add <- function(author_email, team, page_combo, pitcher, session_type, date_start, date_end, note_text) {
  body <- list(
    token        = NOTES_API_TOKEN,
    author_email = author_email,
    team         = team,
    page         = page_combo,
    pitcher      = pitcher,
    session_type = session_type,
    date_start   = as.character(as.Date(date_start)),
    date_end     = as.character(as.Date(date_end)),
    note_text    = note_text
  )
  
  # --- Try POST first ---
  post_resp <- tryCatch({
    httr2::request(NOTES_API_URL) |>
      httr2::req_method("POST") |>
      httr2::req_body_json(body) |>
      httr2::req_timeout(10) |>
      httr2::req_perform()
  }, error = function(e) e)
  
  if (inherits(post_resp, "httr2_response")) {
    st <- httr2::resp_status(post_resp)
    if (st >= 200 && st < 300) {
      out <- httr2::resp_body_json(post_resp, check_type = FALSE)
      if (!is.null(out$error)) stop(sprintf("Notes API error: %s", out$error))
      return(TRUE)
    }
    # Only special-case 405; anything else bubbles up
    if (st != 405) stop(sprintf("Notes API HTTP %s", st))
  }
  
  # --- 405 path: check for a fresh identical note before fallback ---
  # --- Before any fallback, check if an identical note already exists (robust parse + wider window) ---
  try({
    rows <- notes_api_list()
    if (length(rows)) {
      df <- as.data.frame(rows, stringsAsFactors = FALSE, check.names = FALSE)
      
      ct <- parse_utc_datetime(df$created_at_utc)
      recent <- is.finite(ct) & (as.numeric(difftime(Sys.time(), ct, units = "secs")) <= 90)
      
      same_fields <- (
        df$author_email == author_email &
          df$team         == team &
          df$page         == page_combo &
          (df$pitcher     == pitcher | (is.na(df$pitcher) & pitcher %in% c("", "All"))) &
          (df$session_type== session_type | (is.na(df$session_type) & session_type %in% c("", "All"))) &
          as.character(as.Date(df$date_start)) == as.character(as.Date(date_start)) &
          as.character(as.Date(df$date_end))   == as.character(as.Date(date_end)) &
          df$note_text    == note_text
      )
      
      # If we see the exact same note very recently, or already present at all, skip fallback
      if (any(same_fields & recent, na.rm = TRUE) || any(same_fields, na.rm = TRUE)) {
        return(TRUE)
      }
    }
  }, silent = TRUE)
  
  
  # --- If not already present, do GET fallback once ---
  get_resp <- httr2::request(NOTES_API_URL) |>
    httr2::req_method("GET") |>
    httr2::req_url_query(
      op           = "add",
      token        = body$token,
      author_email = body$author_email,
      team         = body$team,
      page         = body$page,
      pitcher      = body$pitcher,
      session_type = body$session_type,
      date_start   = body$date_start,
      date_end     = body$date_end,
      note_text    = body$note_text
    ) |>
    httr2::req_timeout(10) |>
    httr2::req_perform()
  
  out2 <- httr2::resp_body_json(get_resp, check_type = FALSE)
  if (!is.null(out2$error)) stop(sprintf("Notes API error (GET fallback): %s", out2$error))
  TRUE
}


notes_api_list <- function() {
  req <- httr2::request(NOTES_API_URL) |>
    httr2::req_url_query(token = NOTES_API_TOKEN) |>
    httr2::req_method("GET") |>
    httr2::req_timeout(10)
  resp <- httr2::req_perform(req)
  jsonlite::fromJSON(httr2::resp_body_string(resp))
}


# ---------- Helpers ----------

html_unescape <- function(x) {
  if (is.null(x)) return(x)
  x <- gsub("&lt;",   "<", x, fixed = TRUE)
  x <- gsub("&gt;",   ">", x, fixed = TRUE)
  x <- gsub("&amp;",  "&", x, fixed = TRUE)
  x <- gsub("&quot;", "\"", x, fixed = TRUE)
  x <- gsub("&#39;",  "'", x, fixed = TRUE)
  x
}

# Flexible date parser: ISO (YYYY-MM-DD), m/d/yy, m/d/yyyy, with a 2-digit year pivot
# Anything with a 2-digit year that parses < pivot (default 1970) gets +100 years (e.g., 9/5/25 -> 2025)
parse_date_flex <- function(x, pivot = 1970L) {
  # keep Dates as-is
  if (inherits(x, "Date")) return(x)
  
  x <- trimws(as.character(x))
  x[x %in% c("", "NA", "NaN", "NULL", "null")] <- NA_character_
  
  # parse a bunch of common patterns
  dt <- suppressWarnings(lubridate::parse_date_time(
    x,
    orders = c(
      "Y-m-d", "Ymd",          # 2025-09-05, 20250905
      "m/d/y", "mdy",          # 9/5/25, 09/05/25
      "m/d/Y", "mdy",          # 9/5/2025, 09/05/2025
      "Y-m-d HMS", "mdy HMS",  # with times if present
      "Y-m-d HM",  "mdy HM"
    ),
    tz = "UTC",
    exact = FALSE
  ))
  
  # convert to Date
  d <- as.Date(dt)
  
  # Fix two-digit-year cases that landed in 19xx (or otherwise < pivot)
  yrs <- suppressWarnings(lubridate::year(dt))
  idx <- !is.na(yrs) & yrs < pivot
  if (any(idx)) d[idx] <- as.Date(dt[idx] + lubridate::years(100))
  
  d
}

blank_ea_except_all <- function(df) {
  if (!is.data.frame(df) || !("E+A%" %in% names(df))) return(df)
  
  # Look for any column that might be the grouping/pitch column - expanded list
  pitch_cols <- intersect(c("Pitch","PitchType","TaggedPitchType","SplitColumn",
                            "Batter Hand","Count","After Count","Velocity","IVB","HB",
                            "Batter","Pitcher Hand","Date","Player"), names(df))
  
  # If the table is grouped by Player (leaderboards), keep E+A% values
  if ("Player" %in% pitch_cols) return(df)
  if (!length(pitch_cols)) return(df)
  
  # Safe column access with error handling - check column exists first
  pitch_vals <- tryCatch({
    col_name <- pitch_cols[1]
    if (!col_name %in% names(df)) return(character(0))
    tolower(as.character(df[[col_name]]))
  }, error = function(e) {
    return(character(nrow(df)))
  })
  
  # If couldn't get values or wrong length, return unchanged
  if (!length(pitch_vals) || length(pitch_vals) != nrow(df)) return(df)
  
  keep_all <- is.na(pitch_vals) | pitch_vals == "all"
  # Handle NA values in logical condition
  keep_all[is.na(keep_all)] <- FALSE
  df$`E+A%` <- as.character(df$`E+A%`)
  df$`E+A%`[!keep_all] <- ""
  df
}


# --- DT sanitizers & wrapper (place near other helpers, before UI/server) ---

sanitize_for_dt <- function(dfx) {
  # If someone passed an htmlwidget, just hand it back untouched
  if (inherits(dfx, "htmlwidget") || inherits(dfx, "datatables")) return(dfx)
  
  if (!is.data.frame(dfx)) {
    dfx <- tryCatch(as.data.frame(dfx, stringsAsFactors = FALSE, check.names = FALSE),
                    error = function(e) dfx)
  }
  if (!is.data.frame(dfx)) return(dfx)
  
  dfx <- tibble::as_tibble(dfx)
  
  # Enhanced data sanitization with better error handling
  dfx <- tryCatch({
    dplyr::mutate(
      dfx,
      dplyr::across(where(~ inherits(.x, "POSIXt")), ~ format(.x, "%Y-%m-%d %H:%M:%S")),
      dplyr::across(where(~ inherits(.x, "Date")),    ~ format(.x, "%Y-%m-%d")),
      dplyr::across(where(is.factor), as.character),
      # Enhanced list column handling
      dplyr::across(where(is.list), ~ vapply(.x, function(z) {
        tryCatch({
          if (inherits(z, "shiny.tag") || inherits(z, "shiny.tag.list")) {
            as.character(htmltools::tagList(z))
          } else if (is.null(z) || length(z) == 0) {
            ""
          } else if (length(z) == 1) {
            as.character(z)
          } else {
            paste0(z, collapse = ", ")
          }
        }, error = function(e) "")
      }, FUN.VALUE = character(1))),
      # Ensure all columns are proper types for DT
      dplyr::across(where(is.logical), ~ ifelse(is.na(.x), "FALSE", ifelse(.x, "TRUE", "FALSE"))),
      dplyr::across(where(~ is.numeric(.x) && any(is.infinite(.x), na.rm = TRUE)), 
                    ~ ifelse(is.infinite(.x), ifelse(.x > 0, "Inf", "-Inf"), .x))
    )
  }, error = function(e) {
    message("Error in sanitize_for_dt mutate: ", conditionMessage(e))
    # Return the original data frame if mutation fails
    dfx
  })
  
  dfx
}

# Safe wrapper for compute_process_results with error handling
safe_compute_process_results <- function(df, mode = "All") {
  tryCatch({
    compute_process_results(df, mode)
  }, error = function(e) {
    message("Error in compute_process_results: ", conditionMessage(e))
    # Return a minimal data frame with expected structure
    tibble::tibble(
      PitchType = character(0),
      xWOBA = character(0),
      xISO = character(0),
      BABIP = character(0),
      `Barrel%` = character(0),
      `RV/100` = character(0),
      `GB%` = character(0),
      `CSW%` = character(0)
    )
  })
}

# Safe wrapper for make_summary with error handling (supports alternate grouping)
safe_make_summary <- function(df, group_col = "TaggedPitchType") {
  tryCatch({
    make_summary(df, group_col = group_col)
  }, error = function(e) {
    message("Error in make_summary (group_col = ", group_col, "): ", conditionMessage(e))
    # Return a minimal data frame with expected structure
    tibble::tibble(
      PitchType = character(0),
      PitchCount = integer(0),
      Usage = character(0),
      Overall = character(0),
      BF = integer(0),
      Velo_Avg = numeric(0),
      Velo_Max = numeric(0),
      IVB = numeric(0),
      HB = numeric(0),
      ReleaseTilt = character(0),
      BreakTilt = character(0),
      SpinEff = numeric(0),
      SpinRate = numeric(0),
      RelHeight = numeric(0),
      RelSide = numeric(0),
      VertApprAngle = numeric(0),
      HorzApprAngle = numeric(0),
      Extension = numeric(0),
      InZonePercent = character(0),
      CompPercent = character(0),
      KPercent = character(0),
      BBPercent = character(0),
      FPSPercent = character(0),
      EAPercent = character(0),
      StrikePercent = character(0),
      SwingPercent = character(0),
      WhiffPercent = character(0),
      QPPercent = character(0),
      EV = numeric(0),
      LA = numeric(0),
      `Stuff+` = numeric(0),
      `Ctrl+` = numeric(0),
      `QP+` = numeric(0),
      `Pitching+` = numeric(0)
    )
  })
}

datatable_with_colvis <- function(df, lock = character(0), remember = TRUE, default_visible = names(df), mode = NULL, enable_colors = TRUE) {
  # Enhanced error handling wrapper with validation
  tryCatch({
    # Validate input before processing
    if (!is.data.frame(df) || nrow(df) == 0 || ncol(df) == 0) {
      return(DT::datatable(data.frame(Message = "No data available"), options = list(dom = 't'), rownames = FALSE))
    }
    
    df <- sanitize_for_dt(df)
    
    # Wrap blank_ea_except_all in tryCatch to handle column mismatches gracefully
    df <- tryCatch({
      blank_ea_except_all(df)
    }, error = function(e) {
      message("Warning in blank_ea_except_all: ", e$message)
      df  # Return unchanged if error
    })
    
    default_visible <- intersect(default_visible, names(df))
    
    idx_lock   <- which(names(df) %in% lock) - 1
    all_idx0   <- seq_len(ncol(df)) - 1
    colvis_idx <- setdiff(all_idx0, idx_lock)
    
    defs <- list(
      list(className = "dt-center", targets = "_all"),
      list(targets = "_all", render = DT::JS(js_sort))
    )
    hide_idx <- which(!(names(df) %in% default_visible)) - 1
    if (length(hide_idx)) {
      defs <- c(defs, list(list(visible = FALSE, targets = hide_idx)))
    }
    idx_hash <- which(names(df) == "#") - 1
    if (length(idx_hash)) {
      defs <- c(defs, list(list(
        className = "dt-center clickable-cell",
        targets = idx_hash
      )))
    }
    # Force two-state sorting (asc/desc) on all columns to avoid inconsistent tri-state toggles
    defs <- c(defs, list(list(targets = "_all", orderSequence = c("asc", "desc"))))
    
    build_dt <- function(data) {
      data <- as.data.frame(data, stringsAsFactors = FALSE, check.names = FALSE)
      DT::datatable(
        data,
        rownames   = FALSE,
        extensions = c("Buttons","ColReorder","FixedHeader"),
        escape     = FALSE,
        options = list(
          dom           = "Bfrtip",
          buttons       = list(
            "pageLength",
            list(extend = "colvis", text = "Columns", columns = colvis_idx, postfixButtons = list("colvisRestore"))
          ),
          ordering      = TRUE,
          orderMulti    = TRUE,
          orderClasses  = TRUE,
          colReorder    = TRUE,
          fixedHeader   = TRUE,
          stateSave     = remember,
          stateDuration = -1,
          pageLength    = 10,
          autoWidth     = FALSE,    # Changed from TRUE - lets DataTables calculate proper widths
          scrollX       = TRUE,      # Enable horizontal scrolling
          scrollCollapse = TRUE,     # Allow scroll container to collapse
          columnDefs    = defs
        )
      )
    }
    
    dt <- build_dt(df)
    
    color_modes <- c("Process","Live","Results","Bullpen")
    if (identical(mode, "Usage")) {
      color_modes <- setdiff(color_modes, "Usage")
    }
    # Safe condition checking for color mode - now also checks for split column names
    # Allow colors for any split column (Count, BatterSide, PitcherThrows, InducedVert, HorzBreak, etc.)
    split_col_names <- c("Count", "BatterSide", "Batter Side", "PitcherThrows", "InducedVert", "HorzBreak", 
                         "PitcherSet", "Inning", "TaggedHitType", "Date", "Batter Hand", "After Count", 
                         "Velocity", "Batter")
    has_split_column <- any(split_col_names %in% names(df))
    
    enable_color_mode <- tryCatch({
      !is.null(enable_colors) && 
        !is.na(enable_colors) && 
        isTRUE(enable_colors) &&
        !is.null(mode) &&
        !is.na(mode) &&
        mode %in% color_modes && 
        ("Pitch" %in% names(df) || "Player" %in% names(df) || has_split_column)
    }, error = function(e) FALSE)
    
    if (enable_color_mode) {
      color_cols <- switch(
        mode,
        "Process" = c("InZone%","Comp%","Strike%","Swing%","FPS%","E+A%","QP%","Ctrl+","QP+","Pitching+","RV/100"),
        "Live"    = c("InZone%","Strike%","FPS%","E+A%","QP+","Ctrl+","Pitching+","K%","BB%","Whiff%"),
        "Results" = c("Whiff%","K%","BB%","CSW%","GB%","Barrel%","EV"),
        "Bullpen" = c("InZone%","Comp%","Ctrl+","Stuff+"),
        character(0)
      )
      available_cols <- intersect(color_cols, names(df))
      if (length(available_cols)) {
        df_styled <- as.data.frame(df, stringsAsFactors = FALSE, check.names = FALSE)
        styling_failed <- FALSE
        # Use "all" color scale when split by options other than Pitch are used
        safe_pitch <- if ("Player" %in% names(df_styled) || has_split_column) "all" else NULL
        tryCatch({
          for (col in available_cols) {
            for (i in seq_len(nrow(df_styled))) {
              cell <- df_styled[[col]][i]
              # Check for null, NA, or empty values safely
              cell_check <- tryCatch({
                is.null(cell) || 
                  (length(cell) == 1 && is.na(cell)) || 
                  (length(cell) == 1 && !nzchar(as.character(cell)))
              }, error = function(e) TRUE)
              
              if (cell_check) next
              
              # Safe pitch type extraction with NA protection
              pitch_val <- tryCatch({
                if ("Pitch" %in% names(df_styled) && i <= nrow(df_styled)) {
                  df_styled$Pitch[i]
                } else {
                  NULL
                }
              }, error = function(e) NULL)
              
              pitch_type <- tryCatch({
                if (!is.null(safe_pitch)) {
                  safe_pitch
                } else if (!is.null(pitch_val) && !is.na(pitch_val) && nzchar(as.character(pitch_val))) {
                  as.character(pitch_val)
                } else {
                  "all"
                }
              }, error = function(e) "all")
              
              colors <- get_color_scale(cell, col, pitch_type)
              df_styled[[col]][i] <- paste0(
                '<span style="background-color:', colors$bg,
                '; color:', colors$text,
                '; padding: 2px 4px; border-radius: 3px; display:inline-block; width:100%; text-align:center;">',
                cell, '</span>'
              )
            }
          }
        }, error = function(e) {
          styling_failed <<- TRUE
          msg_mode <- mode %||% "unknown"
          message("datatable_with_colvis color error [mode=", msg_mode, "]: ", conditionMessage(e))
        })
        if (!styling_failed) {
          dt <- build_dt(df_styled)
        }
      }
    }
    
    dt
    
  }, error = function(e) {
    message("datatable_with_colvis error: ", conditionMessage(e))
    # Return a fallback datatable with error message
    DT::datatable(
      data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
      options = list(dom = 't'), rownames = FALSE
    )
  })
}

# Default column sets for the table-mode toggle
stuff_cols        <- c("Pitch","#","Velo","Max","IVB","HB","rTilt","bTilt","SpinEff","Spin","Height","Side","Ext","VAA","HAA","Stuff+")
process_cols      <- c("Pitch","#","BF","RV/100","InZone%","Comp%","Strike%","Swing%","FPS%","E+A%","QP%","Ctrl+","QP+","Pitching+")
results_cols      <- c("Pitch","#","BF","K%","BB%","GB%","Barrel%","Whiff%","CSW%","EV","LA")
results_cols_live <- c("Pitch","#","BF","K%","BB%","GB%","Whiff%","CSW%","EV","LA","Pitching+")
bullpen_cols      <- c("Pitch","#","Velo","Max","IVB","HB","Spin","bTilt","Height","Side","Ext","InZone%","Comp%","Ctrl+","Stuff+")
live_cols         <- c("Pitch","#","Velo","Max","IVB","HB","FPS%","E+A%","InZone%","Strike%","Whiff%","K%","BB%","QP+")
usage_cols        <- c("Pitch","#","Usage","0-0","Behind","Even","Ahead","<2K","2K")
perf_cols         <- c("Pitch","#","BF","RV/100","InZone%","Comp%","Strike%","FPS%","E+A%","K%","BB%","Whiff%","CSW%","EV","LA","Ctrl+","QP+","Pitching+")

# ---- unified list for the pickers + a helper to compute visibility
all_table_cols <- unique(c(stuff_cols, process_cols, results_cols, results_cols_live, bullpen_cols, live_cols, usage_cols, perf_cols, "Overall"))

visible_set_for <- function(mode, custom = character(0), session_type = NULL) {
  if (identical(mode, "Process")) return(process_cols)
  if (identical(mode, "Results")) return(results_cols)
  if (identical(mode, "Bullpen")) return(bullpen_cols)
  if (identical(mode, "Live"))    return(live_cols)
  if (identical(mode, "Usage"))   return(usage_cols)
  if (identical(mode, "Raw Data")) return(c("Pitch","IP","P","BF","P/IP","P/BF","H","XBH","Barrels","BB","HBP","K","Whiffs"))
  if (identical(mode, "Custom"))  return(c("Pitch", custom[!duplicated(custom)]))
  stuff_cols
}

# ---- Custom table storage (shared across suites) ----
custom_tables_file <- "custom_tables.json"
custom_tables <- reactiveVal(list())
load_custom_tables <- function() {
  db_ct <- load_custom_tables_db()
  if (length(db_ct)) return(db_ct)
  if (file.exists(custom_tables_file)) {
    out <- tryCatch(jsonlite::fromJSON(custom_tables_file, simplifyVector = TRUE), error = function(e) NULL)
    if (is.list(out)) {
      out <- lapply(out, function(v) {
        if (is.null(v$school_code)) v$school_code <- current_school()
        v
      })
      out <- out[vapply(out, function(v) v$school_code %in% allowed_school_codes(), logical(1))]
      return(out)
    }
  }
  list()
}
save_custom_tables <- function(x) {
  x <- lapply(x, function(v) {
    if (is.null(v$school_code)) v$school_code <- current_school()
    v
  })
  tryCatch({
    save_custom_tables_db(x)
    # lightweight file backup for convenience
    jsonlite::write_json(x, custom_tables_file, auto_unbox = TRUE, pretty = TRUE)
  }, error = function(e) {
    message("Failed to save custom tables: ", e$message)
  })
}
custom_tables(load_custom_tables())

update_custom_table_choices <- function(session) {
  nms <- names(custom_tables())
  base_modes <- c("Stuff","Process","Results","Swing Decisions","Bullpen","Live","Usage","Raw Data","Batted Ball Data")
  pitch_modes <- setdiff(base_modes, "Swing Decisions")
  safe_update <- function(id) {
    try(updateSelectInput(session, id, choices = c("", nms)), silent = TRUE)
  }
  for (id in c(
    "summaryCustomSaved","dpCustomSaved",
    "cmpA_customSaved","cmpB_customSaved",
    "pp_goal1_customSaved","pp_goal2_customSaved","pp_goal3_customSaved"
  )) safe_update(id)
  # Update table-mode dropdowns to include saved customs (custom always last)
  try(updateSelectInput(session, "summaryTableMode", choices = c(pitch_modes, nms, "Custom"), selected = NULL), silent = TRUE)
  try(updateSelectInput(session, "dpTableMode",       choices = c(pitch_modes, nms, "Custom"), selected = NULL), silent = TRUE)
  for (id in c("cmpA_tableMode","cmpB_tableMode","lbMode")) {
    try(updateSelectInput(session, id, choices = c(base_modes, nms, "Custom"), selected = NULL), silent = TRUE)
  }
}

# Helper to resolve custom table modes (works globally)
resolve_table_mode_global <- function(mode_in, custom_cols_in) {
  ct <- custom_tables()
  if (!is.null(mode_in) && mode_in %in% names(ct)) {
    cols <- ct[[mode_in]]$cols %||% character(0)
    return(list(mode = "Custom", cols = cols))
  }
  list(mode = mode_in %||% "Stuff", cols = custom_cols_in %||% character(0))
}

# ---- Leaderboard: visible set helper (swap Pitch -> Player, drop Overall) ----
visible_set_for_lb <- function(mode, custom = character(0)) {
  v <- visible_set_for(mode, custom)
  v[v == "Pitch"] <- "Player"
  unique(setdiff(v, "Overall"))
}

# -------------------------
# Custom Reports persistence
# -------------------------
custom_reports_file <- "custom_reports.json"
load_custom_reports <- function() {
  db_cr <- load_custom_reports_db()
  if (length(db_cr)) return(db_cr)
  if (file.exists(custom_reports_file)) {
    out <- tryCatch(jsonlite::fromJSON(custom_reports_file, simplifyVector = TRUE), error = function(e) NULL)
    if (is.list(out)) {
      out <- lapply(out, function(v) {
        if (is.null(v$school_code)) v$school_code <- current_school()
        v
      })
      out <- out[vapply(out, function(v) v$school_code %in% allowed_school_codes(), logical(1))]
      return(out)
    }
  }
  list()
}
save_custom_reports <- function(x) {
  x <- lapply(x, function(v) {
    if (is.null(v$school_code)) v$school_code <- current_school()
    v
  })
  tryCatch({
    save_custom_reports_db(x)
    jsonlite::write_json(x, custom_reports_file, auto_unbox = TRUE, pretty = TRUE)
  }, error = function(e) {
    message("Failed to save custom reports: ", e$message)
  })
}
custom_reports_store <- reactiveVal(load_custom_reports())

get_color_scale <- function(value, column_name, pitch_type) {
  # normalize pitch type (fallback to "all" when unknown) - safe checks
  pitch_type <- tryCatch({
    if (length(pitch_type) == 0 || is.na(pitch_type) || !nzchar(as.character(pitch_type))) {
      "all"
    } else {
      tolower(as.character(pitch_type))
    }
  }, error = function(e) "all")
  
  # strip percent/extra chars and coerce to numeric for comparisons - safe checks
  value <- tryCatch({
    if (is.character(value)) {
      val <- gsub("[%\\s]", "", value)
      suppressWarnings(as.numeric(val))
    } else {
      as.numeric(value)
    }
  }, error = function(e) NA_real_)
  
  # Safe value validation
  value_check <- tryCatch({
    length(value) == 0 || is.na(value) || !is.finite(value)
  }, error = function(e) TRUE)
  
  if (value_check) {
    return(list(bg = "white", text = "black"))
  }
  
  thresholds <- get_process_thresholds(column_name, pitch_type)
  if (is.null(thresholds)) return(list(bg = "white", text = "black"))
  poor <- thresholds$poor
  avg  <- thresholds$avg
  great <- thresholds$great
  
  reverse_scale <- column_name %in% c("EV","Barrel%","BB%","RV/100")
  if (reverse_scale) {
    if (value >= poor) return(list(bg = "#0066CC", text = "white"))
    if (value >= (poor + avg)/2) return(list(bg = "#66B2FF", text = "black"))
    if (value >= avg) return(list(bg = "#FFFFFF", text = "black"))
    if (value >= (avg + great)/2) return(list(bg = "#FFB3B3", text = "black"))
    if (value >= great) return(list(bg = "#FF6666", text = "white"))
    return(list(bg = "#CC0000", text = "white"))
  }
  
  if (value <= poor) return(list(bg = "#0066CC", text = "white"))
  if (value <= (poor + avg)/2) return(list(bg = "#66B2FF", text = "black"))
  if (value <= avg) return(list(bg = "#FFFFFF", text = "black"))
  if (value <= (avg + great)/2) return(list(bg = "#FFB3B3", text = "black"))
  if (value <= great) return(list(bg = "#FF6666", text = "white"))
  list(bg = "#CC0000", text = "white")
}

get_process_thresholds <- function(column_name, pitch_type) {
  pitch_type <- tolower(as.character(pitch_type))
  if (column_name == "InZone%") {
    if (pitch_type %in% c("fastball","sinker")) return(list(poor = 43, avg = 50, great = 57))
    if (pitch_type %in% c("cutter","slider","sweeper","curveball")) return(list(poor = 37, avg = 43, great = 49))
    if (pitch_type %in% c("changeup","splitter","knuckleball")) return(list(poor = 30, avg = 37, great = 44))
    if (pitch_type == "all") return(list(poor = 42, avg = 47, great = 52))
  }
  if (column_name == "Comp%") {
    if (pitch_type %in% c("fastball","sinker")) return(list(poor = 79, avg = 83, great = 87))
    if (pitch_type %in% c("cutter","slider","sweeper","curveball")) return(list(poor = 70, avg = 76, great = 82))
    if (pitch_type %in% c("changeup","splitter","knuckleball")) return(list(poor = 65, avg = 74, great = 83))
    if (pitch_type == "all") return(list(poor = 76, avg = 79, great = 82))
  }
  if (column_name == "Strike%") return(list(poor = 57, avg = 62, great = 67))
  if (column_name == "Swing%") {
    if (pitch_type %in% c("fastball","sinker")) return(list(poor = 40, avg = 44, great = 48))
    if (pitch_type %in% c("cutter","slider","sweeper")) return(list(poor = 37, avg = 43, great = 49))
    if (pitch_type == "curveball") return(list(poor = 28, avg = 35, great = 42))
    if (pitch_type %in% c("changeup","splitter")) return(list(poor = 43, avg = 47, great = 51))
    if (pitch_type == "all") return(list(poor = 40, avg = 45, great = 50))
  }
  if (column_name == "FPS%") return(list(poor = 55, avg = 60, great = 65))
  if (column_name == "E+A%" && pitch_type == "all") return(list(poor = 65, avg = 70, great = 75))
  if (column_name == "QP%") return(list(poor = 38, avg = 48, great = 58))
  if (column_name == "Ctrl+") return(list(poor = 75, avg = 85, great = 95))
  if (column_name == "QP+") return(list(poor = 75, avg = 90, great = 105))
  if (column_name == "Pitching+") return(list(poor = 80, avg = 95, great = 110))
  if (column_name == "K%" && pitch_type == "all") return(list(poor = 18, avg = 23, great = 28))
  if (column_name == "BB%" && pitch_type == "all") return(list(poor = 11, avg = 9, great = 7))
  if (column_name == "Whiff%") {
    if (pitch_type == "fastball") return(list(poor = 18, avg = 22, great = 26))
    if (pitch_type == "sinker") return(list(poor = 9, avg = 13, great = 17))
    if (pitch_type == "cutter") return(list(poor = 22, avg = 27, great = 32))
    if (pitch_type %in% c("sweeper","curveball","slider","changeup","splitter")) return(list(poor = 29, avg = 35, great = 41))
    if (pitch_type == "all") return(list(poor = 21, avg = 26, great = 31))
  }
  if (column_name == "CSW%") {
    if (pitch_type %in% c("fastball","sinker")) return(list(poor = 23, avg = 27, great = 31))
    if (pitch_type %in% c("cutter","slider","sweeper","curveball")) return(list(poor = 29, avg = 32, great = 35))
    if (pitch_type %in% c("splitter","changeup")) return(list(poor = 22, avg = 28, great = 34))
    if (pitch_type == "all") return(list(poor = 26, avg = 29, great = 32))
  }
  if (column_name == "GB%") {
    if (pitch_type == "fastball") return(list(poor = 31, avg = 39, great = 47))
    if (pitch_type == "sinker") return(list(poor = 43, avg = 54, great = 65))
    if (pitch_type %in% c("cutter","slider","sweeper","curveball")) return(list(poor = 36, avg = 43, great = 50))
    if (pitch_type %in% c("changeup","splitter")) return(list(poor = 35, avg = 47, great = 59))
    if (pitch_type == "all") return(list(poor = 38, avg = 43, great = 48))
  }
  if (column_name == "Barrel%") return(list(poor = 20, avg = 15, great = 10))
  if (column_name == "EV") return(list(poor = 95, avg = 85, great = 75))
  if (column_name == "Stuff+") return(list(poor = 90, avg = 100, great = 110))
  if (column_name == "RV/100") {
    # lower is better for RV/100
    if (pitch_type == "fastball")   return(list(poor = 1.5, avg = 0.7,  great = -0.1))
    if (pitch_type == "sinker")     return(list(poor = 2.3, avg = 0.9,  great = -0.5))
    if (pitch_type == "cutter")     return(list(poor = 0.9, avg = -0.2, great = -1.3))
    if (pitch_type == "slider")     return(list(poor = -0.4, avg = -1.1, great = -1.8))
    if (pitch_type == "curveball")  return(list(poor = -0.1, avg = -1.3, great = -2.5))
    if (pitch_type == "changeup")   return(list(poor = 0.7, avg = -0.5, great = -1.7))
    if (pitch_type == "splitter")   return(list(poor = 0.0, avg = -1.4, great = -2.8))
    # default / All
    return(list(poor = 0.7, avg = 0.0, great = -0.7))
  }
  NULL
}

# ---- Local helpers (self-contained) ----
.s_nz_mean <- function(x) {
  x <- suppressWarnings(as.numeric(x))
  if (!length(x)) return(NA_real_)
  m <- mean(x, na.rm = TRUE)
  if (is.nan(m)) NA_real_ else m
}
.s_safe_div <- function(num, den) {
  num <- suppressWarnings(as.numeric(num))
  den <- suppressWarnings(as.numeric(den))
  ifelse(is.finite(den) & den != 0, num/den, NA_real_)
}
.s_fmt_pct1 <- function(num, den) {
  p <- .s_safe_div(num, den)
  ifelse(is.finite(p), paste0(round(100*p, 1), "%"), "")
}
.s_ip_fmt <- function(ip_num) {
  if (!is.finite(ip_num)) return(NA_character_)
  outs <- round(ip_num * 3)
  paste0(outs %/% 3, ".", outs %% 3)
}
.s_to_date <- function(x) {
  # Accept Date, POSIX, numeric serial (Excel), ISO, and m/d/y
  if (inherits(x, "Date")) return(x)
  if (inherits(x, "POSIXt")) return(as.Date(x))
  # try numeric Excel serial
  num <- suppressWarnings(as.numeric(x))
  out <- rep(as.Date(NA), length(x))
  if (any(!is.na(num))) {
    is_serial <- !is.na(num) & num > 20000 & num < 60000
    out[is_serial] <- as.Date(num[is_serial], origin = "1899-12-30")
  }
  # try ISO
  bad <- is.na(out)
  if (any(bad)) {
    out[bad] <- suppressWarnings(as.Date(x[bad]))
    bad <- is.na(out)
  }
  # try m/d/y
  if (any(bad)) {
    out[bad] <- suppressWarnings(as.Date(x[bad], format = "%m/%d/%Y"))
    bad <- is.na(out)
    if (any(bad)) out[bad] <- suppressWarnings(as.Date(x[bad], format = "%m/%d/%y"))
  }
  out
}

# --- Shared BF (Batters Faced) calculation ---
# Counts PAs that start at 0-0 and only include them if the final pitch
# ends in a Strikeout/Walk (KorBB) or has a non-Undefined PlayResult.
calculate_bf <- function(df) {
  if (!nrow(df)) return(0L)
  
  balls   <- suppressWarnings(as.numeric(df$Balls))
  strikes <- suppressWarnings(as.numeric(df$Strikes))
  valid   <- is.finite(balls) & is.finite(strikes)
  if (!any(valid)) return(0L)
  
  prev_valid <- c(FALSE, head(valid, -1))
  new_pa     <- valid & ((balls == 0 & strikes == 0) | !prev_valid)
  pa_id      <- cumsum(ifelse(valid, new_pa, FALSE))
  if (any(valid) && pa_id[valid][1] == 0) pa_id[valid] <- pa_id[valid] + 1L
  if (all(pa_id[valid] == 0)) pa_id[valid] <- 1L
  pa_id[!valid] <- NA_integer_
  
  # Identify last pitch per PA
  last_idx <- ave(seq_len(nrow(df)), pa_id, FUN = function(idx) rep(max(idx), length(idx)))
  is_last  <- seq_len(nrow(df)) == last_idx
  
  playres <- as.character(df$PlayResult)
  korbb   <- as.character(df$KorBB)
  terminal_ok <- (!is.na(playres) & playres != "Undefined") |
    (!is.na(korbb) & korbb %in% c("Strikeout","Walk"))
  
  last_ok <- is_last & terminal_ok
  if (!any(!is.na(pa_id))) return(0L)
  valid_pa <- !is.na(pa_id)
  pa_vec   <- pa_id[valid_pa]
  last_vec <- last_ok[valid_pa]
  sum(tapply(last_vec, pa_vec, function(x) any(x, na.rm = TRUE)), na.rm = TRUE)
}

# BF helper used elsewhere; now just calls the unified calculation
calculate_completed_bf <- function(df) calculate_bf(df)

# BF that only counts completed PAs (Live only) — helps avoid partial/empty PAs
calculate_completed_bf <- function(df) {
  d <- df %>% dplyr::filter(SessionType == "Live")
  if (!nrow(d)) return(0L)
  
  balls   <- suppressWarnings(as.numeric(d$Balls))
  strikes <- suppressWarnings(as.numeric(d$Strikes))
  valid   <- is.finite(balls) & is.finite(strikes)
  if (!any(valid)) return(0L)
  
  prev_valid <- c(FALSE, head(valid, -1))
  new_pa     <- valid & ((balls == 0 & strikes == 0) | !prev_valid)
  pa_id      <- cumsum(ifelse(valid, new_pa, FALSE))
  if (any(valid) && pa_id[valid][1] == 0) pa_id[valid] <- pa_id[valid] + 1L
  if (all(pa_id[valid] == 0)) pa_id[valid] <- 1L
  pa_id[!valid] <- NA_integer_
  
  pf <- compute_pa_flags(d)
  is_terminal <- pf$is_terminal
  if (length(is_terminal) != length(pa_id)) is_terminal <- rep(FALSE, length(pa_id))
  
  completed_pa <- tapply(is_terminal, pa_id, function(x) any(x, na.rm = TRUE))
  completed_pa <- completed_pa[!is.na(names(completed_pa))]
  sum(as.logical(completed_pa), na.rm = TRUE)
}

# --- Keep Process tables in canonical order: "#, BF, Usage, ..."
enforce_process_order <- function(df) {
  if (all(c("#","BF") %in% names(df)))   df <- dplyr::relocate(df, `BF`, .after = `#`)
  if (all(c("BF","RV/100") %in% names(df))) df <- dplyr::relocate(df, `RV/100`, .after = `BF`)
  if (all(c("RV/100","Usage") %in% names(df))) df <- dplyr::relocate(df, Usage, .after = `RV/100`)
  else if (all(c("BF","Usage") %in% names(df))) df <- dplyr::relocate(df, Usage, .after = `BF`)
  if (all(c("E+A%","QP%") %in% names(df))) df <- dplyr::relocate(df, `QP%`, .after = `E+A%`)
  df
}

# --- Ensure the “All” row has QP% populated (using the current data frame) ---
fill_all_qp_pct <- function(df_table, src_df) {
  if (missing(src_df) || is.null(src_df) || !is.data.frame(src_df) || !nrow(src_df)) return(df_table)
  if (!("QP%" %in% names(df_table))) return(df_table)
  
  idx <- rep(FALSE, nrow(df_table))
  
  # Look across common split columns first
  for (col in c("Pitch","PitchType","SplitColumn","Player")) {
    if (col %in% names(df_table)) {
      val <- tolower(as.character(df_table[[col]]))
      clean <- gsub("[^a-z0-9]+", "", val)
      idx <- idx | val == "all" | grepl("^all\\b", val) | grepl("^all", clean) | clean == "overall"
    }
  }
  
  # If still none, scan all character columns for an "all"-like label
  if (!any(idx)) {
    char_cols <- vapply(df_table, is.character, logical(1))
    if (any(char_cols)) {
      vals <- apply(df_table[, char_cols, drop = FALSE], 2, function(v) tolower(as.character(v)))
      if (is.vector(vals)) vals <- matrix(vals, ncol = 1)
      clean_vals <- apply(vals, 2, function(v) gsub("[^a-z0-9]+", "", v))
      idx <- apply(vals, 1, function(row) any(grepl("^all", row) | row %in% c("all","all players","all pitchers","all pitch types","(all pitch types)"))) |
        apply(clean_vals, 1, function(row) any(grepl("^all", row) | row == "overall"))
    }
  }
  
  missing_qp <- which(is.na(df_table$`QP%`) | df_table$`QP%` == "")
  idx_any <- isTRUE(any(idx))
  if (!idx_any && length(missing_qp) == 1) {
    idx[missing_qp] <- TRUE
  }
  if (!idx_any && length(missing_qp) > 1) {
    idx[missing_qp] <- TRUE
  }
  if (!isTRUE(any(idx))) return(df_table)
  
  qp_val <- safe_pct(
    sum((compute_qp_points(src_df) * 200) >= 100, na.rm = TRUE),
    nrow(src_df)
  )
  df_table$`QP%`[idx] <- qp_val
  df_table
}

# --- Keep Stuff tables with Ext immediately after Side
enforce_stuff_order <- function(df) {
  # Normalize name if some paths still call it "Extension"
  if ("Extension" %in% names(df) && !("Ext" %in% names(df))) {
    df <- dplyr::rename(df, Ext = Extension)
  }
  if (all(c("Side","Ext") %in% names(df))) {
    df <- dplyr::relocate(df, Ext, .after = Side)
  }
  df
}

# Visible set when we group by Date instead of Pitch
visible_set_for_date <- function(mode, custom = character(0)) {
  base <- if (exists("visible_set_for")) visible_set_for(mode, custom) else names(data.frame())
  base[base == "Pitch"] <- "Date"
  setdiff(base, "Usage")
}

# Build the by-date table (averages & rates), honoring Live/Bullpen via filtered_logs()
make_session_logs_table <- function(df) {
  if (!nrow(df)) return(tibble::tibble())
  
  # Pull a FIP constant if available, otherwise 0 (so it never errors)
  fipc <- if (!is.null(get0("FIP_C"))) get0("FIP_C") else if (!is.null(get0("FIP_CONST"))) get0("FIP_CONST") else 0
  
  # Zone bounds (fallbacks in case globals aren’t visible yet)
  zl <- if (!is.null(get0("ZONE_LEFT")))   get0("ZONE_LEFT")   else -0.83
  zr <- if (!is.null(get0("ZONE_RIGHT")))  get0("ZONE_RIGHT")  else  0.83
  zb <- if (!is.null(get0("ZONE_BOTTOM"))) get0("ZONE_BOTTOM") else  1.5
  zt <- if (!is.null(get0("ZONE_TOP")))    get0("ZONE_TOP")    else  3.5
  
  swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
  
  # Normalize a Date column, regardless of source name
  if (!("Date" %in% names(df))) {
    cand <- intersect(c("GameDate","SessionDate","date","DATE"), names(df))
    if (length(cand)) {
      df$Date <- df[[cand[1]]]
    }
  }
  df$Date <- .s_to_date(df$Date)
  
  # Group and compute
  by_date <- df %>%
    dplyr::filter(!is.na(Date)) %>%
    dplyr::group_by(Date) %>%
    dplyr::group_map(~{
      d <- .x
      
      # PA proxy for Live (first-pitch opportunities)
      PAt      <- sum(d$SessionType == "Live" & d$Balls == 0 & d$Strikes == 0, na.rm = TRUE)
      HBP_all  <- sum(d$PlayResult == "HitByPitch", na.rm = TRUE)
      Sac_all  <- sum(d$PlayResult == "Sacrifice",  na.rm = TRUE)
      H1       <- sum(d$PlayResult == "Single",     na.rm = TRUE)
      H2       <- sum(d$PlayResult == "Double",     na.rm = TRUE)
      H3       <- sum(d$PlayResult == "Triple",     na.rm = TRUE)
      HR       <- sum(d$PlayResult == "HomeRun",    na.rm = TRUE)
      H        <- H1 + H2 + H3 + HR
      Kct_all  <- sum(d$KorBB == "Strikeout" |
                        d$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
      BBc_all  <- sum(d$KorBB == "Walk" | d$PlayResult == "Walk", na.rm = TRUE)
      ABt      <- PAt - (BBc_all + HBP_all + Sac_all)
      
      # Swings/whiffs
      swings   <- sum(!is.na(d$PitchCall) & d$PitchCall %in% swing_levels, na.rm = TRUE)
      whiffs   <- sum(d$PitchCall == "StrikeSwinging", na.rm = TRUE)
      
      # EV/LA from live balls in play
      bbe      <- d %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
      ev_all   <- .s_nz_mean(bbe$ExitSpeed)
      la_all   <- .s_nz_mean(bbe$Angle)
      
      # IP/FIP/WHIP
      Outs_all <- (ABt - H) + Sac_all
      IP_all   <- .s_safe_div(Outs_all, 3)
      FIP_all  <- { tmp <- .s_safe_div(13*HR + 3*(BBc_all + HBP_all) - 2*Kct_all, IP_all)
      ifelse(is.finite(tmp), round(tmp + fipc, 2), NA_real_) }
      WHIP_all <- { tmp <- .s_safe_div(H + BBc_all, IP_all)
      ifelse(is.finite(tmp), round(tmp, 2), NA_real_) }
      
      # Command score (“Ctrl+”) with your 1.47 / 0.73 scoring
      scores <- ifelse(
        d$PlateLocSide  >= zl  & d$PlateLocSide  <= zr &
          d$PlateLocHeight>= zb  & d$PlateLocHeight<= zt, 1.47,
        ifelse(
          d$PlateLocSide >= -1.5 & d$PlateLocSide <= 1.5 &
            d$PlateLocHeight>= (2.65 - 1.5) & d$PlateLocHeight <= (2.65 + 1.5),
          0.73, 0
        )
      )
      ctrl_all  <- round(mean(scores, na.rm = TRUE) * 100, 1)
      stuff_all <- round(.s_nz_mean(d$`Stuff+`), 1)
      
      # QP+ scalar — use your real one if available; else NA
      qp_points <- compute_qp_points(d)
      qp_all <- if (!is.null(get0("safe_qp_scalar"))) get0("safe_qp_scalar")(d) else NA_real_
      qp_pct <- .s_fmt_pct1(sum((qp_points * 200) >= 100, na.rm = TRUE), nrow(d))
      pitc_all <- round(.s_nz_mean(c(stuff_all, qp_all)), 1)
      
      tibble::tibble(
        Date     = as.Date(d$Date[1]),
        `#`      = nrow(d),
        Usage    = "",
        BF       = PAt,
        IP       = .s_ip_fmt(IP_all),
        FIP      = FIP_all,
        WHIP     = WHIP_all,
        Velo     = .s_nz_mean(d$RelSpeed),
        Max      = suppressWarnings(max(d$RelSpeed, na.rm = TRUE)),
        IVB      = .s_nz_mean(d$InducedVertBreak),
        HB       = .s_nz_mean(d$HorzBreak),
        rTilt    = .s_nz_mean(d$ReleaseTilt),
        bTilt    = .s_nz_mean(d$BreakTilt),
        SpinEff  = .s_nz_mean(d$SpinEfficiency),
        Spin     = .s_nz_mean(d$SpinRate),
        Height   = .s_nz_mean(d$RelHeight),
        Side     = .s_nz_mean(d$RelSide),
        VAA      = .s_nz_mean(d$VertApprAngle),
        HAA      = .s_nz_mean(d$HorzApprAngle),
        Ext      = .s_nz_mean(d$Extension),
        `InZone%`= .s_safe_div(
          sum(d$PlateLocSide >= zl & d$PlateLocSide <= zr &
                d$PlateLocHeight >= zb & d$PlateLocHeight <= zt, na.rm = TRUE),
          nrow(d)
        ),
        `Comp%`  = .s_safe_div(
          sum(d$PlateLocSide >= -1.5 & d$PlateLocSide <= 1.5 &
                d$PlateLocHeight >= (2.65 - 1.5) & d$PlateLocHeight <= (2.65 + 1.5), na.rm = TRUE),
          nrow(d)
        ),
        `Strike%`= .s_safe_div(
          sum(d$PitchCall %in% c("StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"),
              na.rm = TRUE),
          nrow(d)
        ),
        `FPS%`   = .s_fmt_pct1(
          sum(d$Balls==0 & d$Strikes==0 &
                d$PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","StrikeCalled"),
              na.rm = TRUE),
          sum(d$Balls==0 & d$Strikes==0, na.rm = TRUE)
        ),
        `E+A%`   = .s_fmt_pct1(
          sum(d$SessionType=="Live" & (
            (d$Balls==0 & d$Strikes==0 & d$PitchCall=="InPlay") |
              (d$Balls==0 & d$Strikes==1 & d$PitchCall %in% c("InPlay","FoulBallNotFieldable", "FoulBallFieldable","StrikeSwinging","StrikeCalled")) |
              (d$Balls==1 & d$Strikes==0 & d$PitchCall=="InPlay") |
              (d$Balls==1 & d$Strikes==1 & d$PitchCall %in% c("InPlay","FoulBallNotFieldable","StrikeSwinging","StrikeCalled", "FoulBallFieldable"))
          ), na.rm = TRUE),
          sum(d$SessionType=="Live" & d$Balls==0 & d$Strikes==0, na.rm = TRUE)
        ),
        `QP%`    = qp_pct,
        `K%`     = .s_safe_div(Kct_all, PAt),
        `BB%`    = .s_safe_div(BBc_all, PAt),
        `Whiff%` = .s_safe_div(whiffs, swings),
        `CSW%` = .s_safe_div(
          sum(d$PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE),
          nrow(d)
        ),
        EV       = ev_all,
        LA       = la_all,
        `Stuff+` = stuff_all,
        `Ctrl+`  = ctrl_all,
        `QP+`    = qp_all,
        `Pitching+` = pitc_all
      )
    }) %>%
    dplyr::bind_rows() %>%
    dplyr::arrange(dplyr::desc(Date))
  
  by_date
}

assign_where <- function(vec, cond, value) {
  idx <- which(!is.na(cond) & cond)
  if (length(idx)) vec[idx] <- value
  vec
}

# ----- Hover tooltip helpers -----
inzone_label <- function(side, height) {
  comp   <- !is.na(side) & !is.na(height) &
    side >= -1.5 & side <= 1.5 &
    height >= (2.65 - 1.5) & height <= (2.65 + 1.5)
  inzone <- !is.na(side) & !is.na(height) &
    side >= ZONE_LEFT & side <= ZONE_RIGHT &
    height >= ZONE_BOTTOM & height <= ZONE_TOP
  ifelse(inzone, "Yes", ifelse(comp, "Competitive", "No"))
}

# ---- NEW: display helpers ----
# ---- NEW: display helpers (can live near other helpers) ----
fmt_rate3 <- function(x) {
  x <- suppressWarnings(as.numeric(x))
  s <- ifelse(is.finite(x), sprintf("%.3f", x), "")
  sub("^0\\.", ".", s)  # .303 style (no leading 0) for 0.xxx
}
fmt_num2  <- function(x) ifelse(is.finite(x), sprintf("%.2f", x), "")
fmt_pct1  <- function(num, den) {
  num <- suppressWarnings(as.numeric(num)); den <- suppressWarnings(as.numeric(den))
  if (is.finite(den) && den > 0 && is.finite(num)) paste0(round(100*num/den, 1), "%") else ""
}

make_hover_tt <- function(df) {
  paste0(
    "Session: ", as.character(df$SessionType),
    "<br>Velo: ", ifelse(is.na(df$RelSpeed), "", sprintf("%.1f mph", df$RelSpeed)),
    "<br>IVB: " , ifelse(is.na(df$InducedVertBreak), "", sprintf("%.1f in", df$InducedVertBreak)),
    "<br>HB: "  , ifelse(is.na(df$HorzBreak), "", sprintf("%.1f in", df$HorzBreak)),
    "<br>Stuff+: ", ifelse(is.na(df$`Stuff+`), "", sprintf("%.1f", df$`Stuff+`)),
    "<br>In Zone: ", inzone_label(df$PlateLocSide, df$PlateLocHeight)
  )
}

make_release_tt <- function(df) {
  paste0(
    "Session: ", as.character(df$SessionType),
    "<br>Height: ", ifelse(is.na(df$RelHeight), "", sprintf("%.2f ft", df$RelHeight)),
    "<br>Side: ", ifelse(is.na(df$RelSide), "", sprintf("%.2f ft", df$RelSide)),
    "<br>Extension: ", ifelse(is.na(df$Extension), "", sprintf("%.2f ft", df$Extension))
  )
}


# ---- Outcomes & helpers (GLOBAL) ----
result_levels <- c(
  "Called Strike", "Ball", "Foul", "Whiff",
  "In Play (Out)", "In Play (Hit)",
  "Single", "Double", "Triple", "HomeRun", "Error"
)

# Hitting play results (for spray charts)
hit_levels <- c("Single", "Double", "Triple", "HomeRun")

shape_map <- c(
  "Called Strike" = 19,  # filled circle
  "Ball"          = 1,   # hollow circle
  "Foul"          = 2,   # hollow triangle
  "Whiff"         = 8,   # star
  "In Play (Out)" = 17,  # filled triangle
  "In Play (Hit)" = 15,  # filled square
  "Single"        = 15,  # use In Play (Hit) icon
  "Double"        = 15,  # use In Play (Hit) icon
  "Triple"        = 15,  # use In Play (Hit) icon
  "HomeRun"       = 15,  # use In Play (Hit) icon
  "Error"         = 0    # hollow square
)

# Hitting shape map (for location plots with hitting data)
hit_shape_map <- c(
  "Called Strike" = 19,
  "Ball"          = 1,
  "Foul"          = 2,
  "Whiff"         = 8,
  "In Play"       = 17,
  "Error"         = 0
)

compute_result <- function(pitch_call, play_result) {
  dplyr::case_when(
    pitch_call == "StrikeCalled" ~ "Called Strike",
    pitch_call == "BallCalled"   ~ "Ball",
    pitch_call %in% c("FoulBallNotFieldable","FoulBallFieldable") ~ "Foul",
    pitch_call == "StrikeSwinging" ~ "Whiff",
    pitch_call == "InPlay" & play_result %in% c("Out","FieldersChoice","Sacrifice") ~ "In Play (Out)",
    pitch_call == "InPlay" & play_result %in% c("Single","Double","Triple","HomeRun")       ~ "In Play (Hit)",
    pitch_call == "InPlay" & play_result == "Error" ~ "Error",
    TRUE ~ NA_character_
  )
}

# QP+ Locations plotting function - creates a grid of strike zones for each pitch type
create_qp_locations_plot <- function(data, count_state, pitcher_hand, batter_hand) {
  # Validate inputs
  if (is.null(data) || nrow(data) == 0) {
    return(ggplot() + 
             annotate("text", x = 0, y = 2.5, label = "No data available", size = 6) +
             theme_void())
  }
  
  if (is.null(count_state) || is.null(pitcher_hand) || is.null(batter_hand)) {
    return(ggplot() + 
             annotate("text", x = 0, y = 2.5, label = "Missing parameters", size = 6) +
             theme_void())
  }
  
  # Try to filter data safely
  tryCatch({
    # Filter data for the specific count state
    state_data <- data %>%
      dplyr::filter(
        !is.na(PlateLocSide), !is.na(PlateLocHeight),
        !is.na(Balls), !is.na(Strikes)
      ) %>%
      dplyr::mutate(
        count_group = count_state_vec(Balls, Strikes)
      ) %>%
      dplyr::filter(count_group == count_state)
    
    if (nrow(state_data) == 0) {
      return(ggplot() + 
               annotate("text", x = 0, y = 2.5, label = paste("No data for", count_state, "counts"), size = 5) +
               theme_void())
    }
    
    # Get unique pitch types in the data
    pitch_types <- sort(unique(state_data$TaggedPitchType))
    pitch_types <- pitch_types[!is.na(pitch_types)]
    
    if (length(pitch_types) == 0) {
      return(ggplot() + 
               annotate("text", x = 0, y = 2.5, label = "No pitch types available", size = 6) +
               theme_void())
    }
    
    # Helper function to get custom seeds for count-specific adjustments
    get_custom_seeds_for_count <- function(pt, hand, state) {
      pt <- as.character(pt)
      hand <- ifelse(hand %in% c("Left","Right"), hand, "Right")
      
      glove_col <- ifelse(hand == "Left", 3, 1)
      arm_col   <- ifelse(glove_col == 1, 3, 1)
      
      r_top <- 1; r_mid <- 2; r_bot <- 3
      c_mid <- 2; c_g  <- glove_col; c_a <- arm_col
      
      # Apply count-specific modifications
      if (pt == "Fastball") {
        if (state == "Behind") {
          # For Behind fastballs: make middle very blue, bottom light red
          return(data.frame(r = c(r_top, r_top, r_top, r_mid, r_mid, r_mid, r_bot, r_bot, r_bot),
                            c = c(c_mid, c_g,   c_a,   c_mid, c_g,   c_a,   c_mid, c_g,   c_a),
                            w = c(1.00,  1.00,  1.00,  0.05,  0.05,  0.05,  0.85,  0.85,  0.85)))
        } else if (state == "Ahead") {
          # For Ahead fastballs: make red bottom zone thinner (closer to actual bottom)
          # Add more middle positions that are blue, keep only bottom edge red
          return(data.frame(r = c(r_top, r_top, r_top, r_mid, r_mid, r_mid, r_bot, r_bot, r_bot),
                            c = c(c_mid, c_g,   c_a,   c_mid, c_g,   c_a,   c_mid, c_g,   c_a),
                            w = c(1.00,  1.00,  1.00,  0.30,  0.30,  0.30,  0.50,  0.50,  0.50)))
        } else {
          # For Even fastballs: standard middle/bottom switch
          return(data.frame(r = c(r_top, r_top, r_top, r_mid, r_mid, r_mid, r_bot, r_bot, r_bot),
                            c = c(c_mid, c_g,   c_a,   c_mid, c_g,   c_a,   c_mid, c_g,   c_a),
                            w = c(1.00,  1.00,  1.00,  0.30,  0.30,  0.30,  0.70,  0.70,  0.70)))
        }
      } else if (pt == "Cutter") {
        # For Cutter: make bottom glove side same intensity as middle/upper glove side
        return(data.frame(r = c(r_mid, r_top, r_top, r_bot),
                          c = c(c_g,   c_g,   c_mid, c_g),
                          w = c(1.00,  1.00,  0.75,  1.00)))  # Bottom glove now 1.00 instead of 0.80
      }
      
      # Return NULL to use original seeds for other pitch types/counts
      return(NULL)
    }
    
    # Shared scorer so tiles and pitch tooltips stay in sync (includes out-of-zone penalties)
    score_location <- function(x, y, pt, p_hand, state, session_type = NULL) {
      # Only score live pitches when we have session metadata
      if (!is.null(session_type) && !is.na(session_type) && session_type != "Live") {
        return(NA_real_)
      }
      if (is.na(x) || is.na(y) || is.na(pt)) return(NA_real_)
      
      sq <- zone9_square(x, y)
      
      # Start with base QP+ score (0-200 scale)
      if (is.na(sq)) {
        base_score <- 0  # Outside competitive zone
      } else {
        custom_seeds <- get_custom_seeds_for_count(pt, p_hand, state)
        if (!is.null(custom_seeds)) {
          # Count-specific seed weighting
          rc <- sq_to_rc(sq)
          dec <- qp_decay(state)
          best <- 0
          for (j in seq_len(nrow(custom_seeds))) {
            d  <- abs(custom_seeds$r[j] - rc$r) + abs(custom_seeds$c[j] - rc$c)
            di <- ifelse(d >= 3, 4, d + 1)
            best <- max(best, custom_seeds$w[j] * dec[di])
          }
          base_score <- best * 200
        } else {
          # Default weighting
          base_score <- qp_weight_for_square(sq, pt, p_hand, state) * 200
        }
      }
      
      # Apply count/state penalties for out-of-zone locations
      if (state %in% c("Behind", "Even", "Ahead")) {
        outside_zone <- (x < ZONE_LEFT || x > ZONE_RIGHT ||
                           y < ZONE_BOTTOM || y > ZONE_TOP)
        
        if (outside_zone) {
          # Distance to the nearest part of the strike zone
          x_dist <- pmax(0, pmax(ZONE_LEFT - x, x - ZONE_RIGHT))
          y_dist <- pmax(0, pmax(ZONE_BOTTOM - y, y - ZONE_TOP))
          zone_distance <- sqrt(x_dist^2 + y_dist^2)
          
          below_zone <- y < ZONE_BOTTOM
          over_plate <- x >= ZONE_LEFT && x <= ZONE_RIGHT
          plate_width <- ZONE_RIGHT - ZONE_LEFT
          expanded_plate <- x >= (ZONE_LEFT - plate_width/3) && x <= (ZONE_RIGHT + plate_width/3)
          very_low_over_plate <- below_zone && over_plate && y >= (ZONE_BOTTOM - 0.4)
          low_over_expanded_plate <- below_zone && expanded_plate
          is_non_fastball_sinker <- pt %in% c("Cutter", "Slider", "Sweeper", "Curveball", "ChangeUp", "Splitter")
          
          if (state == "Behind") {
            distance_penalty <- pmin(0.9, 0.5 + zone_distance * 0.8)
            if (zone_distance > 0.5) {
              distance_penalty <- pmin(0.95, 0.7 + zone_distance * 1.2)
            }
          } else if (state == "Even") {
            if (below_zone && is_non_fastball_sinker) {
              distance_penalty <- pmin(0.6, 0.15 + zone_distance * 0.4)
              if (zone_distance > 0.5) {
                distance_penalty <- pmin(0.75, 0.25 + zone_distance * 0.5)
              }
            } else {
              distance_penalty <- pmin(0.75, 0.3 + zone_distance * 0.6)
              if (zone_distance > 0.5) {
                distance_penalty <- pmin(0.85, 0.5 + zone_distance * 0.8)
              }
            }
          } else { # Ahead
            if (low_over_expanded_plate && is_non_fastball_sinker) {
              base_score <- pmax(base_score, 120)
              distance_penalty <- pmin(0.1, 0.01 + zone_distance * 0.05)
            } else if (below_zone && is_non_fastball_sinker) {
              distance_penalty <- pmin(0.6, 0.2 + zone_distance * 0.4)
              if (zone_distance > 0.5) {
                distance_penalty <- pmin(0.75, 0.3 + zone_distance * 0.5)
              }
            } else {
              distance_penalty <- pmin(0.6, 0.2 + zone_distance * 0.4)
              if (zone_distance > 0.5) {
                distance_penalty <- pmin(0.75, 0.4 + zone_distance * 0.6)
              }
            }
          }
          
          base_score <- base_score * (1 - distance_penalty)
        }
      }
      
      base_score
    }
    
    # Function to create QP+ heatmap data for the competitive zone
    create_qp_heatmap_data <- function(pt, p_hand, b_hand, state) {
      # Create a larger grid that extends beyond the competitive zone for better color range
      x_seq <- seq(COMP_LEFT - 0.3, COMP_RIGHT + 0.3, length.out = 18)
      y_seq <- seq(COMP_BOTTOM - 0.3, COMP_TOP + 0.3, length.out = 18)
      grid_data <- expand.grid(x = x_seq, y = y_seq)
      
      grid_data$qp_score <- vapply(
        seq_len(nrow(grid_data)),
        function(i) score_location(grid_data$x[i], grid_data$y[i], pt, p_hand, state),
        numeric(1)
      )
      
      grid_data$pitch_type <- pt
      return(grid_data)
    }
    
    # Prepare QP+ heatmap data for all pitch types
    all_heatmap_data <- do.call(rbind, lapply(pitch_types, function(pt) {
      create_qp_heatmap_data(pt, pitcher_hand, batter_hand, count_state)
    }))
    
    # Ensure per-pitch QP+ (scaled to 0-200) is present for tooltips
    state_data <- tryCatch({
      if (!nrow(state_data)) return(state_data)
      qp_scored <- vapply(
        seq_len(nrow(state_data)),
        function(i) score_location(
          state_data$PlateLocSide[i],
          state_data$PlateLocHeight[i],
          state_data$TaggedPitchType[i],
          pitcher_hand,
          count_state,
          if ("SessionType" %in% names(state_data)) state_data$SessionType[i] else NULL
        ),
        numeric(1)
      )
      state_data %>% dplyr::mutate(`QP+` = round(qp_scored, 1))
    }, error = function(e) state_data)
    
    # Add pitch data with results and colors (includes QP+ for hover)
    state_data_with_result <- state_data %>%
      dplyr::mutate(
        Result = compute_result(PitchCall, PlayResult),
        tooltip = make_hover_tt(.),
        pitch_type = factor(TaggedPitchType, levels = pitch_types),
        # Add pitch type colors
        pitch_color = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray")
      ) %>%
      dplyr::filter(!is.na(Result))
    
    # Create strike zone and home plate data for faceting
    strike_zone_all <- do.call(rbind, lapply(pitch_types, function(pt) {
      data.frame(
        xmin = ZONE_LEFT, xmax = ZONE_RIGHT, 
        ymin = ZONE_BOTTOM, ymax = ZONE_TOP,
        pitch_type = pt
      )
    }))
    
    home_plate_all <- do.call(rbind, lapply(pitch_types, function(pt) {
      data.frame(
        x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
        y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5,
        pitch_type = pt
      )
    }))
    
    # Create the plot with QP+ heatmap and colored pitches
    p <- ggplot() +
      # Add QP+ heatmap
      geom_tile(data = all_heatmap_data, 
                aes(x = x, y = y, fill = qp_score), 
                alpha = 0.6) +
      # Blue to red color scale for QP+
      scale_fill_gradient2(
        low = "blue", mid = "white", high = "red",
        midpoint = 100, name = "QP+",
        limits = c(0, 200),
        guide = "none"
      ) +
      # Add home plate
      geom_polygon(data = home_plate_all, 
                   aes(x = x, y = y, group = pitch_type), 
                   fill = NA, color = "black", linewidth = 1) +
      # Add strike zone
      geom_rect(data = strike_zone_all, 
                aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = "black", linewidth = 1) +
      # Add pitched balls with interactive tooltips and pitch type colors
      {if (nrow(state_data_with_result) > 0) {
        ggiraph::geom_point_interactive(
          data = state_data_with_result,
          aes(x = PlateLocSide, y = PlateLocHeight, 
              shape = Result, tooltip = tooltip, color = pitch_color),
          size = 2.5, alpha = 0.9, stroke = 1.2
        )
      }} +
      scale_shape_manual(
        values = shape_map,
        name = "Result",
        guide = "none"
      ) +
      scale_color_identity() +  # Use the actual colors from pitch_color column
      facet_wrap(~ pitch_type, nrow = 1) +
      coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0.5, 4.5)) +
      theme_void() +
      theme(
        strip.text = element_text(size = 11, face = "bold"),
        panel.spacing = unit(0.5, "lines"),
        legend.position = "none"
      )
    
    return(p)
    
  }, error = function(e) {
    # Return error message plot if something goes wrong
    return(ggplot() + 
             annotate("text", x = 0, y = 2.5, label = paste("Error:", e$message), size = 4) +
             theme_void())
  })
}

# vectorized clock converter
convert_to_clock <- Vectorize(function(x) {
  if (is.na(x)) return(NA_character_)
  h24 <- 6 + x/30
  if (h24 < 13) {
    hour <- floor(h24)
    mins <- round((h24 - hour) * 60)
    sprintf("%d:%02d", hour, mins)
  } else {
    h12  <- h24 - 12
    hour <- floor(h12)
    mins <- round((h12 - hour) * 60)
    sprintf("%d:%02d", hour, mins)
  }
}, USE.NAMES = FALSE)


fmt_date <- function(d) format(d, "%m/%d/%y")

transparent_bg_theme <- theme(
  panel.background = element_rect(fill = "transparent", color = NA),
  plot.background  = element_rect(fill = "transparent", color = NA),
  legend.background = element_rect(fill = "transparent", color = NA),
  legend.box.background = element_rect(fill = "transparent", color = NA),
  strip.background = element_rect(fill = "transparent", color = NA)
)

axis_theme <- theme(
  axis.text.x  = element_text(color="black", face="bold"),
  axis.text.y  = element_text(color="black", face="bold"),
  axis.title.x = element_text(color="black", face="bold"),
  axis.title.y = element_text(color="black", face="bold")
) + transparent_bg_theme

grid_theme <- function(dark_on = FALSE) {
  grid_col <- adjustcolor(if (dark_on) "white" else "black",
                          alpha.f = if (dark_on) 0.18 else 0.12)
  theme(
    panel.grid.major = element_line(color = grid_col),
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "transparent", color = NA),
    plot.background  = element_rect(fill = "transparent", color = NA)
  )
}

# ----- Shared heatmap palette (identical to current heat maps) -----
heat_pal <- function(bins = 10) {
  colorRampPalette(c("white","blue","lightblue","turquoise","yellow","orange","red"))(bins)
}

# ---- Per-base weight scales for Stuff+ ----
pitch_weights_fb <- tibble(
  TaggedPitchType = c("Fastball","Sinker",
                      "Cutter","Slider","Sweeper","Curveball",
                      "ChangeUp","Splitter"),
  w_vel = c(0.6, 0.5, 0.44, 0.34, 0.23, 0.43, 0.2, 0.1),
  w_ivb = c(0.3, 0.3, 0.2, 0.4, 0.1, 0.5, 0.6, 0.85),
  w_hb  = c(0.1, 0.2, 0.3, 0.2, 0.6, 0.0, 0.2, 0.05),
  w_ext = c(0.05, 0.05, 0.05, 0.05, 0.04, 0.04, 0.03, 0.03),
  w_raw_vel = c(0, 0, 0.1, 0.1, 0.1, 0.1, 0, 0)
)

pitch_weights_si <- tibble(
  TaggedPitchType = c("Fastball","Sinker",
                      "Cutter","Slider","Sweeper","Curveball",
                      "ChangeUp","Splitter"),
  w_vel = c(0.6, 0.5, 0.44, 0.34, 0.23, 0.43, 0.2, 0.1),
  w_ivb = c(0.3, 0.3, 0.2, 0.4, 0.1, 0.5, 0.7, 0.85),
  w_hb  = c(0.1, 0.2, 0.3, 0.2, 0.6, 0.0, 0.1, 0.05),
  w_ext = c(0.05, 0.05, 0.05, 0.05, 0.04, 0.04, 0.03, 0.03),
  w_raw_vel = c(0, 0, 0.1, 0.1, 0.1, 0.1, 0, 0)
)

extension_targets <- tibble(
  TaggedPitchType = c("Fastball","Sinker","Cutter","Slider","Sweeper","Curveball","ChangeUp","Splitter"),
  ext_poor = c(5.8, 5.8, 5.6, 5.4, 5.4, 5.3, 5.7, 5.7),
  ext_avg  = c(6.0, 6.0, 5.8, 5.6, 5.6, 5.5, 5.9, 5.9),
  ext_great= c(6.2, 6.2, 6.0, 5.8, 5.8, 5.7, 6.1, 6.1)
)

breaking_vel_targets <- tibble(
  TaggedPitchType = c("Cutter","Slider","Sweeper","Curveball"),
  vel_poor = c(82, 80, 75, 75),
  vel_avg  = c(85, 82, 77, 77),
  vel_great= c(88, 84, 80, 80)
)

# ---- Simplified Stuff+ Helper (vectorized, RelHeight-based FB/SI) ----
compute_stuff_simple <- function(df, base_type, level) {
  # select appropriate weights
  weight_tbl <- if (base_type == "Fastball") pitch_weights_fb else pitch_weights_si
  
  # prepare data and join weights
  ext_candidates <- intersect(c("Ext","Extension"), names(df))
  ext_col <- if (length(ext_candidates)) ext_candidates[1] else NULL
  ext_values <- if (!is.null(ext_col)) df[[ext_col]] else rep(NA_real_, nrow(df))

  df2 <- df %>%
    dplyr::mutate(
      TaggedPitchType = as.character(TaggedPitchType),
      HB_adj = ifelse(PitcherThrows == "Left", HorzBreak, -HorzBreak),
      Ext_value = ext_values
    ) %>%
    dplyr::left_join(weight_tbl, by = "TaggedPitchType") %>%
    dplyr::left_join(extension_targets, by = "TaggedPitchType") %>%
    dplyr::left_join(breaking_vel_targets, by = "TaggedPitchType")
  
  # velocity baselines
  base_vel <- mean(df2$RelSpeed[df2$TaggedPitchType == base_type], na.rm = TRUE)
  vel_avg  <- c(Pro = 94, College = 89, `High School` = 82)[level]
  
  # off-speed break specs
  off_off <- c(Cutter = 5, Slider = 8, Sweeper = 12,
               Curveball = 14, ChangeUp = 8, Splitter = 7)
  sep_fb <- tibble(
    TaggedPitchType = names(off_off),
    sep_ivb = c(-7, -15, -16, -27, -12, -13),
    sep_hb  = c(10, 12, 22, 18, -7, -4)
  )
  sep_si <- tibble(
    TaggedPitchType = names(off_off),
    sep_ivb = c(2, -6, -7, -18, -4, -5),
    sep_hb  = c(18, 20, 30, 25, 1, 2)
  )
  seps <- if (base_type == "Fastball") sep_fb else sep_si
  
  # league-standard baselines by release height
  std_ivb <- case_when(
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 6.2 ~ 17,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.8 ~ 15.5,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.4 ~ 15,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.0 ~ 12.5,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 4.5 ~ 11,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight <  4.5 ~ 10,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 6.2 ~ 10,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.8 ~ 7,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.4 ~ 6,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.0 ~ 4,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 4.5 ~ 3,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight <  4.5 ~ 3,
    TRUE ~ NA_real_
  )
  std_hb_right <- case_when(
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 6.2 ~ 9,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.8 ~ 10,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.4 ~ 11,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.0 ~ 12,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 4.5 ~ 13,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight <  4.5 ~ 11,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 6.2 ~ 15,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.8 ~ 15.5,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.4 ~ 16.7,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.0 ~ 17,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 4.5 ~ 17,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight <  4.5 ~ 17.5,
    TRUE ~ NA_real_
  )
  std_hb <- ifelse(df2$PitcherThrows == "Left", -std_hb_right, std_hb_right)
  
  # personal baselines for off-speed
  base_ivb_val <- mean(df2$InducedVertBreak[df2$TaggedPitchType == base_type], na.rm = TRUE)
  base_hb_val  <- mean(df2$HB_adj[df2$TaggedPitchType == base_type], na.rm = TRUE)
  
  # compute per-pitch ratios
  r_vel <- ifelse(
    df2$TaggedPitchType %in% c("Fastball","Sinker"),
    df2$RelSpeed / vel_avg,
    df2$RelSpeed / pmax(1e-6, base_vel - off_off[df2$TaggedPitchType])
  )
  
  # exaggerate velocity deviations:
  #   below average → square the ratio (shrinks <1 even more)
  #   above average → optional root (or power>1) to tune reward
  alpha <- 4    # exponent for penalizing below-avg
  beta  <- 2  # exponent for rewarding above-avg (tweak as you like)
  
  r_vel <- ifelse(
    r_vel < 1,
    r_vel^alpha,
    r_vel^beta
  )
  
  # Invert velocity scoring for ChangeUp & Splitter so larger FB/SI gap is rewarded
  r_vel <- ifelse(df2$TaggedPitchType %in% c("ChangeUp","Splitter"),
                  1 / pmax(r_vel, 1e-6), r_vel)
  # ---- Updated r_ivb: endpoint-based for Sweeper off Sinker ----
  r_ivb <- case_when(
    df2$TaggedPitchType == "Fastball" ~
      df2$InducedVertBreak / std_ivb,
    
    df2$TaggedPitchType == "Sinker"   ~
      ifelse(df2$InducedVertBreak > 0,
             std_ivb / df2$InducedVertBreak,
             1),
    
    base_type == "Sinker" & df2$TaggedPitchType == "Cutter" ~ {
      endpoint_ivb <- base_ivb_val +
        seps$sep_ivb[match("Cutter", seps$TaggedPitchType)]
      # compute difference (could be negative), then abs() makes it positive
      ivb_diff <- df2$InducedVertBreak - endpoint_ivb
      abs(ivb_diff) / endpoint_ivb
    },
    
    # reward deviations in either direction for Sweeper off Sinker
    base_type == "Sinker" & df2$TaggedPitchType == "Sweeper" ~ {
      endpoint_ivb <- base_ivb_val +
        seps$sep_ivb[match("Sweeper", seps$TaggedPitchType)]
      # compute difference (could be negative), then abs() makes it positive
      ivb_diff <- df2$InducedVertBreak - endpoint_ivb
      abs(ivb_diff) / endpoint_ivb
    },
    
    TRUE ~
      (base_ivb_val - df2$InducedVertBreak) /
      abs(seps$sep_ivb[match(df2$TaggedPitchType, seps$TaggedPitchType)])
  )
  
  # ---- Updated r_hb: endpoint-based for Sweeper off Sinker ----
  r_hb <- case_when(
    # NEW: Fastball HB → reward both below-avg and above-avg HB (symmetric),
    # with a small deadband so tiny differences score ~1.0
    df2$TaggedPitchType == "Fastball" ~ {
      hb_mag  <- abs(df2$HB_adj)
      std_mag <- abs(std_hb)
      # symmetric reward: less HB → std/hb ; more HB → hb/std
      r <- pmax(hb_mag / std_mag, std_mag / pmax(hb_mag, 1e-6))
      # optional deadband (e.g., within 2 in of "standard" HB scores 1.0)
      r <- ifelse(abs(hb_mag - std_mag) < 2, 1, r)
      r
    },
    df2$TaggedPitchType == "Sinker" ~
      abs(df2$HB_adj / std_hb),
    
    df2$TaggedPitchType == "Curveball" ~
      abs(df2$HorzBreak - base_hb_val) /
      abs(seps$sep_hb[match("Curveball", seps$TaggedPitchType)]),
    
    # ← NEW: Sweeper off Sinker uses endpoint (base_hb_val + sep_hb)
    base_type == "Sinker" & df2$TaggedPitchType == "Sweeper" ~ {
      endpoint_hb <- base_hb_val +
        seps$sep_hb[match("Sweeper", seps$TaggedPitchType)]
      abs(df2$HB_adj) / abs(endpoint_hb)
    },
    
    base_type == "Sinker" & df2$TaggedPitchType == "Cutter" ~ {
      endpoint_hb <- base_hb_val +
        seps$sep_hb[match("Cutter", seps$TaggedPitchType)]
      abs(df2$HB_adj) / abs(endpoint_hb)
    },
    
    base_type == "Sinker" & df2$TaggedPitchType == "ChangeUp" ~ {
      (base_hb_val - df2$HB_adj) /
        seps$sep_hb[match("ChangeUp", seps$TaggedPitchType)]
    },
    base_type == "Sinker" & df2$TaggedPitchType == "Splitter" ~ {
      (base_hb_val - df2$HB_adj) /
        seps$sep_hb[match("Splitter", seps$TaggedPitchType)]
    },
    
    TRUE ~
      (df2$HB_adj - base_hb_val) /
      seps$sep_hb[match(df2$TaggedPitchType, seps$TaggedPitchType)]
  )
  
  # ← INSERT YOUR CAPS HERE
  r_ivb <- pmin(r_ivb, 2)   # cap vertical ratio at 2× baseline
  r_hb  <- pmin(r_hb,  2)   # cap horizontal ratio at 2× baseline

  # Extend the score slightly with release extension and raw breaking-ball speed
  valid_ext <- !is.na(df2$Ext_value) & !is.na(df2$ext_avg)
  ext_range <- df2$ext_great - df2$ext_poor
  ext_range <- ifelse(is.na(ext_range) | ext_range <= 0, 1, ext_range)
  ext_norm <- ifelse(valid_ext, (df2$Ext_value - df2$ext_avg) / ext_range, 0)
  r_ext <- 1 + 0.25 * ext_norm
  r_ext <- pmin(pmax(r_ext, 0.8), 1.2)

  vel_mask <- !is.na(df2$vel_avg) & !is.na(df2$RelSpeed)
  vel_range <- df2$vel_great - df2$vel_poor
  vel_range <- ifelse(is.na(vel_range) | vel_range <= 0, 1, vel_range)
  vel_norm <- ifelse(vel_mask, (df2$RelSpeed - df2$vel_avg) / vel_range, 0)
  r_raw_vel <- 1 + 0.25 * vel_norm
  r_raw_vel <- pmin(pmax(r_raw_vel, 0.8), 1.2)

  base_scale <- pmax(1 - (df2$w_ext + df2$w_raw_vel), 0.01)

  # combine into Stuff+
  df2 %>%
    mutate(
      raw = (w_vel * base_scale) * r_vel +
            (w_ivb * base_scale) * r_ivb +
            (w_hb  * base_scale) * r_hb +
            w_ext * r_ext +
            w_raw_vel * r_raw_vel,
      `Stuff+` = round(raw * 100, 1)
    )
}


# Strike zone constants
ZONE_LEFT   <- -0.88
ZONE_RIGHT  <-  0.88
ZONE_BOTTOM <-  1.5
ZONE_TOP    <-  3.6

# =========================
# ===== QP+  HELPERS  =====
# =========================

# Competitive rectangle (same as your dashed box)
COMP_LEFT   <- -1.5
COMP_RIGHT  <-  1.5
COMP_BOTTOM <-  2.65 - 1.5   # 1.15
COMP_TOP    <-  2.65 + 1.5   # 4.15

# Map (Balls, Strikes) to Ahead / Even / Behind like your count filter
count_state_vec <- function(b, s) {
  b <- suppressWarnings(as.integer(b)); s <- suppressWarnings(as.integer(s))
  out <- rep("Even", length(b))
  ahead  <- ( (b==0 & s==1) | (b==0 & s==2) | (b==1 & s==2) )
  behind <- ( (b==1 & s==0) | (b==2 & s==0) | (b==3 & s==0) |
                (b==3 & s==1) | (b==2 & s==1) )
  even   <- ( (b==0 & s==0) | (b==1 & s==1) | (b==2 & s==2) | (b==3 & s==2) )
  
  out[behind] <- "Behind"
  out[ahead]  <- "Ahead"
  out[even]   <- "Even"
  out[is.na(b) | is.na(s)] <- "Even"
  out
}

# 9-square index (1..9) or NA if OUTSIDE competitive box
# Numbering (LEFT → RIGHT per row):
# Top row:    1,2,3
# Middle row: 4,5,6
# Bottom row: 7,8,9
# 9-square index (1..9) or NA if OUTSIDE competitive box
# Numbering (LEFT→RIGHT per row): Top: 1,2,3  |  Middle: 4,5,6  |  Bottom: 7,8,9
zone9_square <- function(x, y) {
  x <- suppressWarnings(as.numeric(x))
  y <- suppressWarnings(as.numeric(y))
  
  # guard missing + bounds (avoid NA in logical index)
  ok <- !is.na(x) & !is.na(y) &
    x >= COMP_LEFT & x <= COMP_RIGHT &
    y >= COMP_BOTTOM & y <= COMP_TOP
  
  sq <- rep(NA_integer_, length(x))
  idx <- which(ok)  # <- integer indices (drops NA/FALSE safely)
  if (!length(idx)) return(sq)
  
  w <- (COMP_RIGHT - COMP_LEFT)
  h <- (COMP_TOP   - COMP_BOTTOM)
  
  # normalized positions in [0,1]
  gx <- pmax(0, pmin(1, (x[idx] - COMP_LEFT)   / w))
  gy <- pmax(0, pmin(1, (y[idx] - COMP_BOTTOM) / h))
  
  # columns: LEFT(1)→RIGHT(3)
  col <- ifelse(gx < 1/3, 1L, ifelse(gx < 2/3, 2L, 3L))
  # rows: TOP(1)→BOTTOM(3)
  row <- ifelse(gy >= 2/3, 1L, ifelse(gy >= 1/3, 2L, 3L))
  
  sq[idx] <- (row - 1L) * 3L + col
  sq
}

# Convenience to convert square to (row,col)
sq_to_rc <- function(sq) {
  r <- ((sq - 1) %/% 3) + 1
  c <- ((sq - 1) %%  3) + 1
  list(r = r, c = c)
}

# Count strictness decay by Manhattan distance from target
# Behind = loosest, Even = moderate, Ahead = strict
qp_decay <- function(state) {
  if (identical(state, "Ahead"))      c(1.00, 0.35, 0.15, 0.05)
  else if (identical(state, "Even"))  c(1.00, 0.55, 0.25, 0.10)
  else                                c(1.00, 0.75, 0.45, 0.20)  # Behind
}

# Seed targets (row, col, base weight) per pitch type & pitcher hand
# UI columns numbered LEFT→RIGHT:
# - RHP glove side → UI col 1 → squares 1/4/7
# - LHP glove side → UI col 3 → squares 3/6/9
qp_seeds_for <- function(pt, hand) {
  pt   <- as.character(pt)
  hand <- ifelse(hand %in% c("Left","Right"), hand, "Right")
  
  glove_col <- ifelse(hand == "Left", 3, 1)
  arm_col   <- ifelse(glove_col == 1, 3, 1)
  
  r_top <- 1; r_mid <- 2; r_bot <- 3
  c_mid <- 2; c_g  <- glove_col; c_a <- arm_col
  
  # Weights reflect your guidance:
  # FB up; SI down; CT middle & up glove; SL/SW down glove;
  # CB down + slight glove; CH/SPL down over plate + slight arm.
  switch(pt,
         "Fastball"  = data.frame(r = c(r_top, r_top, r_top),
                                  c = c(c_mid, c_g,   c_a),
                                  w = c(1.00,  1.00,  1.00)),
         "Sinker"    = data.frame(r = c(r_bot, r_bot, r_bot),
                                  c = c(c_mid, c_a,   c_g),
                                  w = c(0.8,  1.00,  0.90)),
         "Cutter"    = data.frame(r = c(r_mid, r_top, r_top, r_bot),
                                  c = c(c_g,   c_g,   c_mid, c_g),
                                  w = c(1.00,  1.00,  0.75,  0.80)),
         "Slider"    = data.frame(r = c(r_bot, r_bot, r_mid),
                                  c = c(c_g,   c_mid, c_g),
                                  w = c(1.00,  0.80,  0.70)),
         "Sweeper"   = data.frame(r = c(r_bot, r_bot, r_mid),
                                  c = c(c_g,   c_mid, c_g),
                                  w = c(1.00,  0.75,  0.65)),
         "Curveball" = data.frame(r = c(r_bot, r_bot, r_bot),
                                  c = c(c_mid, c_g,   c_a),
                                  w = c(1.00,  1.00,  1.00)),
         "ChangeUp"  = data.frame(r = c(r_bot, r_bot, r_bot),
                                  c = c(c_mid, c_a,   c_g),
                                  w = c(1.00,  0.90,  0.70)),
         "Splitter"  = data.frame(r = c(r_bot, r_bot, r_bot),
                                  c = c(c_mid, c_a,   c_g),
                                  w = c(1.00,  1.00,  1.00)),
         # Fallback: neutral center if unknown pitch label
         data.frame(r = r_mid, c = c_mid, w = 0.60)
  )
}

# Best weight for a given square given pitch, hand, count macro
qp_weight_for_square <- function(sq, pt, hand, state) {
  if (is.na(sq)) return(0)
  seeds <- qp_seeds_for(pt, hand)
  rc    <- sq_to_rc(sq)
  dec   <- qp_decay(state)
  best  <- 0
  for (i in seq_len(nrow(seeds))) {
    d <- abs(seeds$r[i] - rc$r) + abs(seeds$c[i] - rc$c)  # Manhattan distance
    di <- ifelse(d >= 3, 4, d + 1)
    best <- max(best, seeds$w[i] * dec[di])
  }
  best
}

# Vectorized per-pitch QP points (0..1)
# - Live only (non-Live → NA, so not counted)
# - 0 if outside COMP box (non-competitive)
compute_qp_points <- function(df) {
  n <- nrow(df)
  if (!n) return(numeric(0))
  
  live  <- !is.na(df$SessionType) & as.character(df$SessionType) == "Live"
  sq    <- zone9_square(df$PlateLocSide, df$PlateLocHeight)
  state <- count_state_vec(df$Balls, df$Strikes)
  pt    <- as.character(df$TaggedPitchType)
  hand  <- as.character(df$PitcherThrows)
  
  out <- rep(NA_real_, n)
  
  # live & non-competitive = 0  (use integer indices)
  idx_noncomp <- which(live & is.na(sq))
  if (length(idx_noncomp)) out[idx_noncomp] <- 0
  
  # live & inside competitive box
  idx <- which(live & !is.na(sq))
  if (length(idx)) {
    out[idx] <- mapply(
      function(sqi, pti, hnd, st)
        qp_weight_for_square(sqi, pti, hnd, ifelse(is.na(st), "Even", st)),
      sq[idx], pt[idx], hand[idx], state[idx]
    )
  }
  out
}

# QP Locations filter: determine if pitch locations are good (red/QP+ >= 100) or bad (blue/white/QP+ < 100)
# This function calculates QP+ scores for pitch locations and classifies them
filter_qp_locations <- function(df, qp_choice) {
  # Pass-through if "All" or invalid choice
  if (is.null(qp_choice) || qp_choice == "All" || !qp_choice %in% c("Yes", "No")) {
    return(df)
  }
  
  # Need location data to calculate QP+ scores
  if (!all(c("PlateLocSide", "PlateLocHeight", "TaggedPitchType", "PitcherThrows", "Balls", "Strikes") %in% names(df))) {
    return(df)
  }
  
  # Calculate QP+ scores for each pitch
  n <- nrow(df)
  if (!n) return(df)
  
  x <- suppressWarnings(as.numeric(df$PlateLocSide))
  y <- suppressWarnings(as.numeric(df$PlateLocHeight))
  pt <- as.character(df$TaggedPitchType)
  hand <- as.character(df$PitcherThrows)
  state <- count_state_vec(df$Balls, df$Strikes)
  
  # Calculate QP+ scores (0-200 scale)
  qp_scores <- rep(NA_real_, n)
  
  for (i in seq_len(n)) {
    if (is.na(x[i]) || is.na(y[i])) {
      qp_scores[i] <- 0  # Missing location = poor
      next
    }
    
    # Get square position in competitive zone
    sq <- zone9_square(x[i], y[i])
    
    if (is.na(sq)) {
      qp_scores[i] <- 0  # Outside competitive zone = poor
    } else {
      # Calculate QP+ score using existing function
      qp_weight <- qp_weight_for_square(sq, pt[i], hand[i], ifelse(is.na(state[i]), "Even", state[i]))
      qp_scores[i] <- qp_weight * 200
    }
  }
  
  # Apply filter based on choice
  if (qp_choice == "Yes") {
    # Show only good locations (red areas, QP+ >= 100)
    return(df[qp_scores >= 100 & !is.na(qp_scores), , drop = FALSE])
  } else if (qp_choice == "No") {
    # Show only poor locations (blue/white areas, QP+ < 100)
    return(df[qp_scores < 100 & !is.na(qp_scores), , drop = FALSE])
  }
  
  return(df)
}


# Colors & factor levels
all_colors <- c(
  Fastball   = "black",
  Sinker     = "orange",
  Cutter     = "brown",
  Slider     = "red",
  Sweeper    = "purple",
  Curveball  = "blue",
  ChangeUp   = "darkgreen",
  Splitter   = "turquoise",
  Knuckleball= "darkblue"
)
colors_for_mode <- function(dark_on = FALSE) {
  cols <- all_colors
  if (isTRUE(dark_on) && "Fastball" %in% names(cols)) cols["Fastball"] <- "#ffffff"
  cols
}
force_pitch_levels <- function(df) df %>% mutate(
  TaggedPitchType = factor(TaggedPitchType, levels = names(all_colors))
)

# Session colors for Trend when "All" is selected
session_cols <- c(Live = "red", Bullpen = "black")
session_cols_for_mode <- function(dark_on = FALSE) {
  cols <- session_cols
  if (isTRUE(dark_on) && "Bullpen" %in% names(cols)) cols["Bullpen"] <- "#ffffff"
  cols
}

# Filters
# ---- Filters: Zone & In-Zone ----

# Multi-select halves/thirds with INTERSECTION logic, bounded to the strike zone
# ---- Filters: Zone bands that extend beyond the zone ----
# Halves/Thirds act as threshold lines:
#   - Upper Half      => y >= mid_y      (and above the zone)
#   - Bottom Half     => y <= mid_y      (and below the zone)
#   - Upper 3rd       => y >= B + 2*dy   (and above the zone)
#   - Bottom 3rd      => y <= B + dy     (and below the zone)
#   - Left Half       => x <= mid_x      (and left of the zone)
#   - Right Half      => x >= mid_x      (and right of the zone)
#   - Left 3rd        => x <= L + dx     (and left of the zone)
#   - Right 3rd       => x >= L + 2*dx   (and right of the zone)
# Multiple selections are ANDed together (intersection).
enforce_zone <- function(df, choice) {
  # Pass-through if nothing picked or "All"
  if (is.null(choice) || !length(choice)) return(df)
  choice <- unique(as.character(choice))
  if ("All" %in% choice) return(df)
  
  # Coords
  x <- suppressWarnings(as.numeric(df$PlateLocSide))
  y <- suppressWarnings(as.numeric(df$PlateLocHeight))
  ok <- is.finite(x) & is.finite(y)
  if (!any(ok)) return(df[0, , drop = FALSE])
  
  # Zone geometry
  mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
  mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
  dx <- (ZONE_RIGHT - ZONE_LEFT) / 3
  dy <- (ZONE_TOP   - ZONE_BOTTOM) / 3
  L <- ZONE_LEFT; R <- ZONE_RIGHT; B <- ZONE_BOTTOM; T <- ZONE_TOP
  
  # Start with TRUE everywhere (don’t clamp to the zone here)
  mask_vert <- rep(TRUE, length(x))
  mask_horz <- rep(TRUE, length(x))
  
  # Apply each token as a threshold restriction
  for (tok in choice) {
    if (tok %in% c("Upper Half", "Bottom Half", "Upper 3rd", "Bottom 3rd")) {
      cond <- switch(tok,
                     "Upper Half"  = (y >= mid_y),
                     "Bottom Half" = (y <= mid_y),
                     "Upper 3rd"   = (y >= (B + 2*dy)),
                     "Bottom 3rd"  = (y <= (B + dy))
      )
      mask_vert <- mask_vert & cond
    } else if (tok %in% c("Left Half", "Right Half", "Left 3rd", "Right 3rd")) {
      cond <- switch(tok,
                     "Left Half"  = (x <= mid_x),
                     "Right Half" = (x >= mid_x),
                     "Left 3rd"   = (x <= (L + dx)),
                     "Right 3rd"  = (x >= (L + 2*dx))
      )
      mask_horz <- mask_horz & cond
    } else {
      # Unknown token → no change
    }
  }
  
  m <- ok & mask_vert & mask_horz
  df[m, , drop = FALSE]
}


# Keep the legacy in-zone toggle that other code expects
# Values typically: "All", "Yes", "No", "Competitive"
enforce_inzone <- function(df, choice) {
  if (is.null(choice) || identical(choice, "All")) return(df)
  
  x <- suppressWarnings(as.numeric(df$PlateLocSide))
  y <- suppressWarnings(as.numeric(df$PlateLocHeight))
  
  in_zone <- (x >= ZONE_LEFT & x <= ZONE_RIGHT &
                y >= ZONE_BOTTOM & y <= ZONE_TOP)
  
  if (identical(choice, "Yes")) {
    df[in_zone, , drop = FALSE]
  } else if (identical(choice, "No")) {
    df[!in_zone, , drop = FALSE]
  } else if (identical(choice, "Competitive")) {
    comp <- (x >= -1.5 & x <= 1.5 &
               y >= (2.65 - 1.5) & y <= (2.65 + 1.5))
    df[comp, , drop = FALSE]
  } else {
    df
  }
}

# ---- Multi-select "All" helper ----
enforce_all_multiselect <- function(input, session, id) {
  observeEvent(input[[id]], {
    sel <- input[[id]]
    if (is.null(sel) || !length(sel)) {
      updateSelectInput(session, id, selected = "All")
    } else if ("All" %in% sel && length(sel) > 1) {
      updateSelectInput(session, id, selected = setdiff(sel, "All"))
    }
  }, ignoreInit = TRUE)
}


# ---- Count filter helper (supports macros + exact counts) ----
apply_count_filter <- function(df, selection) {
  # If nothing or "All" selected -> no filtering
  if (is.null(selection) || !length(selection) || "All" %in% selection) return(df)
  
  # Build allowed (Balls, Strikes) pairs from exact and macro options
  allowed <- list()
  
  # Exact counts like "1-2"
  exact <- selection[grepl("^\\d-\\d$", selection)]
  if (length(exact)) {
    for (val in exact) {
      sp <- strsplit(val, "-", fixed = TRUE)[[1]]
      allowed <- append(allowed, list(c(as.integer(sp[1]), as.integer(sp[2]))))
    }
  }
  
  # Macros
  if ("Even" %in% selection)  allowed <- append(allowed, list(c(0,0), c(1,1), c(2,2), c(3,2)))
  if ("Behind" %in% selection) allowed <- append(allowed, list(c(1,0), c(2,0), c(3,0), c(3,1), c(2,1)))
  if ("Ahead" %in% selection)  allowed <- append(allowed, list(c(0,1), c(0,2), c(1,2)))
  if ("2KNF" %in% selection)   allowed <- append(allowed, list(c(0,2), c(1,2), c(2,2)))
  
  if (!length(allowed)) return(df)
  
  mat <- do.call(rbind, allowed)  # Nx2 (Balls, Strikes)
  ok  <- is.finite(df$Balls) & is.finite(df$Strikes)
  keep <- rep(FALSE, nrow(df))
  if (nrow(mat)) {
    for (i in seq_len(nrow(mat))) {
      keep <- keep | (df$Balls == mat[i,1] & df$Strikes == mat[i,2])
    }
  }
  df[ ok & keep, , drop = FALSE ]
}

# ---- After Count filter helper - filters pitches that occurred AFTER specific counts ----
apply_after_count_filter <- function(df, selection) {
  # If nothing or "All" selected -> no filtering
  if (is.null(selection) || !length(selection) || "All" %in% selection) return(df)
  
  # First compute the "prior count" for each pitch
  # Group by at-bat identifiers and calculate previous balls/strikes
  if (!all(c("PAofInning", "Inning", "Date") %in% names(df))) {
    # If we don't have at-bat identifiers, can't compute after count
    return(df)
  }
  
  df <- df %>%
    dplyr::arrange(Date, Inning, PAofInning, PitchofPA) %>%
    dplyr::group_by(Date, Inning, PAofInning) %>%
    dplyr::mutate(
      PrevBalls = dplyr::lag(Balls, default = 0),
      PrevStrikes = dplyr::lag(Strikes, default = 0)
    ) %>%
    dplyr::ungroup()
  
  # Build allowed (Balls, Strikes) pairs from selection
  allowed <- list()
  
  # Exact counts like "1-2"
  exact <- selection[grepl("^\\d-\\d$", selection)]
  if (length(exact)) {
    for (val in exact) {
      sp <- strsplit(val, "-", fixed = TRUE)[[1]]
      allowed <- append(allowed, list(c(as.integer(sp[1]), as.integer(sp[2]))))
    }
  }
  
  # Macros
  if ("Even" %in% selection)  allowed <- append(allowed, list(c(0,0), c(1,1), c(2,2), c(3,2)))
  if ("Behind" %in% selection) allowed <- append(allowed, list(c(1,0), c(2,0), c(3,0), c(3,1), c(2,1)))
  if ("Ahead" %in% selection)  allowed <- append(allowed, list(c(0,1), c(0,2), c(1,2)))
  if ("2KNF" %in% selection)   allowed <- append(allowed, list(c(0,2), c(1,2), c(2,2)))
  
  if (!length(allowed)) return(df)
  
  mat <- do.call(rbind, allowed)  # Nx2 (Balls, Strikes)
  ok  <- is.finite(df$PrevBalls) & is.finite(df$PrevStrikes)
  keep <- rep(FALSE, nrow(df))
  if (nrow(mat)) {
    for (i in seq_len(nrow(mat))) {
      keep <- keep | (df$PrevBalls == mat[i,1] & df$PrevStrikes == mat[i,2])
    }
  }
  df[ ok & keep, , drop = FALSE ]
}

# ---- Split By helper - adds a column for grouping based on split selection ----
apply_split_by <- function(df, split_choice) {
  if (is.null(split_choice)) split_choice <- "Pitch Types"
  
  df <- switch(
    split_choice,
    
    "Pitch Types" = {
      df %>% dplyr::mutate(SplitColumn = as.character(TaggedPitchType))
    },
    
    "Batter Hand" = {
      df %>% dplyr::mutate(SplitColumn = ifelse(
        !is.na(BatterSide) & BatterSide != "", 
        as.character(BatterSide), 
        "Unknown"
      ))
    },
    
    "Pitcher Hand" = {
      df %>% dplyr::mutate(SplitColumn = ifelse(
        !is.na(PitcherThrows) & PitcherThrows != "", 
        as.character(PitcherThrows), 
        "Unknown"
      ))
    },
    
    "Count" = {
      df %>% dplyr::mutate(
        SplitColumn = ifelse(
          is.finite(Balls) & is.finite(Strikes),
          paste0(Balls, "-", Strikes),
          "Unknown"
        ),
        CountState = count_state_vec(Balls, Strikes)
      )
    },
    
    "After Count" = {
      # Compute previous count if not already present
      if (!all(c("PAofInning", "Inning", "Date") %in% names(df))) {
        df %>% dplyr::mutate(SplitColumn = "Unknown")
      } else {
        df %>%
          dplyr::arrange(Date, Inning, PAofInning, PitchofPA) %>%
          dplyr::group_by(Date, Inning, PAofInning) %>%
          dplyr::mutate(
            PrevBalls = dplyr::lag(Balls, default = 0),
            PrevStrikes = dplyr::lag(Strikes, default = 0),
            SplitColumn = ifelse(
              is.finite(PrevBalls) & is.finite(PrevStrikes),
              paste0(PrevBalls, "-", PrevStrikes),
              "Unknown"
            )
          ) %>%
          dplyr::ungroup()
      }
    },
    
    "Velocity" = {
      df %>% dplyr::mutate(SplitColumn = dplyr::case_when(
        !is.finite(RelSpeed) ~ "Unknown",
        RelSpeed < 70 ~ "<70",
        RelSpeed >= 100 ~ ">99",
        TRUE ~ paste0(floor(RelSpeed/2)*2, "-", floor(RelSpeed/2)*2 + 1)
      ))
    },
    
    "IVB" = {
      df %>% dplyr::mutate(SplitColumn = dplyr::case_when(
        !is.finite(InducedVertBreak) ~ "Unknown",
        InducedVertBreak < -22 ~ "<-22",
        InducedVertBreak > 22 ~ ">22",
        TRUE ~ paste0(floor(InducedVertBreak/2)*2, "-", floor(InducedVertBreak/2)*2 + 1)
      ))
    },
    
    "HB" = {
      df %>% dplyr::mutate(SplitColumn = dplyr::case_when(
        !is.finite(HorzBreak) ~ "Unknown",
        HorzBreak < -22 ~ "<-22",
        HorzBreak > 22 ~ ">22",
        TRUE ~ paste0(floor(HorzBreak/2)*2, "-", floor(HorzBreak/2)*2 + 1)
      ))
    },
    
    "Batter" = {
      df %>% dplyr::mutate(SplitColumn = ifelse(
        !is.na(Batter) & nzchar(Batter), 
        as.character(Batter), 
        "Unknown"
      ))
    },
    
    "Pitcher" = {
      df %>% dplyr::mutate(SplitColumn = ifelse(
        !is.na(Pitcher) & nzchar(Pitcher), 
        as.character(Pitcher), 
        "Unknown"
      ))
    },
    
    # Default: Pitch Types
    {
      df %>% dplyr::mutate(SplitColumn = as.character(TaggedPitchType))
    }
  )
  attr(df, "split_choice") <- split_choice
  df
}

# Apply Pitch Results filter (multi-select)
apply_pitch_results_filter <- function(df, selection) {
  # If nothing or "All" selected -> no filtering
  if (is.null(selection) || !length(selection) || "All" %in% selection) return(df)
  
  # Separate individual hit types from regular result categories
  hit_types <- c("Single", "Double", "Triple", "HomeRun", "Error")
  selected_hits <- intersect(selection, hit_types)
  selected_results <- setdiff(selection, hit_types)
  
  # If "In Play (Hit)" is selected, expand it to include all hit types
  if ("In Play (Hit)" %in% selected_results) {
    selected_hits <- unique(c(selected_hits, "Single", "Double", "Triple", "HomeRun"))
  }
  
  # Create Result column if not already present (for regular results)
  if (!"Result" %in% names(df)) {
    df$Result <- compute_result(df$PitchCall, df$PlayResult)
  }
  
  # Build filter conditions
  keep_rows <- rep(FALSE, nrow(df))
  
  # Filter by regular result categories (using Result column)
  if (length(selected_results) > 0) {
    keep_rows <- keep_rows | (!is.na(df$Result) & df$Result %in% selected_results)
  }
  
  # Filter by specific hit types (using PlayResult column directly)
  if (length(selected_hits) > 0) {
    keep_rows <- keep_rows | (!is.na(df$PlayResult) & df$PlayResult %in% selected_hits)
  }
  
  df[keep_rows, , drop = FALSE]
}

# Sort table by IVB/HB ranges in descending order
sort_by_range <- function(df, col_name, split_choice) {
  if (!split_choice %in% c("IVB", "HB")) return(df)
  if (!col_name %in% names(df)) return(df)
  
  # Extract numeric values from range strings for sorting
  df <- df %>%
    dplyr::mutate(
      .sort_key = dplyr::case_when(
        grepl("Unknown", .data[[col_name]]) ~ -9999,
        grepl("^<-", .data[[col_name]]) ~ -23,
        grepl("^>", .data[[col_name]]) ~ 23,
        grepl("Even|Ahead|Behind|All", .data[[col_name]]) ~ 9999,  # Keep these at bottom
        TRUE ~ {
          # Extract first number from range like "10-11" or "-10--9"
          val_str <- as.character(.data[[col_name]])
          first_num <- suppressWarnings(as.numeric(sub("(-?\\d+).*", "\\1", val_str)))
          ifelse(is.na(first_num), -9999, first_num)
        }
      )
    ) %>%
    dplyr::arrange(desc(.sort_key)) %>%
    dplyr::select(-.sort_key)
  
  df
}

# Keep "All" semantics tidy (like locResult)


# Robust m/d/y date parser for mixed inputs
parse_date_mdy <- function(x) {
  parse_date_flex(x)
}


# returns a named vector of usage % by pitch type for a given filtered df
usage_by_type <- function(df) {
  # Determine which column to use for pitch type grouping
  pitch_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
  
  total <- nrow(df)
  if (!total) return(setNames(numeric(0), character(0)))
  
  result <- df %>%
    dplyr::count(.data[[pitch_col]], name = "n") %>%
    dplyr::mutate(pct = 100 * n / total)
  
  setNames(result$pct, result[[pitch_col]])
}

# ---- Data import + cleaning (recursive from data/practice and data/V3[/CSV]) ----
library(readr)
library(stringr)   # explicit, even though tidyverse includes it

# Point to the app's local data folder (works locally & on shinyapps.io)
data_parent <- normalizePath(file.path(getwd(), "data"), mustWork = TRUE)

# Find every CSV under data/, keep only those under practice/ or V3/
all_csvs <- list.files(
  path       = data_parent,
  pattern    = "\\.csv$",
  recursive  = TRUE,
  full.names = TRUE
)
all_csvs <- all_csvs[ grepl("([/\\\\]practice[/\\\\])|([/\\\\]v3[/\\\\])", tolower(all_csvs)) ]

if (!length(all_csvs)) stop("No CSVs found under: ", data_parent)

# Map folder → SessionType
infer_session_from_path <- function(fp) {
  fpl <- tolower(fp)
  if (grepl("[/\\\\]practice[/\\\\]", fpl)) "Bullpen"
  else if (grepl("[/\\\\]v3[/\\\\]", fpl)) "Live"
  else "Live"
}

# Grab the LAST YYYY/MM/DD in the path (handles .../V3/2025/08/13/CSV/file.csv)
extract_folder_date <- function(fp) {
  m <- stringr::str_match_all(fp, "(20\\d{2})[\\/](0[1-9]|1[0-2])[\\/](0[1-9]|[12]\\d|3[01])")[[1]]
  if (nrow(m)) as.Date(paste(m[nrow(m),2], m[nrow(m),3], m[nrow(m),4], sep = "-")) else NA
}

read_one <- function(fp) {
  df <- suppressMessages(readr::read_csv(
    fp,
    col_types = readr::cols(.default = readr::col_character())
  ))
  
  # --- NEW: SessionType from folder with CSV fallback/normalization ---
  path_st <- infer_session_from_path(fp)  # "Bullpen" if /practice/, "Live" if /v3/
  if (!"SessionType" %in% names(df)) df$SessionType <- NA_character_
  st_chr <- tolower(trimws(as.character(df$SessionType)))
  
  df$SessionType <- dplyr::case_when(
    grepl("bull|prac", st_chr) ~ "Bullpen",
    grepl("live|game|ab", st_chr) ~ "Live",
    TRUE ~ path_st  # fallback to folder mapping when blank/unknown
  )
  
  
  # Canonicalize to the names used throughout the app (case-insensitive).
  # For each canonical name, if it's missing but an alias exists, rename alias -> canonical.
  canon_aliases <- list(
    InducedVertBreak = c("IVB"),
    HorzBreak        = c("HB"),
    RelSpeed         = c("Velo"),
    ReleaseTilt      = c("ReleaseAngle", "SpinAxis3dTransverseAngle"),
    BreakTilt        = c("BreakAngle",   "SpinAxis"),
    SpinEfficiency   = c("SpinEff",      "SpinAxis3dSpinEfficiency"),
    SpinRate         = c("Spin"),
    RelHeight        = c("RelZ"),
    RelSide          = c("RelX"),
    VertApprAngle    = c("VAA"),
    HorzApprAngle    = c("HAA"),
    PlateLocSide     = c("PlateX"),
    PlateLocHeight   = c("PlateZ")
  )
  
  nm <- names(df)
  for (canon in names(canon_aliases)) {
    if (!(canon %in% nm)) {
      for (al in canon_aliases[[canon]]) {
        hit <- which(tolower(nm) == tolower(al))
        if (length(hit) == 1) {
          names(df)[hit] <- canon
          nm <- names(df)
          break
        }
      }
    }
  }
  
  # --- Date: prefer a real date; fall back to folder date if the CSV "Date" is bad ---
  looks_like_time <- function(x) {
    s <- tolower(trimws(as.character(x)))
    grepl("^\\d{1,2}:\\d{2}(\\.\\d+)?$", s)
  }
  can_parse_as_date <- function(x) {
    x <- as.character(x)
    a <- suppressWarnings(as.Date(x, "%m/%d/%Y"))
    b <- suppressWarnings(as.Date(x, "%m/%d/%y"))
    c <- suppressWarnings(as.Date(x, format = "%Y-%m-%d"))
    num <- suppressWarnings(as.numeric(x))         # Excel serials
    serial_ok <- !is.na(num) & num > 20000 & num < 60000
    any(!is.na(a) | !is.na(b) | !is.na(c) | serial_ok)
  }
  
  needs_folder_date <-
    (!"Date" %in% names(df)) ||
    all(is.na(df$Date)) ||
    all(looks_like_time(df$Date) | !nzchar(as.character(df$Date)), na.rm = TRUE) ||
    !can_parse_as_date(df$Date)
  
  if (needs_folder_date) {
    df$Date <- as.character(extract_folder_date(fp))
  }
  # -------------------------------------------------------------------------------
  
  # Normalize unlabeled pitch types (unchanged)
  if ("TaggedPitchType" %in% names(df)) {
    df$TaggedPitchType <- ifelse(
      is.na(df$TaggedPitchType) | df$TaggedPitchType == "",
      "Undefined",
      df$TaggedPitchType
    )
  }
  
  df$SourceFile <- fp
  df
}


# Build a KDE-based posterior P(Y=1 | x,y) = p1 * f1(x,y) / f_all(x,y)
kde_ratio_grid <- function(x, y, y_is_one, lims = c(-2.5,2.5,0,4.5), n = 180, h = NULL) {
  ok   <- is.finite(x) & is.finite(y) & is.finite(y_is_one)
  x    <- x[ok]; y <- y[ok]; y1 <- y_is_one[ok] > 0
  if (!length(x) || sum(y1) == 0) {
    return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
  }
  p1 <- mean(y1)
  # only pass 'h' if it's not NULL (avoids rep(NULL, ...) warnings inside MASS)
  if (is.null(h)) {
    d_all <- MASS::kde2d(x,      y,      n = n, lims = lims)
    d_pos <- MASS::kde2d(x[y1],  y[y1],  n = n, lims = lims)
  } else {
    d_all <- MASS::kde2d(x,      y,      n = n, lims = lims, h = h)
    d_pos <- MASS::kde2d(x[y1],  y[y1],  n = n, lims = lims, h = h)
  }
  z <- (p1 * d_pos$z) / pmax(d_all$z, 1e-12)
  z <- pmin(pmax(z, 0), 1)  # clamp
  expand.grid(x = d_all$x, y = d_all$y) |> transform(z = as.vector(z))
}


# Smooth mean over space for EV / LA (uses akima if available, else bin+loess fallback)
# replace your smooth_mean_grid() with this version
smooth_mean_grid <- function(x, y, val, lims = c(-2.5,2.5,0,4.5), n = 160,
                             method = c("auto","loess","akima"), span = 0.6) {
  method <- match.arg(method)
  ok <- is.finite(x) & is.finite(y) & is.finite(val)
  x <- x[ok]; y <- y[ok]; val <- val[ok]
  if (!length(x)) return(data.frame(x=numeric(0), y=numeric(0), z=numeric(0)))
  
  xs <- seq(lims[1], lims[2], length.out = n)
  ys <- seq(lims[3], lims[4], length.out = n)
  
  if (method == "akima" || (method == "auto" && have_akima)) {
    surf <- akima::interp(x, y, val, xo = xs, yo = ys,
                          linear = TRUE, extrap = TRUE, duplicate = "mean")
    expand.grid(x = surf$x, y = surf$y) |> transform(z = as.vector(surf$z))
  } else {
    df <- data.frame(x = x, y = y, z = val)
    fit <- suppressWarnings(loess(z ~ x * y, data = df, span = span,
                                  control = loess.control(surface = "direct")))
    grid <- expand.grid(x = xs, y = ys)
    grid$z <- as.numeric(predict(fit, newdata = grid))
    grid
  }
}

# Drawing helper (strike zone + plate + filled contours with your palette)
# replace your current draw_heat() with this version
# Drawing helper (strike zone + plate + filled contours with your palette)
# Updated version with scale legend support
draw_heat <- function(grid, bins = HEAT_BINS, pal_fun = heat_pal_red,
                      title = NULL, mark_max = TRUE, breaks = NULL,
                      show_scale = FALSE, scale_label = NULL, scale_limits = NULL,
                      scale_breaks = NULL, scale_labels = NULL) {
  if (!nrow(grid)) return(ggplot() + theme_void())
  
  home <- data.frame(
    x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
    y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
  )
  sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
  
  peak_df <- NULL
  if (mark_max) {
    i <- which.max(grid$z)
    if (length(i) && is.finite(grid$z[i])) {
      peak_df <- data.frame(px = grid$x[i], py = grid$y[i])
    }
  }
  
  n_bins <- if (is.null(breaks)) bins else max(1, length(breaks) - 1)
  
  # Main heatmap plot
  p_heat <- ggplot(grid, aes(x, y, z = z)) +
    {
      if (is.null(breaks))
        geom_contour_filled(aes(fill = after_stat(level)), bins = bins, show.legend = FALSE)
      else
        geom_contour_filled(aes(fill = after_stat(level)), breaks = breaks, show.legend = FALSE)
    } +
    scale_fill_manual(values = pal_fun(n_bins), guide = "none") +
    geom_polygon(data = home, aes(x, y), fill = NA, color = "black", inherit.aes = FALSE) +
    geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
              fill = NA, color = "black", inherit.aes = FALSE) +
    { if (!is.null(peak_df))
      geom_point(data = peak_df, aes(x = px, y = py), inherit.aes = FALSE,
                 size = 3.8, shape = 21, fill = "red", color = "black", stroke = 0.5)
    } +
    coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
    theme_void() + 
    theme(legend.position = "none",
          plot.title = element_text(face = "bold", hjust = 0.5),
          plot.background = element_rect(fill = "transparent", color = NA),
          panel.background = element_rect(fill = "transparent", color = NA)) +
    labs(title = title)
  
  # If show_scale, add gradient bar on top
  if (show_scale && !is.null(scale_limits)) {
    # Create scale bar data matching strike zone width
    sz_width <- ZONE_RIGHT - ZONE_LEFT  # ~1.66 feet
    scale_data <- data.frame(
      x = seq(scale_limits[1], scale_limits[2], length.out = 200),
      y = 1,
      z = seq(scale_limits[1], scale_limits[2], length.out = 200)
    )
    
    scale_breaks_final <- if (!is.null(scale_breaks)) {
      scale_breaks
    } else if (!is.null(scale_limits) && length(scale_limits) >= 2) {
      c(scale_limits[1], mean(scale_limits), scale_limits[length(scale_limits)])
    } else if (is.null(breaks)) {
      pretty(scale_limits, n = 5)
    } else {
      fin <- breaks[is.finite(breaks)]
      fin[c(1, round(length(fin) / 2), length(fin))]
    }
    
    scale_labels_final <- scale_labels
    if (identical(scale_label, "Pitch Frequency") && length(scale_limits) >= 2) {
      scale_breaks_final <- scale_limits[c(1, length(scale_limits))]
      scale_labels_final <- c("Least", "Most")
    }
    
    p_scale <- ggplot(scale_data, aes(x = z, y = y, fill = z)) +
      geom_tile(width = (scale_limits[2] - scale_limits[1]) / 200, height = 1) +
      scale_fill_gradientn(colors = pal_fun(100), limits = scale_limits) +
      scale_x_continuous(
        breaks = scale_breaks_final,
        labels = if (is.null(scale_labels_final)) ggplot2::waiver() else scale_labels_final,
        limits = scale_limits,
        expand = c(0, 0)
      ) +
      coord_cartesian(xlim = scale_limits, ylim = c(0.5, 1.5)) +
      theme_void() +
      theme(
        legend.position = "none",
        axis.text.x = element_text(size = 10, face = "bold", margin = margin(t = 3)),
        axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 8)),
        plot.margin = margin(5, 0, 10, 0),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.background = element_rect(fill = "transparent", color = NA),
        aspect.ratio = 0.15  # Make scale bar much narrower
      ) +
      labs(x = scale_label)
    
    # Combine scale bar on top of heatmap with tighter layout
    return(p_scale / p_heat + plot_layout(heights = c(0.08, 1), widths = c(sz_width)))
  }
  
  p_heat
}


pitch_data <- purrr::map_dfr(all_csvs, read_one)

# Ensure required columns exist since downstream code expects them
# ------ add to need_cols ------
need_cols <- c(
  "Date","Pitcher","Email","PitcherThrows","TaggedPitchType",
  "InducedVertBreak","HorzBreak","RelSpeed","ReleaseTilt","BreakTilt",
  "SpinEfficiency","SpinRate","RelHeight","RelSide","Extension",
  "VertApprAngle","HorzApprAngle","PlateLocSide","PlateLocHeight",
  "PitchCall","KorBB","Balls","Strikes","SessionType","PlayID",
  "ExitSpeed","Angle","BatterSide",
  "PlayResult","TaggedHitType","OutsOnPlay",
  "Batter", "Catcher",
  "VideoClip","VideoClip2","VideoClip3"
)



for (nm in need_cols) if (!nm %in% names(pitch_data)) pitch_data[[nm]] <- NA_character_

# Type cleanup + standardization (now safe to coerce)
pitch_data <- pitch_data %>%
  mutate(
    Date            = parse_date_mdy(Date),
    Pitcher         = as.character(Pitcher),
    Email           = as.character(Email),
    PitcherThrows   = as.character(PitcherThrows),
    TaggedPitchType = trimws(as.character(TaggedPitchType)),
    InducedVertBreak= as.numeric(InducedVertBreak),
    HorzBreak       = as.numeric(HorzBreak),
    RelSpeed        = as.numeric(RelSpeed),
    ReleaseTilt     = as.numeric(ReleaseTilt),
    BreakTilt       = as.numeric(BreakTilt),
    SpinEfficiency  = as.numeric(SpinEfficiency),
    SpinRate        = as.numeric(SpinRate),
    RelHeight       = as.numeric(RelHeight),
    RelSide         = as.numeric(RelSide),
    VertApprAngle   = as.numeric(VertApprAngle),
    HorzApprAngle   = as.numeric(HorzApprAngle),
    PlateLocSide    = as.numeric(PlateLocSide),
    PlateLocHeight  = as.numeric(PlateLocHeight),
    Extension       = as.numeric(Extension),
    ExitSpeed       = as.numeric(ExitSpeed),   # ← NEW
    Angle           = as.numeric(Angle),       # ← NEW
    BatterSide      = as.character(BatterSide), # ← NEW
    PlayResult      = as.character(PlayResult),
    Batter         = as.character(Batter),
    Catcher = as.character(Catcher),
    SessionType = factor(
      dplyr::case_when(
        grepl("bull|prac", tolower(as.character(SessionType))) ~ "Bullpen",
        grepl("live|game|ab", tolower(as.character(SessionType))) ~ "Live",
        grepl("[/\\\\]practice[/\\\\]", tolower(SourceFile)) ~ "Bullpen",  # fallback: folder
        grepl("[/\\\\]v3[/\\\\]",       tolower(SourceFile)) ~ "Live",
        TRUE ~ NA_character_
      ),
      levels = c("Bullpen","Live")
    ),
    KorBB           = as.character(KorBB),
    Balls           = as.numeric(Balls),
    Strikes         = as.numeric(Strikes),
    # Convert FourSeamFastBall to Fastball
    TaggedPitchType = ifelse(TaggedPitchType == "FourSeamFastBall", "Fastball", TaggedPitchType)
  ) %>%
  dplyr::filter(!is.na(TaggedPitchType) & tolower(TaggedPitchType) != "undefined") %>%
  force_pitch_levels()

# ---- Attach Cloudinary video URLs when available ----
video_map_path <- file.path(data_parent, "video_map.csv")
manual_map_path <- file.path(data_parent, "video_map_manual.csv")
if (!"VideoClip"  %in% names(pitch_data)) pitch_data$VideoClip  <- NA_character_
if (!"VideoClip2" %in% names(pitch_data)) pitch_data$VideoClip2 <- NA_character_
if (!"VideoClip3" %in% names(pitch_data)) pitch_data$VideoClip3 <- NA_character_

# Combine EdgeR and manual/iPhone video maps
video_maps <- list()
if (file.exists(video_map_path)) {
  edger_raw <- suppressMessages(readr::read_csv(video_map_path, show_col_types = FALSE))
  if (nrow(edger_raw) > 0) {
    video_maps[["edger"]] <- edger_raw
    message("📹 Loaded ", nrow(edger_raw), " EdgeR videos")
  }
}
if (file.exists(manual_map_path)) {
  manual_raw <- suppressMessages(readr::read_csv(manual_map_path, show_col_types = FALSE))
  if (nrow(manual_raw) > 0) {
    video_maps[["manual"]] <- manual_raw
    message("📱 Loaded ", nrow(manual_raw), " iPhone videos")
  }
}

if (length(video_maps) > 0) {
  vm_raw <- dplyr::bind_rows(video_maps) %>% dplyr::distinct()
  message("🎬 Combined total: ", nrow(vm_raw), " videos available")
  if (nrow(vm_raw)) {
    vm_wide <- vm_raw %>%
      dplyr::mutate(
        play_id = tolower(as.character(play_id)),
        camera_slot = dplyr::case_when(
          camera_slot %in% c("VideoClip","VideoClip2","VideoClip3") ~ camera_slot,
          TRUE ~ NA_character_
        ),
        uploaded_at = suppressWarnings(lubridate::ymd_hms(uploaded_at, quiet = TRUE, tz = "UTC"))
      ) %>%
      dplyr::filter(
        nzchar(play_id),
        !is.na(camera_slot),
        nzchar(cloudinary_url)
      ) %>%
      dplyr::arrange(play_id, camera_slot, dplyr::desc(uploaded_at)) %>%
      dplyr::group_by(play_id, camera_slot) %>%
      dplyr::slice_head(n = 1) %>%
      dplyr::ungroup() %>%
      tidyr::pivot_wider(
        id_cols = play_id,
        names_from = camera_slot,
        values_from = cloudinary_url
      )
    
    if (nrow(vm_wide)) {
      pitch_data <- pitch_data %>%
        dplyr::mutate(.play_lower = tolower(as.character(PlayID))) %>%
        dplyr::left_join(vm_wide, by = c(".play_lower" = "play_id"), suffix = c("", ".vm")) %>%
        { 
          vm_cols <- paste0(c("VideoClip","VideoClip2","VideoClip3"), ".vm")
          for (vm_col in vm_cols) {
            if (!vm_col %in% names(.)) .[[vm_col]] <- NA_character_
          }
          .
        } %>%
        dplyr::mutate(
          VideoClip  = dplyr::coalesce(.data[["VideoClip.vm"]],  VideoClip),
          VideoClip2 = dplyr::coalesce(.data[["VideoClip2.vm"]], VideoClip2),
          VideoClip3 = dplyr::coalesce(.data[["VideoClip3.vm"]], VideoClip3)
        ) %>%
        dplyr::select(-dplyr::ends_with(".vm"), -.play_lower)
      matched_videos <- sum(nzchar(pitch_data$VideoClip %||% ""))
      message("✅ Attached videos for ", matched_videos, " pitches from combined maps")
    } else {
      message("⚠️  Video maps loaded but no rows matched PlayID in pitch data.")
    }
  }
}

pitch_data <- ensure_pitch_keys(pitch_data)

# Friendly load message
counts <- table(pitch_data$SessionType, useNA = "no")
bcount <- if ("Bullpen" %in% names(counts)) counts[["Bullpen"]] else 0
lcount <- if ("Live"    %in% names(counts)) counts[["Live"]]    else 0
message("Loaded ", nrow(pitch_data), " rows from ", length(all_csvs),
        " files | Bullpen: ", bcount, " | Live: ", lcount,
        " | root: ", data_parent)


# Read lookup table and keep Email in a separate column to avoid .x/.y
lookup_table <- if (file.exists("lookup_table.csv")) {
  read.csv("lookup_table.csv", stringsAsFactors = FALSE) %>%
    dplyr::rename(Pitcher = PlayerName, Email_lookup = Email)
} else {
  data.frame(Pitcher = character(), Email_lookup = character(), stringsAsFactors = FALSE)
}

# Join, then coalesce into a single Email column
pitch_data <- dplyr::left_join(pitch_data, lookup_table, by = "Pitcher") %>%
  dplyr::mutate(Email = dplyr::coalesce(Email, Email_lookup)) %>%
  dplyr::select(-Email_lookup)


# (keep your name_map construction the same)
raw_names <- sort(unique(pitch_data$Pitcher))
display_names <- ifelse(
  grepl(",", raw_names),
  vapply(strsplit(raw_names, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_names
)
name_map <- setNames(raw_names, display_names)

raw_hitters <- sort(unique(na.omit(as.character(pitch_data$Batter))))
hit_display <- ifelse(
  grepl(",", raw_hitters),
  vapply(strsplit(raw_hitters, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_hitters
)
batter_map <- setNames(raw_hitters, hit_display)

# Opponent pitchers map (for hitting suite - pitchers who threw against our batters)
raw_opp_pitchers <- sort(unique(na.omit(as.character(pitch_data$Pitcher))))
opp_pitch_display <- ifelse(
  grepl(",", raw_opp_pitchers),
  vapply(strsplit(raw_opp_pitchers, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_opp_pitchers
)
opponent_pitcher_map <- setNames(raw_opp_pitchers, opp_pitch_display)

raw_catchers <- sort(unique(na.omit(as.character(pitch_data$Catcher))))
catch_display <- ifelse(
  grepl(",", raw_catchers),
  vapply(strsplit(raw_catchers, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_catchers
)
catcher_map <- setNames(raw_catchers, catch_display)


# ==== PITCHERS-ONLY WHITELIST ====
ALLOWED_PITCHERS <- school_setting("allowed_pitchers", c(
  "Wentworth, TP",
  "LeBlanc, Bryce",
  "Lund, Ethan",
  "Fyke, Kai",
  "Rhodes, Stormy",
  "Wech, Noah",
  "Brown, Matthew",
  "Phillips, Brennan",
  "Blake, Drew",
  "Glendinning, Lucas",
  "Golden, Josiah",
  "Kennedy, Jake",
  "Barrett, Hudson",
  "Zagar, Kyler",
  "Albright, Gaige",
  "Sramek, Caden",
  "Jennings, Parker",
  "Burns, Zane",
  "Winslow, Drew",
  "Pearcy, Kyle",
  "Turner, Cael",
  "Pesca, Mario",
  "Watkins, Hunter",
  "Thompson, Brock",
  "Meola, Aidan",
  "Bowen, Terrance",
  "Smithwick, Campbell",
  "Shull, Garrett",
  "Indomenico, Remo",
  "Ortiz, Avery",
  "Wallace, Danny",
  "Brueggemann, Colin",
  "Ritchie, Kollin",
  "Conover, Alex",
  "Norman, Sebastian",
  "Essex, Ezra",
  "Saunders, Evan",
  "Pladson, Cole",
  "Schambow, Quinn",
  "Kennedy, Ty",
  "Francisco, Brady",
  "Pomeroy, Deacon",
  "Kennedy, Jacob"
))

# Mirror list for hitters (GCU hitters)
ALLOWED_HITTERS <- school_setting("allowed_hitters", c(
  "Wentworth, TP",
  "LeBlanc, Bryce",
  "Lund, Ethan",
  "Fyke, Kai",
  "Rhodes, Stormy",
  "Wech, Noah",
  "Brown, Matthew",
  "Phillips, Brennan",
  "Blake, Drew",
  "Glendinning, Lucas",
  "Golden, Josiah",
  "Kennedy, Jake",
  "Barrett, Hudson",
  "Zagar, Kyler",
  "Albright, Gaige",
  "Sramek, Caden",
  "Jennings, Parker",
  "Burns, Zane",
  "Winslow, Drew",
  "Pearcy, Kyle",
  "Turner, Cael",
  "Pesca, Mario",
  "Watkins, Hunter",
  "Thompson, Brock",
  "Meola, Aidan",
  "Bowen, Terrance",
  "Smithwick, Campbell",
  "Shull, Garrett",
  "Indomenico, Remo",
  "Ortiz, Avery",
  "Wallace, Danny",
  "Brueggemann, Colin",
  "Ritchie, Kollin",
  "Conover, Alex",
  "Norman, Sebastian",
  "Essex, Ezra",
  "Saunders, Evan",
  "Pladson, Cole",
  "Schambow, Quinn",
  "Kennedy, Ty",
  "Francisco, Brady",
  "Pomeroy, Deacon"
))

# CAMPS SUITE - Allowed campers for camps module
ALLOWED_CAMPERS <- school_setting("allowed_campers", c(
  "Bowman, Brock",
  "Daniels, Tyke",
  "Pearson, Blake",
  "Rodriguez, Josiah",
  "James, Brody",
  "Nevarez, Matthew",
  "Nunes, Nolan",
  "Parks, Jaeden",
  "Hill, Grant",
  "McGinnis, Ayden",
  "Morton, Ryker",
  "McGuire, John",
  "Willson, Brandon",
  "Lauterbach, Camden",
  "Turnquist, Dylan",
  "Bournonville, Tanner",
  "Evans, Lincoln",
  "Gnirk, Will",
  "Mann, Tyson",
  "Neneman, Chase",
  "Warmus, Joaquin",
  "Kapadia, Taylor",
  "Stoner, Timothy",
  "Bergloff, Cameron",
  "Hamm, Jacob",
  "Hofmeister, Ben",
  "Moo, Eriksen",
  "Peltz, Zayden",
  "Huff, Tyler",
  "Moseman, Cody"
))


`%in_ci%` <- function(x, y) tolower(x) %in% tolower(y)

# NEW: normalize for case, spaces, punctuation (so "D.J." == "DJ")
norm_name_ci <- function(x) gsub("[^a-z]", "", tolower(trimws(as.character(x))))

# Keep the full dataset for Hitting & global refs
# but build a PITCHING-ONLY copy that is filtered to the whitelist
# (affects Pitching, Comparison, Leaderboard modules that use pitch_data_pitching)
# If you ever want admins to bypass this, wrap the filter in `if (!is_admin()) { ... }`.
pitch_data_pitching <- pitch_data %>%
  dplyr::mutate(
    Pitcher = as.character(Pitcher),
    # Build a "First Last" display from "Last, First" for matching either style
    .disp = ifelse(grepl(",", Pitcher),
                   paste0(trimws(sub(".*,", "", Pitcher)), " ", trimws(sub(",.*", "", Pitcher))),
                   Pitcher)
  )

# Accept either "Last, First" or "First Last" in ALLOWED_PITCHERS
ALLOWED_PITCHERS_DL <- unique(c(
  ALLOWED_PITCHERS,
  ifelse(grepl(",", ALLOWED_PITCHERS),
         paste0(trimws(sub(".*,", "", ALLOWED_PITCHERS)), " ", trimws(sub(",.*", "", ALLOWED_PITCHERS))),
         ALLOWED_PITCHERS)
))
ALLOWED_HITTERS_DL <- unique(c(
  ALLOWED_HITTERS,
  ifelse(grepl(",", ALLOWED_HITTERS),
         paste0(trimws(sub(".*,", "", ALLOWED_HITTERS)), " ", trimws(sub(",.*", "", ALLOWED_HITTERS))),
         ALLOWED_HITTERS)
))

# Also include ALLOWED_CAMPERS in the pitching dataset
ALLOWED_CAMPERS_DL <- unique(c(
  ALLOWED_CAMPERS,
  ifelse(grepl(",", ALLOWED_CAMPERS),
         paste0(trimws(sub(".*,", "", ALLOWED_CAMPERS)), " ", trimws(sub(",.*", "", ALLOWED_CAMPERS))),
         ALLOWED_CAMPERS)
))

# Combine both allowed lists for the pitching dataset
ALL_ALLOWED_PITCHERS <- unique(c(ALLOWED_PITCHERS_DL, ALLOWED_CAMPERS_DL))
ALL_ALLOWED_HITTERS  <- unique(c(ALLOWED_HITTERS_DL,  ALLOWED_CAMPERS_DL))

# Robust, case/spacing/punctuation-insensitive filter
allowed_norm <- norm_name_ci(ALL_ALLOWED_PITCHERS)
pitch_data_pitching <- pitch_data_pitching %>%
  dplyr::mutate(.norm_raw  = norm_name_ci(Pitcher),
                .norm_disp = norm_name_ci(.disp)) %>%
  dplyr::filter(.norm_raw %in% allowed_norm | .norm_disp %in% allowed_norm) %>%
  dplyr::select(-.disp, -.norm_raw, -.norm_disp)

pitch_data_pitching <- ensure_pitch_keys(pitch_data_pitching)

# Name map for Pitching UI (restricted to the filtered set)
raw_names_p <- sort(unique(pitch_data_pitching$Pitcher))
display_names_p <- ifelse(
  grepl(",", raw_names_p),
  vapply(strsplit(raw_names_p, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_names_p
)
name_map_pitching <- setNames(raw_names_p, display_names_p)


# ---- NEW: xStat reference bins from your data ----
xbin_ref <- pitch_data %>%
  dplyr::filter(SessionType == "Live",
                PitchCall == "InPlay",
                is.finite(ExitSpeed), is.finite(Angle)) %>%
  dplyr::mutate(
    EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
    LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
  ) %>%
  dplyr::group_by(EVb, LAb) %>%
  dplyr::summarise(
    n   = dplyr::n(),
    p1B = mean(PlayResult == "Single", na.rm = TRUE),
    p2B = mean(PlayResult == "Double", na.rm = TRUE),
    p3B = mean(PlayResult == "Triple", na.rm = TRUE),
    pHR = mean(PlayResult == "HomeRun",na.rm = TRUE),
    .groups = "drop"
  )

# Fallback weighted means in case some bins are empty
x_overall <- xbin_ref %>%
  dplyr::summarise(
    p1B = weighted.mean(p1B, n), p2B = weighted.mean(p2B, n),
    p3B = weighted.mean(p3B, n), pHR = weighted.mean(pHR, n)
  )

# FanGraphs-like wOBA weights (approx)
W_BB <- 0.69; W_1B <- 0.90; W_2B <- 1.24; W_3B <- 1.56; W_HR <- 1.95

# ---- Usage calculations for count-based usage percentages ----
compute_usage_by_count <- function(df, original_df = NULL) {
  # Determine which column to use for pitch type grouping
  pitch_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
  
  denom_df <- if (!is.null(original_df)) original_df else df
  by_pt <- split(df, ifelse(is.na(df[[pitch_col]]) | !nzchar(as.character(df[[pitch_col]])), "Undefined", as.character(df[[pitch_col]])))
  
  total_pitches <- nrow(denom_df)
  total_0_0 <- sum(denom_df$Balls == 0 & denom_df$Strikes == 0, na.rm = TRUE)
  total_behind <- sum(denom_df$Balls %in% c(1,2,3) & denom_df$Strikes %in% c(0,1) &
                        ((denom_df$Balls == 1 & denom_df$Strikes == 0) |
                           (denom_df$Balls == 2 & denom_df$Strikes %in% c(0,1)) |
                           (denom_df$Balls == 3 & denom_df$Strikes %in% c(0,1))), na.rm = TRUE)
  total_even <- sum((denom_df$Balls == 0 & denom_df$Strikes == 0) |
                      (denom_df$Balls == 1 & denom_df$Strikes == 1) |
                      (denom_df$Balls == 2 & denom_df$Strikes == 2) |
                      (denom_df$Balls == 3 & denom_df$Strikes == 2), na.rm = TRUE)
  total_ahead <- sum((denom_df$Balls == 0 & denom_df$Strikes %in% c(1,2)) |
                       (denom_df$Balls == 1 & denom_df$Strikes == 2), na.rm = TRUE)
  total_less_2k <- sum(denom_df$Strikes < 2, na.rm = TRUE)
  total_2k <- sum(denom_df$Strikes == 2, na.rm = TRUE)
  
  pct_string <- function(num, den) {
    if (is.na(den) || den <= 0) return("0.0%")
    paste0(round(100 * num / den, 1), "%")
  }
  
  calc_usage <- function(dfi) {
    pitch_lab <- dfi[[pitch_col]][1]
    if (is.factor(pitch_lab)) pitch_lab <- as.character(pitch_lab)
    pitch_lab <- ifelse(is.na(pitch_lab) || !nzchar(pitch_lab), "Undefined", pitch_lab)
    
    overall <- pct_string(nrow(dfi), total_pitches)
    usage_0_0 <- pct_string(sum(dfi$Balls == 0 & dfi$Strikes == 0, na.rm = TRUE), total_0_0)
    usage_behind <- pct_string(
      sum(dfi$Balls %in% c(1,2,3) & dfi$Strikes %in% c(0,1) &
            ((dfi$Balls == 1 & dfi$Strikes == 0) |
               (dfi$Balls == 2 & dfi$Strikes %in% c(0,1)) |
               (dfi$Balls == 3 & dfi$Strikes %in% c(0,1))), na.rm = TRUE),
      total_behind
    )
    usage_even <- pct_string(
      sum((dfi$Balls == 0 & dfi$Strikes == 0) |
            (dfi$Balls == 1 & dfi$Strikes == 1) |
            (dfi$Balls == 2 & dfi$Strikes == 2) |
            (dfi$Balls == 3 & dfi$Strikes == 2), na.rm = TRUE),
      total_even
    )
    usage_ahead <- pct_string(
      sum((dfi$Balls == 0 & dfi$Strikes %in% c(1,2)) |
            (dfi$Balls == 1 & dfi$Strikes == 2), na.rm = TRUE),
      total_ahead
    )
    usage_less_2k <- pct_string(sum(dfi$Strikes < 2, na.rm = TRUE), total_less_2k)
    usage_2k <- pct_string(sum(dfi$Strikes == 2, na.rm = TRUE), total_2k)
    
    tibble::tibble(
      PitchType = pitch_lab,
      Usage     = overall,
      `0-0`     = usage_0_0,
      Behind    = usage_behind,
      Even      = usage_even,
      Ahead     = usage_ahead,
      `<2K`     = usage_less_2k,
      `2K`      = usage_2k
    )
  }
  
  out <- purrr::map_dfr(by_pt, calc_usage) %>%
    dplyr::mutate(PitchType = as.character(PitchType))
  all_row <- calc_usage(df) %>%
    dplyr::mutate(PitchType = "All")
  dplyr::bind_rows(out, all_row)
}

# ---- NEW: calculator for Process/Results metrics per pitch type (+ All) ----
compute_process_results <- function(df, mode = "All") {
  return(tryCatch({
    # Flatten any list columns early to avoid list inputs in downstream sums
    df <- flatten_metrics_df(df)
    # Force key fields to atomic types
    chr_fields <- intersect(c("PitchCall","PlayResult","TaggedHitType","KorBB","SessionType","SplitColumn","TaggedPitchType"), names(df))
    num_fields <- intersect(c("ExitSpeed","Angle","OutsOnPlay","Balls","Strikes"), names(df))
    for (nm in chr_fields) {
      if (is.list(df[[nm]])) {
        df[[nm]] <- vapply(df[[nm]], function(v) if (length(v)) as.character(v[[1]]) else NA_character_, character(1))
      } else {
        df[[nm]] <- as.character(df[[nm]])
      }
    }
    for (nm in num_fields) {
      if (is.list(df[[nm]])) {
        df[[nm]] <- vapply(df[[nm]], function(v) if (length(v)) suppressWarnings(as.numeric(v[[1]])) else NA_real_, numeric(1))
      } else {
        df[[nm]] <- suppressWarnings(as.numeric(df[[nm]]))
      }
    }
    # Last sweep: collapse any remaining list columns to character
    for (nm in names(df)) {
      if (is.list(df[[nm]])) {
        df[[nm]] <- vapply(df[[nm]], function(v) if (length(v)) as.character(v[[1]]) else NA_character_, character(1))
      }
    }
    
    # Determine which column to use for pitch type grouping
    # Prefer SplitColumn if it exists (Split By mode), otherwise use TaggedPitchType
    pitch_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
  
  calc_run_value <- function(pitch_call, play_result, korbb = NA) {
    pitch_call  <- as.character(pitch_call)
    play_result <- as.character(play_result)
    korbb       <- as.character(korbb)
    
    if (!is.na(korbb) && nzchar(korbb) && korbb != "NA") {
      if (korbb == "Strikeout") return(-0.27)
      if (korbb == "Walk")     return(0.33)
    }
    if (pitch_call %in% c("BallCalled", "BallIntentional", "BallinDirt")) return(0.03)
    if (pitch_call %in% c("StrikeCalled", "StrikeSwinging", "FoulBall",
                          "FoulBallFieldable", "FoulBallNotFieldable"))  return(-0.03)
    if (pitch_call == "HitByPitch" || play_result %in% c("Walk","IntentionalWalk","HitByPitch")) return(0.33)
    if (pitch_call == "InPlay") {
      if (play_result == "Single")   return(0.47)
      if (play_result == "Double")   return(0.78)
      if (play_result == "Triple")   return(1.09)
      if (play_result == "HomeRun")  return(1.40)
      if (play_result == "Error")    return(0.33)
      return(-0.27)
    }
    0
  }
  
  # split by pitch *as character*, not factor (prevents int/chr mixups later)
  by_pt <- split(
    df,
    ifelse(
      is.na(df[[pitch_col]]) | !nzchar(as.character(df[[pitch_col]])),
      "Undefined",
      as.character(df[[pitch_col]])
    )
  )
  
  calc_one <- function(dfi) {
    # Per-group safety: flatten again after split
    dfi <- as.data.frame(dfi, stringsAsFactors = FALSE, check.names = FALSE)
    for (nm in names(dfi)) {
      col <- dfi[[nm]]
      if (is.list(col)) {
        # If list of scalars, unlist; else take first element
        if (all(lengths(col) <= 1)) {
          dfi[[nm]] <- vapply(col, function(v) if (length(v)) v[[1]] else NA, FUN.VALUE = NA_character_)
        } else {
          dfi[[nm]] <- vapply(col, function(v) if (length(v)) as.character(v[[1]]) else NA_character_, character(1))
        }
      }
    }
    # Coerce key fields per group
    chr_fields_g <- intersect(c("PitchCall","PlayResult","TaggedHitType","KorBB","SessionType","SplitColumn", pitch_col), names(dfi))
    num_fields_g <- intersect(c("Balls","Strikes","OutsOnPlay","ExitSpeed","Angle"), names(dfi))
    for (nm in chr_fields_g) dfi[[nm]] <- as.character(dfi[[nm]])
    for (nm in num_fields_g) dfi[[nm]] <- suppressWarnings(as.numeric(dfi[[nm]]))

    # label for this group (force character, fall back to "Undefined")
    pitch_lab <- dfi[[pitch_col]][1]
    if (is.factor(pitch_lab)) pitch_lab <- as.character(pitch_lab)
    pitch_lab <- ifelse(is.na(pitch_lab) || !nzchar(pitch_lab), "Undefined", pitch_lab)
    
    pitch_n   <- nrow(dfi)
    dfi_live  <- dfi %>% dplyr::filter(SessionType == "Live")
    # Use the shared completed-PA BF calc (same as Leaderboard), Live only
    BF_live   <- calculate_bf(dfi_live)
    K_ct      <- sum(dfi_live$KorBB == "Strikeout", na.rm = TRUE)
    BB_ct     <- sum(dfi_live$KorBB == "Walk",      na.rm = TRUE)
    
    # CSW% (prefer PitchResult if present)
    # --- CSW% (from PitchCall only) ---
    csw_num <- if ("PitchCall" %in% names(dfi)) {
      sum(dfi$PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE)
    } else 0L
    
    `CSW%` <- fmt_pct1(csw_num, nrow(dfi))  # 1-decimal percent string
    
    
    # In-play denominators
    inplay_all  <- sum(dfi$PitchCall == "InPlay", na.rm = TRUE)
    inplay_live <- sum(dfi$SessionType == "Live" & dfi$PitchCall == "InPlay", na.rm = TRUE)
    
    # BABIP
    H_bip <- sum(dfi$PlayResult %in% c("Single","Double","Triple","HomeRun"), na.rm = TRUE)
    BABIP <- if (inplay_all > 0) fmt_rate3(H_bip / inplay_all) else ""
    
    # GB%
    GB_pct <- if (inplay_all > 0)
      paste0(round(100 * sum(dfi$TaggedHitType == "GroundBall", na.rm = TRUE) / inplay_all, 1), "%") else ""
    
    # Barrel%
    barrel_n <- sum(dfi$SessionType == "Live" & dfi$PitchCall == "InPlay" &
                      is.finite(dfi$ExitSpeed) & is.finite(dfi$Angle) &
                      dfi$ExitSpeed >= 95 & dfi$Angle >= 10 & dfi$Angle <= 35, na.rm = TRUE)
    Barrel_pct <- if (inplay_live > 0) paste0(round(100 * barrel_n / inplay_live, 1), "%") else ""
    
    # AVG / SLG over AB (exclude Undefined, Sacrifice)
    is_ab   <- !is.na(dfi$PlayResult) & !(dfi$PlayResult %in% c("Undefined","Sacrifice"))
    AB_ct   <- sum(is_ab, na.rm = TRUE)
    s1 <- sum(dfi$PlayResult == "Single",   na.rm = TRUE)
    s2 <- sum(dfi$PlayResult == "Double",   na.rm = TRUE)
    s3 <- sum(dfi$PlayResult == "Triple",   na.rm = TRUE)
    hr <- sum(dfi$PlayResult == "HomeRun",  na.rm = TRUE)
    H  <- s1 + s2 + s3 + hr
    TB <- 1*s1 + 2*s2 + 3*s3 + 4*hr
    
    AVG <- if (AB_ct > 0) fmt_rate3(H  / AB_ct) else ""
    SLG <- if (AB_ct > 0) fmt_rate3(TB / AB_ct) else ""
    
    # Expected hits/total bases from EV/LA bins (uses globals: xbin_ref, x_overall)
    bip_evla <- dfi %>%
      dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                    is.finite(ExitSpeed), is.finite(Angle)) %>%
      dplyr::mutate(
        EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
        LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
      ) %>%
      dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
    
    if (nrow(bip_evla)) {
      for (nm in c("p1B","p2B","p3B","pHR")) {
        bip_evla[[nm]][!is.finite(bip_evla[[nm]])] <- x_overall[[nm]]
      }
      x1B <- sum(bip_evla$p1B, na.rm = TRUE)
      x2B <- sum(bip_evla$p2B, na.rm = TRUE)
      x3B <- sum(bip_evla$p3B, na.rm = TRUE)
      xHR <- sum(bip_evla$pHR, na.rm = TRUE)
    } else {
      x1B <- x2B <- x3B <- xHR <- 0
    }
    
    xH   <- x1B + x2B + x3B + xHR
    xTB  <- 1*x1B + 2*x2B + 3*x3B + 4*xHR
    
    xAVG <- if (AB_ct > 0) fmt_rate3(xH / AB_ct)  else ""
    xSLG <- if (AB_ct > 0) fmt_rate3(xTB / AB_ct) else ""
    xISO <- if (AB_ct > 0) {
      as_num <- function(s) if (nzchar(s)) as.numeric(paste0("0", s)) else NA_real_
      v <- as_num(xSLG) - as_num(xAVG); fmt_rate3(v)
    } else ""
    
    # xWOBA per BF (globals: W_BB, W_1B, W_2B, W_3B, W_HR)
    xWOBA <- if (BF_live > 0) {
      w_num <- W_BB*BB_ct + W_1B*(x1B) + W_2B*(x2B) + W_3B*(x3B) + W_HR*(xHR)
      fmt_rate3(w_num / BF_live)
    } else ""
    
    # --- Outs / IP / FIP / WHIP (now includes strikeout outs) ---
    o_on_play <- suppressWarnings(sum(as.numeric(dfi$OutsOnPlay), na.rm = TRUE))
    k_outs    <- K_ct                              # each strikeout = 1 out
    tot_outs  <- o_on_play + k_outs
    ip_num    <- tot_outs / 3
    
    # RV/100 (sum of run values per pitch, scaled)
    # RV/100 (Live only; leave blank for bullpens/other sessions)
    rv_vals <- mapply(
      calc_run_value,
      dfi_live$PitchCall,
      dfi_live$PlayResult,
      if ("KorBB" %in% names(dfi_live)) dfi_live$KorBB else NA
    )
    rv_sum <- sum(rv_vals, na.rm = TRUE)
    pitch_n_live <- nrow(dfi_live)
    rv100  <- if (pitch_n_live > 0) ((rv_sum / pitch_n_live) * 100) - 0.43 else NA_real_
    rv100_fmt <- ifelse(is.finite(rv100), sprintf("%.1f", rv100), "")
    
    # Baseball-style IP text (e.g., 2.1, 3.2)
    IP_txt <- {
      inns <- tot_outs %/% 3
      rem  <- tot_outs %% 3
      paste0(inns, if (rem == 0) "" else paste0(".", rem))
    }
    
    # FIP (no constant), per IP
    FIP <- if (tot_outs > 0) {
      val <- (13*hr + 3*BB_ct - 2*K_ct) / ip_num
      fmt_num2(val)
    } else ""
    
    # WHIP = (H + BB) / IP   ← now counts K outs via tot_outs → ip_num
    WHIP <- if (tot_outs > 0) fmt_num2((H + BB_ct) / ip_num) else ""
    
    tibble::tibble(
      PitchType = pitch_lab,
      `CSW%`    = fmt_pct1(
        sum(dfi$PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE),
        nrow(dfi)
      ),
      IP        = IP_txt,
      BABIP     = BABIP,
      `GB%`     = GB_pct,
      `Barrel%` = Barrel_pct,
      AVG       = AVG,
      SLG       = SLG,
      xWOBA     = xWOBA,
      xISO      = xISO,
      FIP       = FIP,
      WHIP      = WHIP,
      `RV/100`  = rv100_fmt
    )
  }
  
  # build per-type rows (force character), then append the "All" row
  out <- purrr::map_dfr(by_pt, calc_one) %>%
    dplyr::mutate(PitchType = as.character(PitchType))
  
  all_row <- calc_one(df) %>%
    dplyr::mutate(PitchType = "All")
  
  dplyr::bind_rows(out, all_row)
  }, error = function(e) {
    message("compute_process_results fallback (error): ", conditionMessage(e))
    tibble::tibble(
      PitchType = character(0),
      `CSW%`    = character(0),
      IP        = character(0),
      BABIP     = character(0),
      `GB%`     = character(0),
      `Barrel%` = character(0),
      AVG       = character(0),
      SLG       = character(0),
      xWOBA     = character(0),
      xISO      = character(0),
      FIP       = character(0),
      WHIP      = character(0),
      `RV/100`  = character(0)
    )
  }))
}

# ---- Global table helpers shared by Pitching & Hitting ----
safe_pct <- function(num, den) {
  num <- suppressWarnings(as.numeric(num))
  den <- suppressWarnings(as.numeric(den))
  ifelse(is.finite(den) & den > 0 & is.finite(num),
         paste0(round(100 * num / den, 1), "%"),
         "")
}

nz_mean <- function(x) {
  x <- suppressWarnings(as.numeric(x))
  m <- mean(x, na.rm = TRUE)
  if (is.finite(m)) m else NA_real_
}

.make_summary_legacy <- function(df) {
  if (!nrow(df)) {
    return(tibble::tibble(
      PitchType = character(), PitchCount = integer(), Usage = character(),
      BF = integer(), Velo_Avg = numeric(), Velo_Max = numeric(), IVB = numeric(), HB = numeric(),
      ReleaseTilt = character(), BreakTilt = character(),  # <- now character
      SpinEff = character(), InZonePercent = character(), CompPercent = character(),
      KPercent = character(), BBPercent = character(), FPSPercent = character(),
      EAPercent = character(), StrikePercent = character(), WhiffPercent = character(),
      SpinRate = numeric(), RelHeight = numeric(), RelSide = numeric(),
      VertApprAngle = numeric(), HorzApprAngle = numeric(), Extension = numeric(),
      EV = numeric(), LA = numeric(), `Stuff+` = numeric(), `Ctrl+` = numeric(),
      `QP+` = numeric(), `Pitching+` = numeric()
    ))
  }
  
  
  nz_mean <- function(x) { x <- suppressWarnings(as.numeric(x)); m <- mean(x, na.rm = TRUE); if (is.finite(m)) m else NA_real_ }
  safe_div <- function(num, den) ifelse(den > 0, num/den, NA_real_)
  
  # BF usage map for % column - with error handling
  usage_map <- tryCatch({
    df %>%
      dplyr::filter(SessionType == "Live", Balls == 0, Strikes == 0) %>%
      dplyr::count(TaggedPitchType, name = "BF") %>%
      dplyr::mutate(Usage = ifelse(sum(BF) > 0, 100*BF/sum(BF), 0)) %>%
      { stats::setNames(.$Usage, .$TaggedPitchType) }
  }, error = function(e) {
    message("Error creating usage_map: ", conditionMessage(e))
    # Return empty named vector
    stats::setNames(numeric(0), character(0))
  })
  
  # NEW: per-pitch QP points (0..1); NA for non-live or out of competitive box
  df <- df %>% dplyr::mutate(QP_pts = compute_qp_points(.))
  
  df %>%
    dplyr::group_by(TaggedPitchType) %>%
    dplyr::summarise(
      PitchCount     = dplyr::n(),
      BF_live        = sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE),
      
      Velo_Avg       = nz_mean(RelSpeed),
      Velo_Max       = suppressWarnings(max(RelSpeed, na.rm = TRUE)),
      IVB            = nz_mean(InducedVertBreak),
      HB             = nz_mean(HorzBreak),
      ReleaseTilt    = convert_to_clock(nz_mean(ReleaseTilt)),
      BreakTilt      = convert_to_clock(nz_mean(BreakTilt)),
      SpinEff        = nz_mean(SpinEfficiency),
      SpinRate       = nz_mean(SpinRate),
      RelHeight      = nz_mean(RelHeight),
      RelSide        = nz_mean(RelSide),
      VertApprAngle  = nz_mean(VertApprAngle),
      HorzApprAngle  = nz_mean(HorzApprAngle),
      Extension      = nz_mean(Extension),
      
      InZonePercent  = safe_div(
        sum(PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
              PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, na.rm = TRUE),
        dplyr::n()
      ),
      CompPercent    = safe_div(
        sum(PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
              PlateLocHeight >= (2.65-1.5) & PlateLocHeight <= (2.65+1.5), na.rm = TRUE),
        dplyr::n()
      ),
      StrikePercent  = safe_div(
        sum(PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE),
        sum(!is.na(PitchCall))
      ),
      FPSPercent     = safe_div(
        sum(SessionType == "Live" & Balls == 0 & Strikes == 0 &
              PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","StrikeCalled","FoulBallFieldable"), na.rm = TRUE),
        BF_live
      ),
      EAPercent      = safe_div(
        sum(SessionType == "Live" & Balls == 0 & Strikes == 0 &
              PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE),
        BF_live
      ),
      KPercent       = safe_div(sum(SessionType == "Live" & KorBB == "Strikeout", na.rm = TRUE), BF_live),
      BBPercent      = safe_div(sum(SessionType == "Live" & KorBB == "Walk",      na.rm = TRUE), BF_live),
      WhiffPercent   = safe_div(sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
                                sum(PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)),
      
      EV             = nz_mean(ifelse(SessionType == "Live", ExitSpeed, NA_real_)),
      LA             = nz_mean(ifelse(SessionType == "Live", Angle,     NA_real_)),
      
      `Stuff+`       = round(nz_mean(`Stuff+`), 1),
      
      # Keep Command+ available for users/tables that still show it
      `Ctrl+`     = round(nz_mean(ifelse(
        PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
          PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, 1.47,
        ifelse(PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                 PlateLocHeight >= (2.65-1.5) & PlateLocHeight <= (2.65+1.5), 0.73, 0)
      )) * 100, 1),
      
      # NEW: QP+ per pitch type, then Pitching+ from Stuff+ and QP+
      `QP+`          = round(nz_mean(QP_pts) * 200, 1),
      `Pitching+`    = round((`Stuff+` + `QP+`) / 2, 1),
      .groups = "drop"
    ) %>%
    {
      # Handle both TaggedPitchType and SplitColumn cases
      if ("TaggedPitchType" %in% names(.)) {
        dplyr::rename(., PitchType = TaggedPitchType)
      } else if ("SplitColumn" %in% names(.)) {
        dplyr::rename(., PitchType = SplitColumn)
      } else {
        .
      }
    } %>%
    dplyr::mutate(PitchType = as.character(PitchType)) %>%
    dplyr::arrange(factor(PitchType, levels = names(all_colors))) %>%
    dplyr::mutate(
      Usage = paste0(dplyr::coalesce(round(usage_map[as.character(PitchType)], 1), 0), "%")
    ) %>%
    dplyr::select(
      PitchType, PitchCount, Usage, BF = BF_live,
      Velo_Avg, Velo_Max, IVB, HB,
      ReleaseTilt, BreakTilt, SpinEff, SpinRate,
      RelHeight, RelSide, VertApprAngle, HorzApprAngle, Extension,
      InZonePercent, CompPercent, KPercent, BBPercent, FPSPercent, EAPercent,
      StrikePercent, WhiffPercent, EV, LA, `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
    )
}


# modern summary builder (aligned with app-21, retains Usage/Overall columns)
make_summary <- function(df, group_col = "TaggedPitchType") {
  if (!nrow(df)) {
    return(tibble::tibble(
      PitchType     = character(),
      PitchCount    = integer(),
      Usage         = character(),
      Overall       = character(),
      BF            = integer(),
      Velo_Avg      = numeric(),
      Velo_Max      = numeric(),
      IVB           = numeric(),
      HB            = numeric(),
      ReleaseTilt   = character(),
      BreakTilt     = character(),
      SpinEff       = numeric(),
      SpinRate      = numeric(),
      RelHeight     = numeric(),
      RelSide       = numeric(),
      VertApprAngle = numeric(),
      HorzApprAngle = numeric(),
      Extension     = numeric(),
      InZonePercent = character(),
      CompPercent   = character(),
      KPercent      = character(),
      BBPercent     = character(),
      FPSPercent    = character(),
      EAPercent     = character(),
      StrikePercent = character(),
      SwingPercent  = character(),
      WhiffPercent  = character(),
      QPPercent     = character(),
      EV            = numeric(),
      LA            = numeric(),
      `Stuff+`      = numeric(),
      `Ctrl+`       = numeric(),
      `QP+`         = numeric(),
      `Pitching+`   = numeric()
    ))
  }
  
  usage_map    <- tryCatch(
    usage_by_type(df),
    error = function(e) {
      message("Error in usage_by_type: ", conditionMessage(e))
      stats::setNames(numeric(0), character(0))
    }
  )
  swing_levels <- default_swing_levels()
  
  pf <- compute_pa_flags(df)
  df <- pf$df %>%
    dplyr::mutate(
      .is_strikeout = pf$is_strikeout,
      .is_walk      = pf$is_walk,
      .is_swing     = ifelse(!is.na(PitchCall) & PitchCall %in% swing_levels, 1, 0)
    )
  
  df <- df %>% dplyr::mutate(QP_pts = compute_qp_points(.))
  
  df %>%
    dplyr::group_by(.data[[group_col]]) %>%
    dplyr::summarise(
      PitchCount    = dplyr::n(),
      Velo_Avg      = round(nz_mean(RelSpeed), 1),
      Velo_Max      = round(suppressWarnings(max(as.numeric(RelSpeed), na.rm = TRUE)), 1),
      IVB           = round(nz_mean(InducedVertBreak), 1),
      HB            = round(nz_mean(HorzBreak), 1),
      ReleaseTilt   = convert_to_clock(nz_mean(ReleaseTilt)),
      BreakTilt     = convert_to_clock(nz_mean(BreakTilt)),
      SpinEff       = nz_mean(SpinEfficiency),
      SpinRate      = round(nz_mean(SpinRate), 0),
      RelHeight     = round(nz_mean(RelHeight), 1),
      RelSide       = round(nz_mean(RelSide), 1),
      VertApprAngle = round(nz_mean(VertApprAngle), 1),
      HorzApprAngle = round(nz_mean(HorzApprAngle), 1),
      Extension     = round(nz_mean(Extension), 1),
      
      InZonePercent = {
        inzone <- (PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                     PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP)
        safe_pct(sum(inzone, na.rm = TRUE), sum(!is.na(inzone)))
      },
      CompPercent   = {
        comp <- (PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                   PlateLocHeight >= (2.65-1.7) & PlateLocHeight <= (2.65+1.3))
        safe_pct(sum(comp, na.rm = TRUE), sum(!is.na(comp)))
      },
      
      # Use shared BF calculation
      BF_live = calculate_bf(dplyr::cur_data_all()),
      BF_all  = calculate_bf(dplyr::cur_data_all()),
      K_all   = sum(!is.na(Strikes) & Strikes == 2 & !is.na(PitchCall) & PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE),
      BB_all  = sum(!is.na(Balls) & Balls == 3 & !is.na(PitchCall) & PitchCall == "BallCalled", na.rm = TRUE),
      
      KPercent  = safe_pct(K_all,  BF_all),
      BBPercent = safe_pct(BB_all, BF_all),
      QPCount   = sum((QP_pts * 200) >= 100, na.rm = TRUE),
      fps_opp  = sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE),
      
      FPS_all = sum(SessionType == "Live" & !is.na(Balls) & !is.na(Strikes) & Balls == 0 & Strikes == 0 &
                      !is.na(PitchCall) & PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBall","FoulBallFieldable"), na.rm = TRUE),
      EA_all  = sum(
        SessionType == "Live" & (!is.na(Balls) & !is.na(Strikes) & !is.na(PitchCall)) & (
          (Balls == 0 & Strikes == 0 & PitchCall == "InPlay") |
            (Balls == 0 & Strikes == 1 & PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable","FoulBall"
            )) |
            (Balls == 1 & Strikes == 0 & PitchCall == "InPlay") |
            (Balls == 1 & Strikes == 1 & PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable","FoulBall"
            ))
        ), na.rm = TRUE
      ),
      
      FPSPercent = safe_pct(FPS_all, fps_opp),
      EAPercent  = safe_pct(EA_all,  fps_opp),
      QPPercent  = safe_pct(QPCount, PitchCount),
      
      StrikePercent = {
        strike_calls <- c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable","FoulBall")
        strikes <- sum(PitchCall %in% strike_calls, na.rm = TRUE)
        safe_pct(strikes, PitchCount)
      },
      SwingPercent = safe_pct(sum(.is_swing, na.rm = TRUE), PitchCount),
      WhiffPercent  = {
        sw  <- sum(PitchCall == "StrikeSwinging", na.rm = TRUE)
        den <- sum(PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay","FoulBall"), na.rm = TRUE)
        safe_pct(sw, den)
      },
      
      EV = round(nz_mean(ifelse(SessionType == "Live", ExitSpeed, NA_real_)), 1),
      LA = round(nz_mean(ifelse(SessionType == "Live", Angle,     NA_real_)), 1),
      
      `Stuff+`   = round(nz_mean(`Stuff+`), 1),
      `Ctrl+` = round(nz_mean(ifelse(
        PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
          PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, 1.47,
        ifelse(
          PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
            PlateLocHeight >= (2.65-1.7) & PlateLocHeight <= (2.65+1.3),
          0.73, 0
        )
      )) * 100, 1),
      
      `QP+`       = round(mean(QP_pts, na.rm = TRUE) * 200, 1),
      `Pitching+` = round((`Stuff+` + `QP+`) / 2, 1),
      .groups = "drop"
    ) %>%
    {
      # The group_by column will have the name specified in group_col
      # Rename it to PitchType for consistency
      current_names <- names(.)
      if (group_col %in% current_names && group_col != "PitchType") {
        dplyr::rename(., PitchType = !!rlang::sym(group_col))
      } else {
        .
      }
    } %>%
    dplyr::mutate(PitchType = as.character(PitchType)) %>%
    dplyr::arrange(factor(PitchType, levels = names(all_colors))) %>%
    dplyr::mutate(
      UsagePct = tryCatch(
        dplyr::coalesce(round(usage_map[as.character(PitchType)], 1), 0),
        error = function(e) 0
      ),
      Usage    = paste0(UsagePct, "%"),
      Overall  = Usage
    ) %>%
    dplyr::select(
      PitchType, PitchCount, Usage, Overall, BF = BF_all,
      Velo_Avg, Velo_Max, IVB, HB,
      ReleaseTilt, BreakTilt, SpinEff, SpinRate,
      RelHeight, RelSide, VertApprAngle, HorzApprAngle, Extension,
      InZonePercent, CompPercent, KPercent, BBPercent, FPSPercent, EAPercent, QPPercent,
      StrikePercent, SwingPercent, WhiffPercent, EV, LA,
      `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
    ) %>%
    # Conditionally remove UsagePct if it exists
    {if ("UsagePct" %in% names(.)) dplyr::select(., -UsagePct) else .}
}


# --- UI ----
# === ui wrapper ===
pitch_ui <- function(show_header = FALSE) {
  # ⬇️ Pitching UI (updated: ggiraphOutput → girafeOutput)
  fluidPage(
    tags$head(
    tags$style(HTML(colorize_css(
        '@media print { .tab-content>.tab-pane{display:block!important;opacity:1!important;page-break-after:always;} .tab-content>.tab-pane:last-child{page-break-after:auto;} .nav-tabs,.sidebar,.form-group,#printBtn{display:none!important;} }
        #pitchingSidebarToggle { 
          position: fixed; 
          bottom: 20px; 
          left: 20px; 
          z-index: 1000; 
          background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
          color: white; 
          border: none; 
          padding: 15px 18px; 
          border-radius: 50px;
          cursor: pointer;
          box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
          transition: all 0.3s ease;
          font-size: 20px;
          width: 56px;
          height: 56px;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        #pitchingSidebarToggle:hover { 
          transform: translateY(-2px);
          box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
          background: linear-gradient(135deg, #ff8c1a 0%, #e35205 100%);
        }
        #pitchingSidebarToggle:active {
          transform: translateY(0);
        }
        /* Hide the sidebar column */
        .pitching-sidebar-hidden .col-sm-3,
        .pitching-sidebar-hidden .sidebar { 
          display: none !important; 
        }
        /* Force the entire page to full width */
        .pitching-sidebar-hidden,
        .pitching-sidebar-hidden body,
        .pitching-sidebar-hidden .container-fluid,
        .pitching-sidebar-hidden .tab-content {
          width: 100vw !important;
          max-width: 100vw !important;
          margin: 0 !important;
          padding-left: 15px !important;
          padding-right: 15px !important;
        }
        /* Force sidebarLayout and all rows to full viewport width */
        .pitching-sidebar-hidden .row {
          width: 100vw !important;
          max-width: 100vw !important;
          margin-left: -15px !important;
          margin-right: -15px !important;
          padding-left: 15px !important;
          padding-right: 15px !important;
        }
        /* Expand main content to absolute full viewport width */
        .pitching-sidebar-hidden .col-sm-9,
        .pitching-sidebar-hidden .main-panel { 
          width: 100vw !important; 
          max-width: 100vw !important;
          flex: 0 0 100vw !important;
          margin-left: -15px !important;
          margin-right: -15px !important;
          padding: 15px !important;
          float: none !important;
        }
        /* Force all inner rows to full width */
        .pitching-sidebar-hidden .col-sm-9 > .row,
        .pitching-sidebar-hidden .tab-pane > .row {
          width: calc(100vw - 30px) !important;
          max-width: calc(100vw - 30px) !important;
          margin: 0 !important;
        }
        /* Force inner columns to expand and fill space */
        .pitching-sidebar-hidden .col-sm-9 .col-sm-4,
        .pitching-sidebar-hidden .tab-pane .col-sm-4 {
          width: calc((100vw - 60px) / 3) !important;
          max-width: calc((100vw - 60px) / 3) !important;
          flex: 0 0 calc((100vw - 60px) / 3) !important;
        }
        .pitching-sidebar-hidden .col-sm-9 .col-sm-6,
        .pitching-sidebar-hidden .tab-pane .col-sm-6 {
          width: calc((100vw - 45px) / 2) !important;
          max-width: calc((100vw - 45px) / 2) !important;
          flex: 0 0 calc((100vw - 45px) / 2) !important;
        }
        .pitching-sidebar-hidden .col-sm-9 .col-sm-8,
        .pitching-sidebar-hidden .tab-pane .col-sm-8 {
          width: calc((100vw - 60px) * 2 / 3) !important;
          max-width: calc((100vw - 60px) * 2 / 3) !important;
          flex: 0 0 calc((100vw - 60px) * 2 / 3) !important;
        }
        .pitching-sidebar-hidden .col-sm-9 .col-sm-12,
        .pitching-sidebar-hidden .tab-pane .col-sm-12 {
          width: calc(100vw - 30px) !important;
          max-width: calc(100vw - 30px) !important;
          flex: 0 0 calc(100vw - 30px) !important;
        }
        /* Expand all charts and plots to fill their containers */
        .pitching-sidebar-hidden .shiny-plot-output,
        .pitching-sidebar-hidden .plotly,
        .pitching-sidebar-hidden canvas,
        .pitching-sidebar-hidden svg {
          width: 100% !important;
          max-width: 100% !important;
          height: auto !important;
        }
        /* Expand all tables */
        .pitching-sidebar-hidden .dataTables_wrapper,
        .pitching-sidebar-hidden .dataTable,
        .pitching-sidebar-hidden table {
          width: 100% !important;
          max-width: 100% !important;
        }
        /* Expand ggiraph outputs */
        .pitching-sidebar-hidden .ggiraph-output,
        .pitching-sidebar-hidden .girafe_container_std {
          width: 100% !important;
          max-width: 100% !important;
        }
        /* Force tab content to full width */
        .pitching-sidebar-hidden .tab-pane {
          width: 100% !important;
          max-width: 100% !important;
        }
        .pitching-sidebar-hidden .tab-pane:not(.active) {
          display: none !important;
        }
        .pitching-sidebar-hidden .tab-pane.active {
          display: block !important;
        }',
      accent_color, accent_secondary_color, background_color, background_secondary_color))),
      tags$script(HTML("
        $(document).ready(function() {
          $('#pitchingSidebarToggle').click(function() {
            $('body').toggleClass('pitching-sidebar-hidden');
            var btn = $(this);
            var icon = btn.find('i');
            if ($('body').hasClass('pitching-sidebar-hidden')) {
              icon.removeClass('fa-angle-double-left').addClass('fa-angle-double-right');
              btn.attr('title', 'Show Filters');
              // Force resize event to trigger chart redraws
              setTimeout(function() { 
                $(window).trigger('resize');
                // Force Plotly charts to resize
                if (window.Plotly) {
                  $('.plotly').each(function() {
                    Plotly.Plots.resize(this);
                  });
                }
                // Force DataTables to recalculate column widths
                if ($.fn.DataTable) {
                  $.fn.dataTable.tables({visible: true, api: true}).columns.adjust().draw();
                }
              }, 350);
            } else {
              icon.removeClass('fa-angle-double-right').addClass('fa-angle-double-left');
              btn.attr('title', 'Hide Filters');
              setTimeout(function() { 
                $(window).trigger('resize');
                if (window.Plotly) {
                  $('.plotly').each(function() {
                    Plotly.Plots.resize(this);
                  });
                }
                if ($.fn.DataTable) {
                  $.fn.dataTable.tables({visible: true, api: true}).columns.adjust().draw();
                }
              }, 350);
            }
          });
        });
      "))
    ),
    
    # Sidebar toggle button (floating in bottom left)
    tags$button(
      id = "pitchingSidebarToggle",
      class = "btn",
      title = "Hide Filters",
      HTML('<i class="fa fa-angle-double-left"></i>')
    ),
    
    # Anchored dark mode toggle (under navbar, above sidebar)
    fluidRow(
      column(
        width = 3,
        div(
          style = "padding: 6px 0 4px 4px;",
          tags$div(
            class = "dark-toggle inline-toggle",
            tags$label(
              class = "switch-label",
              tags$input(id = "dark_mode", type = "checkbox"),
              tags$span(class = "switch-track", tags$span(class = "switch-thumb")),
              tags$span(class = "switch-text", "Dark mode")
            )
          )
        )
      )
    ),
    
    # Optional header (logos + title). Hidden by default.
    if (isTRUE(show_header)) {
      fluidRow(
        class = "suite-header",
        column(2, tags$img(src = "PCUlogo.png", height = "100px")),
        column(
          8,
          div(
            style = "height:100%; display:flex; justify-content:center; align-items:flex-start;",
            tags$h1("Pitching Dashboard", style = "margin-top:25px; font-weight:bold;")
          )
        ),
        column(
          2,
          div(style = "text-align:right; margin-top:10px;",
              tags$img(src = school_logo, height = "80px", alt = school_display_name))
        )
      )
    },
    sidebarLayout(
      sidebarPanel(
        selectInput(
          "sessionType", "Session Type:",
          choices = c("All", "Bullpen", "Live"),
          selected = "All"
        ),
        selectInput(
          "withVideo", "With Video:",
          choices = c("All", "Yes", "No"),
          selected = "All"
        ),
        selectInput(
          "teamType", "Team:",
          choices = TEAM_CHOICES,
          selected = "All"
        ),
        uiOutput("pitcher_ui"),
        selectInput(
          "oppHitter", "Select Hitter:",
          choices = c("All" = "All", batter_map),
          selected = "All"
        ),
        dateRangeInput(
          "dates", "Date Range:",
          start  = if(exists("pitch_data") && nrow(pitch_data) > 0) max(pitch_data$Date, na.rm = TRUE) else Sys.Date(),
          end    = if(exists("pitch_data") && nrow(pitch_data) > 0) max(pitch_data$Date, na.rm = TRUE) else Sys.Date(),
          format = "mm/dd/yyyy"
        ),
        selectInput(
          "hand", "Pitcher Hand:",
          choices = c("All", "Left", "Right"), selected = "All"
        ),
        selectInput(
          "pitchType", "Pitch Type:",
          choices = c("All", if(exists("pitch_data") && nrow(pitch_data) > 0) levels(pitch_data$TaggedPitchType) else character(0)),
          selected = "All", multiple = TRUE
        ),
        selectInput(
          "zoneLoc", "Zone Location:",
          choices = c("All",
                      "Upper Half","Bottom Half","Left Half","Right Half",
                      "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
          selected = "All",
          multiple = TRUE
        ),
        selectInput(
          "inZone", "In Zone:",
          choices = c("All", "Yes", "No", "Competitive"),
          selected = "All"
        ),
        selectInput(
          "batterSide", "Batter Hand:",
          choices = c("All","Left","Right"), selected = "All"
        ),
        selectInput(
          "qpLocations", "QP Locations:",
          choices = c("All", "Yes", "No"), selected = "All"
        ),
        
        # NEW: Pitch Results filter (multi-select)
        selectInput(
          "pitchResults", "Pitch Results:",
          choices = c("All", result_levels),
          selected = "All",
          multiple = TRUE
        ),
        
        # NEW: Count filter (multi-select)
        selectInput(
          "countFilter", "Count:",
          choices = c(
            "All" = "All",
            "Even"   = "Even",
            "Behind" = "Behind",
            "Ahead"      = "Ahead",
            "2K Not Full"= "2KNF",
            "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
          ),
          selected = "All",
          multiple = TRUE
        ),
        
        # NEW: After Count filter (multi-select)
        selectInput(
          "afterCountFilter", "After Count:",
          choices = c(
            "All" = "All",
            "Even"   = "Even",
            "Behind" = "Behind",
            "Ahead"      = "Ahead",
            "2K Not Full"= "2KNF",
            "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
          ),
          selected = "All",
          multiple = TRUE
        ),
        selectInput(
          "breakLines", "Break Lines:",
          choices = c("None", "Fastball", "Sinker"), selected = "None"
        ),
        selectInput(
          "stuffLevel", "Stuff+ Level:",
          choices = c("Pro", "College", "High School"), selected = "College"
        ),
        selectInput(
          "stuffBase", "Stuff+ Base Pitch:",
          choices = c("Fastball", "Sinker"), selected = "Fastball"
        ),
        fluidRow(
          column(6, numericInput("veloMin", "Velocity Min (MPH):", value = NA)),
          column(6, numericInput("veloMax", "Velocity Max (MPH):", value = NA))
        ),
        fluidRow(
          column(6, numericInput("ivbMin", "IVB Min (inches):", value = NA)),
          column(6, numericInput("ivbMax", "IVB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput("hbMin", "HB Min (inches):", value = NA)),
          column(6, numericInput("hbMax", "HB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput("pcMin", "Pitch Count Min:", value = NA, min = 1)),
          column(6, numericInput("pcMax", "Pitch Count Max:", value = NA, min = 1))
        ),
        
        # Data refresh section
        hr(),
        div(
          style = "text-align:center; margin: 10px 0;",
          radioButtons(
            "pitch_click_action",
            label = NULL,
            choices = c("Play video" = "video", "Edit pitch" = "edit"),
            selected = "video",
            inline = TRUE,
            width = "100%"
          ),
          actionButton(
            "refreshModifications", 
            "Refresh Pitch Edits",
            icon = icon("refresh"),
            class = "btn-info btn-sm",
            style = "margin: 6px 0 4px 0;"
          ),
          downloadButton(
            "downloadPitchMods",
            "Download Pitch Edits",
            class = "btn-default btn-sm",
            style = "margin-top: 5px;"
          ),
          br(),
          div(
            id = "modificationStatus",
            style = "font-size: 12px; color: #666; margin-top: 5px;",
            textOutput("modificationStatusText")
          )
        ),
        
        width = 3,
        class = "sidebar"
      ),
      mainPanel(
        tabsetPanel(
          id = "tabs",
          tabPanel(
            "Summary",
            uiOutput("summaryHeader"), br(),
            fluidRow(
              column(
                4,
                div("Release",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px; text-align:center;"),
                div(
                  style = "text-align:center; margin-bottom:5px;",
                  selectInput("summaryReleaseDisplay", NULL,
                              choices = c("Averages Only", "Averages and Pitches", "Pitches"),
                              selected = "Averages Only",
                              multiple = FALSE,
                              width = "100%")
                ),
                ggiraph::girafeOutput("summary_releasePlot", height = "300px", width = "100%")
              ),              
              column(
                4,
                div("Movement",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px; text-align:center;"),
                div(
                  style = "text-align:center; margin-bottom:5px;",
                  selectInput("summaryMovementDisplay", NULL,
                              choices = c("Averages Only", "Averages and Pitches", 
                                          "Target Shapes Only", "Target Shapes and Pitches"),
                              selected = c("Averages and Pitches"),
                              multiple = TRUE,
                              width = "100%"),
                  actionButton("targetShapesSettings", "Target Settings", size = "xs", 
                               style = "padding:2px 8px; font-size:11px; margin-top:-5px;")
                ),
                ggiraph::girafeOutput("summary_movementPlot", height = "300px", width = "100%")
              ),
              column(
                4,
                div(
                  style = "text-align:center;",
                  div(
                    "HeatMaps",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px;"
                  ),
                  div(
                    style = "display:inline-block; width:80%;",
                    selectInput(
                      "summaryLocType",
                      label    = NULL,
                      choices  = c(
                        "Pitch",
                        "Frequency",
                        "Whiff Rate",
                        "GB Rate",
                        "Contact Rate",
                        "Swing Rate",
                        "Exit Velocity",
                        "Run Values"
                      ),
                      selected = "Pitch",
                      width    = "100%"
                    )
                  )
                ),
                conditionalPanel(
                  "input.summaryLocType=='Pitch'",
                  ggiraph::girafeOutput("summary_zonePlot", height = "300px", width = "100%")
                ),
                conditionalPanel(
                  "input.summaryLocType!='Pitch'",
                  plotOutput("summary_heatZonePlot", height = "300px")
                )
              )
            ),
            fluidRow(
              column(
                12,
                div(
                  class = "legend-plot-wrap",
                  style = "display:flex; flex-direction:column; align-items:center; justify-content:center; gap:0px; min-height: 130px;",
                  plotOutput("summary_legend", height = "70px", width = "100%"),
                  plotOutput("summary_result_legend", height = "70px", width = "100%")
                )
              )
            ),
            tags$style(HTML("
              #summary_legend, #summary_result_legend {
                background: transparent !important;
                border: none !important;
                box-shadow: none !important;
              }
            ")),
            br(),
            div(style = "margin: 8px 0;", uiOutput("summaryTableButtons")),
            DT::dataTableOutput("summaryTablePage")
          ),
          # --- Pitching → AB Report tab ---
          tabPanel(
            "AB Report",
            value = "pitch_ab_report",
            sidebarLayout(
              sidebarPanel(width = 3, uiOutput("abpSidebar")),
              mainPanel(
                width = 9,
                div(style = "display:flex; align-items:baseline; gap:12px; margin-bottom:8px;",
                    uiOutput("abpHeader")),
                uiOutput("abpPanels")
              )
            )
          ),
          tabPanel("Release",
                   div(
                     style = "text-align:center; margin-bottom:10px;",
                     selectInput("releaseComboDisplay", NULL,
                                 choices = c("Averages Only", "Averages and Pitches", "Pitches"),
                                 selected = "Averages Only",
                                 multiple = FALSE,
                                 width = "30%")
                   ),
                   ggiraph::girafeOutput("releaseCombo", height = "950px", width = "100%")),
          tabPanel(
            "Movement Plot",
            div(
              style = "text-align:center; margin-bottom:10px;",
              selectInput("movementPlotDisplay", NULL,
                          choices = c("Averages Only", "Averages and Pitches", 
                                      "Target Shapes Only", "Target Shapes and Pitches"),
                          selected = c("Averages and Pitches"),
                          multiple = TRUE,
                          width = "50%"),
              actionButton("targetShapesSettings", "Target Shapes Settings", 
                           style = "margin-top:-10px;")
            ),
            ggiraph::girafeOutput("movementPlot", height = "400px")
          ),
          tabPanel(
            "Data and Performance",
            div(style = "margin: 8px 0;", uiOutput("dpTableButtons")),
            DT::dataTableOutput("summaryTable")
          ),
          tabPanel(
            "Velocity",
            ggiraph::girafeOutput("velocityPlot", height = "450px"),
            ggiraph::girafeOutput("velocityByGamePlot", height = "450px"),
            ggiraph::girafeOutput("velocityInningPlot", height = "450px")
          ),
          # --- PITCHING HEATMAPS TAB (NON-MODULE UI) ---
          tabPanel(
            "HeatMaps",
            sidebarLayout(
              sidebarPanel(
                selectInput("hmChartType", "Select Chart:", choices = c("Heat","Pitch","QP+"), selected = "Heat"),
                conditionalPanel(
                  "input.hmChartType=='Heat'",
                  selectInput(
                    "hmStat", "Select Stat:",
                    choices = c(
                      "Frequency"      = "Frequency",
                      "Whiff Rate"     = "Whiff Rate",
                      "Exit Velocity"  = "EV",
                      "GB Rate"        = "GB Rate",
                      "Contact Rate"   = "Contact Rate",
                      "Swing Rate"     = "Swing Rate",
                      "Run Values"     = "Run Values"
                    ),
                    selected = "Frequency"
                  ),
                  uiOutput("hmNote")
                ),
                conditionalPanel(
                  "input.hmChartType=='QP+'",
                  helpText("Requires batter hand + counts from the same family (Ahead, Even, or Behind).")
                ),
                uiOutput("locLegend"),
                width = 3
              ),
              mainPanel(
                conditionalPanel("input.hmChartType=='Heat'",  plotOutput("heatmapsHeatPlot", height = "500px")),
                conditionalPanel("input.hmChartType=='Pitch'", ggiraph::girafeOutput("heatmapsPitchPlot", height = "500px")),
                conditionalPanel("input.hmChartType=='QP+'",   ggiraph::girafeOutput("heatmapsQPPlot",   height = "500px"))
              )
            )
          ),
          # --- QP LOCATIONS TAB ---
          tabPanel(
            "QP Locations",
            value = "qp_locations",
            fluidRow(
              column(2,
                     div(style = "padding: 10px;",
                         h5("Pitch Results", style = "font-weight: bold; margin-bottom: 10px;"),
                         div(style = "font-size: 12px;",
                             div(style = "margin-bottom: 3px;", "\u25CF Called Strike"),  # ●
                             div(style = "margin-bottom: 3px;", "\u25CB Ball"),           # ○
                             div(style = "margin-bottom: 3px;", "\u25B3 Foul"),           # △
                             div(style = "margin-bottom: 3px;", "\u2605 Whiff"),          # ★
                             div(style = "margin-bottom: 3px;", "\u25B2 In Play (Out)"),  # ▲
                             div(style = "margin-bottom: 3px;", "\u25A0 In Play (Hit)"),  # ■
                             div(style = "margin-bottom: 3px;", "\u25A1 Error")           # □
                         ),
                         br(),
                         h5("Pitch Type", style = "font-weight: bold; margin-bottom: 10px;"),
                         uiOutput("qpPitchTypeColors"),
                         br(),
                         h5("QP+ Heatmap", style = "font-weight: bold; margin-bottom: 10px;"),
                         div(style = "font-size: 12px;",
                             div(style = "display: flex; align-items: center; margin-bottom: 3px;",
                                 div(style = "width: 20px; height: 10px; background: linear-gradient(to right, blue, white, red); margin-right: 8px; border: 1px solid #ccc;"),
                                 "Blue (Low) → Red (High)"
                             ),
                             p(style = "font-size: 11px; color: #666; margin-top: 5px;",
                               "Shows optimal QP+ locations for each pitch type based on count situation."
                             )
                         )
                     )
              ),
              column(10,
                     # Main content area - all controlled by qpLocationsMessage
                     uiOutput("qpLocationsMessage")
              )
            )
          ),
          tabPanel(
            "Trend",
            sidebarLayout(
              sidebarPanel(
                selectInput(
                  "trendMetric", "Select Metric:",
                  choices = c(
                    "Velocity (Avg)",
                    "Velocity (Max)",
                    "InZone %",
                    "Comp %",
                    "FPS%",
                    "E+A%",
                    "Whiff%",
                    "CSW%",
                    "Strike%",
                    "K%",
                    "BB%",
                    "Stuff+",
                    "Ctrl+",
                    "QP+",
                    "QP%",
                    "Pitching+",
                    "IVB",
                    "HB",
                    "Release Height",
                    "Extension"
                  ),
                  selected = "Velocity (Avg)"
                ),
                width = 3
              ),
              mainPanel(
                uiOutput("trendPlotUI"),
                width = 9
              )
            )
          )
          
          , tabPanel(
            "Stuff+ Calculator",
            value = "stuff_calc",
            fluidRow(
              column(6,
                     h3("Pitch A"),
                     wellPanel(
                       selectInput("calc1_hand", "Pitcher Hand", choices = c("Right","Left"), selected = "Right"),
                       selectInput("calc1_pitch", "Pitch Type",
                                   choices = c("Fastball","Sinker","Cutter","Slider","Sweeper","Curveball","ChangeUp","Splitter"),
                                   selected = "Fastball"
                       ),
                       selectInput("calc1_level","Level", choices = c("High School","College","Pro"), selected = "College"),
                       numericInput("calc1_vel","Velocity (mph)", value = 92, min = 60, max = 110, step = 0.1),
                       numericInput("calc1_ivb","IVB (in)", value = 15, min = -40, max = 40, step = 0.1),
                       numericInput("calc1_hb","HB (in)", value = 10, min = -40, max = 40, step = 0.1),
                       numericInput("calc1_relheight","RelHeight (ft)", value = 5.8, min = 3.5, max = 7.5, step = 0.1),
                       conditionalPanel("!(['Fastball','Sinker'].includes(input.calc1_pitch))",
                                        tags$hr(),
                                        strong("Base pitch for off-speed context"),
                                        radioButtons("calc1_base_type","Base Type", choices = c("Fastball","Sinker"), selected = "Fastball", inline = TRUE),
                                        numericInput("calc1_base_vel","Base Velo (mph)", value = 92, min = 60, max = 110, step = 0.1),
                                        numericInput("calc1_base_ivb","Base IVB (in)", value = 15, min = -40, max = 40, step = 0.1),
                                        numericInput("calc1_base_hb","Base HB (in)", value = 10, min = -40, max = 40, step = 0.1)
                       ),
                       div(em("HB_adj (hand-agnostic): "), textOutput("calc1_hb_adj"))
                     ),
                     h2(textOutput("calc1_stuff"))
              ),
              column(6,
                     h3("Pitch B"),
                     wellPanel(
                       selectInput("calc2_hand", "Pitcher Hand", choices = c("Right","Left"), selected = "Right"),
                       selectInput("calc2_pitch", "Pitch Type",
                                   choices = c("Fastball","Sinker","Cutter","Slider","Sweeper","Curveball","ChangeUp","Splitter"),
                                   selected = "Slider"
                       ),
                       selectInput("calc2_level","Level", choices = c("High School","College","Pro"), selected = "College"),
                       numericInput("calc2_vel","Velocity (mph)", value = 85, min = 60, max = 110, step = 0.1),
                       numericInput("calc2_ivb","IVB (in)", value = -2, min = -40, max = 40, step = 0.1),
                       numericInput("calc2_hb","HB (in)", value = 15, min = -40, max = 40, step = 0.1),
                       numericInput("calc2_relheight","RelHeight (ft)", value = 5.8, min = 3.5, max = 7.5, step = 0.1),
                       conditionalPanel("!(['Fastball','Sinker'].includes(input.calc2_pitch))",
                                        tags$hr(),
                                        strong("Base pitch for off-speed context"),
                                        radioButtons("calc2_base_type","Base Type", choices = c("Fastball","Sinker"), selected = "Fastball", inline = TRUE),
                                        numericInput("calc2_base_vel","Base Velo (mph)", value = 92, min = 60, max = 110, step = 0.1),
                                        numericInput("calc2_base_ivb","Base IVB (in)", value = 15, min = -40, max = 40, step = 0.1),
                                        numericInput("calc2_base_hb","Base HB (in)", value = 10, min = -40, max = 40, step = 0.1)
                       ),
                       div(em("HB_adj (hand-agnostic): "), textOutput("calc2_hb_adj"))
                     ),
                     h2(textOutput("calc2_stuff"))
              )
            )
          )
        )
      )
    )
  )
}

# =========================
# == Hitting Suite (v1) ==
# =========================

mod_hit_ui <- function(id, show_header = FALSE) {
  ns <- NS(id)
  fluidPage(
    if (isTRUE(show_header)) {
      fluidRow(
        class = "suite-header",
        column(2, tags$img(src = "PCUlogo.png", height = "100px")),
        column(
          8,
          div(
            style = "height:100%; display:flex; justify-content:center; align-items:flex-start;",
            tags$h1("Hitting Dashboard", style = "margin-top:25px; font-weight:bold;")
          )
        ),
        column(
          2,
          div(style = "text-align:right; margin-top:10px;",
              tags$img(src = school_logo, height = "80px", alt = school_display_name))
        )
      )
    },
    sidebarLayout(
      sidebarPanel(
        selectInput(ns("hitter"), "Select Hitter:", choices = c("All" = "All", batter_map), selected = "All"),
        selectInput(ns("oppPitcher"), "Select Pitcher:", choices = c("All" = "All", opponent_pitcher_map), selected = "All"),
        selectInput(
          ns("teamType"), "Team:",
          choices = TEAM_CHOICES,
          selected = "All"
        ),
        dateRangeInput(ns("dates"), "Date Range:",
                       start = max(pitch_data$Date, na.rm = TRUE),
                       end   = max(pitch_data$Date, na.rm = TRUE),
                       format = "mm/dd/yyyy"),
        selectInput(ns("hand"),       "Pitcher Hand:",  choices = c("All","Left","Right"), selected = "All"),
        selectInput(
          ns("pitchType"), "Pitch Type:",
          choices = c("All", levels(pitch_data$TaggedPitchType)),
          selected = "All", multiple = TRUE
        ),
        selectInput(
          ns("zoneLoc"), "Zone Location:",
          choices = c("All",
                      "Upper Half","Bottom Half","Left Half","Right Half",
                      "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
          selected = "All",
          multiple = TRUE
        ),
        selectInput(ns("inZone"),     "In Zone:",       choices = c("All","Yes","No","Competitive"), selected = "All"),
        selectInput(ns("batterSide"), "Batter Hand:",   choices = c("All","Left","Right"), selected = "All"),
        
        # NEW: Pitch Results filter (multi-select)
        selectInput(
          ns("pitchResults"), "Pitch Results:",
          choices = c("All", result_levels),
          selected = "All",
          multiple = TRUE
        ),
        
        selectInput(
          ns("countFilter"), "Count:",
          choices  = c("All"="All","Even"="Even","Behind"="Behind","Ahead"="Ahead","2K Not Full"="2KNF",
                       "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
          selected = "All", multiple = TRUE
        ),
        selectInput(
          ns("afterCountFilter"), "After Count:",
          choices  = c("All"="All","Even"="Even","Behind"="Behind","Ahead"="Ahead","2K Not Full"="2KNF",
                       "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
          selected = "All", multiple = TRUE
        ),
        selectInput(
          ns("bipResult"), "BIP Result:",
          choices  = c("All","Single","Double","Triple","HomeRun","Out"),
          selected = "All", multiple = TRUE
        ),
        fluidRow(
          column(6, numericInput(ns("veloMin"), "Velocity Min (MPH):", value = NA)),
          column(6, numericInput(ns("veloMax"), "Velocity Max (MPH):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("ivbMin"), "IVB Min (inches):", value = NA)),
          column(6, numericInput(ns("ivbMax"), "IVB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("hbMin"), "HB Min (inches):", value = NA)),
          column(6, numericInput(ns("hbMax"), "HB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("pcMin"), "Pitch Count Min:", value = NA, min = 1)),
          column(6, numericInput(ns("pcMax"), "Pitch Count Max:", value = NA, min = 1))
        ),
        width = 3,
        class = "sidebar"
      ),
      mainPanel(
        tabsetPanel(
          id = ns("tabs"),
          tabPanel(
            "Summary",
            tagList(
              fluidRow(
                column(
                  4,
                  tags$div(
                    "vs. RHP",
                    style = "font-weight:bold; text-align:center; margin-bottom:6px;"
                  ),
                  ggiraph::girafeOutput(ns("loc_rhp"), height = "340px", width = "100%")
                ),
                column(
                  4,
                  tags$div(
                    "Spray Chart",
                    style = "font-weight:bold; text-align:center; margin-bottom:6px;"
                  ),
                  ggiraph::girafeOutput(ns("sprayChart"), height = "340px", width = "100%")
                ),
                column(
                  4,
                  tags$div(
                    "vs. LHP",
                    style = "font-weight:bold; text-align:center; margin-bottom:6px;"
                  ),
                  ggiraph::girafeOutput(ns("loc_lhp"), height = "340px", width = "100%")
                )
              ),
              div(
                style = "display:flex; justify-content:center; align-items:center; gap:60px; margin:12px 0;",
                div(style = "flex:1;", plotOutput(ns("result_key"), height = 120, width = "100%")),
                div(style = "flex:1;", plotOutput(ns("pitch_type_key"), height = 100, width = "100%"))
              ),
              div(style = "margin: 8px 0;", uiOutput(ns("dpButtons"))),
              DT::DTOutput(ns("dpTable"))
            )
          ),
          tabPanel(
            "AB Report",
            sidebarLayout(
              sidebarPanel(
                # Select Game control and legend live here
                uiOutput(ns("abSidebar")),
                width = 3
              ),
              mainPanel(
                # top-right header with player and date
                div(style = "display:flex; justify-content:flex-start; margin-bottom:8px;",
                    uiOutput(ns("abHeader"))),
                # all AB charts + tables (2 per row)
                uiOutput(ns("abPanels"))
              )
            )
          ),
          tabPanel(
            "HeatMaps",
            sidebarLayout(
              sidebarPanel(
                selectInput(
                  ns("hmChartType"), "Select Chart:",
                  choices = c("Heat", "Pitch"),
                  selected = "Heat"
                ),
                selectInput(
                  ns("hmStat"), "Select Stat:",
                  choices = c("Frequency","Whiff Rate","Exit Velocity","GB Rate","Contact Rate","Swing Rate","Run Values"),
                  selected = "Frequency"
                ),
                uiOutput(ns("hmNote")),
                width = 3
              ),
              mainPanel(
                conditionalPanel(
                  sprintf("input['%s']=='Heat'", ns("hmChartType")),
                  plotOutput(ns("heatmapsHeatPlot"), height = "500px")
                ),
                conditionalPanel(
                  sprintf("input['%s']=='Pitch'", ns("hmChartType")),
                  ggiraph::girafeOutput(ns("heatmapsPitchPlot"), height = "500px")
                )
              )
            )
          )
        )
      )
    )
  )
}

# -- Valid date range guard
is_valid_dates <- function(d) { !is.null(d) && length(d) == 2 && all(is.finite(d)) }

# -- Safe numeric mean
nz_mean <- function(x) {
  x <- suppressWarnings(as.numeric(x))
  if (!length(x)) return(NA_real_)
  m <- mean(x, na.rm = TRUE)
  if (is.finite(m)) m else NA_real_
}

# -- Safe clock conversion
safe_clock <- function(x) {
  if (!is.finite(x) || is.na(x)) return("")
  tryCatch(convert_to_clock(x), error = function(...) "")
}

# -- Safe QP+ scalar
safe_qp_scalar <- function(df) {
  out <- tryCatch(compute_qp_points(df), error = function(...) NA_real_)
  out <- suppressWarnings(as.numeric(out))
  if (!length(out)) return(NA_real_)
  round(mean(out, na.rm = TRUE) * 200, 1)
}

# Flatten list/matrix/factor/date cols so DT never sees objects
collapse_list_cols <- function(dat) {
  if (!nrow(dat)) return(dat)
  dat %>%
    dplyr::mutate(dplyr::across(
      where(is.list),
      ~ vapply(., function(x) {
        if (is.null(x)) "" else if (length(x) == 1 && !is.list(x)) as.character(x)
        else paste0(unlist(x), collapse = ", ")
      }, character(1))
    ))
}

safe_for_dt <- function(df) {
  if (!nrow(df)) return(df)
  out <- collapse_list_cols(df)
  out[] <- lapply(out, function(col) {
    if (is.factor(col)) as.character(col)
    else if (inherits(col, c("POSIXct","POSIXt","Date"))) as.character(col)
    else if (is.matrix(col)) apply(col, 1, paste, collapse = ", ")
    else col
  })
  as.data.frame(out, stringsAsFactors = FALSE, check.names = FALSE)
}

# Flatten list columns (preferring numeric when possible) so downstream math
# never sees list/NULL values (bullpen data occasionally carries nested cells)
flatten_metrics_df <- function(df) {
  if (!is.data.frame(df) || !nrow(df)) return(df)

  # NUCLEAR OPTION: Force to plain data.frame first
  df <- as.data.frame(df, stringsAsFactors = FALSE)

  flatten_col <- function(col) {
    if (is.factor(col)) col <- as.character(col)
    # Use is.atomic to catch all non-atomic types
    if (is.atomic(col) && !is.list(col)) return(col)

    # First pass: extract first element from each list item
    vals <- lapply(col, function(x) {
      if (is.null(x) || length(x) == 0) return(NA)
      # Handle nested lists
      val <- x[[1]]
      if (is.list(val)) val <- val[[1]]
      if (is.null(val) || length(val) == 0) return(NA)
      val
    })

    vals_chr <- vapply(vals, function(v) {
      if (is.null(v) || length(v) == 0 || (length(v) == 1 && is.na(v))) return(NA_character_)
      as.character(v[1])
    }, character(1))
    vals_num <- suppressWarnings(as.numeric(vals_chr))

    if (sum(!is.na(vals_num)) >= sum(!is.na(vals_chr)) * 0.6) {
      vals_num
    } else {
      vals_chr
    }
  }

  # Apply flattening to all columns
  df[] <- lapply(df, flatten_col)

  # Second pass: ensure no non-atomic columns remain
  for (nm in names(df)) {
    col <- df[[nm]]
    if (!is.atomic(col) || is.list(col)) {
      df[[nm]] <- tryCatch({
        vapply(col, function(x) {
          if (is.null(x) || length(x) == 0) NA_character_
          else as.character(x[[1]])
        }, character(1))
      }, error = function(e) {
        as.character(unlist(col))
      })
    }
  }

  df
}

mod_hit_server <- function(id, is_active = shiny::reactive(TRUE), global_date_range = NULL) {
  moduleServer(id, function(input, output, session) {
    # Global dark-mode flag (root scope toggle)
    is_dark_mode <- reactive({
      dm <- NULL
      # Prefer root scope (non-namespaced) dark_mode toggle
      dm <- tryCatch({
        rs <- session$rootScope()
        if (!is.null(rs) && !is.null(rs$input$dark_mode)) rs$input$dark_mode else NULL
      }, error = function(...) NULL)
      # Fallback to local (in case running outside root)
      if (is.null(dm) && !is.null(input$dark_mode)) dm <- input$dark_mode
      isTRUE(dm)
    })
    observe({
      custom_tables()
      update_custom_table_choices(session)
    })
    
    # Render per-cell filters UI based on selection
    output_filters_for_cell <- function(cell_id) {
      renderUI({
        sel <- input[[paste0("cell_filter_select_", cell_id)]]
        out <- list()
        if ("Dates" %in% sel) {
          # default date range from available data
          all_dates <- c(pitch_data_pitching$Date, pitch_data$Date)
          d_min <- suppressWarnings(min(all_dates, na.rm = TRUE)); d_max <- suppressWarnings(max(all_dates, na.rm = TRUE))
          if (!is.finite(d_min)) d_min <- Sys.Date() - 30
          if (!is.finite(d_max)) d_max <- Sys.Date()
          out <- c(out, list(
            dateRangeInput(ns(paste0("cell_dates_", cell_id)), "Dates:",
                           start = d_max - 30, end = d_max, min = d_min, max = d_max,
                           format = "mm/dd/yyyy")
          ))
        }
        if ("Session Type" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_session_", cell_id)), "Session Type:", choices = c("All","Bullpen","Live"), selected = "All")
          ))
        }
        if ("Pitch Types" %in% sel) {
          pts <- if (input$report_type == "Pitching") {
            sort(unique(as.character(pitch_data_pitching$TaggedPitchType)))
          } else {
            sort(unique(as.character(pitch_data$TaggedPitchType)))
          }
          out <- c(out, list(
            selectizeInput(ns(paste0("cell_pitch_types_", cell_id)), "Pitch Types:", choices = c("All", pts), multiple = TRUE, selected = "All")
          ))
        }
        if ("Batter Hand" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_batter_side_", cell_id)), "Batter Hand:", choices = c("All","Left","Right"), selected = "All")
          ))
        }
        if ("Pitcher Hand" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_pitcher_hand_", cell_id)), "Pitcher Hand:", choices = c("All","Left","Right"), selected = "All")
          ))
        }
        if ("Pitch Results" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_results_", cell_id)), "Pitch Results:", choices = c("All", result_levels), selected = "All", multiple = TRUE)
          ))
        }
        if ("QP Locations" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_qp_", cell_id)), "QP Locations:", choices = c("All","Yes","No"), selected = "All")
          ))
        }
        if ("Count" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_count_", cell_id)), "Count:", choices = c("All","Even","Behind","Ahead","2KNF",
                                                                                  "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
                        selected = "All", multiple = TRUE)
          ))
        }
        if ("After Count" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_after_count_", cell_id)), "After Count:", choices = c("All","Even","Behind","Ahead","2KNF",
                                                                                              "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
                        selected = "All", multiple = TRUE)
          ))
        }
        if ("Zone Location" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_zone_", cell_id)), "Zone Location:", choices = c("All",
                                                                                         "Upper Half","Bottom Half","Left Half","Right Half",
                                                                                         "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
                        selected = "All", multiple = TRUE)
          ))
        }
        if ("Velo Min/Max" %in% sel) {
          out <- c(out, list(
            numericInput(ns(paste0("cell_velo_min_", cell_id)), "Velo Min", value = NA),
            numericInput(ns(paste0("cell_velo_max_", cell_id)), "Velo Max", value = NA)
          ))
        }
        if ("IVB Min/Max" %in% sel) {
          out <- c(out, list(
            numericInput(ns(paste0("cell_ivb_min_", cell_id)), "IVB Min", value = NA),
            numericInput(ns(paste0("cell_ivb_max_", cell_id)), "IVB Max", value = NA)
          ))
        }
        if ("HB Min/Max" %in% sel) {
          out <- c(out, list(
            numericInput(ns(paste0("cell_hb_min_", cell_id)), "HB Min", value = NA),
            numericInput(ns(paste0("cell_hb_max_", cell_id)), "HB Max", value = NA)
          ))
        }
        if (length(out)) tagList(out) else div("No filters selected")
      })
    }
    
    observe({
      rows <- suppressWarnings(as.integer(input$report_rows))
      cols <- suppressWarnings(as.integer(input$report_cols))
      if (is.null(rows) || length(rows)==0 || is.na(rows) || rows < 1) return()
      if (is.null(cols) || length(cols)==0 || is.na(cols) || cols < 1) return()
      for (r in seq_len(rows)) for (c in seq_len(cols)) {
        local({
          rid <- r; cid <- c
          cell_id <- paste0("r", rid, "c", cid)
          output[[paste0("cell_filters_", cell_id)]] <- output_filters_for_cell(cell_id)
        })
      }
    })
    # Sync local date input with global date range
    if (!is.null(global_date_range)) {
      observe({
        if (!is.null(global_date_range()) && length(global_date_range()) == 2) {
          updateDateRangeInput(session, "dates", 
                               start = global_date_range()[1], 
                               end = global_date_range()[2])
        }
      })
      
      # Update global date range when local input changes
      observeEvent(input$dates, {
        if (!is.null(input$dates) && length(input$dates) == 2) {
          global_date_range(input$dates)
        }
      })
    }
    ns <- session$ns
    
    # ----- TEAM FILTER (GCU/Campers/Opponents) -----
    pd_team <- reactive({
      req(is_active())
      d <- pitch_data
      
      # If specific hitter or pitcher is selected, skip team filtering
      # This allows selecting any opponent player
      has_specific_hitter <- !is.null(input$hitter) && input$hitter != "All"
      has_specific_pitcher <- !is.null(input$oppPitcher) && input$oppPitcher != "All"
      
      if (has_specific_hitter || has_specific_pitcher) {
        # When specific player selected, show all data (team filter ignored)
        return(d)
      }
      
      # Apply team filtering based on selection when no specific player chosen
      # For HITTING suite: filter by Batter (our hitters)
      if (!is.null(input$teamType)) {
        if (input$teamType == "Campers") {
          # Filter to only allowed campers (as batters)
          d <- dplyr::filter(d, Batter %in% ALLOWED_CAMPERS)
        } else if (input$teamType == TEAM_CODE) {
          # For GCU hitting: show all non-camper batters
          d <- dplyr::filter(d, !(Batter %in% ALLOWED_CAMPERS))
        } else if (input$teamType == "Opponents") {
          # Show only opponent batters
          all_known <- unique(c(ALLOWED_HITTERS, ALLOWED_CAMPERS))
          d <- dplyr::filter(d, !(Batter %in% all_known))
        }
        # If "All" is selected, don't filter - show all data
      }
      d
    })
    
    # Update hitter choices based on team selection
    observeEvent(input$teamType, {
      d <- pd_team()
      hitters <- sort(unique(as.character(d$Batter)))
      # Map "Last, First" -> "First Last" for labels
      pretty <- if (length(hitters)) {
        stats::setNames(hitters, sapply(hitters, function(x) {
          x <- as.character(x)
          if (grepl(",", x)) paste0(trimws(sub(".*,", "", x)), " ", trimws(sub(",.*", "", x))) else x
        }))
      } else character(0)
      updateSelectInput(session, "hitter",
                        choices = c("All" = "All", pretty),
                        selected = "All")
      if (nrow(d)) {
        rng <- range(d$Date, na.rm = TRUE)
        if (all(is.finite(rng))) {
          updateDateRangeInput(session, "dates", start = rng[1], end = rng[2])
        }
      }
    }, ignoreInit = FALSE)
    
    # On init: set initial choices
    observeEvent(is_active(), {
      # This will trigger the teamType observer above
    }, ignoreInit = FALSE, once = TRUE)
    
    # ---- small helpers ----
    # ---------- AB Report: utilities ----------
    # Detect terminal pitches for PA segmentation (include HBP via PitchCall)
    .ab_is_terminal <- function(df) {
      (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
        (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk")) |
        (!is.na(df$PitchCall) & df$PitchCall == "HitByPitch")
    }
    
    fmt_mdy <- function(d) format(as.Date(d), "%m/%d/%Y")
    
    .pretty_name <- function(x) {
      x <- as.character(x)
      ifelse(grepl(",", x), paste0(trimws(sub(".*,", "", x)), " ", trimws(sub(",.*", "", x))), x)
    }
    
    # Pretty pitcher name: "Last, First" -> "First Last"
    .pretty_pitcher <- function(x) {
      x <- as.character(x)
      sub("^\\s*,\\s*", "",
          paste0(trimws(sub(".*,", "", x)), " ", trimws(sub(",.*", "", x))))
    }
    
    # Build the PA-level result label per your rules
    .pa_result_label <- function(last_row) {
      pr <- as.character(last_row$PlayResult)
      kc <- as.character(last_row$KorBB)
      pc <- as.character(last_row$PitchCall)
      th <- as.character(last_row$TaggedHitType)
      
      if (!is.na(pc) && pc == "HitByPitch") return("HitByPitch")
      
      if (!is.na(kc) && kc %in% c("Strikeout","Walk")) return(kc)
      
      if (!is.na(pr) && pr != "" && !identical(pr, "Undefined")) {
        if (pr == "HomeRun") return("HomeRun")
        # In play – include TaggedHitType first (except HR)
        th_clean <- ifelse(is.na(th) | th == "", "", paste0(th, " "))
        return(paste0(th_clean, pr))
      }
      
      # Fallback
      if (!is.na(pr) && pr != "") return(pr)
      if (!is.na(pc) && pc != "") return(pc)
      "Result"
    }
    
    # Small ggplot bits to draw the zone + dashed competitive box
    .ab_geom_zone <- function() {
      dark_on <- is_dark_mode()
      line_col <- if (dark_on) "#ffffff" else "black"
      home <- data.frame(
        x=c(-0.75,0.75,0.75,0.00,-0.75),
        y=c(1.05,1.05,1.15,1.25,1.15)-0.5
      )
      cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      list(
        geom_polygon(data = home, aes(x, y), fill = NA, color = line_col),
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col, linetype = "dashed"),
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col)
      )
    }
    
    # ---------- AB Report: date choices + default ----------
    # Dates where this hitter has at least one terminal pitch (a completed PA)
    ab_dates <- reactive({
      req(is_active())
      hit <- input$hitter
      if (is.null(hit) || identical(hit, "All")) return(as.Date(character(0)))
      
      # Use LSU-only data (ignore main date filter for this page)
      d <- pd_team() %>% dplyr::filter(Batter == hit)
      term <- (!is.na(d$PlayResult) & d$PlayResult != "Undefined") |
        (!is.na(d$KorBB) & d$KorBB %in% c("Strikeout","Walk")) |
        (!is.na(d$PitchCall) & d$PitchCall == "HitByPitch")
      dates <- sort(unique(as.Date(d$Date[term])))
      dates
    })
    
    
    # Build the sidebar UI (Select Game + legend or an info message)
    output$abSidebar <- renderUI({
      hit <- input$hitter
      if (is.null(hit) || identical(hit, "All")) {
        return(tagList(
          tags$em("Select a single hitter in the main sidebar to enable AB Report.")
        ))
      }
      dark_on <- is_dark_mode()
      cols <- colors_for_mode(dark_on)
      border_col <- if (dark_on) "rgba(255,255,255,0.35)" else "rgba(0,0,0,.25)"
      
      dates <- ab_dates()
      if (!length(dates)) return(tagList(tags$em("No completed plate appearances found for this hitter.")))
      
      vals <- as.character(as.Date(dates))  # stable values
      labs <- fmt_mdy(dates)                # pretty labels
      choices <- stats::setNames(vals, labs)
      
      cur <- isolate(input$abGameDate)
      sel <- if (!is.null(cur) && cur %in% vals) cur else vals[length(vals)]
      
      # Pitch-type legend (color chips) – LSU only
      types_for_legend <- {
        d <- pd_team() %>% dplyr::filter(Batter == hit)
        intersect(names(all_colors), as.character(unique(d$TaggedPitchType)))
      }
      
      # Shape legend: plain rows (no bullets)
      shape_rows <- tagList(
        tags$div("\u25CF Called Strike"),  # ●
        tags$div("\u25CB Ball"),           # ○
        tags$div("\u25B3 Foul"),           # △
        tags$div("\u2605 Whiff"),          # ★
        tags$div("\u25B2 In Play (Out)"),  # ▲
        tags$div("\u25A0 In Play (Hit)"),  # ■
        tags$div("\u25A1 Error")           # □
      )
      
      tagList(
        selectInput(ns("abGameDate"), "Select Game:", choices = choices, selected = sel),
        tags$hr(),
        tags$div(tags$strong("Pitch Result Key")),
        shape_rows,
        tags$br(),
        tags$div(tags$strong("Pitch Types")),
        tags$div(lapply(types_for_legend, function(tt) {
          col <- cols[[as.character(tt)]]; if (is.null(col)) col <- "gray"
          tags$div(style="display:flex;align-items:center;margin:2px 0;",
                   tags$span(style=paste0("display:inline-block;width:12px;height:12px;",
                                          "background:", col, ";margin-right:6px;",
                                          "border:1px solid ", border_col, ";border-radius:2px;")),
                   tags$span(as.character(tt))
          )
        }))
      )
    })
    
    # Header at top-right: Player + Date
    output$abHeader <- renderUI({
      hit <- input$hitter
      if (is.null(hit) || identical(hit, "All")) return(NULL)
      dt_val <- input$abGameDate
      if (is.null(dt_val)) {
        ds <- ab_dates(); if (!length(ds)) return(NULL)
        dt_val <- as.character(max(ds))
      }
      tags$div(
        style = "text-align:left;",
        tags$strong(.pretty_name(hit)), tags$br(),
        fmt_mdy(as.Date(dt_val))
      )
    })
    
    # ---------- AB Report: panels (charts + tables) ----------
    output$abPanels <- renderUI({
      req(is_active())
      hit <- input$hitter
      if (is.null(hit) || identical(hit, "All"))
        return(div(style="margin:8px 0;", tags$em("Select a single hitter to view the AB Report.")))
      
      dt_chr <- input$abGameDate; req(!is.null(dt_chr))
      dt <- as.Date(dt_chr)
      
      # Ignore main date range for this page, LSU only:
      df <- pd_team() %>% dplyr::filter(Batter == hit, as.Date(Date) == dt)
      if (!nrow(df)) return(div(tags$em("No pitches for this hitter on the selected date.")))
      
      term <- (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
        (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk")) |
        (!is.na(df$PitchCall) & df$PitchCall == "HitByPitch")
      
      pa_id <- cumsum(c(1L, as.integer(utils::head(term, -1))))
      df$._pa_id <- pa_id
      done_ids <- unique(df$._pa_id[term])
      df <- dplyr::filter(df, ._pa_id %in% done_ids)
      if (!nrow(df)) return(div(tags$em("No completed plate appearances on this date.")))
      
      pa_list <- split(df, df$._pa_id)
      n_pa <- length(pa_list)
      
      # ---------- CHART grid (2 per row) ----------
      chart_rows <- list()
      for (i in seq_len(n_pa)) {
        dat <- pa_list[[i]] %>% dplyr::mutate(
          pitch_idx = dplyr::row_number(),
          Result    = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
          tt_fill   = dplyr::coalesce(colors_for_mode(is_dark_mode())[as.character(TaggedPitchType)], "gray80"),
          tt        = paste0(
            "EV: ", ifelse(is.finite(ExitSpeed), sprintf("%.1f", ExitSpeed), "—"), " mph\n",
            "LA: ", ifelse(is.finite(Angle),     sprintf("%.1f", Angle),     "—"), "°\n",
            "Distance: ", ifelse(is.finite(Distance), sprintf("%.0f", Distance), "—"), "\n",
            "Pitch: ", TaggedPitchType, "\n",
            "Result: ", ifelse(PitchCall == "InPlay" & !is.na(PlayResult), PlayResult, coalesce(as.character(PitchCall), ""))
          )
        )
        pid <- names(pa_list)[i]
        out_plot_id <- ns(paste0("abPlot_", pid))
        
        # Build title text (result line)
        title_result <- {
          last_row <- dat[nrow(dat), , drop = FALSE]
          pr <- as.character(last_row$PlayResult)
          kc <- as.character(last_row$KorBB)
          pc <- as.character(last_row$PitchCall)
          th <- as.character(last_row$TaggedHitType)
          if (!is.na(pc) && pc == "HitByPitch") "HitByPitch"
          else if (!is.na(kc) && kc %in% c("Strikeout","Walk")) kc
          else if (!is.na(pr) && pr != "" && pr != "Undefined") {
            if (pr == "HomeRun") "HomeRun" else paste0(ifelse(is.na(th) | th=="","", paste0(th," ")), pr)
          } else dplyr::coalesce(pr, pc, "Result")
        }
        
        # Register plot renderer
        local({
          dat_local <- dat
          out_plot_id_local <- paste0("abPlot_", pid)
          output[[out_plot_id_local]] <- ggiraph::renderGirafe({
            types <- as.character(intersect(names(all_colors), unique(dat_local$TaggedPitchType)))
            cols <- colors_for_mode(is_dark_mode())
            col_vals <- cols[types]
            col_vals[is.na(col_vals)] <- "gray70"
            p <- ggplot() +
              .ab_geom_zone() +
              # visible points
              ggiraph::geom_point_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight,
                    color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
                    tooltip = tt, data_id = pitch_idx),
                size = 5, alpha = 0.95, stroke = 0.8
              ) +
              # bigger pitch number next to dot
              ggiraph::geom_text_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight, label = pitch_idx, tooltip = tt, data_id = pitch_idx),
                nudge_y = 0.21, size = 5.5
              ) +
              # invisible hover pad to ensure tooltip bg shows over hollow shapes
              ggiraph::geom_point_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = pitch_idx, fill = I(tt_fill)),
                shape = 21, size = 7, alpha = 0.001, stroke = 0, inherit.aes = FALSE
              ) +
              scale_color_manual(values = col_vals, limits = types, name = NULL) +
              scale_fill_manual(values  = col_vals, limits = types, name = NULL) +
              scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
              coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
              theme_void() + theme(legend.position = "none")
            
            girafe_transparent(
              ggobj = p,
              options = list(
                ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                      css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"),
                ggiraph::opts_hover(css = "stroke-width:1.5px;"),
                ggiraph::opts_hover_inv(css = "opacity:0.15;")
              )
            )
          })
        })
        
        # Panel UI: centered "PA #i" then result line under it
        panel_ui <- div(
          tags$div(style="text-align:center; margin-top:6px;",
                   tags$div(tags$strong(paste0("PA #", i))),
                   tags$div(title_result)
          ),
          ggiraph::girafeOutput(out_plot_id, height = "350px")
        )
        
        if ((i %% 2) == 1) {
          chart_rows[[length(chart_rows) + 1]] <- fluidRow(
            column(6, panel_ui),
            column(6, if (i + 1 <= n_pa) div(id = ns(paste0("abChartCol_", i+1))) else NULL)
          )
        } else {
          chart_rows[[length(chart_rows)]]$children[[2]] <- column(6, panel_ui)
        }
      }
      
      # ---------- TABLES (bottom, one per row) ----------
      table_rows <- list()
      for (i in seq_len(n_pa)) {
        dat <- pa_list[[i]] %>% dplyr::mutate(pitch_idx = dplyr::row_number())
        pid <- names(pa_list)[i]
        out_table_id <- ns(paste0("abTable_", pid))
        
        local({
          dat_local <- pa_list[[i]] %>% dplyr::mutate(pitch_idx = dplyr::row_number())
          out_table_id_local <- paste0("abTable_", pid)
          output[[out_table_id_local]] <- DT::renderDT({
            tbl <- dat_local %>% dplyr::transmute(
              `Pitch #` = pitch_idx,
              Pitch     = as.character(TaggedPitchType),
              Velo      = ifelse(is.finite(RelSpeed), round(RelSpeed, 1), NA_real_),
              IVB       = ifelse(is.finite(InducedVertBreak), round(InducedVertBreak, 1), NA_real_),
              HB        = ifelse(is.finite(HorzBreak), round(HorzBreak, 1), NA_real_),
              EV        = ifelse(is.finite(ExitSpeed), round(ExitSpeed, 1), NA_real_),
              LA        = ifelse(is.finite(Angle), round(Angle, 1), NA_real_),
              Distance  = ifelse(is.finite(Distance), round(Distance, 0), NA_real_),
              Result    = dplyr::case_when(
                PitchCall == "InPlay" & !is.na(PlayResult) ~ PlayResult,
                TRUE ~ as.character(PitchCall)
              )
            )
            nd <- function(x) { x[is.na(x)] <- "-"; x }
            tbl$EV <- nd(tbl$EV); tbl$LA <- nd(tbl$LA); tbl$Distance <- nd(tbl$Distance)
            
            DT::datatable(
              tbl,
              options = list(dom = 't', pageLength = nrow(tbl), ordering = FALSE),
              rownames = FALSE
            )
          })
        })
        
        pitcher_label <- {
          p <- as.character(dat$Pitcher[nrow(dat)])
          paste0(trimws(sub(".*,", "", p)), " ", trimws(sub(",.*", "", p)))
        }
        
        table_rows[[i]] <- fluidRow(
          column(12,
                 tags$div(style="margin:8px 0 4px 0;",
                          tags$strong(paste0("PA #", i, " vs. ", pitcher_label))
                 ),
                 DT::DTOutput(out_table_id)
          )
        )
      }
      
      tagList(chart_rows, tags$hr(), table_rows)
    })
    
    fmt_avg  <- function(x) { z <- ifelse(is.finite(x), sprintf("%.3f", x), NA_character_); sub("^0", "", z) }
    safe_div <- function(num, den) ifelse(den > 0, num/den, NA_real_)
    parse_num <- function(x) {
      if (is.numeric(x)) return(x)
      x1 <- trimws(as.character(x)); x1[x1 == ""] <- NA_character_
      ifelse(grepl("%$", x1), suppressWarnings(as.numeric(sub("%$","",x1)))/100,
             suppressWarnings(as.numeric(x1)))
    }
    swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
    hit_levels   <- c("Single","Double","Triple","HomeRun")
    
    # Shape map for hitting results
    hit_shape_map <- c(
      "Called Strike" = 19,
      "Ball"          = 1,
      "Foul"          = 2,
      "Whiff"         = 8,
      "In Play"       = 17,
      "Error"         = 0
    )
    
    # Helper to create location plot with green box
    make_location_plot <- function(df_subset) {
      if (!"Result" %in% names(df_subset)) {
        df_subset$Result <- compute_result(df_subset$PitchCall, df_subset$PlayResult)
      }
      dark_on <- is_dark_mode()
      line_col <- if (dark_on) "#ffffff" else "black"
      grid_col <- if (dark_on) "#d1d5db" else "black"
      cols <- colors_for_mode(dark_on)
      
      # Use hit_shape_map levels for the hitting suite
      hit_result_levels <- names(hit_shape_map)
      
      df_subset <- df_subset %>%
        dplyr::mutate(
          ResultDisplay = dplyr::case_when(
            Result %in% c("In Play (Out)", "In Play (Hit)") ~ "In Play",
            TRUE ~ as.character(Result)
          )
        )
      
      df_plot <- df_subset %>%
        dplyr::filter(is.finite(as.numeric(PlateLocSide)), is.finite(as.numeric(PlateLocHeight))) %>%
        dplyr::mutate(
          PlateLocSide = as.numeric(PlateLocSide),
          PlateLocHeight = as.numeric(PlateLocHeight),
          TaggedPitchType = as.character(TaggedPitchType),
          ResultDisplay = dplyr::case_when(
            ResultDisplay %in% hit_result_levels ~ ResultDisplay,
            TRUE ~ NA_character_
          ),
          ResultDisplay = factor(ResultDisplay, levels = hit_result_levels),
          tooltip = paste0(
            "<b>", TaggedPitchType, "</b><br>",
            "PitchCall: ", ifelse(is.na(PitchCall), "—", as.character(PitchCall)), "<br>",
            "Result: ", ifelse(is.na(ResultDisplay), "—", as.character(ResultDisplay)), "<br>",
            "Velo: ", ifelse(is.finite(as.numeric(RelSpeed)), sprintf("%.1f mph", as.numeric(RelSpeed)), "—"), "<br>",
            "EV: ", ifelse(is.finite(as.numeric(ExitSpeed)), sprintf("%.1f mph", as.numeric(ExitSpeed)), "—"), "<br>",
            "LA: ", ifelse(is.finite(as.numeric(Angle)), sprintf("%.1f°", as.numeric(Angle)), "—")
          ),
          rid = dplyr::row_number()
        )
      
      if (!nrow(df_plot)) {
        p_empty <- ggplot() + 
          annotate("text", x = 0, y = 2.5, label = "No pitches", size = 5) +
          theme_void()
        return(girafe_transparent(ggobj = p_empty))
      }
      
      types_chr <- intersect(names(cols), unique(df_plot$TaggedPitchType))
      if (!length(types_chr)) types_chr <- unique(df_plot$TaggedPitchType)
      col_vals <- cols[types_chr]
      col_vals[is.na(col_vals)] <- "gray70"
      
      home <- data.frame(
        x = c(-0.75, 0.75, 0.75, 0, -0.75),
        y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
      )
      sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
      mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
      dx <- (ZONE_RIGHT - ZONE_LEFT) / 3
      dy <- (ZONE_TOP - ZONE_BOTTOM) / 3
      grid_vertical <- data.frame(
        x = c(ZONE_LEFT + dx, ZONE_LEFT + 2 * dx),
        ymin = ZONE_BOTTOM,
        ymax = ZONE_TOP
      )
      grid_horizontal <- data.frame(
        y = c(ZONE_BOTTOM + dy, ZONE_BOTTOM + 2 * dy),
        xmin = ZONE_LEFT,
        xmax = ZONE_RIGHT
      )
      inner_half <- 7 / 12  # 7 inches converted to feet
      green_box <- data.frame(
        xmin = mid_x - inner_half,
        xmax = mid_x + inner_half,
        ymin = mid_y - inner_half,
        ymax = mid_y + inner_half
      )
      
      df_known <- dplyr::filter(df_plot, !is.na(ResultDisplay))
      df_other <- dplyr::filter(df_plot, is.na(ResultDisplay))
      
      tooltip_css <- "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), inherit.aes = FALSE, fill = NA, color = line_col) +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  inherit.aes = FALSE, fill = NA, color = line_col) +
        geom_rect(data = green_box,
                  aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  inherit.aes = FALSE,
                  fill = "#66c87a", alpha = 0.18, color = NA) +
        geom_segment(data = grid_vertical,
                     aes(x = x, xend = x, y = ymin, yend = ymax),
                     inherit.aes = FALSE, color = grid_col, linewidth = 0.4) +
        geom_segment(data = grid_horizontal,
                     aes(x = xmin, xend = xmax, y = y, yend = y),
                     inherit.aes = FALSE, color = grid_col, linewidth = 0.4) +
        ggiraph::geom_point_interactive(
          data = df_other,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tooltip, data_id = rid),
          size = 4.5, alpha = 0.9, shape = 21, stroke = 0.4
        ) +
        ggiraph::geom_point_interactive(
          data = df_known,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType, shape = ResultDisplay,
              tooltip = tooltip, data_id = rid),
          size = 5, alpha = 0.95, stroke = 0.8
        ) +
        scale_color_manual(values = col_vals, limits = types_chr, drop = FALSE, name = NULL) +
        scale_fill_manual(values = col_vals, limits = types_chr, drop = FALSE, name = NULL) +
        scale_shape_manual(values = hit_shape_map, drop = TRUE) +
        coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
        theme_void() +
        theme(legend.position = "none")
      
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    }
    
    # Keep count filter tidy
    observeEvent(input$countFilter, {
      sel <- input$countFilter
      if (is.null(sel) || !length(sel)) {
        updateSelectInput(session, "countFilter", selected = "All")
      } else if ("All" %in% sel && length(sel) > 1) {
        updateSelectInput(session, "countFilter", selected = setdiff(sel, "All"))
      }
    }, ignoreInit = TRUE)
    
    # Keep BIP Result tidy (handle "All")
    observeEvent(input$bipResult, {
      sel <- input$bipResult
      if (is.null(sel) || !length(sel)) {
        updateSelectInput(session, "bipResult", selected = "All")
      } else if ("All" %in% sel && length(sel) > 1) {
        updateSelectInput(session, "bipResult", selected = setdiff(sel, "All"))
      }
    }, ignoreInit = TRUE)
    
    # Track if user has manually changed dates
    user_changed_dates <- reactiveVal(FALSE)
    
    # Detect manual date changes
    observeEvent(input$dates, {
      user_changed_dates(TRUE)
    }, ignoreInit = TRUE)
    
    # Default date range to last date for selected hitter (LSU only)
    # Only update if user hasn't manually changed dates
    observeEvent(input$hitter, {
      req(is_active())
      
      # Skip if user has manually changed dates
      if (user_changed_dates()) return()
      
      d <- pd_team()
      last_date <- if (isTRUE(input$hitter == "All")) {
        max(d$Date, na.rm = TRUE)
      } else {
        mx <- max(d$Date[d$Batter == input$hitter], na.rm = TRUE)
        if (is.finite(mx)) mx else max(d$Date, na.rm = TRUE)
      }
      if (is.finite(last_date)) {
        updateDateRangeInput(session, "dates", start = last_date, end = last_date)
      }
    }, ignoreInit = TRUE)
    
    # --- Filtered data for Hitting (LSU only; no Session Type input) ---
    filtered_hit <- reactive({
      req(is_active(), input$dates, input$hand, input$zoneLoc, input$inZone)
      pitch_types <- if (is.null(input$pitchType)) "All" else input$pitchType
      
      df <- pd_team() %>% dplyr::filter(Date >= input$dates[1], Date <= input$dates[2])
      
      hit_pick <- input$hitter
      if (!is.null(hit_pick) && hit_pick != "All") df <- dplyr::filter(df, Batter == hit_pick)
      
      # NEW: Filter by opponent pitcher
      pitch_pick <- input$oppPitcher
      if (!is.null(pitch_pick) && pitch_pick != "All") df <- dplyr::filter(df, Pitcher == pitch_pick)
      
      if (input$hand != "All") df <- dplyr::filter(df, PitcherThrows == input$hand)
      
      if (!is.null(input$batterSide) && input$batterSide != "All") {
        df <- df %>% dplyr::filter(SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide))
      }
      
      df <- enforce_zone(df, input$zoneLoc)
      df <- enforce_inzone(df, input$inZone)
      # Note: No QP Locations filter in hitting suite
      df <- apply_count_filter(df, input$countFilter)
      df <- apply_after_count_filter(df, input$afterCountFilter)
      df <- apply_pitch_results_filter(df, input$pitchResults)
      
      # ---- Apply BIP Result filter (balls in play only) ----
      bip <- input$bipResult
      if (!is.null(bip) && !("All" %in% bip)) {
        inplay <- !is.na(df$PitchCall) & df$PitchCall == "InPlay"
        pr     <- as.character(df$PlayResult)
        hit_opts <- c("Single","Double","Triple")
        
        mask <- rep(FALSE, nrow(df))
        
        # Selected BIP hits (Single/Double/Triple)
        sel_hits <- intersect(bip, hit_opts)
        if (length(sel_hits)) {
          mask <- mask | (inplay & pr %in% sel_hits)
        }
        
        # Selected BIP outs (exclude HR so HR isn't counted as Out)
        if ("Out" %in% bip) {
          mask <- mask | (inplay & !(pr %in% c(hit_opts, "HomeRun")) & !is.na(pr))
        }
        
        df <- df[mask, , drop = FALSE]
      }
      
      nnz <- function(x) !is.null(x) && !is.na(x)
      if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed >= input$veloMin)
      if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed <= input$veloMax)
      if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
      if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
      if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak >= input$hbMin)
      if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak <= input$hbMax)
      
      df <- df %>% dplyr::arrange(Date) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
      if (nnz(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
      if (nnz(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
      
      df2 <- compute_stuff_simple(df, base_type = "Fastball", level = "College") %>% force_pitch_levels()
      if (!("All" %in% pitch_types)) df2 <- dplyr::filter(df2, TaggedPitchType %in% pitch_types)
      df2
    })
    
    # ---- HeatMaps note ----
    output$hmNote <- renderUI({
      stat <- input$hmStat
      if (is.null(stat)) return(NULL)
      if (identical(stat, "Exit Velocity")) {
        HTML(sprintf("<small><em>Shows Live in-play balls with EV ≥ %d mph; lower-density areas are floored for readability.</em></small>", HEAT_EV_THRESHOLD))
      } else if (identical(stat, "Whiff Rate")) {
        HTML("<small><em>Locations of swinging strikes.</em></small>")
      } else if (identical(stat, "GB Rate")) {
        HTML("<small><em>Locations of ground balls (Live only).</em></small>")
      } else if (identical(stat, "Contact Rate")) {
        HTML("<small><em>Locations of balls put in play (Live only).</em></small>")
      } else if (identical(stat, "Swing Rate")) {
        HTML("<small><em>Locations of swings (whiffs, fouls, balls in play).</em></small>")
      } else {
        HTML("<small><em>Kernel density of pitch locations.</em></small>")
      }
    })
    
    # Local helper for 2D KDE grid (like the pitching version)
    make_kde_grid <- function(x, y, lims = c(-2.5,2.5,0,4.5), n = 180) {
      ok <- is.finite(x) & is.finite(y)
      x <- x[ok]; y <- y[ok]
      if (length(x) < 2 || length(unique(x)) < 2 || length(unique(y)) < 2) {
        return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
      }
      d <- MASS::kde2d(x, y, n = n, lims = lims)
      expand.grid(x = d$x, y = d$y) |> transform(z = as.vector(d$z))
    }
    
    # Helper to create binned rate heatmap data
    make_rate_grid <- function(df, numerator_condition, denominator_condition = NULL, 
                               bin_size = 0.75, x_range = c(-2.5, 2.5), y_range = c(0, 4.5),
                               min_sample = 3) {
      # If no denominator condition provided, use all data
      if (is.null(denominator_condition)) {
        df_denom <- df
      } else {
        df_denom <- df[denominator_condition, ]
      }
      df_numer <- df[numerator_condition, ]
      
      # Create bins
      x_breaks <- seq(x_range[1], x_range[2], by = bin_size)
      y_breaks <- seq(y_range[1], y_range[2], by = bin_size)
      
      # Bin the denominator data
      df_denom$x_bin <- cut(df_denom$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
      df_denom$y_bin <- cut(df_denom$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
      
      # Count denominator
      denom_counts <- df_denom %>%
        filter(!is.na(x_bin) & !is.na(y_bin)) %>%
        group_by(x_bin, y_bin) %>%
        summarise(denom = n(), .groups = 'drop')
      
      # Bin the numerator data
      df_numer$x_bin <- cut(df_numer$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
      df_numer$y_bin <- cut(df_numer$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
      
      # Count numerator
      numer_counts <- df_numer %>%
        filter(!is.na(x_bin) & !is.na(y_bin)) %>%
        group_by(x_bin, y_bin) %>%
        summarise(numer = n(), .groups = 'drop')
      
      # Merge and calculate rate
      rate_data <- denom_counts %>%
        left_join(numer_counts, by = c("x_bin", "y_bin")) %>%
        mutate(
          numer = ifelse(is.na(numer), 0, numer),
          rate = (numer / denom) * 100
        ) %>%
        filter(denom >= min_sample)
      
      # Get bin centers for plotting
      rate_data <- rate_data %>%
        mutate(
          x = (as.numeric(sub("\\((.+),.*", "\\1", x_bin)) + 
                 as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", x_bin))) / 2,
          y = (as.numeric(sub("\\((.+),.*", "\\1", y_bin)) + 
                 as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", y_bin))) / 2
        ) %>%
        dplyr::select(x, y, z = rate)
      
      return(rate_data)
    }
    
    # Helper to smooth binned data using interpolation
    smooth_grid <- function(grid_data, n = 100, x_range = c(-2.5, 2.5), y_range = c(0, 4.5)) {
      if (nrow(grid_data) < 4) return(grid_data)  # Need minimum points to interpolate
      
      # Remove any rows with NA or Inf values
      grid_data <- grid_data %>%
        filter(is.finite(x) & is.finite(y) & is.finite(z))
      
      if (nrow(grid_data) < 4) return(grid_data)
      
      # Use akima for smooth interpolation
      if (!requireNamespace("akima", quietly = TRUE)) {
        return(grid_data)  # Fall back to binned data if akima not available
      }
      
      # Wrap in tryCatch to handle any interpolation errors
      smooth_data <- tryCatch({
        interp_result <- akima::interp(
          x = grid_data$x,
          y = grid_data$y,
          z = grid_data$z,
          xo = seq(x_range[1], x_range[2], length.out = n),
          yo = seq(y_range[1], y_range[2], length.out = n),
          linear = FALSE,
          extrap = TRUE,  # Allow light extrapolation to avoid white holes
          duplicate = "mean"
        )
        
        result <- expand.grid(x = interp_result$x, y = interp_result$y) %>%
          mutate(z = as.vector(interp_result$z)) %>%
          filter(is.finite(z))
        
        # If we lost too much data, add back original bins to fill gaps
        if (nrow(result) < nrow(grid_data) * 2) {
          result <- bind_rows(result, grid_data) %>%
            distinct(x, y, .keep_all = TRUE)
        }
        
        result
      }, error = function(e) {
        # If interpolation fails, return original binned data
        grid_data
      })
      
      return(smooth_data)
    }
    
    # Helper to create binned average heatmap data (for EV)
    make_avg_grid <- function(df, value_col, bin_size = 0.75, 
                              x_range = c(-2.5, 2.5), y_range = c(0, 4.5), min_sample = 2) {
      # Filter to valid values
      df <- df[is.finite(df[[value_col]]), ]
      
      # Create bins
      x_breaks <- seq(x_range[1], x_range[2], by = bin_size)
      y_breaks <- seq(y_range[1], y_range[2], by = bin_size)
      
      df$x_bin <- cut(df$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
      df$y_bin <- cut(df$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
      
      # Calculate average per bin
      avg_data <- df %>%
        filter(!is.na(x_bin) & !is.na(y_bin)) %>%
        group_by(x_bin, y_bin) %>%
        summarise(
          count = n(),
          avg_value = mean(.data[[value_col]], na.rm = TRUE),
          .groups = 'drop'
        ) %>%
        filter(count >= min_sample)
      
      # Get bin centers
      avg_data <- avg_data %>%
        mutate(
          x = (as.numeric(sub("\\((.+),.*", "\\1", x_bin)) + 
                 as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", x_bin))) / 2,
          y = (as.numeric(sub("\\((.+),.*", "\\1", y_bin)) + 
                 as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", y_bin))) / 2
        ) %>%
        dplyr::select(x, y, z = avg_value)
      
      return(avg_data)
    }
    
    # ---- HeatMaps → Heat plot ----
    output$heatmapsHeatPlot <- renderPlot({
      df <- filtered_hit(); if (!nrow(df)) return()
      stat <- input$hmStat
      if (identical(stat, "Exit Velocity")) stat <- "EV"
      
      pitch_type <- input$hmPitchType
      if (!is.null(pitch_type) && pitch_type != "All") {
        df <- df %>% filter(TaggedPitchType == pitch_type)
        if (!nrow(df)) return(ggplot() + theme_void())
      }
      
      render_heatmap_stat(df, stat)
    }, bg = "transparent")
    
    # ---- HeatMaps → Pitch (interactive scatter) ----
    output$heatmapsPitchPlot <- ggiraph::renderGirafe({
      req(input$hmChartType == "Pitch")
      df <- filtered_hit(); if (!nrow(df)) return(NULL)
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      types_chr <- as.character(types)
      
      df_i <- df %>%
        dplyr::mutate(
          Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
          tt  = make_hover_tt(.),
          rid = dplyr::row_number()
        )
      
      home <- data.frame(x=c(-0.75,0.75,0.75,0.00,-0.75),
                         y=c(1.05,1.05,1.15,1.25,1.15)-0.5)
      cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      
      df_known <- dplyr::filter(df_i, !is.na(Result))
      df_other <- dplyr::filter(df_i,  is.na(Result))
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), fill = NA, color = line_col) +
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col, linetype = "dashed") +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col) +
        ggiraph::geom_point_interactive(
          data = df_other,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
        ) +
        ggiraph::geom_point_interactive(
          data = df_known,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
              tooltip = tt, data_id = rid),
          size = 4.0, alpha = 0.95, stroke = 0.8
        ) +
        scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
        scale_fill_manual(values  = cols[types_chr], limits = types_chr, name = NULL) +
        scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
        coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
        theme_void() + theme(legend.position = "none")
      
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
    # ---- Location plots (strike zones with green box) ----
    output$loc_rhp <- ggiraph::renderGirafe({
      df <- filtered_hit()
      df <- dplyr::filter(df, PitcherThrows == "Right")
      make_location_plot(df)
    })
    
    output$loc_lhp <- ggiraph::renderGirafe({
      df <- filtered_hit()
      df <- dplyr::filter(df, PitcherThrows == "Left")
      make_location_plot(df)
    })
    
    # ---- Result key (legend for pitch results) ----
    output$result_key <- renderPlot({
      dark_on <- is_dark_mode()
      text_col <- if (dark_on) "#e5e7eb" else "#333333"
      stroke_col <- text_col
      fill_inplay <- if (dark_on) "#e5e7eb" else "#333333"
      fill_other  <- if (dark_on) "#0f172a" else "#ffffff"
      df <- data.frame(
        Result = factor(names(hit_shape_map), levels = names(hit_shape_map)),
        x = seq_along(hit_shape_map)
      )
      df$fill <- ifelse(df$Result == "In Play", fill_inplay, fill_other)
      
      ggplot(df, aes(x = x, y = 0)) +
        geom_point(aes(shape = Result, fill = fill), color = stroke_col, size = 5.5, stroke = 1.1, show.legend = FALSE) +
        geom_text(aes(y = -0.48, label = Result), size = 4, fontface = "bold", color = text_col) +
        scale_shape_manual(values = hit_shape_map, drop = FALSE) +
        scale_fill_identity() +
        coord_cartesian(xlim = c(0.5, length(hit_shape_map) + 0.5), ylim = c(-0.85, 0.35)) +
        theme_void() +
        theme(
          plot.background = element_rect(fill = "transparent", color = NA),
          panel.background = element_rect(fill = "transparent", color = NA)
        )
    }, bg = "transparent")
    
    # ---- Pitch type key (legend for pitch types) ----
    output$pitch_type_key <- renderPlot({
      dark_on <- is_dark_mode()
      text_col <- if (dark_on) "#e5e7eb" else "#333333"
      stroke_col <- text_col
      df <- filtered_hit()
      if (is.null(df) || !nrow(df)) return(NULL)
      
      # Safe extraction of pitch types with error handling
      types <- tryCatch({
        unique_types <- unique(df$TaggedPitchType)
        unique_types[!is.na(unique_types) & nzchar(as.character(unique_types))]
      }, error = function(e) {
        character(0)
      })
      
      if (!length(types)) return(NULL)
      
      # Convert to character
      types <- as.character(types)
      
      # Sort types in the canonical order (Fastball, Sinker, Cutter, Slider, Sweeper, Curveball, ChangeUp, Splitter, Knuckleball)
      # First, filter to types that exist in all_colors (in order), then append any unknown types
      canonical_order <- names(all_colors)
      known_types <- canonical_order[canonical_order %in% types]
      unknown_types <- setdiff(types, canonical_order)
      types <- c(known_types, sort(unknown_types))
      
      # Create color mapping - use default gray for any unknown types
      cols <- colors_for_mode(dark_on)
      type_colors <- sapply(types, function(t) {
        if (t %in% names(cols)) {
          cols[t]
        } else {
          if (dark_on) "#e5e7eb" else "gray50"
        }
      })
      names(type_colors) <- types
      
      leg_df <- data.frame(
        TaggedPitchType = factor(types, levels = types),
        x = seq_along(types),
        stringsAsFactors = FALSE
      )
      
      ggplot(leg_df, aes(x = x, y = 0)) +
        geom_point(aes(fill = TaggedPitchType), shape = 21, size = 6, color = stroke_col, stroke = 1.1) +
        geom_text(aes(label = TaggedPitchType, y = -0.48), size = 4, fontface = "bold", color = text_col) +
        scale_fill_manual(values = type_colors, limits = types, drop = FALSE, guide = "none") +
        coord_cartesian(xlim = c(0.5, length(types) + 0.5), ylim = c(-0.9, 0.35)) +
        theme_void() +
        theme(
          plot.background = element_rect(fill = "transparent", color = NA),
          panel.background = element_rect(fill = "transparent", color = NA)
        )
    }, bg = "transparent")
    
    # ---- Spray chart (interactive) ----
    output$sprayChart <- ggiraph::renderGirafe({
      df <- filtered_hit(); if (!nrow(df)) return(NULL)
      dark_on <- is_dark_mode()
      cols <- colors_for_mode(dark_on)
      field_fill  <- if (dark_on) "transparent" else "#f3f5f7"
      field_alpha <- if (dark_on) 0 else 0.6
      foul_line_col <- if (dark_on) "#e5e7eb" else "grey50"
      fence_col  <- if (dark_on) "#9ca3af" else "grey40"
      infield_col <- if (dark_on) "#cbd5e1" else "grey70"
      text_col   <- if (dark_on) "#e5e7eb" else "black"
      
      # Accept any live-like session text
      st <- tolower(trimws(as.character(df$SessionType)))
      live_mask <- grepl("live|game|ab", st)
      
      # Require in-play with numeric distance/direction
      dist_num <- suppressWarnings(as.numeric(df$Distance))
      dir_num  <- suppressWarnings(as.numeric(df$Direction))
      ok <- which(live_mask & df$PitchCall == "InPlay" &
                    is.finite(dist_num) & is.finite(dir_num))
      
      # --- Field geometry (±45°, 330/370/400/370/330) ---
      fence_pts <- data.frame(deg = c(-45,-22.5,0,22.5,45),
                              r   = c(330,370,400,370,330))
      deg_seq <- seq(-45, 45, length.out = 301)
      r_seq   <- stats::spline(fence_pts$deg, fence_pts$r, xout = deg_seq)$y
      fence   <- data.frame(x = r_seq * sin(deg_seq*pi/180),
                            y = r_seq * cos(deg_seq*pi/180))
      fl_l <- data.frame(x = c(0, 330*sin(-45*pi/180)),
                         y = c(0, 330*cos(-45*pi/180)))
      fl_r <- data.frame(x = c(0, 330*sin( 45*pi/180)),
                         y = c(0, 330*cos( 45*pi/180)))
      th_in <- seq(-45, 45, length.out = 121)
      infield <- data.frame(x = 95 * sin(th_in*pi/180),
                            y = 95 * cos(th_in*pi/180))
      # home plate (simple)
      home <- data.frame(
        x = c(-0.75, 0.75, 0.75, 0, -0.75),
        y = c( 1.05, 1.05, 1.15, 1.25, 1.15) - 2.0
      )
      
      # If nothing to plot, show field + message
      if (!length(ok)) {
        p_empty <- ggplot() +
          geom_polygon(data = home, aes(x, y), fill = NA, color = foul_line_col) +
          geom_path(data = fence, aes(x, y), color = fence_col, linewidth = 0.8) +
          geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                       fill = field_fill, color = NA, alpha = field_alpha) +
          geom_path(data = fl_l, aes(x, y), color = foul_line_col) +
          geom_path(data = fl_r, aes(x, y), color = foul_line_col) +
          geom_path(data = infield, aes(x, y), color = infield_col) +
          annotate("text", x = 0, y = 200, label = "No balls in play for current filters", size = 5, color = text_col) +
          coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
          theme_void()
        return(girafe_transparent(ggobj = p_empty))
      }
      
      # --- Points to plot ---
      bbe <- df[ok, , drop = FALSE]
      bbe$Distance  <- dist_num[ok]
      bbe$Direction <- dir_num[ok]
      
      # Fixed mapping: raw Direction ±75 -> on-field ±45 (foul lines)
      FOUL_DEG_RAW  <- 90    # raw "down the line"
      FOUL_DEG_GEOM <- 110    # field drawing foul line angle
      angle_scale   <- FOUL_DEG_GEOM / FOUL_DEG_RAW
      
      # Polar (0° = CF, +RF, −LF) → cartesian
      th     <- bbe$Direction * angle_scale * pi/180
      bbe$x  <- bbe$Distance * sin(th)
      bbe$y  <- bbe$Distance * cos(th)
      
      # Outcome colors
      outcome <- dplyr::case_when(bbe$PlayResult %in% hit_levels ~ bbe$PlayResult, TRUE ~ "Out")
      bbe$Outcome <- factor(outcome, levels = c("Out", hit_levels))
      outcome_cols <- if (dark_on) {
        c("Single"="#34d399","Double"="#60a5fa","Triple"="#c084fc","HomeRun"="#f87171","Out"="#e5e7eb")
      } else {
        c("Single"="#1fab54","Double"="#1f77b4","Triple"="#7b1fa2","HomeRun"="#d62728","Out"="#222222")
      }
      
      # Tooltip + tooltip fill by pitch type color
      bbe <- bbe %>%
        dplyr::mutate(
          rid     = dplyr::row_number(),
          tt      = paste0(
            "EV: ", ifelse(is.finite(ExitSpeed), sprintf("%.1f", ExitSpeed), "—"), " mph\n",
            "LA: ", ifelse(is.finite(Angle),     sprintf("%.1f", Angle),     "—"), "°\n",
            "Distance: ", ifelse(is.finite(Distance), paste0(sprintf("%.0f", Distance), " ft"), "—"), "\n",
            "Pitch: ", TaggedPitchType, "\n",
            "Result: ", PlayResult
          ),
          tt_fill = dplyr::coalesce(cols[as.character(TaggedPitchType)], "gray80")
        )
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), fill = NA, color = foul_line_col) +
        geom_path(data = fence, aes(x, y), color = fence_col, linewidth = 0.8) +
        geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                     fill = field_fill, color = NA, alpha = field_alpha) +
        geom_path(data = fl_l, aes(x, y), color = foul_line_col) +
        geom_path(data = fl_r, aes(x, y), color = foul_line_col) +
        geom_path(data = infield, aes(x, y), color = infield_col) +
        
        ggiraph::geom_point_interactive(
          data = bbe,
          aes(x, y, color = Outcome, tooltip = tt, data_id = rid),
          size = 2.8, alpha = 0.95
        ) +
        ggiraph::geom_point_interactive( # invisible hover pad to color tooltip bg by pitch type
          data = bbe,
          aes(x, y, tooltip = tt, data_id = rid, fill = I(tt_fill)),
          shape = 21, size = 8, alpha = 0.001, stroke = 0, inherit.aes = FALSE
        ) +
        scale_color_manual(values = outcome_cols, name = NULL) +
        coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
        theme_void() + theme(
          legend.position = "bottom",
          legend.direction = "horizontal",
          legend.box = "horizontal",
          legend.margin = margin(t = -4, r = 0, b = -12, l = 0),
          legend.box.margin = margin(t = -6, r = 0, b = -14, l = 0),
          plot.margin = margin(t = 0, r = 0, b = -16, l = 0),
          legend.text = element_text(size = 11, face = "bold", color = text_col),
          legend.background = element_rect(fill = "transparent", color = NA),
          legend.box.background = element_rect(fill = "transparent", color = NA),
          legend.key = element_rect(fill = "transparent", color = NA)
        ) +
        guides(
          color = guide_legend(
            direction = "horizontal",
            title.position = "top",
            title.hjust = 0.5,
            nrow = 1,
            keywidth = grid::unit(1.2, "lines"),
            keyheight = grid::unit(0.5, "lines")
          )
        )
      
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_sizing(rescale = TRUE),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.35);"),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
    # --- “Results” only toggle (UI) ---
    output$dpButtons <- renderUI({
      sel <- isolate(input$dpMode); if (is.null(sel)) sel <- "Results"
      tagList(
        div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Tables:"),
        selectInput(
          ns("dpMode"), label = NULL,
          choices  = c("Results", "Swing Decisions", "Custom"),
          selected = sel,
          width = "200px"
        ),
        div(style = "display:inline-block; margin-left:10px;",
            tags$div(
              "Split By:",
              style = "font-weight:bold; font-size:12px; margin-bottom:2px;"
            ),
            selectInput(
              ns("dpSplitBy"), label = NULL,
              choices = c("Pitch Types", "Pitcher Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Pitcher"),
              selected = "Pitch Types",
              width = "140px"
            )
        ),
        conditionalPanel(
          sprintf("input['%s']=='Custom'", ns("dpMode")),
          tagList(
            selectInput(ns("dpCustomSaved"), "Saved Table:", choices = c("", names(custom_tables())), selected = ""),
            textInput(ns("dpCustomName"), "Name:", value = ""),
            selectizeInput(
              ns("dpCustomCols"), label = "Columns (drag to order):",
              choices  = c("PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
                           "Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%","EV","LA"),
              multiple = TRUE,
              options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
            ),
            actionButton(ns("dpSaveCustom"), "Save / Update", class = "btn-primary btn-sm"),
            actionButton(ns("dpDeleteCustom"), "Delete", class = "btn-danger btn-sm")
          )
        )
      )
    })
    
    # --- Data & Performance table (Results-only custom view for Hitting) ---
    output$dpTable <- DT::renderDT({
      tryCatch({
        req(is_active())
        df <- filtered_hit()
        if (is.null(df) || !nrow(df)) {
          return(DT::datatable(
            data.frame(Message = "No data available for current filters"),
            options = list(dom = 't'),
            rownames = FALSE
          ))
        }
        
        # Apply Split By transformation
        split_choice <- if (!is.null(input$dpSplitBy)) input$dpSplitBy else "Pitch Types"
        df <- apply_split_by(df, split_choice)
        
        # Determine column name based on split choice
        split_col_name <- switch(
          split_choice,
          "Pitch Types" = "Pitch",
          "Pitcher Hand" = "Pitcher Hand",
          "Count" = "Count",
          "After Count" = "After Count",
          "Velocity" = "Velocity",
          "IVB" = "InducedVert",
          "HB" = "HorzBreak",
          "Pitcher" = "Pitcher",
          "Pitch"  # default
        )
        
        # More helpful validation message
        if (nrow(df) == 0) {
          # Check what filters are active
          active_filters <- c()
          if (!is.null(input$hitter) && input$hitter != "All") {
            active_filters <- c(active_filters, paste("Hitter:", input$hitter))
          }
          if (!is.null(input$oppPitcher) && input$oppPitcher != "All") {
            active_filters <- c(active_filters, paste("Pitcher:", input$oppPitcher))
          }
          if (!is.null(input$dates) && length(input$dates) == 2) {
            active_filters <- c(active_filters, paste("Dates:", format(input$dates[1], "%m/%d/%y"), "-", format(input$dates[2], "%m/%d/%y")))
          }
          
          msg <- if (length(active_filters) > 0) {
            paste("No data found with these filters:", paste(active_filters, collapse = ", "))
          } else {
            "No data for selected filters"
          }
          
          validate(need(FALSE, msg))
        }
        
        swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
        parse_pct_prop <- function(x) {
          x_num <- suppressWarnings(as.numeric(sub("%$", "", as.character(x))))
          ifelse(is.finite(x_num), x_num / 100, NA_real_)
        }
        
        # ----- Terminal PA logic (match v1 behavior) -----
        # Add safety checks for NA values
        safe_terminal_check <- function(play_result, korbb) {
          play_ok <- !is.na(play_result) & play_result != "Undefined"
          korbb_ok <- !is.na(korbb) & korbb %in% c("Strikeout","Walk")
          return(play_ok | korbb_ok)
        }
        
        is_terminal <- safe_terminal_check(df$PlayResult, df$KorBB)
        term <- df[is_terminal, , drop = FALSE]
        
        # Ensure we have some terminal data
        if (nrow(term) == 0) {
          return(DT::datatable(
            data.frame(Message = "No completed plate appearances in selected data"),
            options = list(dom = 't'), rownames = FALSE
          ))
        }
        
        # Pitch totals for Swing%/Whiff%
        pitch_totals <- tryCatch({
          df %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              Pitches = dplyr::n(),
              Swings  = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
              Whiffs  = sum(!is.na(PitchCall) & PitchCall == "StrikeSwinging", na.rm = TRUE),
              CalledStrikes = sum(!is.na(PitchCall) & PitchCall == "StrikeCalled", na.rm = TRUE),
              .groups = "drop"
            )
        }, error = function(e) {
          # Return minimal structure if grouping fails
          data.frame(
            SplitColumn = "All",
            Pitches = nrow(df),
            Swings = sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE),
            Whiffs = sum(!is.na(df$PitchCall) & df$PitchCall == "StrikeSwinging", na.rm = TRUE),
            CalledStrikes = sum(!is.na(df$PitchCall) & df$PitchCall == "StrikeCalled", na.rm = TRUE),
            stringsAsFactors = FALSE
          )
        })
        total_pitches <- sum(pitch_totals$Pitches, na.rm = TRUE)
        
        # EV/LA from live balls in play
        bbe <- tryCatch({
          df %>%
            dplyr::filter(
              !is.na(SessionType),
              grepl("live|game|ab", tolower(SessionType)), 
              !is.na(PitchCall),
              PitchCall == "InPlay"
            )
        }, error = function(e) {
          # Return empty data frame if filtering fails
          df[FALSE, , drop = FALSE]
        })
        
        evla <- tryCatch({
          if (nrow(bbe) > 0) {
            bbe %>%
              dplyr::group_by(SplitColumn) %>%
              dplyr::summarise(
                EV = nz_mean(ExitSpeed), 
                LA = nz_mean(Angle), 
                .groups = "drop"
              )
          } else {
            data.frame(
              SplitColumn = character(0),
              EV = numeric(0),
              LA = numeric(0),
              stringsAsFactors = FALSE
            )
          }
        }, error = function(e) {
          data.frame(
            SplitColumn = character(0),
            EV = numeric(0),
            LA = numeric(0),
            stringsAsFactors = FALSE
          )
        })
        
        # GB%
        gb <- tryCatch({
          if (nrow(bbe) > 0) {
            bbe %>%
              dplyr::group_by(SplitColumn) %>%
              dplyr::summarise(
                GBpct = safe_div(
                  sum(!is.na(TaggedHitType) & TaggedHitType == "GroundBall", na.rm = TRUE),
                  sum(!is.na(TaggedHitType), na.rm = TRUE)
                ),
                .groups = "drop"
              )
          } else {
            data.frame(
              SplitColumn = character(0),
              GBpct = numeric(0),
              stringsAsFactors = FALSE
            )
          }
        }, error = function(e) {
          data.frame(
            SplitColumn = character(0),
            GBpct = numeric(0),
            stringsAsFactors = FALSE
          )
        })
        
        # Per-pitch-type PA/AB/hit/K/BB tallies (match v1 K/BB logic)
        per_type <- term %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            PA   = dplyr::n(),
            HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
            SFct = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
            IBBct= sum(PlayResult == "IntentionalWalk", na.rm = TRUE),
            `1B` = sum(PlayResult == "Single",  na.rm = TRUE),
            `2B` = sum(PlayResult == "Double",  na.rm = TRUE),
            `3B` = sum(PlayResult == "Triple",  na.rm = TRUE),
            HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
            Kct  = sum(KorBB == "Strikeout" |
                         PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
            BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
            .groups = "drop"
          ) %>%
          dplyr::mutate(
            AB  = PA - (BBct + HBP + Sac),
            H   = `1B` + `2B` + `3B` + HR,
            TB  = 1*`1B` + 2*`2B` + 3*`3B` + 4*HR,
            AVG = safe_div(H, AB),
            SLG = safe_div(TB, AB),
            OBP = safe_div(H + BBct + HBP, PA),
            OPS = SLG + OBP,
            ISO = SLG - AVG,
            uBB = BBct - IBBct,
            wOBA_num = 0.690*uBB + 0.722*HBP + 0.888*`1B` + 1.271*`2B` + 1.616*`3B` + 2.101*HR,
            wOBA_den = AB + BBct - IBBct + SFct + HBP,
            wOBA = safe_div(wOBA_num, wOBA_den)
          )
        
        # Extras (xWOBA/xISO/BABIP/Barrel%) — force numeric & use correct name
        extras_raw <- compute_process_results(df)
        extras <- extras_raw %>%
          {
            df_proc <- .
            if (!"SplitColumn" %in% names(df_proc) && "PitchType" %in% names(df_proc)) {
              df_proc <- dplyr::rename(df_proc, SplitColumn = PitchType)
            }
            df_proc
          } %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_pct_prop(`Barrel%`)
          ) %>%
          dplyr::select(SplitColumn, xWOBA, xISO, BABIP, `Barrel%`) %>%
          dplyr::rename(!!split_col_name := SplitColumn)
        
        # Join and build output rows per pitch type
        out <- per_type %>%
          dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
          dplyr::left_join(evla,         by = "SplitColumn") %>%
          dplyr::left_join(gb,           by = "SplitColumn") %>%
          dplyr::mutate(
            `Swing%` = safe_div(Swings, Pitches),
            `Whiff%` = safe_div(Whiffs, Swings),
            `GB%`    = GBpct,
            `K%`     = safe_div(Kct, PA),
            `BB%`    = safe_div(BBct, PA)
          ) %>%
          dplyr::transmute(
            !!split_col_name := as.character(SplitColumn),
            PA, AB, AVG, SLG, OBP, OPS,
            wOBA, xWOBA = NA_real_,
            ISO, xISO = NA_real_, BABIP = NA_real_,
            `Swing%`, `Whiff%`, `GB%`, `K%`, `BB%`,
            `Barrel%` = NA_real_, EV, LA
          )
        
        # Join extras if we have the right column
        out <- out %>% dplyr::left_join(extras, by = split_col_name)
        if (any(c("xWOBA.x","xWOBA.y") %in% names(out) |
                c("xISO.x","xISO.y") %in% names(out) |
                c("BABIP.x","BABIP.y") %in% names(out) |
                c("Barrel%.x","Barrel%.y") %in% names(out))) {
          for (nm in c("xWOBA","xISO","BABIP","Barrel%")) {
            if (!nm %in% names(out)) out[[nm]] <- NA_real_
          }
          out <- out %>%
            dplyr::mutate(
              xWOBA     = dplyr::coalesce(.data[["xWOBA.y"]], .data[["xWOBA.x"]], .data[["xWOBA"]]),
              xISO      = dplyr::coalesce(.data[["xISO.y"]],  .data[["xISO.x"]],  .data[["xISO"]]),
              BABIP     = dplyr::coalesce(.data[["BABIP.y"]], .data[["BABIP.x"]], .data[["BABIP"]]),
              `Barrel%` = dplyr::coalesce(.data[["Barrel%.y"]], .data[["Barrel%.x"]], .data[["Barrel%"]])
            ) %>%
            dplyr::select(-dplyr::matches("\\.(x|y)$"))
        }
        
        # ----- ALL row (same definitions as above, but ungrouped; keep your guards) -----
        PAt <- nrow(term)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
        H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
        H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
        HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        H   <- H1 + H2 + H3 + HR
        IBB_all <- sum(term$PlayResult == "IntentionalWalk", na.rm = TRUE)
        TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
        Kct_all <- sum(term$KorBB == "Strikeout" |
                         term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
        BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        ABt <- PAt - (BBc_all + HBP_all + Sac_all)
        
        swings  <- sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE)
        whiffs  <- sum(df$PitchCall == "StrikeSwinging",                      na.rm = TRUE)
        pitches <- nrow(df)
        csw_all_num <- sum(df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
        
        gbpct_all <- {
          d <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
          safe_div(sum(d$TaggedHitType == "GroundBall", na.rm = TRUE),
                   sum(!is.na(d$TaggedHitType),         na.rm = TRUE))
        }
        
        # Create all_row with dynamic column name
        all_row_data <- list(
          PA = PAt, AB = ABt,
          AVG = safe_div(H, ABt),
          SLG = safe_div(TB, ABt),
          OBP = safe_div(H + BBc_all + HBP_all, PAt),
          OPS = NA_real_,  # filled just below
          xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
          `Swing%` = safe_div(swings, total_pitches),
          `Whiff%` = safe_div(whiffs, swings),
          `CSW%`   = safe_div(csw_all_num, total_pitches),
          `GB%`    = gbpct_all,
          `K%`     = safe_div(Kct_all, PAt),
          `BB%`    = safe_div(BBc_all, PAt),
          `Barrel%`= NA_real_,
          EV = nz_mean(bbe$ExitSpeed),
          LA = nz_mean(bbe$Angle),
          ISO = safe_div(TB, ABt) - safe_div(H, ABt),
          wOBA = {
            uBB_all <- BBc_all - IBB_all
            num <- 0.690*uBB_all + 0.722*HBP_all + 0.888*H1 + 1.271*H2 + 1.616*H3 + 2.101*HR
            den <- ABt + BBc_all - IBB_all + Sac_all + HBP_all
            safe_div(num, den)
          }
        )
        all_row_data[[split_col_name]] <- "All"
        all_row <- tibble::as_tibble(all_row_data)
        all_row$OPS <- all_row$SLG + all_row$OBP
        
        extras_all <- {
          df_all <- df
          df_all$SplitColumn <- "All"
          compute_process_results(df_all) %>%
            dplyr::mutate(
              xWOBA     = parse_num(xWOBA),
              xISO      = parse_num(xISO),
              BABIP     = parse_num(BABIP),
              `Barrel%` = parse_pct_prop(`Barrel%`)
            ) %>%
            dplyr::summarise(
              xWOBA     = nz_mean(xWOBA),
              xISO      = nz_mean(xISO),
              BABIP     = nz_mean(BABIP),
              `Barrel%` = nz_mean(`Barrel%`),
              .groups = "drop"
            )
        }
        if (nrow(extras_all)) {
          all_row$xWOBA     <- extras_all$xWOBA[1]
          all_row$xISO      <- extras_all$xISO[1]
          all_row$BABIP     <- extras_all$BABIP[1]
          all_row$`Barrel%` <- extras_all$`Barrel%`[1]
        }
        
        # Add Even/Ahead/Behind summary rows if splitting by Count (Hitting Suite)
        hit_count_state_rows <- NULL
        if (split_choice == "Count" && "CountState" %in% names(df)) {
          for (state in c("Even", "Ahead", "Behind")) {
            state_df <- df %>% dplyr::filter(CountState == state)
            state_term <- term %>% dplyr::filter(CountState == state)
            
            if (nrow(state_df) > 0) {
              # Calculate stats for this count state
              state_PA <- nrow(state_term)
              state_HBP <- sum(state_term$PlayResult == "HitByPitch", na.rm = TRUE)
              state_Sac <- sum(state_term$PlayResult == "Sacrifice", na.rm = TRUE)
              state_H1 <- sum(state_term$PlayResult == "Single", na.rm = TRUE)
              state_H2 <- sum(state_term$PlayResult == "Double", na.rm = TRUE)
              state_H3 <- sum(state_term$PlayResult == "Triple", na.rm = TRUE)
              state_HR <- sum(state_term$PlayResult == "HomeRun", na.rm = TRUE)
              state_H <- state_H1 + state_H2 + state_H3 + state_HR
              state_TB <- 1*state_H1 + 2*state_H2 + 3*state_H3 + 4*state_HR
              state_Kct <- sum(state_term$KorBB == "Strikeout" |
                                 state_term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
              state_BBct <- sum(state_term$KorBB == "Walk" | state_term$PlayResult == "Walk", na.rm = TRUE)
              state_AB <- state_PA - (state_BBct + state_HBP + state_Sac)
              
              state_swings <- sum(!is.na(state_df$PitchCall) & state_df$PitchCall %in% swing_levels, na.rm = TRUE)
              state_whiffs <- sum(state_df$PitchCall == "StrikeSwinging", na.rm = TRUE)
              state_pitches <- nrow(state_df)
              state_bbe <- state_df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
              state_gbpct <- safe_div(sum(state_bbe$TaggedHitType == "GroundBall", na.rm = TRUE),
                                      sum(!is.na(state_bbe$TaggedHitType), na.rm = TRUE))
              
              # Calculate BABIP for count state
              state_inplay_all <- sum(state_df$PitchCall == "InPlay", na.rm = TRUE)
              state_BABIP <- safe_div(state_H, state_inplay_all)
              
              # Calculate Barrel% for count state
              state_barrels <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay" &
                                     is.finite(state_df$ExitSpeed) & is.finite(state_df$Angle) &
                                     state_df$ExitSpeed >= 95 & state_df$Angle >= 10 & state_df$Angle <= 35, na.rm = TRUE)
              state_inplay_live <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay", na.rm = TRUE)
              state_BarrelPct <- safe_div(state_barrels, state_inplay_live)
              
              # Calculate xWOBA and xISO for count state (using expected stats if available)
              state_bip_evla <- state_df %>%
                dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                              is.finite(ExitSpeed), is.finite(Angle)) %>%
                dplyr::mutate(
                  EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
                  LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
                )
              if (exists("xbin_ref") && nrow(state_bip_evla) > 0) {
                state_bip_evla <- state_bip_evla %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
                for (nm in c("p1B","p2B","p3B","pHR")) {
                  if (exists("x_overall") && nm %in% names(x_overall)) {
                    state_bip_evla[[nm]][!is.finite(state_bip_evla[[nm]])] <- x_overall[[nm]]
                  }
                }
                state_x1B <- sum(state_bip_evla$p1B, na.rm = TRUE)
                state_x2B <- sum(state_bip_evla$p2B, na.rm = TRUE)
                state_x3B <- sum(state_bip_evla$p3B, na.rm = TRUE)
                state_xHR <- sum(state_bip_evla$pHR, na.rm = TRUE)
                state_xH   <- state_x1B + state_x2B + state_x3B + state_xHR
                state_xTB  <- 1*state_x1B + 2*state_x2B + 3*state_x3B + 4*state_xHR
                state_xAVG <- safe_div(state_xH, state_AB)
                state_xSLG <- safe_div(state_xTB, state_AB)
                state_xISO <- state_xSLG - state_xAVG
                # xWOBA calculation (using weights if they exist)
                state_BF_live <- sum(state_df$SessionType == "Live" & state_df$Balls == 0 & state_df$Strikes == 0, na.rm = TRUE)
                if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
                  state_xWOBA <- safe_div(W_BB*state_BBct + W_1B*state_x1B + W_2B*state_x2B + W_3B*state_x3B + W_HR*state_xHR, state_BF_live)
                } else {
                  state_xWOBA <- NA_real_
                }
              } else {
                state_xWOBA <- NA_real_
                state_xISO <- NA_real_
              }
              
              state_row_data <- list(
                PA = state_PA,
                AB = state_AB,
                AVG = safe_div(state_H, state_AB),
                SLG = safe_div(state_TB, state_AB),
                OBP = safe_div(state_H + state_BBct + state_HBP, state_PA),
                OPS = NA_real_,
                wOBA = NA_real_,
                xWOBA = state_xWOBA,
                ISO = safe_div(state_TB, state_AB) - safe_div(state_H, state_AB),
                xISO = state_xISO,
                BABIP = state_BABIP,
                `Swing%` = safe_div(state_swings, state_pitches),
                `Whiff%` = safe_div(state_whiffs, state_swings),
                `GB%` = state_gbpct,
                `K%` = safe_div(state_Kct, state_PA),
                `BB%` = safe_div(state_BBct, state_PA),
                `Barrel%` = state_BarrelPct,
                EV = nz_mean(state_bbe$ExitSpeed),
                LA = nz_mean(state_bbe$Angle)
              )
              state_row_data[[split_col_name]] <- state
              state_row <- tibble::as_tibble(state_row_data)
              state_row$OPS <- state_row$SLG + state_row$OBP
              
              hit_count_state_rows <- dplyr::bind_rows(hit_count_state_rows, state_row)
            }
          }
        }
        
        # Bind, coerce numerics (prevents blanks), then format
        num_cols <- c("PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
                      "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
        
        df_out <- dplyr::bind_rows(out, hit_count_state_rows, all_row) %>%
          dplyr::mutate(
            dplyr::across(dplyr::all_of(num_cols), ~ suppressWarnings(as.numeric(.)))
          )
        
        # Keep pitch type order consistent with other suites
        if (split_choice == "Pitch Types" && split_col_name %in% names(df_out)) {
          ord <- names(all_colors)
          other <- setdiff(as.character(df_out[[split_col_name]]), c(ord, "All"))
          df_out[[split_col_name]] <- factor(
            df_out[[split_col_name]],
            levels = c(ord, other, "All")
          )
          df_out <- df_out %>%
            dplyr::arrange(.data[[split_col_name]]) %>%
            dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
          all_rows <- df_out[df_out[[split_col_name]] == "All", , drop = FALSE]
          other_rows <- df_out[df_out[[split_col_name]] != "All", , drop = FALSE]
          df_out <- dplyr::bind_rows(other_rows, all_rows)
        }
        
        # Sort by IVB/HB in descending order if applicable
        df_out <- sort_by_range(df_out, split_col_name, split_choice)
        
        # Display formatting
        tryCatch({
          pct_cols  <- c("Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%")
          rate_cols <- c("AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP")
          
          # Only format columns that exist
          existing_pct <- intersect(pct_cols, names(df_out))
          existing_rate <- intersect(rate_cols, names(df_out))
          
          if (length(existing_pct)) {
            df_out[existing_pct] <- lapply(df_out[existing_pct], function(z) {
              ifelse(is.finite(suppressWarnings(as.numeric(z))), 
                     paste0(round(suppressWarnings(as.numeric(z))*100,1), "%"), "")
            })
          }
          
          if (length(existing_rate)) {
            df_out[existing_rate] <- lapply(df_out[existing_rate], function(z) {
              ifelse(is.finite(suppressWarnings(as.numeric(z))), fmt_avg(as.numeric(z)), "")
            })
          }
          
          if ("EV" %in% names(df_out)) {
            df_out$EV <- ifelse(is.finite(suppressWarnings(as.numeric(df_out$EV))), 
                                round(suppressWarnings(as.numeric(df_out$EV)), 1), "")
          }
          if ("LA" %in% names(df_out)) {
            df_out$LA <- ifelse(is.finite(suppressWarnings(as.numeric(df_out$LA))), 
                                round(suppressWarnings(as.numeric(df_out$LA)), 1), "")
          }
        }, error = function(e) {
          # If formatting fails, continue with unformatted data
          message("Formatting error: ", conditionMessage(e))
        })
        
        # ===== SWING DECISION TABLE =====
        mode_check <- input$dpMode
        if (!is.null(mode_check) && mode_check == "Swing Decisions") {
          # Define green box boundaries (7 inches = 7/12 feet)
          inner_half <- 7 / 12
          mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
          mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
          green_xmin <- mid_x - inner_half
          green_xmax <- mid_x + inner_half
          green_ymin <- mid_y - inner_half
          green_ymax <- mid_y + inner_half
          
          # Pre-calculate PosSD points for each pitch
          df_with_possd <- df %>%
            dplyr::mutate(
              possd_point = {
                pc <- PitchCall
                ps <- PlateLocSide
                ph <- PlateLocHeight
                
                is_swing <- !is.na(pc) & pc %in% swing_levels
                in_green <- !is.na(ps) & !is.na(ph) & 
                  ps >= green_xmin & ps <= green_xmax & ph >= green_ymin & ph <= green_ymax
                in_zone <- !is.na(ps) & !is.na(ph) & 
                  ps >= ZONE_LEFT & ps <= ZONE_RIGHT & ph >= ZONE_BOTTOM & ph <= ZONE_TOP
                out_zone <- !in_zone
                
                dplyr::case_when(
                  in_green & is_swing ~ 2,      # +2: swing in green
                  in_green & !is_swing ~ -1,    # -1: take in green
                  in_zone & !in_green & is_swing ~ 1,   # +1: swing in zone but not green
                  in_zone & !in_green & !is_swing ~ 0,  # +0: take in zone but not green
                  out_zone & is_swing ~ -1,     # -1: swing out of zone
                  out_zone & !is_swing ~ 1,     # +1: take out of zone
                  TRUE ~ 0
                )
              }
            )
          
          # Compute stats by pitch type
          swing_decision_by_type <- df_with_possd %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              # Total pitches
              total_pitches = dplyr::n(),
              
              # Swings
              swings = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
              
              # FPS% - swings on 0-0 count
              fps_num = sum(
                !is.na(Balls) & !is.na(Strikes) & Balls == 0 & Strikes == 0 &
                  !is.na(PitchCall) & PitchCall %in% c("StrikeSwinging","InPlay","FoulBall","FoulBallNotFieldable","FoulBallFieldable"),
                na.rm = TRUE
              ),
              fps_den = sum(!is.na(Balls) & !is.na(Strikes) & Balls == 0 & Strikes == 0, na.rm = TRUE),
              
              # Called%
              called = sum(!is.na(PitchCall) & PitchCall == "StrikeCalled", na.rm = TRUE),
              
              # Chase% - swings outside zone
              chase_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  (PlateLocSide < ZONE_LEFT | PlateLocSide > ZONE_RIGHT | 
                     PlateLocHeight < ZONE_BOTTOM | PlateLocHeight > ZONE_TOP),
                na.rm = TRUE
              ),
              chase_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  (PlateLocSide < ZONE_LEFT | PlateLocSide > ZONE_RIGHT | 
                     PlateLocHeight < ZONE_BOTTOM | PlateLocHeight > ZONE_TOP),
                na.rm = TRUE
              ),
              
              # GoZoneSw% - swings in green box / pitches in green box
              gozone_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                  PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
                na.rm = TRUE
              ),
              gozone_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                  PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
                na.rm = TRUE
              ),
              
              # IZswing% - swings in zone / pitches in zone
              iz_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
                na.rm = TRUE
              ),
              iz_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
                na.rm = TRUE
              ),
              
              # EdgeSwing% - swings in zone but not green / pitches in zone but not green
              edge_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP &
                  !(PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                      PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax),
                na.rm = TRUE
              ),
              edge_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP &
                  !(PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                      PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax),
                na.rm = TRUE
              ),
              
              # PosSD% - Positive Swing Decision percentage
              possd_points = sum(possd_point, na.rm = TRUE),
              
              .groups = "drop"
            ) %>%
            dplyr::mutate(
              `Swing%` = safe_div(swings, total_pitches) * 100,
              `FPS%` = safe_div(fps_num, fps_den) * 100,
              `Called%` = safe_div(called, total_pitches) * 100,
              `Chase%` = safe_div(chase_num, chase_den) * 100,
              `GoZoneSw%` = safe_div(gozone_sw_num, gozone_sw_den) * 100,
              `IZswing%` = safe_div(iz_sw_num, iz_sw_den) * 100,
              `EdgeSwing%` = safe_div(edge_sw_num, edge_sw_den) * 100,
              `PosSD%` = safe_div(possd_points, total_pitches) * 100
            ) %>%
            dplyr::select(SplitColumn, `Swing%`, `FPS%`, `Called%`, `Chase%`, 
                          `GoZoneSw%`, `IZswing%`, `EdgeSwing%`, `PosSD%`) %>%
            dplyr::rename(!!split_col_name := SplitColumn)
          
          # Compute "All" row
          all_swing_decision <- df_with_possd %>%
            dplyr::summarise(
              total_pitches = dplyr::n(),
              swings = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
              fps_num = sum(
                !is.na(Balls) & !is.na(Strikes) & Balls == 0 & Strikes == 0 &
                  !is.na(PitchCall) & PitchCall %in% c("StrikeSwinging","InPlay","FoulBall","FoulBallNotFieldable","FoulBallFieldable"),
                na.rm = TRUE
              ),
              fps_den = sum(!is.na(Balls) & !is.na(Strikes) & Balls == 0 & Strikes == 0, na.rm = TRUE),
              called = sum(!is.na(PitchCall) & PitchCall == "StrikeCalled", na.rm = TRUE),
              chase_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  (PlateLocSide < ZONE_LEFT | PlateLocSide > ZONE_RIGHT | 
                     PlateLocHeight < ZONE_BOTTOM | PlateLocHeight > ZONE_TOP),
                na.rm = TRUE
              ),
              chase_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  (PlateLocSide < ZONE_LEFT | PlateLocSide > ZONE_RIGHT | 
                     PlateLocHeight < ZONE_BOTTOM | PlateLocHeight > ZONE_TOP),
                na.rm = TRUE
              ),
              gozone_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                  PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
                na.rm = TRUE
              ),
              gozone_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                  PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
                na.rm = TRUE
              ),
              iz_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
                na.rm = TRUE
              ),
              iz_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
                na.rm = TRUE
              ),
              edge_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP &
                  !(PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                      PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax),
                na.rm = TRUE
              ),
              edge_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP &
                  !(PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                      PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax),
                na.rm = TRUE
              ),
              possd_points = sum(possd_point, na.rm = TRUE)
            ) %>%
            dplyr::mutate(
              !!split_col_name := "All",
              `Swing%` = safe_div(swings, total_pitches) * 100,
              `FPS%` = safe_div(fps_num, fps_den) * 100,
              `Called%` = safe_div(called, total_pitches) * 100,
              `Chase%` = safe_div(chase_num, chase_den) * 100,
              `GoZoneSw%` = safe_div(gozone_sw_num, gozone_sw_den) * 100,
              `IZswing%` = safe_div(iz_sw_num, iz_sw_den) * 100,
              `EdgeSwing%` = safe_div(edge_sw_num, edge_sw_den) * 100,
              `PosSD%` = safe_div(possd_points, total_pitches) * 100
            ) %>%
            dplyr::select(.data[[split_col_name]], `Swing%`, `FPS%`, `Called%`, `Chase%`, 
                          `GoZoneSw%`, `IZswing%`, `EdgeSwing%`, `PosSD%`)
          
          # Combine and format
          df_swing_decision <- dplyr::bind_rows(swing_decision_by_type, all_swing_decision)
          
          # Format to 1 decimal
          pct_cols_sd <- c("Swing%", "FPS%", "Called%", "Chase%", "GoZoneSw%", "IZswing%", "EdgeSwing%", "PosSD%")
          for (col in pct_cols_sd) {
            if (col %in% names(df_swing_decision)) {
              df_swing_decision[[col]] <- ifelse(
                is.finite(df_swing_decision[[col]]),
                paste0(round(df_swing_decision[[col]], 1), "%"),
                ""
              )
            }
          }
          
          # EdgeSwing% was missing, let me add it
          if (!"EdgeSwing%" %in% names(df_swing_decision)) {
            df_swing_decision$`EdgeSwing%` <- ""
          }
          
          df_dt <- if (exists("safe_for_dt")) safe_for_dt(df_swing_decision) else df_swing_decision
          
          return(datatable_with_colvis(
            df_dt,
            lock            = split_col_name,
            remember        = FALSE,
            default_visible = c(split_col_name, pct_cols_sd),
            mode            = NULL,
            enable_colors   = FALSE
          ))
        }
        
        # Clean for DT + final guard for All-row % blanks
        df_dt <- if (exists("safe_for_dt")) safe_for_dt(df_out) else df_out
        
        # Ensure split column has no NAs to avoid logical errors
        if (!split_col_name %in% names(df_dt)) df_dt[[split_col_name]] <- "Unknown"
        df_dt[[split_col_name]][is.na(df_dt[[split_col_name]])] <- "Unknown"
        
        is_all <- !is.na(df_dt[[split_col_name]]) & df_dt[[split_col_name]] == "All"
        for (nm in c("Swing%","Whiff%","CSW%","GB%","K%","BB%")) {
          if (nm %in% names(df_dt)) {
            z <- df_dt[[nm]]
            z[is_all & (is.na(z) | trimws(as.character(z)) == "")] <- "0.0%"
            df_dt[[nm]] <- z
          }
        }
        
        # Visible set: Results vs Custom
        mode   <- input$dpMode
        if (is.null(mode)) mode <- "Results"
        custom <- input$dpCustomCols; if (is.null(custom)) custom <- character(0)
        base_cols <- c(split_col_name,"PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
                       "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
        # Replace "Pitch" with split_col_name in custom if present
        if ("Pitch" %in% custom && split_col_name != "Pitch") {
          custom <- c(split_col_name, setdiff(custom, "Pitch"))
        }
        visible_set <- if (identical(mode, "Custom")) unique(c(split_col_name, custom)) else base_cols
        
        # Ensure visible_set only contains valid column names
        valid_visible <- intersect(visible_set, names(df_dt))
        if (!length(valid_visible)) valid_visible <- split_col_name
        
        datatable_with_colvis(
          df_dt,
          lock            = split_col_name,
          remember        = FALSE,
          default_visible = valid_visible,
          mode            = NULL,
          enable_colors   = FALSE  # Disable colors for hitting suite
        )
      }, error = function(e) {
        # Provide detailed error information for debugging
        error_msg <- conditionMessage(e)
        error_details <- paste(
          "Detailed error in Hitting dpTable:",
          "Error:", error_msg,
          "Call stack available in R console",
          sep = "\n"
        )
        
        # Log the full error for debugging
        cat("Hitting dpTable error:\n")
        cat("Message:", error_msg, "\n")
        cat("Traceback:\n")
        traceback()
        
        DT::datatable(
          data.frame(
            Error_Type = "Table Generation Error",
            Error_Message = error_msg,
            Suggestion = "Check console for full error details"
          ),
          options = list(dom = 't'), rownames = FALSE
        )
      })
    }, server = FALSE)
  })
}


# =============================
# 0) DATA HOOKS (top-level)
#    • Add "Catcher" to need_cols
#    • Coerce to character like other columns
#    • Build catcher_map (display names)
# =============================

# --- A) need_cols: add Catcher ---
# Find your existing need_cols <- c(...). Add "Catcher" at the end:
#   "Batter", "Catcher"   # ← add this

# --- B) After the for(nm in need_cols) loop and before force_pitch_levels(),
# in the big mutate(...) where you coerce types, add:
#   Catcher         = as.character(Catcher),

# --- C) Build catcher_map (just after batter_map is created) ---
raw_catchers <- sort(unique(na.omit(as.character(pitch_data$Catcher))))
catch_display <- ifelse(
  grepl(",", raw_catchers),
  vapply(strsplit(raw_catchers, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_catchers
)
catcher_map <- setNames(raw_catchers, catch_display)


# ==================================
# 1) CATCHING UI MODULE (replace stub)
# ==================================
mod_catch_ui <- function(id, show_header = FALSE) {
  ns <- NS(id)
  shiny::fluidPage(
    if (isTRUE(show_header)) {
      fluidRow(
        class = "suite-header",
        column(2, tags$img(src = "PCUlogo.png", height = "100px")),
        column(
          8,
          div(
            style = "height:100%; display:flex; justify-content:center; align-items:flex-start;",
            tags$h1("Catching Dashboard", style = "margin-top:25px; font-weight:bold;")
          )
        ),
        column(
          2,
          div(style = "text-align:right; margin-top:10px;",
              tags$img(src = school_logo, height = "80px", alt = school_display_name))
        )
      )
    },
    sidebarLayout(
      sidebarPanel(
        # Exact same main sidebar as Pitching, but with Catcher selector
        selectInput(ns("sessionType"), "Session Type:", choices = c("All","Bullpen","Live"), selected = "All"),
        selectInput(ns("catcher"), "Select Catcher:", choices = c("All" = "All", catcher_map), selected = "All"),
        selectInput(
          ns("teamType"), "Team:",
          choices = TEAM_CHOICES,
          selected = "All"
        ),
        dateRangeInput(ns("dates"), "Date Range:",
                       start = max(pitch_data$Date, na.rm = TRUE),
                       end   = max(pitch_data$Date, na.rm = TRUE),
                       format = "mm/dd/yyyy"),
        selectInput(ns("hand"), "Pitcher Hand:", choices = c("All","Left","Right"), selected = "All"),
        selectInput(ns("pitchType"), "Pitch Type:",
                    choices = c("All", levels(pitch_data$TaggedPitchType)), selected = "All", multiple = TRUE),
        selectInput(
          ns("zoneLoc"), "Zone Location:",
          choices = c("All",
                      "Upper Half","Bottom Half","Left Half","Right Half",
                      "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
          selected = "All",
          multiple = TRUE
        ),
        selectInput(ns("inZone"), "In Zone:", choices = c("All","Yes","No","Competitive"), selected = "All"),
        selectInput(ns("batterSide"), "Batter Hand:", choices = c("All","Left","Right"), selected = "All"),
        selectInput(
          ns("countFilter"), "Count:",
          choices = c("All"="All","Even"="Even","Behind"="Behind","Ahead"="Ahead","2K Not Full"="2KNF",
                      "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
          selected = "All", multiple = TRUE
        ),
        selectInput(ns("breakLines"), "Break Lines:", choices = c("None","Fastball","Sinker"), selected = "None"),
        selectInput(ns("stuffLevel"), "Stuff+ Level:", choices = c("Pro","College","High School"), selected = "College"),
        selectInput(ns("stuffBase"),  "Stuff+ Base Pitch:", choices = c("Fastball","Sinker"), selected = "Fastball"),
        fluidRow(column(6, numericInput(ns("veloMin"), "Velocity Min (MPH):", value = NA)),
                 column(6, numericInput(ns("veloMax"), "Velocity Max (MPH):", value = NA))),
        fluidRow(column(6, numericInput(ns("ivbMin"), "IVB Min (inches):", value = NA)),
                 column(6, numericInput(ns("ivbMax"), "IVB Max (inches):", value = NA))),
        fluidRow(column(6, numericInput(ns("hbMin"), "HB Min (inches):", value = NA)),
                 column(6, numericInput(ns("hbMax"), "HB Max (inches):", value = NA))),
        fluidRow(column(6, numericInput(ns("pcMin"), "Pitch Count Min:", value = NA, min = 1)),
                 column(6, numericInput(ns("pcMax"), "Pitch Count Max:", value = NA, min = 1))),
        width = 3,
        class = "sidebar"
      ),
      mainPanel(
        tabsetPanel(
          id = ns("tabs"),
          tabPanel(
            "Data and Performance",
            div(style = "margin: 8px 0;", uiOutput(ns("dpButtons"))),
            DT::dataTableOutput(ns("dpTable"))
          ),
          # ---- Catching: Location page (UI) ----
          tabPanel(
            "Location",
            fluidRow(
              column(
                3,
                selectInput(ns("loc_targetBase"), "Target Base:", c("2B","3B","1B"), selected = "2B"),
                selectInput(ns("loc_units"), "Units:", c("auto","feet","inches","meters"), selected = "auto"),
                sliderInput(ns("loc_zoom"), "Zoom (half-width, ft):", min = 2, max = 12, value = 6, step = 0.5),
                helpText("Only rows with PopTime and ThrowSpeed ≥ 70 mph are counted as throws.")
              ),
              column(
                9,
                tabsetPanel(
                  id = ns("loc_tabs"),
                  tabPanel("Top-down", ggiraph::girafeOutput(ns("loc_topdown"), height = "420px"),
                           verbatimTextOutput(ns("loc_td_summary"))),
                  tabPanel("3D",       plotly::plotlyOutput(ns("loc_3d"), height = "520px"))
                )
              )
            )
          ),
          tabPanel(
            "HeatMaps",
            sidebarLayout(
              sidebarPanel(
                selectInput(ns("hmChartType"), "Select Chart:", choices = c("Heat","Pitch"), selected = "Heat"),
                
                # NEW: server-driven multi-select for results (so choices load safely)
                uiOutput(ns("hmResultsUI")),
                
                uiOutput(ns("hmNote")),
                width = 3
              ),
              mainPanel(
                div(style = "background: transparent !important;",
                    conditionalPanel(sprintf("input['%s']=='Heat'", ns("hmChartType")),
                                     plotOutput(ns("heatPlot"), height = "500px")),
                    conditionalPanel(sprintf("input['%s']=='Pitch'", ns("hmChartType")),
                                     ggiraph::girafeOutput(ns("pitchPlot"), height = "500px"))
                )
              )
            )
          )
        )
      )
    )
  )
}


# =====================================
# 2) CATCHING SERVER MODULE (replace stub)
# =====================================
mod_catch_server <- function(id, is_active = shiny::reactive(TRUE), global_date_range = NULL) {
  moduleServer(id, function(input, output, session) {
    
    # Sync local date input with global date range
    if (!is.null(global_date_range)) {
      observe({
        if (!is.null(global_date_range()) && length(global_date_range()) == 2) {
          updateDateRangeInput(session, "dates", 
                               start = global_date_range()[1], 
                               end = global_date_range()[2])
        }
      })
      
      # Update global date range when local input changes
      observeEvent(input$dates, {
        if (!is.null(input$dates) && length(input$dates) == 2) {
          global_date_range(input$dates)
        }
      })
    }
    ns <- session$ns
    
    MIN_THROW_MPH <- 70  # only count throws at/above this speed
    
    output$hmResultsUI <- renderUI({
      # Prefer global result_levels; fall back to what’s present in the filtered data
      ch <- if (exists("result_levels")) {
        result_levels
      } else {
        df0 <- filtered_catch()
        sort(unique(na.omit(as.character(df0$Result))))
      }
      if (length(ch) == 0) ch <- character(0)
      
      selectizeInput(
        session$ns("hmResults"),
        "Pitch Results:",
        choices  = ch,
        selected = ch,
        multiple = TRUE,
        options  = list(plugins = list("remove_button"))
      )
    })
    
    # ---- Default date to last live/game/AB (one-time on load) ----
    .local_once_set <- reactiveVal(FALSE)
    observeEvent(filtered_catch(), {
      if (isTRUE(.local_once_set())) return()
      df <- filtered_catch(); if (!nrow(df)) return()
      
      st <- tolower(trimws(as.character(df$SessionType)))
      live_mask <- grepl("live|game|ab", st)
      
      # Parse dates robustly
      parse_date_safely <- function(x) {
        if (inherits(x, "Date")) return(x)
        d <- suppressWarnings(as.Date(x))
        if (all(is.na(d))) {
          d <- suppressWarnings(lubridate::ymd(x))
          if (all(is.na(d))) d <- suppressWarnings(lubridate::mdy(x))
        }
        as.Date(d)
      }
      d <- parse_date_safely(df$Date)
      
      if (any(live_mask & !is.na(d))) {
        last_dt <- max(d[live_mask], na.rm = TRUE)
        updateDateRangeInput(session, "dateRange", start = last_dt, end = last_dt)
        .local_once_set(TRUE)  # prevent re-trigger loops
      }
    }, ignoreInit = FALSE)  # <— run on initial load
    
    
    # Flatten any list columns before sending to DT
    collapse_list_cols <- function(dat) {
      if (!nrow(dat)) return(dat)
      dat %>%
        dplyr::mutate(dplyr::across(
          dplyr::where(is.list),
          ~ vapply(., function(x) {
            if (is.null(x)) "" else if (length(x) == 1 && !is.list(x)) as.character(x)
            else paste0(unlist(x), collapse = ", ")
          }, character(1))
        ))
    }
    
    # Keep count filter tidy
    observeEvent(input$countFilter, {
      sel <- input$countFilter
      if (is.null(sel) || !length(sel)) {
        updateSelectInput(session, "countFilter", selected = "All")
      } else if ("All" %in% sel && length(sel) > 1) {
        updateSelectInput(session, "countFilter", selected = setdiff(sel, "All"))
      }
    }, ignoreInit = TRUE)
    
    # Default dates to last date for selected catcher (or global last)
    observeEvent(input$catcher, {
      req(is_active())
      last_date <- if (isTRUE(input$catcher == "All")) {
        max(pitch_data$Date, na.rm = TRUE)
      } else {
        mx <- max(pitch_data$Date[pitch_data$Catcher == input$catcher], na.rm = TRUE)
        if (is.finite(mx)) mx else max(pitch_data$Date, na.rm = TRUE)
      }
      if (is.finite(last_date)) {
        updateDateRangeInput(session, "dates", start = last_date, end = last_date)
      }
    }, ignoreInit = TRUE)
    
    # Filtered data for Catching
    filtered_catch <- reactive({
      req(is_active(), input$teamType)
      
      # helpers
      is_valid_dates <- function(d) !is.null(d) && length(d) == 2 && all(is.finite(d))
      nnz <- function(x) !is.null(x) && !is.na(x)
      
      # Guard: if dates are mid-update, return empty quickly
      if (!is_valid_dates(input$dates)) return(pitch_data[0, , drop = FALSE])
      
      pitch_types <- if (is.null(input$pitchType)) "All" else input$pitchType
      
      # Session type first
      df <- if (identical(input$sessionType, "All")) pitch_data
      else dplyr::filter(pitch_data, SessionType == input$sessionType)
      
      # ⛔️ Team filtering - Filter by team selection ⛔️
      if (!is.null(input$teamType)) {
        all_osu_and_campers <- unique(c(ALLOWED_PITCHERS, ALLOWED_CAMPERS))
        
        if (input$teamType == "Campers") {
          # Filter to only allowed campers (as pitchers)
          df <- dplyr::filter(df, Pitcher %in% ALLOWED_CAMPERS)
        } else if (input$teamType == TEAM_CODE) {
          # Filter to GCU allowed pitchers
          df <- dplyr::filter(df, Pitcher %in% ALLOWED_PITCHERS)
        } else if (input$teamType == "Opponents") {
          # Show only opponent pitchers (anyone NOT in GCU or Campers lists)
          df <- dplyr::filter(df, !(Pitcher %in% all_osu_and_campers))
        }
        # If "All" is selected, don't filter - show all data
      }
      
      # ⛔️ Drop warmups & blank pitch types
      if ("TaggedPitchType" %in% names(df)) {
        df <- df %>%
          dplyr::mutate(.tpt = trimws(as.character(TaggedPitchType))) %>%
          dplyr::filter(!is.na(.tpt) & nzchar(.tpt)) %>%
          dplyr::select(-.tpt)
      }
      if ("PitchSession" %in% names(df)) {
        df <- dplyr::filter(df, is.na(PitchSession) | PitchSession != "Warmup")
      }
      
      # Catcher filter
      cat_pick <- input$catcher
      if (!is.null(cat_pick) && cat_pick != "All") {
        df <- dplyr::filter(df, Catcher == cat_pick)
      }
      
      
      # Date range
      df <- dplyr::filter(df, Date >= input$dates[1], Date <= input$dates[2])
      
      # Pitcher hand
      if (input$hand != "All") df <- dplyr::filter(df, PitcherThrows == input$hand)
      
      # NEW: Opponent Hitter filter (for pitching suite)
      if (!is.null(input$oppHitter) && input$oppHitter != "All") {
        df <- dplyr::filter(df, Batter == input$oppHitter)
      }
      
      # Batter side (Live only)
      if (!is.null(input$batterSide) && input$batterSide != "All") {
        df <- df %>% dplyr::filter(SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide))
      }
      
      # Spatial & count filters
      df <- enforce_zone(df, input$zoneLoc)
      df <- enforce_inzone(df, input$inZone)
      df <- filter_qp_locations(df, input$qpLocations)
      df <- apply_count_filter(df, input$countFilter)
      df <- apply_after_count_filter(df, input$afterCountFilter)
      df <- apply_pitch_results_filter(df, input$pitchResults)
      df <- apply_after_count_filter(df, input$afterCountFilter)
      df <- apply_pitch_results_filter(df, input$pitchResults)
      df <- apply_pitch_results_filter(df, input$pitchResults)
      
      # Numeric ranges
      if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed >= input$veloMin)
      if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed <= input$veloMax)
      if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
      if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
      if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak >= input$hbMin)
      if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak <= input$hbMax)
      
      # Pitch number window
      df <- df %>% dplyr::arrange(Date) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
      if (nnz(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
      if (nnz(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
      
      # Stuff+ calc
      df2 <- compute_stuff_simple(df, base_type = input$stuffBase, level = input$stuffLevel) %>%
        force_pitch_levels() %>%
        dplyr::mutate(Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels))
      
      # Pitch types (post-derive)
      if (!("All" %in% pitch_types)) df2 <- dplyr::filter(df2, TaggedPitchType %in% pitch_types)
      
      df2
    })
    
    # ---- Catching: Data/Custom controls ----
    output$dpButtons <- renderUI({
      sel <- isolate(input$dpMode); if (is.null(sel)) sel <- "Data"
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("dpMode"), label = NULL,
                            choices = c("Data","Custom"),
                            selected = sel, width = "100px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("dpColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']==='Custom'", ns("dpMode")),
          selectizeInput(
            ns("dpCustomCols"), label = NULL,
            choices = c("#","Velo","ExchangeTime","PopTime","SL+"),  # <— added "#"
            multiple = TRUE,
            options = list(placeholder = "Choose columns to show…")
          )
        )
      )
    })
    
    
    # ---- Catching: Data/Custom table (PopTime-gated throws; ALL last) ----
    output$dpTable <- DT::renderDataTable({
      req(is_active())
      df_all <- filtered_catch()
      if (!nrow(df_all)) {
        return(DT::datatable(data.frame(Note = "No rows for current filters."),
                             options = list(dom = 't'), rownames = FALSE))
      }
      
      to_num <- function(x) suppressWarnings(as.numeric(x))
      
      # ---------- SL+ on TAKES from the full dataset ----------
      # Safe logical operations for takes calculation
      takes <- tryCatch({
        pitch_call_safe <- as.character(df_all$PitchCall)
        (!is.na(pitch_call_safe)) & (pitch_call_safe %in% c("StrikeCalled","BallCalled", "BallinDirt"))
      }, error = function(e) {
        rep(FALSE, nrow(df_all))
      })
      buckets <- inzone_label(df_all$PlateLocSide, df_all$PlateLocHeight)
      
      base_tbl <- dplyr::tibble(
        take   = takes,
        bucket = buckets,
        is_cs  = tryCatch({
          pitch_call_safe <- as.character(df_all$PitchCall)
          pitch_call_safe == "StrikeCalled"
        }, error = function(e) rep(FALSE, nrow(df_all)))
      ) %>%
        dplyr::filter(take) %>%
        dplyr::group_by(bucket) %>%
        dplyr::summarise(cs_rate = mean(is_cs, na.rm = TRUE), n = dplyr::n(), .groups = "drop")
      
      overall_rate <- if (nrow(base_tbl) && sum(base_tbl$n) > 0) {
        sum(base_tbl$cs_rate * base_tbl$n) / sum(base_tbl$n)
      } else NA_real_
      
      rate_for_bucket <- function(b) {
        r <- base_tbl$cs_rate[match(b, base_tbl$bucket)]
        ifelse(is.na(r), overall_rate, r)
      }
      
      sl_by_pitch <- df_all %>%
        dplyr::mutate(
          Pitch  = as.character(TaggedPitchType),
          take   = takes,
          bucket = buckets
        ) %>%
        dplyr::group_by(Pitch) %>%
        dplyr::summarise(
          `SL+` = {
            any_take <- tryCatch(any(take, na.rm = TRUE), error = function(e) FALSE)
            if (!any_take) {
              NA_real_
            } else {
              # Safe comparison for PitchCall
              pitch_call_subset <- tryCatch({
                as.character(PitchCall[take])
              }, error = function(e) character(0))
              
              obs <- if (length(pitch_call_subset) > 0) {
                mean(pitch_call_subset == "StrikeCalled", na.rm = TRUE)
              } else {
                NA_real_
              }
              
              tb  <- table(bucket[take])
              if (length(tb)) {
                exp <- sum(as.numeric(tb) * vapply(names(tb), rate_for_bucket, numeric(1))) / sum(tb)
                exp_check <- tryCatch(is.finite(exp) && exp > 0, error = function(e) FALSE)
                if (exp_check) round(100 * obs / exp, 1) else NA_real_
              } else NA_real_
            }
          },
          .groups = "drop"
        )
      
      # ---------- Define "throws" as rows WITH PopTime present ----------
      df_throw <- df_all %>%
        dplyr::mutate(
          Pitch            = as.character(TaggedPitchType),
          ThrowSpeed_num   = to_num(ThrowSpeed),
          ExchangeTime_num = to_num(ExchangeTime),
          PopTime_num      = to_num(PopTime)
        ) %>%
        dplyr::filter(
          is.finite(PopTime_num),
          is.finite(ThrowSpeed_num),
          ThrowSpeed_num >= MIN_THROW_MPH   # or use 70 directly
        )
      
      # Per-pitch stats + count of throws (“#”) over PopTime-present rows
      stats_throw <- if (nrow(df_throw)) {
        df_throw %>%
          dplyr::group_by(Pitch) %>%
          dplyr::summarise(
            `#`           = dplyr::n(),                                # <-- throws counted by PopTime presence
            Velo          = round(mean(ThrowSpeed_num,   na.rm = TRUE), 1),  # may be NA if no ThrowSpeed for that pitch
            ExchangeTime  = round(mean(ExchangeTime_num, na.rm = TRUE), 1),
            PopTime       = round(mean(PopTime_num,      na.rm = TRUE), 2),
            .groups = "drop"
          )
      } else {
        dplyr::tibble(Pitch = character(), `#` = integer(),
                      Velo = numeric(), ExchangeTime = numeric(), PopTime = numeric())
      }
      
      # ---------- Join SL+ and order pitches ----------
      out <- stats_throw %>%
        dplyr::left_join(sl_by_pitch, by = "Pitch")
      
      # robust pitch ordering (works with your helpers)
      safe_pitch_order <- function(v) {
        v_chr <- as.character(v)
        if (exists("ordered_types")) {
          ord_try <- tryCatch({
            o <- ordered_types(v_chr)
            if (is.factor(o)) levels(o) else unique(as.character(o))
          }, error = function(e) NULL)
          if (length(ord_try)) return(ord_try)
        }
        if (exists("force_pitch_levels")) {
          ord_try2 <- tryCatch({
            tmp <- data.frame(TaggedPitchType = v_chr, stringsAsFactors = FALSE)
            o <- force_pitch_levels(tmp)
            if ("TaggedPitchType" %in% names(o)) {
              if (is.factor(o$TaggedPitchType)) levels(o$TaggedPitchType)
              else unique(as.character(o$TaggedPitchType))
            } else NULL
          }, error = function(e) NULL)
          if (length(ord_try2)) return(ord_try2)
        }
        unique(na.omit(v_chr))
      }
      ord <- safe_pitch_order(df_all$TaggedPitchType)
      
      out <- out %>%
        dplyr::mutate(Pitch = factor(Pitch, levels = ord)) %>%
        dplyr::arrange(Pitch) %>%
        dplyr::mutate(Pitch = as.character(Pitch))
      
      # ---------- ALL row LAST (totals also over PopTime-present rows) ----------
      total_throws <- nrow(df_throw)  # <-- total PopTime-present throws
      all_velo <- if (total_throws) round(mean(df_throw$ThrowSpeed_num,   na.rm = TRUE), 1) else NA_real_
      all_xch  <- if (total_throws) round(mean(df_throw$ExchangeTime_num, na.rm = TRUE), 1) else NA_real_
      all_pop  <- if (total_throws) round(mean(df_throw$PopTime_num,      na.rm = TRUE), 2) else NA_real_
      obs_all  <- tryCatch({
        any_takes <- tryCatch(any(takes, na.rm = TRUE), error = function(e) FALSE)
        if (any_takes) {
          pitch_call_takes <- as.character(df_all$PitchCall[takes])
          if (length(pitch_call_takes) > 0) {
            mean(pitch_call_takes == "StrikeCalled", na.rm = TRUE)
          } else {
            NA_real_
          }
        } else {
          NA_real_
        }
      }, error = function(e) NA_real_)
      exp_all  <- overall_rate
      sl_all   <- tryCatch({
        if (is.finite(obs_all) && is.finite(exp_all) && exp_all > 0) {
          round(100 * obs_all / exp_all, 1)
        } else {
          NA_real_
        }
      }, error = function(e) NA_real_)
      
      all_row <- dplyr::tibble(Pitch = "ALL", `#` = total_throws,
                               Velo = all_velo, ExchangeTime = all_xch, PopTime = all_pop, `SL+` = sl_all)
      
      final <- dplyr::bind_rows(out, all_row)  # ALL last
      
      # ---------- Visible set based on mode ----------
      mode <- if (is.null(input$dpMode)) "Data" else input$dpMode
      default_visible <- if (identical(mode, "Custom")) {
        unique(c("Pitch", "#", input$dpCustomCols))
      } else {
        c("Pitch","#","Velo","ExchangeTime","PopTime","SL+")
      }
      
      datatable_with_colvis(
        final,
        lock            = "Pitch",
        remember        = TRUE,
        default_visible = default_visible
      )
    }, server = FALSE)
    
    # =========================
    # Catching: Location server
    # =========================
    
    # ---- tiny helpers (scoped to this module) ----
    loc_to_num <- function(x) suppressWarnings(as.numeric(x))
    loc_convert_to_feet <- function(x, mode = "auto") {
      x <- as.numeric(x)
      if (mode == "feet")   return(x)
      if (mode == "inches") return(x/12)
      if (mode == "meters") return(x*3.28084)
      p95 <- suppressWarnings(stats::quantile(abs(x), 0.95, na.rm = TRUE))
      if (is.na(p95)) return(x)
      if (p95 > 20)       x/12      else if (p95 < 2) x*3.28084 else x
    }
    loc_guess_cols_xy  <- function(df) {
      nms <- names(df)
      pick <- function(...) { pats <- c(...); for (p in pats) { hit <- nms[grepl(p, nms, ignore.case=TRUE)]; if (length(hit)) return(hit[1]) }; "" }
      list(
        x  = pick("BasePositionX","BagX","ThrowEndX","ArrivalX","BaseX"),
        y  = pick("BasePositionY","BagY","ThrowEndY","ArrivalY","BaseY"),
        cx = pick("SecondBaseX","BagCenterX","BaseCenterX","TargetBaseX"),
        cy = pick("SecondBaseY","BagCenterY","BaseCenterY","TargetBaseY")
      )
    }
    loc_guess_cols_xyz <- function(df) {
      nms <- names(df)
      pick <- function(...) { pats <- c(...); for (p in pats) { hit <- nms[grepl(p, nms, ignore.case=TRUE)]; if (length(hit)) return(hit[1]) }; "" }
      list(
        x  = pick("BasePositionX","BagX","ThrowEndX","ArrivalX","BaseX"),
        y  = pick("BasePositionY","BagY","ThrowEndY","ArrivalY","BaseY"),
        z  = pick("BasePositionZ","BagZ","ThrowEndZ","ArrivalZ","BaseZ","Height"),
        cx = pick("SecondBaseX","BagCenterX","BaseCenterX","TargetBaseX"),
        cy = pick("SecondBaseY","BagCenterY","BaseCenterY","TargetBaseY"),
        cz = pick("SecondBaseZ","BagCenterZ","BaseCenterZ","TargetBaseZ")
      )
    }
    loc_make_bag_poly <- function(size_in = 18) {
      sft <- size_in/12; r <- sft/sqrt(2)
      data.frame(x = c(0, r, 0, -r, 0), y = c(r, 0, -r, 0, r))
    }
    loc_inside_bag <- function(x, y, size_in = 18) {
      r <- (size_in/12)/sqrt(2); (abs(x)+abs(y)) <= r
    }
    
    # ---- common reactive: throws filtered to PopTime present & base selection ----
    loc_throws <- reactive({
      df <- filtered_catch()
      if (!nrow(df)) return(df[0, , drop=FALSE])
      
      # Only rows with PopTime AND ThrowSpeed ≥ 70 mph are considered throws
      df$PopTime_num     <- loc_to_num(df$PopTime)
      df$ThrowSpeed_num  <- loc_to_num(df$ThrowSpeed)
      df <- df[
        is.finite(df$PopTime_num) &
          is.finite(df$ThrowSpeed_num) &
          df$ThrowSpeed_num >= (if (exists("MIN_THROW_MPH")) MIN_THROW_MPH else 70),
        ,
        drop = FALSE
      ]
      if (!nrow(df)) return(df)
      
      tgt <- if (is.null(input$loc_targetBase)) "2B" else input$loc_targetBase
      if ("TargetBase" %in% names(df)) {
        df <- df[as.character(df$TargetBase) == tgt, , drop = FALSE]
      }
      df
    })
    
    
    # ---- TOP-DOWN (2D) ----
    output$loc_topdown <- ggiraph::renderGirafe({
      req(is_active())
      df <- loc_throws(); if (!nrow(df)) return(NULL)
      
      gc <- loc_guess_cols_xy(df)
      if (!nzchar(gc$x) || !nzchar(gc$y)) {
        return(girafe_transparent(code = print(ggplot2::ggplot() +
                                                 ggplot2::annotate("text", x=0, y=0, label="No base-arrival X/Y columns found") +
                                                 ggplot2::theme_void())))
      }
      
      mode <- if (is.null(input$loc_units)) "auto" else input$loc_units
      x <- loc_convert_to_feet(loc_to_num(df[[gc$x]]), mode)
      y <- loc_convert_to_feet(loc_to_num(df[[gc$y]]), mode)
      
      # center to bag: prefer explicit bag center cols; else median-center
      if (nzchar(gc$cx) && nzchar(gc$cy)) {
        cx <- loc_convert_to_feet(loc_to_num(df[[gc$cx]]), mode)
        cy <- loc_convert_to_feet(loc_to_num(df[[gc$cy]]), mode)
        dx <- x - cx; dy <- y - cy
      } else {
        dx <- x - stats::median(x, na.rm = TRUE)
        dy <- y - stats::median(y, na.rm = TRUE)
      }
      
      bag <- loc_make_bag_poly(18)
      zoom <- if (is.null(input$loc_zoom)) 6 else input$loc_zoom
      
      tip <- paste0(
        "dx: ", sprintf("%.2f", dx), " ft\n",
        "dy: ", sprintf("%.2f", dy), " ft\n",
        "Pop: ", ifelse(is.na(df$PopTime), "", df$PopTime), "\n",
        "Velo: ", ifelse(is.na(df$ThrowSpeed), "", df$ThrowSpeed)
      )
      
      p <- ggplot2::ggplot() +
        ggplot2::geom_polygon(data = bag, ggplot2::aes(x, y), fill = NA, linewidth = 1) +
        ggplot2::annotate("point", x=0, y=0, shape=3, size=3) +
        ggplot2::geom_hline(yintercept = 0, linetype = 3) +
        ggplot2::geom_vline(xintercept = 0, linetype = 3) +
        ggiraph::geom_point_interactive(
          ggplot2::aes(dx, dy, tooltip = tip),
          data = data.frame(dx, dy, tip)
        ) +
        ggplot2::coord_fixed(xlim = c(-zoom, zoom), ylim = c(-zoom, zoom)) +
        ggplot2::labs(x = "Across-bag (ft)", y = "Up/down-bag (ft)",
                      title = paste("Throw Location (Top-down) →", if (is.null(input$loc_targetBase)) "2B" else input$loc_targetBase)) +
        ggplot2::theme_minimal() +
        transparent_bg_theme
      
      girafe_transparent(
        code = print(p),
        options = list(
          ggiraph::opts_hover(css = "opacity:0.9;"),
          ggiraph::opts_toolbar(saveaspng = TRUE)
        )
      )
    })
    
    output$loc_td_summary <- renderText({
      req(is_active())
      df <- loc_throws(); if (!nrow(df)) return("No throws with PopTime in current filters.")
      gc <- loc_guess_cols_xy(df); if (!nzchar(gc$x) || !nzchar(gc$y)) return("No base-arrival X/Y columns found.")
      
      mode <- if (is.null(input$loc_units)) "auto" else input$loc_units
      x <- loc_convert_to_feet(loc_to_num(df[[gc$x]]), mode)
      y <- loc_convert_to_feet(loc_to_num(df[[gc$y]]), mode)
      
      if (nzchar(gc$cx) && nzchar(gc$cy)) {
        cx <- loc_convert_to_feet(loc_to_num(df[[gc$cx]]), mode)
        cy <- loc_convert_to_feet(loc_to_num(df[[gc$cy]]), mode)
        dx <- x - cx; dy <- y - cy
      } else {
        dx <- x - stats::median(x, na.rm = TRUE)
        dy <- y - stats::median(y, na.rm = TRUE)
      }
      
      r <- sqrt(dx^2 + dy^2)
      pct_on <- mean(loc_inside_bag(dx, dy, size_in = 18), na.rm = TRUE)
      paste0(
        "# throws: ", length(r), "\n",
        "Avg miss radius: ", sprintf("%.2f", mean(r, na.rm = TRUE)), " ft\n",
        "68% radius: ",     sprintf("%.2f", stats::quantile(r, 0.68, na.rm = TRUE)), " ft\n",
        "% on bag: ",       sprintf("%.1f%%", 100*pct_on), "\n",
        "Bias (dx, dy): ",  sprintf("%.2f, %.2f", mean(dx, na.rm = TRUE), mean(dy, na.rm = TRUE)), " ft"
      )
    })
    
    # ---- 3D view ----
    output$loc_3d <- plotly::renderPlotly({
      req(is_active())
      df <- loc_throws(); if (!nrow(df)) return(NULL)
      
      gc <- loc_guess_cols_xyz(df)
      if (!nzchar(gc$x) || !nzchar(gc$y) || !nzchar(gc$z)) {
        return(plotly::plot_ly() |> plotly::add_text(x=0, y=0, text="No BasePosition X/Y/Z found"))
      }
      
      mode <- if (is.null(input$loc_units)) "auto" else input$loc_units
      x <- loc_convert_to_feet(loc_to_num(df[[gc$x]]), mode)
      y <- loc_convert_to_feet(loc_to_num(df[[gc$y]]), mode)
      z <- loc_convert_to_feet(loc_to_num(df[[gc$z]]), mode)
      
      if (nzchar(gc$cx) && nzchar(gc$cy)) {
        cx <- loc_convert_to_feet(loc_to_num(df[[gc$cx]]), mode)
        cy <- loc_convert_to_feet(loc_to_num(df[[gc$cy]]), mode)
      } else {
        cx <- stats::median(x, na.rm = TRUE)
        cy <- stats::median(y, na.rm = TRUE)
      }
      cz <- if (nzchar(gc$cz)) loc_convert_to_feet(loc_to_num(df[[gc$cz]]), mode) else 0
      
      dx <- x - cx; dy <- y - cy; dz <- z - cz
      r  <- sqrt(dx^2 + dy^2 + dz^2)
      
      # bag outline at z=0
      side_ft <- 18/12; rbag <- side_ft/sqrt(2)
      bag <- data.frame(x = c(0, rbag, 0, -rbag, 0), y = c(rbag, 0, -rbag, 0, rbag), z = 0)
      
      tip <- paste0(
        "dx=", sprintf("%.2f", dx)," ft<br>",
        "dy=", sprintf("%.2f", dy)," ft<br>",
        "dz=", sprintf("%.2f", dz)," ft<br>",
        "3D miss=", sprintf("%.2f", r)," ft<br>",
        "Pop=", ifelse(is.na(df$PopTime), "", df$PopTime), "<br>",
        "Velo=", ifelse(is.na(df$ThrowSpeed), "", df$ThrowSpeed)
      )
      
      zoom <- if (is.null(input$loc_zoom)) 6 else input$loc_zoom
      lim  <- c(-zoom, zoom)
      
      plotly::plot_ly() |>
        plotly::add_trace(type="scatter3d", mode="lines",
                          x=bag$x, y=bag$y, z=bag$z,
                          line = list(width = 6), hoverinfo="skip", name="Bag") |>
        plotly::add_markers(x = dx, y = dy, z = dz, type = "scatter3d", mode = "markers",
                            marker = list(size = 4, opacity = 0.8),
                            text = tip, hoverinfo = "text", name = "Throws") |>
        plotly::layout(
          scene = list(
            xaxis = list(title = "Across-bag (ft)", range = lim),
            yaxis = list(title = "Up/down-bag (ft)", range = lim),
            zaxis = list(title = "Height (ft)"),
            aspectmode = "cube",
            bgcolor = "rgba(0,0,0,0)"
          ),
          title = paste("Throw Location (3D) →", if (is.null(input$loc_targetBase)) "2B" else input$loc_targetBase),
          paper_bgcolor = "rgba(0,0,0,0)",
          plot_bgcolor = "rgba(0,0,0,0)"
        )
    })
    
    
    # ---- HeatMaps: note ----
    output$hmNote <- renderUI({
      HTML("<small><em>Heat shows Called-Strike% by location (per taken-pitch opportunity = called strike or called ball). Use the Pitch Results filter to include/exclude outcomes.</em></small>")
    })
    
    
    # --- NEW helpers for Heat surface (place inside mod_catch_server, above output$heatPlot) ---
    
    .safe_heat_cols <- function(n = 256) {
      if (exists("heat_pal_red")) {
        heat_pal_red(n)
      } else {
        grDevices::colorRampPalette(c("#ffffff", "#ffc0c0", "#ff6666", "#d7301f"))(n)
      }
    }
    
    # Fit a smooth Called-Strike% surface (per taken opportunity) and an alpha map for opportunity density
    .fit_cs_surface <- function(df_taken, lims = c(-2.5, 2.5, 0, 4.5), n = 180) {
      stopifnot(all(c("PlateLocSide","PlateLocHeight","PitchCall") %in% names(df_taken)))
      df_taken <- df_taken[is.finite(df_taken$PlateLocSide) & is.finite(df_taken$PlateLocHeight), , drop = FALSE]
      if (!nrow(df_taken)) return(NULL)
      df_taken$cs <- as.integer(df_taken$PitchCall == "StrikeCalled")
      
      grid <- expand.grid(
        x = seq(lims[1], lims[2], length.out = n),
        y = seq(lims[3], lims[4], length.out = n)
      )
      
      # Primary: smooth logistic surface with mgcv (best) ; Fallback: binned ratio with Beta prior
      p_hat <- NULL
      if (requireNamespace("mgcv", quietly = TRUE) &&
          length(unique(df_taken$cs)) > 1 && nrow(df_taken) >= 60) {
        m <- mgcv::gam(cs ~ s(PlateLocSide, PlateLocHeight, k = 60),
                       data = df_taken, family = stats::binomial(link = "logit"))
        p_hat <- stats::plogis(stats::predict(m, newdata = data.frame(
          PlateLocSide = grid$x, PlateLocHeight = grid$y
        )))
      } else {
        # Fallback: 2D binned CS% with prior shrinkage toward global rate
        nx <- 60; ny <- 60
        xbreaks <- seq(lims[1], lims[2], length.out = nx + 1)
        ybreaks <- seq(lims[3], lims[4], length.out = ny + 1)
        xi <- cut(df_taken$PlateLocSide, xbreaks, include.lowest = TRUE)
        yi <- cut(df_taken$PlateLocHeight, ybreaks, include.lowest = TRUE)
        opp  <- as.matrix(stats::xtabs(~ xi + yi))
        num  <- as.matrix(stats::xtabs(cs ~ xi + yi))
        p0   <- mean(df_taken$cs, na.rm = TRUE)
        alpha <- 20  # prior sample size
        p_bin <- (num + alpha * p0) / (opp + alpha)
        grid <- expand.grid(
          x = head(xbreaks, -1) + diff(xbreaks) / 2,
          y = head(ybreaks, -1) + diff(ybreaks) / 2
        )
        p_hat <- as.vector(p_bin)
      }
      
      # Opportunity alpha: denser regions more opaque (fade sparse)
      if (requireNamespace("MASS", quietly = TRUE)) {
        den <- MASS::kde2d(df_taken$PlateLocSide, df_taken$PlateLocHeight, n = n, lims = lims)$z
        den <- den / max(den, na.rm = TRUE)
        alpha <- pmax(0.25, as.vector(den))  # 0.25..1
      } else {
        alpha <- rep(1, length(p_hat))
      }
      
      data.frame(x = grid$x, y = grid$y, p = p_hat, a = alpha)
    }
    
    # ---- HeatMaps: Heat (Called-Strike% per opportunity) ----
    # ---- HeatMaps: Heat (Called-Strike% per taken opportunity, smooth; alpha = opportunity) ----
    output$heatPlot <- renderPlot({
      df <- filtered_catch(); if (!nrow(df)) return()
      # NEW: filter by selected pitch results (matches pitching suite behavior)
      res_sel <- input$hmResults
      if (!is.null(res_sel) && length(res_sel)) {
        df <- dplyr::filter(df, Result %in% res_sel)
      }
      
      
      # taken-pitch opportunities only (called strike/ball; include BID as "ball" opportunity)
      df_taken <- dplyr::filter(
        df,
        !is.na(PitchCall) & PitchCall %in% c("StrikeCalled","BallCalled","BallinDirt"),
        is.finite(PlateLocSide), is.finite(PlateLocHeight)
      )
      if (!nrow(df_taken) || length(unique(df_taken$PitchCall)) < 2) {
        return(ggplot() + theme_void() + labs(title = "Insufficient taken-pitch data"))
      }
      
      lims <- c(-2, 2, 0, 4.5); n <- 180
      surf <- .fit_cs_surface(df_taken, lims = lims, n = n)
      if (is.null(surf)) return(ggplot() + theme_void())
      
      # Overlays (same geometry you use elsewhere)
      home <- data.frame(x = c(-0.75,0.75,0.75,0.00,-0.75), y = c(1.05,1.05,1.15,1.25,1.15) - 0.5)
      cz   <- data.frame(xmin = -1.5, xmax =  1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz   <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      
      cols <- .safe_heat_cols(256)
      
      ggplot() +
        geom_raster(data = surf, aes(x, y, fill = p, alpha = a), interpolate = TRUE) +
        scale_fill_gradientn(colors = cols, limits = c(0, 1), name = "CS%") +
        scale_alpha(range = c(0.25, 1), guide = "none") +
        geom_polygon(data = home, aes(x, y), fill = NA, color = "black", linewidth = 0.6) +
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = "black", linetype = "dashed", linewidth = 0.6) +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = "black", linewidth = 0.8) +
        coord_fixed(ratio = 1, xlim = c(lims[1], lims[2]), ylim = c(lims[3], lims[4])) +
        labs(title = "Called-Strike%", x = NULL, y = NULL) +
        theme_void() +
        theme(plot.title = element_text(face = "bold", hjust = 0.5))
    }, bg = "transparent")
    
    
    # ---- HeatMaps: Pitch (interactive scatter) ----
    output$pitchPlot <- ggiraph::renderGirafe({
      req(input$hmChartType == "Pitch")
      df <- filtered_catch(); if (!nrow(df)) return(NULL)
      # NEW: filter by selected pitch results
      res_sel <- input$hmResults
      if (!is.null(res_sel) && length(res_sel)) {
        df <- dplyr::filter(df, Result %in% res_sel)
      }
      
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      types_chr <- as.character(types)
      
      df_i <- df %>% dplyr::mutate(tt = make_hover_tt(.), rid = dplyr::row_number(),
                                   Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels))
      
      home <- data.frame(x=c(-0.75,0.75,0.75,0.00,-0.75), y=c(1.05,1.05,1.15,1.25,1.15)-0.5)
      cz   <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz   <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      
      df_known <- dplyr::filter(df_i, !is.na(Result))
      df_other <- dplyr::filter(df_i,  is.na(Result))
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), fill = NA, color = "black") +
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = NA, color = "black", linetype = "dashed") +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = NA, color = "black") +
        ggiraph::geom_point_interactive(
          data = df_other,
          aes(PlateLocSide, PlateLocHeight, color = TaggedPitchType, fill = TaggedPitchType, tooltip = tt, data_id = rid),
          size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
        ) +
        ggiraph::geom_point_interactive(
          data = df_known,
          aes(PlateLocSide, PlateLocHeight, color = TaggedPitchType, fill = TaggedPitchType, shape = Result, tooltip = tt, data_id = rid),
          size = 4.0, alpha = 0.95, stroke = 0.8
        ) +
        scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
        scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
        scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
        coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
        theme_void() + theme(legend.position = "none")
      
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
  })  # <-- closes moduleServer(id, function(...) { ... })
}     # <-- closes mod_catch_server()

# ==========================
# == Leaderboard (new)    ==
# ==========================
mod_camps_ui <- function(id, show_header = FALSE) {
  ns <- NS(id)
  fluidPage(
    # No header (hidden to match other suites)
    sidebarLayout(
      sidebarPanel(
        # Same as Pitching suite, but no Session Type + label changed
        selectInput(ns("player"), "Select Player:", choices = c("All" = "All"), selected = "All"),
        dateRangeInput(ns("dates"), "Date Range:",
                       start = Sys.Date() - 30, end = Sys.Date(),
                       format = "mm/dd/yyyy"),
        selectInput(ns("hand"),       "Pitcher Hand:",  choices = c("All","Left","Right"), selected = "All"),
        selectInput(ns("pitchType"),  "Pitch Type:",    choices = "All", selected = "All", multiple = TRUE),
        selectInput(
          ns("zoneLoc"), "Zone Location:",
          choices = c("All",
                      "Upper Half","Bottom Half","Left Half","Right Half",
                      "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
          selected = "All", multiple = TRUE
        ),
        selectInput(ns("inZone"),     "In Zone:",       choices = c("All","Yes","No","Competitive"), selected = "All"),
        selectInput(ns("batterSide"), "Batter Hand:",   choices = c("All","Left","Right"), selected = "All"),
        selectInput(
          ns("countFilter"), "Count:",
          choices  = c("All"="All","Even"="Even","Behind"="Behind","Ahead"="Ahead","2K Not Full"="2KNF",
                       "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
          selected = "All", multiple = TRUE
        ),
        fluidRow(
          column(6, numericInput(ns("veloMin"), "Velocity Min (MPH):", value = NA)),
          column(6, numericInput(ns("veloMax"), "Velocity Max (MPH):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("ivbMin"), "IVB Min (inches):", value = NA)),
          column(6, numericInput(ns("ivbMax"), "IVB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("hbMin"), "HB Min (inches):", value = NA)),
          column(6, numericInput(ns("hbMax"), "HB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("pcMin"), "Pitch Count Min:", value = NA, min = 1)),
          column(6, numericInput(ns("pcMax"), "Pitch Count Max:", value = NA, min = 1))
        ),
        width = 3,
        class = "sidebar"
      ),
      mainPanel(
        tabsetPanel(
          id = ns("tabs"),
          
          # --- SUMMARY (Summary page layout) ---
          tabPanel(
            "Summary",
            uiOutput(ns("campSummaryHeader")), br(),
            fluidRow(
              column(
                4,
                div("Release",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px; text-align:center;"),
                ggiraph::girafeOutput(ns("campSummaryReleasePlot"), height = "300px", width = "100%")
              ),              
              column(
                4,
                div("Movement",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px; text-align:center;"),
                ggiraph::girafeOutput(ns("campSummaryMovementPlot"), height = "300px", width = "100%")
              ),
              column(
                4,
                div(
                  style = "text-align:center;",
                  div(
                    "Location",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px;"
                  ),
                  div(
                    style = "display:inline-block; width:80%;",
                    selectInput(
                      ns("campSummaryLocType"),
                      label    = NULL,
                      choices  = c("Pitch", "Heat"),
                      selected = "Pitch",
                      width    = "100%"
                    )
                  )
                ),
                conditionalPanel(
                  paste0("input['", ns("campSummaryLocType"), "']=='Pitch'"),
                  ggiraph::girafeOutput(ns("campSummaryZonePlot"), height = "300px", width = "100%")
                ),
                conditionalPanel(
                  paste0("input['", ns("campSummaryLocType"), "']=='Heat'"),
                  plotOutput(ns("campSummaryHeatZonePlot"), height = "300px")
                )
              )
            ),
            fluidRow(column(12, plotOutput(ns("campSummaryLegend"), height = "70px"))),
            br(),
            div(style = "margin: 8px 0;", uiOutput(ns("campSummaryTableButtons"))),
            DT::dataTableOutput(ns("campSummaryTablePage"))
          ),
          
          # --- HITTING (Data & Performance) ---
          tabPanel(
            "Hitting",
            div(style = "margin: 8px 0;", uiOutput(ns("campHitButtons"))),
            div(style = "margin: 8px 0;", ggiraph::girafeOutput(ns("campSprayChart"), height = "460px")),
            DT::dataTableOutput(ns("campHitTable"))
          ),
          
          # --- CATCHING (Data & Performance) ---
          tabPanel(
            "Catching",
            div(style = "margin: 8px 0;", uiOutput(ns("campCatchButtons"))),
            DT::dataTableOutput(ns("campCatchTable"))
          )
        )
      )
    )
  )
}

mod_camps_server <- function(id, is_active = shiny::reactive(TRUE)) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    dp_like_table_fn <- tryCatch(get(".dp_like_table", envir = .GlobalEnv), error = function(...) NULL)
    
    # ---------------------------
    # Load allowed campers configuration
    # ---------------------------
    load_allowed_campers <- function() {
      # Return hardcoded list of allowed campers
      return(ALLOWED_CAMPERS)
    }
    
    # ---------------------------
    # Camps data hooks (Camps-only)
    # ---------------------------
    get_camps_pitching <- function() {
      # Use the unfiltered main dataset (pitch_data) for camps to be independent of ALLOWED_PITCHERS
      if (exists("pitch_data", inherits = TRUE)) return(get("pitch_data", inherits = TRUE))
      if (exists("load_camps_pitching", inherits = TRUE)) return(get("load_camps_pitching", inherits = TRUE)())
      data.frame(Date = as.Date(character()),
                 Pitcher = character(), PitcherThrows = character(),
                 TaggedPitchType = factor(character()),
                 PlateLocSide = numeric(), PlateLocHeight = numeric(),
                 RelSpeed = numeric(), InducedVertBreak = numeric(), HorzBreak = numeric(),
                 ReleaseTilt = numeric(), BreakTilt = numeric(),
                 SpinEfficiency = numeric(), SpinRate = numeric(),
                 RelHeight = numeric(), RelSide = numeric(),
                 VertApprAngle = numeric(), HorzApprAngle = numeric(),
                 Extension = numeric(), Balls = integer(), Strikes = integer(),
                 SessionType = character(), PitchCall = character(),
                 ExitSpeed = numeric(), Angle = numeric(),
                 KorBB = character(), PlayResult = character(),
                 stringsAsFactors = FALSE)
    }
    get_camps_all <- function() {
      # Use the main dataset (pitch_data)
      if (exists("pitch_data", inherits = TRUE)) return(get("pitch_data", inherits = TRUE))
      if (exists("load_camps_all", inherits = TRUE)) return(get("load_camps_all", inherits = TRUE)())
      data.frame(Date = as.Date(character()),
                 Pitcher = character(), Batter = character(), Catcher = character(),
                 PitcherThrows = character(), BatterSide = character(),
                 TaggedPitchType = factor(character()),
                 PlateLocSide = numeric(), PlateLocHeight = numeric(),
                 RelSpeed = numeric(), InducedVertBreak = numeric(), HorzBreak = numeric(),
                 ReleaseTilt = numeric(), BreakTilt = numeric(),
                 SpinEfficiency = numeric(), SpinRate = numeric(),
                 RelHeight = numeric(), RelSide = numeric(),
                 VertApprAngle = numeric(), HorzApprAngle = numeric(),
                 Extension = numeric(), Balls = integer(), Strikes = integer(),
                 SessionType = character(), PitchCall = character(),
                 ExitSpeed = numeric(), Angle = numeric(), Distance = numeric(), Direction = numeric(),
                 KorBB = character(), PlayResult = character(),
                 stringsAsFactors = FALSE)
    }
    
    # ---------------------------
    # Helpers
    # ---------------------------
    as_date_any <- function(x) {
      if (inherits(x, "Date")) return(x)
      if (inherits(x, c("POSIXct","POSIXt"))) return(as.Date(x))
      x_chr <- as.character(x)
      suppressWarnings(
        as.Date(x_chr, tryFormats = c("%Y-%m-%d", "%m/%d/%Y", "%m/%d/%y"))
      )
    }
    nnz <- function(x) !is.null(x) && !is.na(x)
    nz_mean <- function(x) { x <- suppressWarnings(as.numeric(x)); m <- mean(x, na.rm = TRUE); if (is.finite(m)) m else NA_real_ }
    safe_div <- function(a,b) { a <- suppressWarnings(as.numeric(a)); b <- suppressWarnings(as.numeric(b)); ifelse(is.finite(b) & b != 0 & is.finite(a), a/b, NA_real_) }
    fmt_rate3 <- function(x) { x <- suppressWarnings(as.numeric(x)); s <- ifelse(is.finite(x), sprintf("%.3f", x), ""); sub("^0\\.", ".", s) }
    parse_num <- function(x) {
      if (is.numeric(x)) return(x)
      sx <- trimws(as.character(x)); sx[sx==""] <- NA_character_
      is_pct <- grepl("%", sx)
      val <- suppressWarnings(as.numeric(gsub("[^0-9eE.+-]", "", sx)))
      val[is_pct] <- val[is_pct] / 100
      val
    }
    
    # ---------------------------
    # Load & normalize Camps data (filtered by allowed campers)
    # ---------------------------
    camps_pitching <- shiny::reactive({
      d <- get_camps_pitching()
      d$Date <- as_date_any(d$Date)
      
      # TEMPORARY: Disable filtering to test
      # allowed_campers <- load_allowed_campers()
      # if (length(allowed_campers) > 0) {
      #   d <- d[d$Pitcher %in% allowed_campers, ]
      # }
      
      d
    })
    camps_all <- shiny::reactive({
      d <- get_camps_all()
      d$Date <- as_date_any(d$Date)
      
      # TEMPORARY: Disable filtering to test
      # allowed_campers <- load_allowed_campers()
      # if (length(allowed_campers) > 0) {
      #   d <- d[d$Pitcher %in% allowed_campers, ]
      # }
      
      d
    })
    
    # ---------------------------
    # Populate sidebar choices from Camps datasets
    # ---------------------------
    observe({
      req(is_active())
      # Player choices (TEMPORARY: show all players for testing)
      d <- camps_all()
      
      # TEMPORARY: Disable allowed campers filtering
      # allowed_campers <- load_allowed_campers()
      # if (length(allowed_campers) > 0) {
      #   # Use allowed campers list
      #   player_choices <- c("All" = "All", setNames(allowed_campers, allowed_campers))
      # } else {
      # Show all players in data for testing
      all_players <- unique(d$Pitcher)
      all_players <- all_players[!is.na(all_players) & nzchar(all_players)]
      player_choices <- c("All" = "All", setNames(all_players, all_players))
      # }
      
      updateSelectInput(session, "player", choices = player_choices)
      
      # Pitch types (from Camps)
      lv <- levels(d$TaggedPitchType)
      pt_levels <- if (is.null(lv)) unique(as.character(d$TaggedPitchType)) else lv
      updateSelectInput(session, "pitchType",
                        choices = c("All", pt_levels),
                        selected = "All")
    })
    
    observe({
      req(is_active())
      # Date range bounds reflect Camps-only data; robust to POSIX/char
      d1 <- camps_pitching(); d2 <- camps_all()
      all_dates <- c(as_date_any(d1$Date), as_date_any(d2$Date))
      all_dates <- all_dates[is.finite(all_dates)]
      if (!length(all_dates)) return()
      first_date <- min(all_dates, na.rm = TRUE)
      last_date  <- max(all_dates, na.rm = TRUE)
      if (is.finite(first_date) && is.finite(last_date)) {
        updateDateRangeInput(session, "dates", start = first_date, end = last_date)
      }
    })
    
    observe({
      req(is_active())
      # Player list = union of Pitchers, Batters, Catchers (Camps only)
      d1 <- camps_pitching(); d2 <- camps_all()
      players <- sort(unique(c(
        as.character(d1$Pitcher),
        as.character(d2$Pitcher),
        as.character(d2$Batter),
        as.character(d2$Catcher)
      )))
      players <- players[nzchar(players)]
      .pretty_name <- function(x) {
        x <- as.character(x)
        ifelse(grepl(",", x), paste0(trimws(sub(".*,", "", x)), " ", trimws(sub(",.*", "", x))), x)
      }
      named <- stats::setNames(players, .pretty_name(players))
      updateSelectInput(session, "player",
                        choices = c("All" = "All", named),
                        selected = "All")
    })
    
    # ---------------------------
    # Common filtering (Camps-only base)
    # ---------------------------
    filtered_base <- reactive({
      req(is_active(), input$dates, input$hand, input$zoneLoc, input$inZone, input$qpLocations)
      # Use the same base as Leaderboard when available; otherwise fall back to camps_all
      df <- tryCatch(team_base(), error = function(...) camps_all())
      
      # Align with leaderboard filtering: drop warmups and blank pitch types
      if ("TaggedPitchType" %in% names(df)) {
        df <- df %>%
          dplyr::mutate(.tpt = trimws(as.character(TaggedPitchType))) %>%
          dplyr::filter(!is.na(.tpt) & nzchar(.tpt)) %>%
          dplyr::select(-.tpt)
      }
      if ("PitchSession" %in% names(df)) {
        df <- df %>% dplyr::filter(is.na(PitchSession) | PitchSession != "Warmup")
      }
      # Per-user visibility: Coaches see all, Players see only their own data
      is_coach_val <- tryCatch({
        exists("is_coach", inherits = TRUE) && isTRUE(get("is_coach", inherits = TRUE)())
      }, error = function(...) FALSE)
      admin_val <- tryCatch({
        exists("is_admin", inherits = TRUE) && isTRUE(get("is_admin", inherits = TRUE)())
      }, error = function(...) FALSE)
      
      if (!admin_val && !is_coach_val && "Email" %in% names(df)) {
        norm_email_local <- function(x) tolower(trimws(x))
        ue <- tryCatch({
          if (exists("user_email", inherits = TRUE)) get("user_email", inherits = TRUE)() else NA_character_
        }, error = function(...) NA_character_)
        if (!is.na(ue)) df <- dplyr::filter(df, norm_email_local(Email) == norm_email_local(ue))
      }
      
      # Date range (use Date column coerced to Date)
      dcol <- as_date_any(df$Date)
      if (length(input$dates) == 2) {
        df <- df[!is.na(dcol) & dcol >= as.Date(input$dates[1]) & dcol <= as.Date(input$dates[2]), , drop = FALSE]
      }
      # Pitcher hand
      if (input$hand != "All") df <- dplyr::filter(df, PitcherThrows == input$hand)
      
      # Batter hand (Live only)
      if (!is.null(input$batterSide) && input$batterSide != "All") {
        df <- df %>% dplyr::filter(SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide))
      }
      
      # Zone / in-zone / count (your existing helpers)
      df <- enforce_zone(df, input$zoneLoc)
      df <- enforce_inzone(df, input$inZone)
      df <- filter_qp_locations(df, input$qpLocations)
      df <- apply_count_filter(df, input$countFilter)
      
      # Numeric ranges
      if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed >= input$veloMin)
      if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed <= input$veloMax)
      if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
      if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
      if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak >= input$hbMin)
      if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak <= input$hbMax)
      
      # Pitch types
      ptypes <- input$pitchType; if (is.null(ptypes)) ptypes <- "All"
      if (!("All" %in% ptypes)) df <- dplyr::filter(df, TaggedPitchType %in% ptypes)
      
      # Chronological pitch number → pitch count filter
      df <- df %>% dplyr::arrange(as_date_any(Date)) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
      if (nnz(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
      if (nnz(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
      
      # Compute Stuff+ (harmless if not used)
      df2 <- compute_stuff_simple(df, base_type = "Fastball", level = "College") %>% force_pitch_levels()
      df2
    })
    
    # ======================================================
    # CAMPS SUMMARY PAGE (Exact copy of Pitching Summary)
    # ======================================================
    
    # Summary header
    output$campSummaryHeader <- renderUI({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(div("No data available"))
      
      player_name <- if (!is.null(input$player) && input$player != "All") input$player else "All Players"
      total_pitches <- nrow(df)
      
      div(
        style = "text-align: center; font-size: 18px; font-weight: bold;",
        paste0(player_name, " - ", total_pitches, " pitches")
      )
    })
    
    # Summary Release Plot - Match main Pitching Summary exactly
    output$campSummaryReleasePlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots(); if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      line_col <- if (dark_on) "#ffffff" else "black"
      
      # Get ordered types like main Pitching Summary
      types_chr <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      types_chr <- types_chr[types_chr %in% names(all_colors)]
      
      # Create session label
      sess_lbl <- if (length(unique(df$SessionType)) == 1) unique(df$SessionType)[1] else "All Sessions"
      
      # --- background geometry (same as main Pitching Summary)
      rp_w <- 4; rp_h <- 0.83
      xs <- seq(-rp_w, rp_w, length.out = 100)
      ys <- rp_h * (1 - (xs / rp_w)^2)
      mound <- data.frame(x = c(xs, rev(xs)), y = c(ys, rep(0, length(xs))))
      
      # --- averages for hover+dot (same as main Pitching Summary)
      avg <- df %>%
        dplyr::filter(is.finite(RelSide), is.finite(RelHeight)) %>%
        dplyr::group_by(TaggedPitchType) %>%
        dplyr::summarise(
          avg_RelSide    = mean(RelSide,    na.rm = TRUE),
          avg_RelHeight  = mean(RelHeight,  na.rm = TRUE),
          avg_Extension  = mean(Extension,  na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::filter(TaggedPitchType %in% types_chr) %>%
        dplyr::mutate(
          TaggedPitchType = factor(TaggedPitchType, levels = types_chr),
          tt = paste0(
            "Session: ", sess_lbl,
            "<br>Height: ", sprintf("%.1f ft", avg_RelHeight),
            "<br>Side: ", sprintf("%.1f ft", avg_RelSide),
            "<br>Extension: ", sprintf("%.1f ft", avg_Extension)
          )
        )
      
      # --- ensure y axis goes to at least 6 (same as main Pitching Summary)
      y_max <- max(6, suppressWarnings(max(df$RelHeight, na.rm = TRUE) + 0.2))
      
      p <- ggplot() +
        geom_polygon(data = mound, aes(x, y), fill = "tan", color = "tan") +
        annotate("rect", xmin = -0.5, xmax = 0.5, ymin = rp_h - 0.05, ymax = rp_h + 0.05, fill = "white") +
        geom_vline(xintercept = 0, color = line_col, size = 0.7) +
        geom_hline(yintercept = 0, color = line_col, size = 0.7) +
        ggiraph::geom_point_interactive(
          data = avg,
          aes(x = avg_RelSide, y = avg_RelHeight,
              color = TaggedPitchType, tooltip = tt, data_id = TaggedPitchType),
          size = 8, show.legend = FALSE
        ) +
        scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
        scale_y_continuous(limits = c(0, y_max), breaks = seq(0, ceiling(y_max), by = 1)) +
        theme_minimal() + axis_theme + grid_theme(dark_on) +
        labs(x = NULL, y = NULL) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
          axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
          panel.grid = element_blank(),
          axis.ticks = element_blank()
        )
      
      girafe_transparent(
        ggobj = p,
        width_svg = 8, height_svg = 6.5,
        bg = "transparent",
        options = list(
          ggiraph::opts_sizing(rescale = TRUE),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
          ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
    # Summary Movement Plot - Match main Pitching Summary exactly
    output$campSummaryMovementPlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots(); if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      line_col <- if (dark_on) "#ffffff" else "gray"
      
      types_chr <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      types_chr <- types_chr[types_chr %in% names(all_colors)]
      if (!length(types_chr)) return(NULL)
      
      # Averages per type (respect filters)
      avg_mov <- df %>%
        dplyr::group_by(TaggedPitchType) %>%
        dplyr::summarise(
          avg_HorzBreak        = mean(HorzBreak, na.rm = TRUE),
          avg_InducedVertBreak = mean(InducedVertBreak, na.rm = TRUE),
          .groups = "drop"
        )
      
      # interactive payload (per pitch) — uses make_hover_tt()
      df_i <- df %>%
        dplyr::mutate(
          tt  = make_hover_tt(.),
          rid = dplyr::row_number()
        )
      
      # Note: breakLines input doesn't exist in Camps, so skip the baseline reference lines
      
      p <- ggplot() +
        geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
        geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
        ggiraph::geom_point_interactive(
          data = avg_mov %>% dplyr::filter(TaggedPitchType %in% types_chr),
          aes(x = avg_HorzBreak, y = avg_InducedVertBreak, color = TaggedPitchType,
              tooltip = paste0(TaggedPitchType, "<br>IVB: ", round(avg_InducedVertBreak,1), 
                               " in<br>HB: ", round(avg_HorzBreak,1), " in"),
              data_id = TaggedPitchType),
          size = 8, show.legend = FALSE
        ) +
        scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
        theme_minimal() + axis_theme + grid_theme(dark_on) +
        labs(x = NULL, y = NULL) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
          axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
          panel.grid = element_blank(),
          axis.ticks = element_blank()
        )
      
      girafe_transparent(
        ggobj = p,
        width_svg = 8, height_svg = 6.5,
        bg = "transparent",
        options = list(
          ggiraph::opts_sizing(rescale = TRUE),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
          ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
    # Summary Zone Plot (interactive)
    output$campSummaryZonePlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(NULL)
      df <- df %>% dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
      if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      line_col <- if (dark_on) "#ffffff" else "black"
      
      # Create outcome categories like the main Summary page
      df$Result <- compute_result(df$PitchCall, df$PlayResult)
      df$Result <- factor(df$Result, levels = result_levels)
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      p <- ggplot(df, aes(PlateLocSide, PlateLocHeight)) +
        ggiraph::geom_point_interactive(aes(
          color = TaggedPitchType,
          shape = Result,
          tooltip = make_hover_tt(df)
        ), size = 2.8, alpha = 0.9) +
        scale_color_manual(values = all_colors[types], limits = types, name = NULL) +
        scale_shape_manual(values = shape_map, name = NULL) +
        geom_rect(aes(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP),
                  fill = NA, color = line_col, linewidth = 1) +
        geom_rect(aes(xmin = -1.5, xmax = 1.5, ymin = 2.65-1.5, ymax = 2.65+1.5),
                  fill = NA, color = line_col, linetype = "dashed", linewidth = 0.8) +
        coord_fixed(ratio = 1) +
        labs(x = "Plate Side (ft)", y = "Plate Height (ft)") +
        theme_minimal() + axis_theme + grid_theme(dark_on) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(color = axis_col),
          axis.text.y = element_text(color = axis_col),
          axis.title.x = element_text(color = axis_col),
          axis.title.y = element_text(color = axis_col)
        )
      
      girafe_transparent(ggobj = p, options = list(ggiraph::opts_hover_inv(css = "opacity:0.1;")))
    })
    
    # Summary Heat Zone Plot
    output$campSummaryHeatZonePlot <- renderPlot({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(NULL)
      
      # Use advanced KDE frequency heatmap (matching all other suites)
      grid <- make_kde_grid(df$PlateLocSide, df$PlateLocHeight, n = 200)
      if (!nrow(grid)) return(ggplot() + theme_void())
      
      # Normalize KDE values to 0-100 scale
      grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
      
      # Use the draw_heat function for consistency with all other heatmaps
      draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
                show_scale = TRUE, scale_label = "Pitch Frequency",
                scale_limits = c(0, 80))
    }, bg = "transparent")
    
    # Summary Legend
    output$campSummaryLegend <- renderPlot({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(ggplot() + theme_void())
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#ffffff" else "black"
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      if (!length(types)) return(ggplot() + theme_void())
      pal <- colors_for_mode(dark_on)
      
      # Create a simple legend plot
      legend_df <- data.frame(
        x = seq_along(types),
        y = 1,
        type = factor(types, levels = types)
      )
      
      ggplot(legend_df, aes(x, y, color = type)) +
        geom_point(size = 6) +
        scale_color_manual(values = pal[types], name = "Pitch Type") +
        theme_void() +
        theme(
          legend.position = "bottom",
          legend.direction = "horizontal",
          legend.box = "horizontal",
          legend.text = element_text(size = 12, color = axis_col),
          legend.title = element_text(size = 14, face = "bold", color = axis_col),
          legend.margin = margin(t = 0, b = 0)
        ) +
        guides(color = guide_legend(override.aes = list(size = 4), nrow = 1))
    }, bg = "transparent")
    
    # Summary Table Buttons
    output$campSummaryTableButtons <- renderUI({
      sel <- isolate(input$campSummaryMode); if (is.null(sel)) sel <- "Stuff"
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("campSummaryMode"), label = NULL,
                            choices = c("Stuff","Process","Results","Raw Data","Custom"),
                            selected = sel, width = "120px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("campSummaryColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']=='Custom'", ns("campSummaryMode")),
          selectizeInput(ns("campSummaryCustomCols"), label = NULL,
                         choices = setdiff(all_table_cols, "Pitch"),
                         multiple = TRUE,
                         options = list(placeholder = "Choose columns to show…"))
        )
      )
    })
    
    # Summary Table
    output$campSummaryTablePage <- DT::renderDataTable({
      df <- pitch_df_for_plots()
      if (!nrow(df)) {
        return(DT::datatable(
          data.frame(Message = "No data for selected filters"),
          options = list(dom = 't'), rownames = FALSE
        ))
      }
      
      mode   <- if (!is.null(input$campSummaryMode)) input$campSummaryMode else "Stuff"
      custom <- if (!is.null(input$campSummaryCustomCols)) input$campSummaryCustomCols else character(0)
      
      # Use make_summary and then transform to match main Pitching Summary exactly
      summ <- safe_make_summary(df)
      summ <- dplyr::mutate(summ,
                            ReleaseTilt = as.character(ReleaseTilt),
                            BreakTilt   = as.character(BreakTilt)
      )
      
      # Add Process/Results columns (same as main Pitching Summary)
      extras <- compute_process_results(df, mode) %>%
        dplyr::rename(Pitch = PitchType) %>%
        dplyr::mutate(Pitch = as.character(Pitch))
      
      # Build the exact same table structure as main Pitching Summary
      df_table <- summ %>%
        dplyr::mutate(
          Pitch     = PitchType,
          `#`       = PitchCount,
          Velo      = round(Velo_Avg, 1),
          Max       = round(Velo_Max, 1),
          rTilt     = ReleaseTilt,
          bTilt     = BreakTilt,
          SpinEff   = ifelse(is.na(SpinEff), "", paste0(round(SpinEff * 100, 1), "%")),
          Spin      = round(SpinRate, 0),
          Height    = round(RelHeight, 1),
          Side      = round(RelSide, 1),
          Ext       = round(Extension, 1),
          `InZone%` = InZonePercent,
          `Comp%`   = CompPercent,
          `K%`      = KPercent,
          `BB%`     = BBPercent,
          `FPS%`    = FPSPercent,
          `E+A%`    = EAPercent,
          `QP%`     = QPPercent,
          `Strike%` = StrikePercent,
          `Swing%`  = SwingPercent,
          `Whiff%`  = WhiffPercent,
          VAA       = VertApprAngle,
          HAA       = HorzApprAngle
        ) %>%
        dplyr::mutate(Pitch = as.character(Pitch)) %>%
        dplyr::select(
          Pitch, `#`, Usage,
          dplyr::any_of(c("0-0","Behind","Even","Ahead","<2K","2K")),
          BF, `RV/100`,
          Velo, Max, IVB, HB, rTilt, bTilt, SpinEff, Spin, Height, Side, VAA, HAA, Ext,
          `InZone%`, `Comp%`, `Strike%`, `Swing%`, `FPS%`, `E+A%`, `QP%`, `K%`, `BB%`, `Whiff%`, EV, LA,
          `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
        ) %>%
        dplyr::mutate(
          SpinEff = {
            val <- suppressWarnings(as.numeric(SpinEff))
            ifelse(is.na(val), "", paste0(round(val * 100, 1), "%"))
          },
          EV = ifelse(is.na(as.numeric(EV)), "", round(as.numeric(EV), 1)),
          LA = ifelse(is.na(as.numeric(LA)), "", round(as.numeric(LA), 1))
        )
      
      # Add Process/Results columns and join
      df_table <- df_table %>% dplyr::left_join(extras, by = "Pitch")
      df_table <- fill_all_qp_pct(df_table, df)
      
      # Column reordering (same as main Pitching Summary)
      df_table <- enforce_process_order(df_table)
      df_table <- enforce_stuff_order(df_table)
      
      visible_set <- visible_set_for(mode, custom)
      datatable_with_colvis(
        df_table,
        lock            = "Pitch",
        remember        = FALSE,
        default_visible = intersect(visible_set, names(df_table)),
        mode            = mode
      )
    })
    
    # ======================================================
    # ORIGINAL PITCHING PAGE PLOTS (keep for backward compatibility)
    # ======================================================
    
    output$campPitchButtons <- renderUI({
      sel <- isolate(input$campPitchMode); if (is.null(sel)) sel <- "Stuff"
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("campPitchMode"), label = NULL,
                            choices = c("Stuff","Process","Results","Raw Data","Custom"),
                            selected = sel, width = "120px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("campPitchColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']=='Custom'", ns("campPitchMode")),
          selectizeInput(ns("campPitchCustomCols"), label = NULL,
                         choices = setdiff(all_table_cols, "Pitch"),
                         multiple = TRUE,
                         options = list(placeholder = "Choose columns to show…"))
        )
      )
    })
    
    # ----- Plot data (pitching-only rows; optional player filter) -----
    pitch_df_for_plots <- reactive({
      df <- filtered_base()
      
      # TEMPORARY: Disable filtering to test
      # allowed_campers <- load_allowed_campers()
      # if (length(allowed_campers) > 0) {
      #   df <- dplyr::filter(df, Pitcher %in% allowed_campers)
      # }
      
      # Apply individual player selection
      if (!is.null(input$player) && input$player != "All") {
        df <- dplyr::filter(df, Pitcher == input$player)
      }
      df
    })
    
    # Release Plot: RelSide vs RelHeight
    output$campPitchReleasePlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(NULL)
      df <- df %>% dplyr::filter(is.finite(RelSide), is.finite(RelHeight))
      if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      p <- ggplot(df, aes(RelSide, RelHeight, color = TaggedPitchType)) +
        ggiraph::geom_point_interactive(aes(
          tooltip = paste0("Pitch: ", TaggedPitchType,
                           "\nVelo: ", ifelse(is.finite(RelSpeed), round(RelSpeed,1), NA), " mph",
                           "\nSpin: ", ifelse(is.finite(SpinRate), round(SpinRate,0), NA), " rpm")
        ), size = 2.8, alpha = 0.9) +
        scale_color_manual(values = all_colors[types], limits = types, name = NULL) +
        labs(x = "Release Side (ft)", y = "Release Height (ft)") +
        theme_minimal() + grid_theme(dark_on) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(color = axis_col),
          axis.text.y = element_text(color = axis_col),
          axis.title.x = element_text(color = axis_col),
          axis.title.y = element_text(color = axis_col)
        )
      
      girafe_transparent(ggobj = p)
    })
    
    # Movement Plot: HB vs IVB
    output$campPitchMovePlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(NULL)
      df <- df %>% dplyr::filter(is.finite(HorzBreak), is.finite(InducedVertBreak))
      if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      p <- ggplot(df, aes(HorzBreak, InducedVertBreak, color = TaggedPitchType)) +
        ggiraph::geom_point_interactive(aes(
          tooltip = paste0("Pitch: ", TaggedPitchType,
                           "\nHB: ", round(HorzBreak,1), " in",
                           "\nIVB: ", round(InducedVertBreak,1), " in")
        ), size = 2.8, alpha = 0.9) +
        scale_color_manual(values = all_colors[types], limits = types, name = NULL) +
        labs(x = "Horizontal Break (in)", y = "Induced Vertical Break (in)") +
        theme_minimal() + grid_theme(dark_on) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(color = axis_col),
          axis.text.y = element_text(color = axis_col),
          axis.title.x = element_text(color = axis_col),
          axis.title.y = element_text(color = axis_col)
        )
      
      girafe_transparent(ggobj = p)
    })
    
    # Location Plot: PlateLocSide vs PlateLocHeight + zone
    output$campPitchLocPlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(NULL)
      df <- df %>% dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
      if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      line_col <- if (dark_on) "#ffffff" else "black"
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      
      home <- data.frame(x=c(-0.75,0.75,0.75,0.00,-0.75),
                         y=c(1.05,1.05,1.15,1.25,1.15)-0.5)
      cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), fill = NA, color = line_col) +
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col, linetype = "dashed") +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col) +
        ggiraph::geom_point_interactive(
          data = df,
          aes(PlateLocSide, PlateLocHeight, color = TaggedPitchType,
              tooltip = paste0("Pitch: ", TaggedPitchType,
                               "\nCall: ", coalesce(PitchCall, ""),
                               "\nVelo: ", ifelse(is.finite(RelSpeed), round(RelSpeed,1), NA), " mph")),
          size = 3.0, alpha = 0.95, stroke = 0.7
        ) +
        scale_color_manual(values = all_colors[types], limits = types, name = NULL) +
        coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
        theme_void() + theme(legend.position = "none")
      
      girafe_transparent(ggobj = p)
    })
    
    # ----- Pitching table (same options/defs as your Pitching Summary) -----
    output$campPitchTable <- DT::renderDataTable({
      df_all <- filtered_base()
      # Only filter by Pitcher if the selected player exists in the Pitcher column
      if (!is.null(input$player) && input$player != "All") {
        # Check if player exists in Pitcher column before filtering
        if (input$player %in% df_all$Pitcher) {
          df_all <- dplyr::filter(df_all, Pitcher == input$player)
        }
      }
      validate(need(nrow(df_all) > 0, "No pitching data for current filters / player"))
      
      by_type <- split(df_all, df_all$TaggedPitchType)
      
      build_row <- function(df) {
        safe_pct <- function(num, den) {
          num <- suppressWarnings(as.numeric(num)); den <- suppressWarnings(as.numeric(den))
          ifelse(is.finite(den) & den > 0 & is.finite(num), paste0(round(100*num/den, 1), "%"), "")
        }
        scores <- ifelse(
          df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
            df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
          ifelse(
            df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
              df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5),
            0.73, 0
          )
        )
        has_pc  <- sum(!is.na(df$PitchCall)) > 0
        strikes <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
        sw      <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
        den     <- sum(df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
        
        bf_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
        fps_opp <- bf_live
        k_live  <- sum(df$SessionType == "Live" & df$KorBB == "Strikeout",        na.rm = TRUE)
        bb_live <- sum(df$SessionType == "Live" & df$KorBB == "Walk",             na.rm = TRUE)
        fps_live <- sum(df$SessionType == "Live" &
                          df$Balls == 0 & df$Strikes == 0 &
                          df$PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"),
                        na.rm = TRUE)
        ea_live  <- sum(df$SessionType == "Live" & (
          (df$Balls == 0 & df$Strikes == 0 & df$PitchCall == "InPlay") |
            (df$Balls == 0 & df$Strikes == 1 & df$PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
            )) |
            (df$Balls == 1 & df$Strikes == 0 & df$PitchCall == "InPlay") |
            (df$Balls == 1 & df$Strikes == 1 & df$PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
            ))
        ),
        na.rm = TRUE
        )
        
        vmax   <- suppressWarnings(max(as.numeric(df$RelSpeed), na.rm = TRUE)); vmax <- if (is.finite(vmax)) round(vmax, 1) else NA_real_
        ev_all <- nz_mean(ifelse(df$SessionType=="Live", df$ExitSpeed, NA_real_))
        la_all <- nz_mean(ifelse(df$SessionType=="Live", df$Angle,     NA_real_))
        stuff_all <- round(nz_mean(df$`Stuff+`), 1)
        ctrl_all   <- round(nz_mean(scores) * 100, 1)
        qp_vals   <- compute_qp_points(df)
        qp_all    <- round(nz_mean(qp_vals) * 200, 1)
        qp_pct    <- safe_pct(sum((qp_vals * 200) >= 100, na.rm = TRUE), nrow(df))
        
        tibble::tibble(
          `#`            = nrow(df),
          Usage          = NA_character__,  # filled after bind
          Velo           = round(nz_mean(df$RelSpeed), 1),
          Max            = vmax,
          IVB            = round(nz_mean(df$InducedVertBreak), 1),
          HB             = round(nz_mean(df$HorzBreak), 1),
          ReleaseTilt   = convert_to_clock(nz_mean(df$ReleaseTilt)),
          BreakTilt     = convert_to_clock(nz_mean(df$BreakTilt)),
          SpinEff        = { v <- nz_mean(df$SpinEfficiency); if (is.na(v)) "" else paste0(round(v*100,1), "%") },
          Spin           = round(nz_mean(df$SpinRate), 0),
          Height         = round(nz_mean(df$RelHeight), 1),
          Side           = round(nz_mean(df$RelSide), 1),
          VAA            = round(nz_mean(df$VertApprAngle), 1),
          HAA            = round(nz_mean(df$HorzApprAngle), 1),
          Ext            = round(nz_mean(df$Extension), 1),
          `InZone%`      = { inzone <- (df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
                                          df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP);
          safe_pct(sum(inzone, na.rm = TRUE), sum(!is.na(inzone))) },
          `Comp%`        = { comp <- (df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                                        df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5));
          safe_pct(sum(comp, na.rm = TRUE), sum(!is.na(comp))) },
          `Strike%`      = if (has_pc) safe_pct(strikes, nrow(df)) else "",
          `FPS%`         = safe_pct(fps_live, fps_opp),
          `E+A%`         = safe_pct(ea_live,  fps_opp),
          `QP%`          = qp_pct,
          `K%`           = safe_pct(k_live,   bf_live),
          `BB%`          = safe_pct(bb_live,  bf_live),
          `Whiff%`       = safe_pct(sw, den),
          EV = round(ev_all, 1),
          LA = round(la_all, 1),
          `Stuff+`       = stuff_all,
          `Ctrl+`        = ctrl_all,
          `QP+`          = qp_all,
          `Pitching+`    = round((stuff_all + qp_all)/2, 1)
        )
      }
      
      rows <- lapply(names(by_type), function(p) {
        dfi <- by_type[[p]]
        tibble::tibble(Pitch = as.character(p)) %>% dplyr::bind_cols(build_row(dfi))
      })
      
      out_tbl <- dplyr::bind_rows(rows)
      tot <- sum(out_tbl$`#`, na.rm = TRUE)
      out_tbl$Usage <- ifelse(tot > 0, paste0(round(100*out_tbl$`#`/tot, 1), "%"), "")
      
      all_row <- tibble::tibble(Pitch = "All") %>% dplyr::bind_cols(build_row(df_all))
      all_row$Usage <- "100%"
      out_tbl <- dplyr::bind_rows(out_tbl, all_row)
      
      mode   <- input$campPitchMode
      custom <- input$campPitchCustomCols; if (is.null(custom)) custom <- character(0)
      visible_set <- visible_set_for_lb(mode, custom)
      
      datatable_with_colvis(
        out_tbl,
        lock            = "Pitch",
        remember        = FALSE,
        default_visible = intersect(visible_set, names(out_tbl))
      )
    }, server = FALSE)
    
    # ======================================================
    # HITTING page (Data & Performance — spray + table)
    # ======================================================
    output$campHitButtons <- renderUI({
      sel <- isolate(input$campHitMode); if (is.null(sel)) sel <- "Results"
      tagList(
        radioButtons(
          ns("campHitMode"), NULL,
          choices = c("Results", "Custom"),
          selected = sel, inline = TRUE
        ),
        conditionalPanel(
          sprintf("input['%s']==='Custom'", ns("campHitMode")),
          selectizeInput(
            ns("campHitCustomCols"), NULL,
            choices = c(
              "PA","AB","AVG","SLG","OBP","OPS",
              "xWOBA","xISO","BABIP","GB%","Barrel%",
              "Swing%","Whiff%","K%","BB%","EV","LA"
            ),
            selected = c("PA","AB","AVG","SLG","OBP","OPS"),
            multiple = TRUE, options = list(placeholder = "Pick columns…")
          )
        )
      )
    })
    
    filtered_hit_camps <- reactive({
      df <- filtered_base()
      # Only filter by Batter if the selected player exists in the Batter column
      if (!is.null(input$player) && input$player != "All") {
        # Check if player exists in Batter column before filtering
        if (input$player %in% df$Batter) {
          df <- dplyr::filter(df, Batter == input$player)
        }
      }
      df
    })
    
    # Spray chart
    output$campSprayChart <- ggiraph::renderGirafe({
      df <- filtered_hit_camps(); if (!nrow(df)) return(NULL)
      st <- tolower(trimws(as.character(df$SessionType)))
      live_mask <- grepl("live|game|ab", st)
      
      dist_num <- suppressWarnings(as.numeric(df$Distance))
      dir_num  <- suppressWarnings(as.numeric(df$Direction))
      ok <- which(live_mask & df$PitchCall == "InPlay" & is.finite(dist_num) & is.finite(dir_num))
      
      fence_pts <- data.frame(deg = c(-45,-22.5,0,22.5,45), r = c(330,370,400,370,330))
      deg_seq <- seq(-45, 45, length.out = 301)
      r_seq   <- stats::spline(fence_pts$deg, fence_pts$r, xout = deg_seq)$y
      fence   <- data.frame(x = r_seq * sin(deg_seq*pi/180), y = r_seq * cos(deg_seq*pi/180))
      fl_l <- data.frame(x = c(0, 330*sin(-45*pi/180)), y = c(0, 330*cos(-45*pi/180)))
      fl_r <- data.frame(x = c(0, 330*sin( 45*pi/180)), y = c(0, 330*cos( 45*pi/180)))
      th_in <- seq(-45, 45, length.out = 121)
      infield <- data.frame(x = 95 * sin(th_in*pi/180), y = 95 * cos(th_in*pi/180))
      home <- data.frame(x = c(-0.75, 0.75, 0.75, 0, -0.75),
                         y = c( 1.05, 1.05, 1.15, 1.25, 1.15) - 2.0)
      
      if (!length(ok)) {
        p_empty <- ggplot() +
          geom_polygon(data = home, aes(x, y), fill = NA, color = "grey50") +
          geom_path(data = fence, aes(x, y), color = "grey40", linewidth = 0.8) +
          geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                       fill = "#f3f5f7", color = NA, alpha = 0.6) +
          geom_path(data = fl_l, aes(x, y), color = "grey50") +
          geom_path(data = fl_r, aes(x, y), color = "grey50") +
          geom_path(data = infield, aes(x, y), color = "grey70") +
          annotate("text", x = 0, y = 200, label = "No balls in play for current filters", size = 5) +
          coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
          theme_void()
        return(girafe_transparent(ggobj = p_empty))
      }
      
      bbe <- df[ok, , drop = FALSE]
      bbe$Distance  <- dist_num[ok]
      bbe$Direction <- dir_num[ok]
      
      FOUL_DEG_RAW  <- 90
      FOUL_DEG_GEOM <- 110
      angle_scale   <- FOUL_DEG_GEOM / FOUL_DEG_RAW
      
      th     <- bbe$Direction * angle_scale * pi/180
      bbe$x  <- bbe$Distance * sin(th)
      bbe$y  <- bbe$Distance * cos(th)
      
      hit_levels <- c("Single","Double","Triple","HomeRun")
      outcome <- dplyr::case_when(bbe$PlayResult %in% hit_levels ~ bbe$PlayResult, TRUE ~ "Out")
      bbe$Outcome <- factor(outcome, levels = c("Out", hit_levels))
      outcome_cols <- c("Single"="#1fab54","Double"="#1f77b4","Triple"="#7b1fa2","HomeRun"="#d62728","Out"="#222222")
      
      bbe <- bbe %>%
        dplyr::mutate(
          rid     = dplyr::row_number(),
          tt      = paste0(
            "EV: ", ifelse(is.finite(ExitSpeed), sprintf("%.1f", ExitSpeed), "—"), " mph\n",
            "LA: ", ifelse(is.finite(Angle),     sprintf("%.1f", Angle),     "—"), "°\n",
            "Distance: ", ifelse(is.finite(Distance), paste0(sprintf("%.0f", Distance), " ft"), "—"), "\n",
            "Pitch: ", TaggedPitchType, "\n",
            "Result: ", PlayResult
          ),
          tt_fill = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray80")
        )
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), fill = NA, color = "grey50") +
        geom_path(data = fence, aes(x, y), color = "grey40", linewidth = 0.8) +
        geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                     fill = "#f3f5f7", color = NA, alpha = 0.6) +
        geom_path(data = fl_l, aes(x, y), color = "grey50") +
        geom_path(data = fl_r, aes(x, y), color = "grey50") +
        geom_path(data = infield, aes(x, y), color = "grey70") +
        ggiraph::geom_point_interactive(
          data = bbe,
          aes(x, y, color = Outcome, tooltip = tt, data_id = rid),
          size = 2.8, alpha = 0.95
        ) +
        ggiraph::geom_point_interactive(
          data = bbe,
          aes(x, y, tooltip = tt, data_id = rid, fill = I(tt_fill)),
          shape = 21, size = 8, alpha = 0.001, stroke = 0, inherit.aes = FALSE
        ) +
        scale_color_manual(values = outcome_cols, name = "Result") +
        coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
        theme_void() + theme(legend.position = "right")
      
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_sizing(rescale = TRUE),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.35);"),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
    # Hitting table (same DP logic/formatting)
    output$campHitTable <- DT::renderDataTable({
      df <- filtered_hit_camps()
      if (!nrow(df)) return(DT::datatable(data.frame(message = "No rows after filters"), rownames = FALSE))
      df <- df %>% dplyr::filter(!is.na(Batter) & nzchar(Batter))
      if (!nrow(df)) return(DT::datatable(data.frame(message = "No batters for current filters"), rownames = FALSE))
      
      swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
      by_batter <- split(df, df$Batter)
      
      rows <- lapply(by_batter, function(dfi) {
        is_term_i <- (
          (!is.na(dfi$PlayResult) & dfi$PlayResult != "Undefined") |
            (!is.na(dfi$KorBB) & dfi$KorBB %in% c("Strikeout","Walk"))
        )
        term <- dfi[is_term_i, , drop = FALSE]
        PAt <- nrow(term)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
        H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
        H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
        HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        H_all <- H1 + H2 + H3 + HR
        TB_all <- 1*H1 + 2*H2 + 3*H3 + 4*HR
        Kct_all <- sum(term$KorBB == "Strikeout" |
                         term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
        BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        ABt <- PAt - (BBc_all + HBP_all + Sac_all)
        
        swings_all <- sum(!is.na(dfi$PitchCall) & dfi$PitchCall %in% swing_levels, na.rm = TRUE)
        whiffs_all <- sum(dfi$PitchCall == "StrikeSwinging", na.rm = TRUE)
        
        bbe_i <- dfi %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
        EV_i <- nz_mean(bbe_i$ExitSpeed)
        LA_i <- nz_mean(bbe_i$Angle)
        GB_i <- safe_div(sum(bbe_i$TaggedHitType == "GroundBall", na.rm = TRUE),
                         sum(!is.na(bbe_i$TaggedHitType), na.rm = TRUE))
        
        extras_all <- compute_process_results(dfi) %>%
          dplyr::filter(PitchType == "All") %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::summarise(
            xWOBA = nz_mean(xWOBA), xISO = nz_mean(xISO),
            BABIP = nz_mean(BABIP), BarrelFrac = nz_mean(`Barrel%`)
          )
        barrel_frac <- extras_all$BarrelFrac[1]
        if (is.na(barrel_frac)) {
          candidates <- c("Barrel","Barrels","BarrelFlag","IsBarrel","Barreled","Barrelled")
          nm <- candidates[candidates %in% names(bbe_i)]
          barrel_frac <- if (!length(nm)) NA_real_ else safe_div(sum(as.logical(bbe_i[[nm[1]]]), na.rm = TRUE),
                                                                 sum(!is.na(bbe_i[[nm[1]]])))
        }
        
        tibble::tibble(
          Player = as.character(dfi$Batter[1]),
          PA  = PAt,
          AB  = ABt,
          AVG = safe_div(H_all, ABt),
          SLG = safe_div(TB_all, ABt),
          OBP = safe_div(H_all + BBc_all + HBP_all, PAt),
          OPS = NA_real_,
          xWOBA = extras_all$xWOBA[1],
          xISO  = extras_all$xISO[1],
          BABIP = extras_all$BABIP[1],
          `Swing%` = safe_div(swings_all, nrow(dfi)),
          `Whiff%` = safe_div(whiffs_all, swings_all),
          `GB%`    = GB_i,
          `K%`     = safe_div(Kct_all, PAt),
          `BB%`    = safe_div(BBc_all, PAt),
          `Barrel%`= barrel_frac,
          EV = EV_i,
          LA = LA_i
        ) %>% dplyr::mutate(OPS = SLG + OBP)
      })
      
      out <- dplyr::bind_rows(rows)
      num_cols <- c("PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP",
                    "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
      out <- out %>% dplyr::mutate(dplyr::across(dplyr::all_of(num_cols), ~ suppressWarnings(as.numeric(.))))
      out$EV <- ifelse(is.finite(out$EV), round(out$EV, 1), out$EV)
      out$LA <- ifelse(is.finite(out$LA), round(out$LA, 1), out$LA)
      
      pct_cols  <- c("Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%")
      rate_cols <- c("AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP")
      out[pct_cols]  <- lapply(out[pct_cols],  function(z) ifelse(is.finite(z), paste0(round(z*100,1), "%"), ""))
      out[rate_cols] <- lapply(out[rate_cols], fmt_rate3)
      suppressWarnings(out <- out %>% dplyr::arrange(dplyr::desc(as.numeric(OPS))))
      
      mode   <- input$campHitMode; if (is.null(mode)) mode <- "Results"
      custom <- input$campHitCustomCols; if (is.null(custom)) custom <- character(0)
      default_visible <- if (identical(mode, "Custom")) unique(c("Player", custom)) else {
        c("Player","PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP","GB%","Barrel%","Swing%","Whiff%","K%","BB%","EV","LA")
      }
      
      datatable_with_colvis(
        out,
        lock            = "Player",
        remember        = FALSE,
        default_visible = intersect(default_visible, names(out))
      )
    }, server = FALSE)
    
    # ======================================================
    # CATCHING page (Data & Performance)
    # ======================================================
    output$campCatchButtons <- renderUI({
      sel <- isolate(input$campCatchMode); if (is.null(sel)) sel <- "Data"
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("campCatchMode"), label = NULL,
                            choices = c("Data","Custom"), selected = sel, width = "100px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("campCatchColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']==='Custom'", ns("campCatchMode")),
          selectizeInput(
            ns("campCatchCustomCols"), label = NULL,
            choices = c("#","Velo","ExchangeTime","PopTime","SL+"),
            multiple = TRUE,
            options = list(placeholder = "Choose columns…")
          )
        )
      )
    })
    
    output$campCatchTable <- DT::renderDataTable({
      df_all <- filtered_base()
      if (!is.null(input$player) && input$player != "All") {
        df_all <- dplyr::filter(df_all, Catcher == input$player)
      }
      df_all <- df_all %>% dplyr::filter(!is.na(Catcher) & nzchar(Catcher))
      if (!nrow(df_all)) {
        return(DT::datatable(data.frame(Note = "No rows for current filters / player."), options = list(dom = 't'), rownames = FALSE))
      }
      
      to_num <- function(x) suppressWarnings(as.numeric(x))
      takes_all   <- tryCatch({
        pitch_call_safe <- as.character(df_all$PitchCall)
        (!is.na(pitch_call_safe)) & (pitch_call_safe %in% c("StrikeCalled","BallCalled"))
      }, error = function(e) rep(FALSE, nrow(df_all)))
      buckets_all <- inzone_label(df_all$PlateLocSide, df_all$PlateLocHeight)
      
      by_catcher <- split(seq_len(nrow(df_all)), df_all$Catcher)
      
      rows <- lapply(names(by_catcher), function(name) {
        idx <- by_catcher[[name]]
        dfi <- df_all[idx, , drop = FALSE]
        
        takes   <- takes_all[idx]
        buckets <- buckets_all[idx]
        
        base_tbl <- dplyr::tibble(
          take   = takes,
          bucket = buckets,
          is_cs  = dfi$PitchCall == "StrikeCalled"
        ) |>
          dplyr::filter(take) |>
          dplyr::group_by(bucket) |>
          dplyr::summarise(cs_rate = mean(is_cs, na.rm = TRUE), n = dplyr::n(), .groups = "drop")
        
        overall_rate <- if (nrow(base_tbl) && sum(base_tbl$n) > 0) {
          sum(base_tbl$cs_rate * base_tbl$n) / sum(base_tbl$n)
        } else NA_real_
        
        rate_for_bucket <- function(b) {
          r <- base_tbl$cs_rate[match(b, base_tbl$bucket)]
          ifelse(is.na(r), overall_rate, r)
        }
        
        obs_all <- if (any(takes, na.rm = TRUE)) mean(dfi$PitchCall[takes] == "StrikeCalled", na.rm = TRUE) else NA_real_
        tb      <- table(buckets[takes])
        exp_all <- if (length(tb)) sum(as.numeric(tb) * vapply(names(tb), rate_for_bucket, numeric(1))) / sum(tb) else NA_real_
        sl_all  <- if (is.finite(obs_all) && is.finite(exp_all) && exp_all > 0) round(100 * obs_all / exp_all, 1) else NA_real_
        
        dft <- dfi |>
          dplyr::mutate(
            ThrowSpeed_num   = to_num(ThrowSpeed),
            ExchangeTime_num = to_num(ExchangeTime),
            PopTime_num      = to_num(PopTime)
          ) |>
          dplyr::filter(is.finite(PopTime_num))
        
        tibble::tibble(
          Player       = name,
          `#`          = nrow(dft),
          Velo         = if (nrow(dft)) round(mean(dft$ThrowSpeed_num,   na.rm = TRUE), 1) else NA_real_,
          ExchangeTime = if (nrow(dft)) round(mean(dft$ExchangeTime_num, na.rm = TRUE), 1) else NA_real_,
          PopTime      = if (nrow(dft)) round(mean(dft$PopTime_num,      na.rm = TRUE), 2) else NA_real_,
          `SL+`        = sl_all
        )
      })
      
      final <- dplyr::bind_rows(rows)
      
      mode <- input$campCatchMode; if (is.null(mode)) mode <- "Data"
      default_visible <- if (identical(mode, "Custom")) {
        unique(c("Player", input$campCatchCustomCols))
      } else {
        c("Player","#","Velo","ExchangeTime","PopTime","SL+")
      }
      
      datatable_with_colvis(
        final,
        lock            = "Player",
        remember        = TRUE,
        default_visible = intersect(default_visible, names(final)),
        enable_colors   = FALSE
      )
    }, server = FALSE)
  })
}


# ==========================
# == Leaderboard (new)    ==
# ==========================
mod_leader_ui <- function(id, show_header = FALSE) {
  ns <- NS(id)
  fluidPage(
    if (isTRUE(show_header)) {
      fluidRow(
        class = "suite-header",
        column(2, tags$img(src = "PCUlogo.png", height = "100px")),
        column(
          8,
          div(
            style = "height:100%; display:flex; justify-content:center; align-items:flex-start;",
            tags$h1("Leaderboards", style = "margin-top:25px; font-weight:bold;")
          )
        ),
        column(
          2,
          div(style = "text-align:right; margin-top:10px;",
              tags$img(src = school_logo, height = "80px", alt = school_display_name))
        )
      )
    },
    sidebarLayout(
      sidebarPanel(
        selectInput(ns("domain"), "Leaderboard Domain:", choices = c("Pitching","Hitting","Catching"), selected = "Pitching"),
        selectInput(ns("teamType"), "Team:", choices = TEAM_CHOICES, selected = "All"),
        
        # --- Common filters (apply to all domains) ---
        selectInput(ns("sessionType"), "Session Type:", choices = c("All","Bullpen","Live"), selected = "All"),
        dateRangeInput(ns("dates"), "Date Range:",
                       start = max(pitch_data$Date, na.rm = TRUE),
                       end   = max(pitch_data$Date, na.rm = TRUE),
                       format = "mm/dd/yyyy"),
        selectInput(ns("hand"),       "Pitcher Hand:",  choices = c("All","Left","Right"), selected = "All"),
        selectInput(ns("pitchType"),  "Pitch Type:",    choices = c("All", levels(pitch_data$TaggedPitchType)), selected = "All", multiple = TRUE),
        selectInput(
          ns("zoneLoc"), "Zone Location:",
          choices = c("All",
                      "Upper Half","Bottom Half","Left Half","Right Half",
                      "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
          selected = "All", multiple = TRUE
        ),
        selectInput(ns("inZone"),     "In Zone:",       choices = c("All","Yes","No","Competitive"), selected = "All"),
        selectInput(ns("batterSide"), "Batter Hand:",   choices = c("All","Left","Right"), selected = "All"),
        selectInput(ns("qpLocations"), "QP Locations:", choices = c("All", "Yes", "No"), selected = "All"),
        selectInput(
          ns("countFilter"), "Count:",
          choices  = c("All"="All","Even"="Even","Behind"="Behind","Ahead"="Ahead","2K Not Full"="2KNF",
                       "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
          selected = "All", multiple = TRUE
        ),
        fluidRow(
          column(6, numericInput(ns("veloMin"), "Velocity Min (MPH):", value = NA)),
          column(6, numericInput(ns("veloMax"), "Velocity Max (MPH):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("ivbMin"), "IVB Min (inches):", value = NA)),
          column(6, numericInput(ns("ivbMax"), "IVB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("hbMin"), "HB Min (inches):", value = NA)),
          column(6, numericInput(ns("hbMax"), "HB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("pcMin"), "Pitch Count Min:", value = NA, min = 1)),
          column(6, numericInput(ns("pcMax"), "Pitch Count Max:", value = NA, min = 1))
        ),
        width = 3,
        class = "sidebar"
      ),
      mainPanel(
        # --- Pitching (unchanged UI) ---
        conditionalPanel(
          condition = sprintf("input['%s'] === 'Pitching'", ns("domain")),
          tagList(
            div(style = "margin: 8px 0;", uiOutput(ns("lbButtons"))),
            DT::dataTableOutput(ns("lbTable"))
          )
        ),
        
        # --- Hitting (per-player) ---
        conditionalPanel(
          condition = sprintf("input['%s'] === 'Hitting'", ns("domain")),
          tagList(
            div(style="display:flex; align-items:center; gap:12px; margin-bottom:8px;", uiOutput(ns("lbHitButtons"))),
            DT::dataTableOutput(ns("lbHitTable"))
          )
        ),
        
        # --- Catching (per-player) ---
        conditionalPanel(
          condition = sprintf("input['%s'] === 'Catching'", ns("domain")),
          tagList(
            div(style="display:flex; align-items:center; gap:12px; margin-bottom:8px;", uiOutput(ns("lbCatchButtons"))),
            DT::dataTableOutput(ns("lbCatchTable"))
          )
        )
      )
    )
  )
}

mod_leader_server <- function(id, is_active = shiny::reactive(TRUE), global_date_range = NULL) {
  moduleServer(id, function(input, output, session) {
    
    # Sync local date input with global date range
    if (!is.null(global_date_range)) {
      observe({
        if (!is.null(global_date_range()) && length(global_date_range()) == 2) {
          updateDateRangeInput(session, "dates", 
                               start = global_date_range()[1], 
                               end = global_date_range()[2])
        }
      })
      
      # Update global date range when local input changes
      observeEvent(input$dates, {
        if (!is.null(input$dates) && length(input$dates) == 2) {
          global_date_range(input$dates)
        }
      })
    }
    ns <- session$ns
    
    # ---------- constants ----------
    TEAM_CODE <- "GRA_CAN"
    
    # Map team-code synonyms (extend this list as needed)
    TEAM_SYNONYMS <- list(
      GRA_CAN = c("GRA_CAN")
    )
    
    # ---------- small helpers ----------
    nnz <- function(x) !is.null(x) && !is.na(x)
    safe_div <- function(a,b) {
      a <- suppressWarnings(as.numeric(a)); b <- suppressWarnings(as.numeric(b))
      ifelse(is.finite(den <- b) & den != 0 & is.finite(a), a/den, NA_real_)
    }
    # Parse numbers; treat anything with % as percentage -> fraction
    parse_num <- function(x) {
      if (is.numeric(x)) return(x)
      sx <- trimws(as.character(x))
      sx[sx == ""] <- NA_character_
      is_pct <- grepl("%", sx)
      val <- suppressWarnings(as.numeric(gsub("[^0-9eE.+-]", "", sx)))
      val[is_pct] <- val[is_pct] / 100
      val
    }
    nz_mean <- function(x) {
      x <- suppressWarnings(as.numeric(x))
      m <- mean(x, na.rm = TRUE)
      if (is.finite(m)) m else NA_real_
    }
    # 3-dec rate with NO leading zero for 0.xxx
    fmt_rate3 <- function(x) {
      x <- suppressWarnings(as.numeric(x))
      s <- ifelse(is.finite(x), sprintf("%.3f", x), "")
      sub("^0\\.", ".", s)
    }
    # Barrel% fallback finder (common column names)
    barrel_share_from_flags <- function(df) {
      candidates <- c("Barrel","Barrels","BarrelFlag","IsBarrel","Barreled","Barrelled")
      nm <- candidates[candidates %in% names(df)]
      if (!length(nm)) return(NA_real_)
      col <- df[[nm[1]]]
      safe_div(sum(as.logical(col), na.rm = TRUE), sum(!is.na(col)))
    }
    
    # Keep count filter tidy
    observeEvent(input$countFilter, {
      sel <- input$countFilter
      if (is.null(sel) || !length(sel)) {
        updateSelectInput(session, "countFilter", selected = "All")
      } else if ("All" %in% sel && length(sel) > 1) {
        updateSelectInput(session, "countFilter", selected = setdiff(sel, "All"))
      }
    }, ignoreInit = TRUE)
    
    # ---------- TEAM-SCOPED BASE ----------
    # Returns the base dataset for the selected domain & session type,
    # filtered to team-specific rows based on Team selector.
    team_base <- reactive({
      req(is_active(), input$teamType)
      # Use modified_pitch_data() to match Pitching suite (includes pitch type/pitcher modifications)
      modified_data <- tryCatch(modified_pitch_data(), error = function(e) pitch_data_pitching)
      if (is.null(modified_data)) modified_data <- pitch_data_pitching
      
      base <- switch(
        input$domain,
        "Pitching" = if (input$sessionType == "All") modified_data else dplyr::filter(modified_data, SessionType == input$sessionType),
        "Hitting"  = if (input$sessionType == "All") pitch_data else dplyr::filter(pitch_data, SessionType == input$sessionType),
        "Catching" = if (input$sessionType == "All") pitch_data else dplyr::filter(pitch_data, SessionType == input$sessionType)
      )
      
      # Filter by team selection
      if (input$teamType == "Campers") {
        if (identical(input$domain, "Hitting")) {
          dplyr::filter(base, Batter %in% ALLOWED_CAMPERS)
        } else {
          dplyr::filter(base, Pitcher %in% ALLOWED_CAMPERS)
        }
      } else if (input$teamType == TEAM_CODE) {
        if (identical(input$domain, "Hitting")) {
          dplyr::filter(base, Batter %in% ALLOWED_HITTERS)
        } else {
          dplyr::filter(base, Pitcher %in% ALLOWED_PITCHERS)
        }
      } else {
        base
      }
    })
    
    
    # Default the date range to the most recent date with data for the chosen domain/sessionType
    observe({
      req(is_active())
      base <- team_base()
      last_date <- suppressWarnings(max(base$Date, na.rm = TRUE))
      if (is.finite(last_date)) {
        updateDateRangeInput(session, "dates", start = last_date, end = last_date)
      }
    })
    
    # Domain-aware filtered data BEFORE pitch-type filtering (used for usage denominators)
    filtered_lb_before_pitch_type <- reactive({
      req(is_active(), input$dates, input$hand, input$zoneLoc, input$inZone, input$qpLocations)
      
      df <- team_base()
      
      # ⛔️ Drop warmups & blank pitch types (match Pitching suite filtering)
      if ("TaggedPitchType" %in% names(df)) {
        df <- df %>%
          dplyr::mutate(.tpt = trimws(as.character(TaggedPitchType))) %>%
          dplyr::filter(!is.na(.tpt) & nzchar(.tpt)) %>%
          dplyr::select(-.tpt)
      }
      if ("PitchSession" %in% names(df)) {
        df <- dplyr::filter(df, is.na(PitchSession) | PitchSession != "Warmup")
      }
      
      # Date range
      df <- dplyr::filter(df, Date >= input$dates[1], Date <= input$dates[2])
      
      # Pitcher hand
      if (input$hand != "All") df <- dplyr::filter(df, PitcherThrows == input$hand)
      
      # Batter hand (Live only)
      if (!is.null(input$batterSide) && input$batterSide != "All") {
        df <- df %>% dplyr::filter(
          SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide)
        )
      }
      
      # Zone / in-zone / count filters
      df <- enforce_zone(df, input$zoneLoc)
      df <- enforce_inzone(df, input$inZone)
      df <- filter_qp_locations(df, input$qpLocations)
      df <- apply_count_filter(df, input$countFilter)
      
      # Numeric ranges
      if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed >= input$veloMin)
      if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed <= input$veloMax)
      if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
      if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
      if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak >= input$hbMin)
      if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak <= input$hbMax)
      
      # Chronological pitch number bounds
      df <- df %>% dplyr::arrange(Date) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
      if (nnz(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
      if (nnz(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
      
      # Per-user visibility: Coaches see all, Players see only their own data
      is_coach_val <- tryCatch({
        exists("is_coach", inherits = TRUE) && isTRUE(get("is_coach", inherits = TRUE)())
      }, error = function(...) FALSE)
      admin_val <- tryCatch({
        exists("is_admin", inherits = TRUE) && isTRUE(get("is_admin", inherits = TRUE)())
      }, error = function(...) FALSE)
      
      if (!admin_val && !is_coach_val && "Email" %in% names(df)) {
        norm_email_local <- function(x) tolower(trimws(x))
        ue <- tryCatch({
          if (exists("user_email", inherits = TRUE)) get("user_email", inherits = TRUE)() else NA_character_
        }, error = function(...) NA_character_)
        if (!is.na(ue)) df <- dplyr::filter(df, norm_email_local(Email) == norm_email_local(ue))
      }
      
      compute_stuff_simple(df, base_type = "Fastball", level = "College") %>%
        force_pitch_levels()
    })
    
    # Domain-aware filtered data (LSU-only)
    filtered_lb <- reactive({
      df <- filtered_lb_before_pitch_type()
      
      # Pitch types
      ptypes <- input$pitchType
      if (is.null(ptypes)) ptypes <- "All"
      if (!("All" %in% ptypes)) df <- dplyr::filter(df, TaggedPitchType %in% ptypes)
      
      df
    })
    
    # =========================
    # Pitching (unchanged)
    # =========================
    output$lbButtons <- renderUI({
      sel <- isolate(input$lbMode); if (is.null(sel)) sel <- "Stuff"
      ct_names <- names(custom_tables())
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("lbMode"), label = NULL,
                            choices = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data", ct_names, "Custom"),
                            selected = sel, width = "120px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("lbColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']=='Custom'", ns("lbMode")),
          selectizeInput(ns("lbCustomCols"), label = NULL,
                         choices = setdiff(all_table_cols, "Pitch"),
                         multiple = TRUE,
                         options = list(placeholder = "Choose columns to show…"))
        )
      )
    })
    
    # Build leaderboard table by player for the selected domain (Pitching path you already had)
    output$lbTable <- DT::renderDataTable({
      df <- filtered_lb()
      validate(need(nrow(df) > 0, "No data for selected filters"))
      
      player_col <- switch(input$domain,
                           "Pitching" = "Pitcher",
                           "Hitting"  = "Batter",
                           "Catching" = "Catcher")
      if (!player_col %in% names(df)) {
        return(DT::datatable(data.frame(Message = "Player column not found"), options = list(dom = 't')))
      }
      
      df <- df %>% dplyr::filter(!is.na(.data[[player_col]]) & nzchar(.data[[player_col]]))
      by_player <- split(df, df[[player_col]])
      
      res_mode <- resolve_table_mode_global(input$lbMode, input$lbCustomCols)
      mode <- res_mode$mode
      custom <- res_mode$cols
      # Check for Raw Data mode first
      if (identical(mode, "Raw Data")) {
        # Helper function for innings pitched calculation
        ip_calculation <- function(pitches_data) {
          outs <- sum(pitches_data$KorBB == "Strikeout", na.rm = TRUE) + 
            sum(pitches_data$PlayResult %in% c("Out", "FieldersChoice", "Error"), na.rm = TRUE)
          innings <- outs / 3
          whole_innings <- floor(innings)
          remaining_outs <- outs %% 3
          if (remaining_outs == 0) {
            return(paste0(whole_innings, ".0"))
          } else {
            return(paste0(whole_innings, ".", remaining_outs))
          }
        }
        
        rows <- lapply(by_player, function(dfi) {
          all_ip <- ip_calculation(dfi)
          all_p <- nrow(dfi)
          # Completed BF calculation (shared)
          all_bf <- calculate_bf(dfi)
          all_h <- sum(dfi$PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
          all_xbh <- sum(dfi$PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE)
          all_barrels <- sum(dfi$ExitSpeed >= 95 & dfi$Angle >= 10 & dfi$Angle <= 35, na.rm = TRUE)
          all_bb <- sum(dfi$KorBB == "Walk", na.rm = TRUE)
          all_hbp <- sum(dfi$PlayResult == "HitByPitch", na.rm = TRUE)
          all_k <- sum(dfi$KorBB == "Strikeout", na.rm = TRUE)
          all_whiffs <- sum(dfi$PitchCall == "StrikeSwinging", na.rm = TRUE)
          
          # Calculate P/IP and P/BF for the player
          # Convert IP from "X.Y" format to decimal (X + Y/3)
          ip_decimal <- if (all_ip != "0.0") {
            parts <- strsplit(all_ip, "\\.")[[1]]
            as.numeric(parts[1]) + as.numeric(parts[2])/3
          } else 0
          
          p_per_ip <- if (ip_decimal > 0) as.character(round(all_p / ip_decimal, 1)) else ""
          p_per_bf <- if (all_bf > 0) as.character(round(all_p / all_bf, 1)) else ""
          
          tibble::tibble(
            Player = as.character(dfi[[player_col]][1]),
            IP = all_ip,
            P = all_p,
            BF = all_bf,
            `P/IP` = p_per_ip,
            `P/BF` = p_per_bf,
            H = all_h,
            XBH = all_xbh,
            Barrels = all_barrels,
            BB = all_bb,
            HBP = all_hbp,
            K = all_k,
            Whiffs = all_whiffs
          )
        })
        
        out_tbl <- dplyr::bind_rows(rows)
        visible_set <- c("Player", "IP", "P", "BF", "P/IP", "P/BF", "H", "XBH", "Barrels", "BB", "HBP", "K", "Whiffs")
        
        tryCatch({
          # Only enable colors for Pitching domain, disable for Hitting and Catching
          use_colors <- isTRUE(input$lbColors) && input$domain == "Pitching"
          datatable_with_colvis(
            out_tbl,
            lock            = "Player",
            remember        = FALSE,
            default_visible = visible_set,
            mode            = "Raw Data",
            enable_colors   = use_colors
          )
        }, error = function(e) {
          message("lbTable Raw Data error: ", conditionMessage(e))
          DT::datatable(
            data.frame(Message = "Error creating table"),
            options = list(dom = 't'), rownames = FALSE
          )
        })
      } else {
        # Normal mode processing
        
        build_all_row <- function(df) {
          scalar_chr <- function(x) {
            if (length(x) < 1) return("")
            as.character(x[[1]])
          }
          scalar_num <- function(x) {
            x <- suppressWarnings(as.numeric(x))
            if (length(x) < 1) return(NA_real_)
            v <- x[[1]]
            if (is.finite(v)) v else NA_real_
          }
          safe_pct <- function(num, den) {
            num <- suppressWarnings(as.numeric(num)); den <- suppressWarnings(as.numeric(den))
            out <- ifelse(is.finite(den) & den > 0 & is.finite(num), paste0(round(100*num/den, 1), "%"), "")
            scalar_chr(out)
          }
          nz_mean_local <- function(x) {
            x <- suppressWarnings(as.numeric(x))
            m <- mean(x, na.rm = TRUE)
            if (is.finite(m)) m else NA_real_
          }
          
          scores <- ifelse(
            df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
              df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
            ifelse(
              df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5),
              0.73, 0
            )
          )
          has_pc  <- sum(!is.na(df$PitchCall)) > 0
          strikes <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
          sw      <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
          den     <- sum(df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
          csw_all  <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE)
          
          df_live <- dplyr::filter(df, SessionType == "Live")
          bf_live <- calculate_bf(df_live)
          fps_opp <- sum(df_live$Balls == 0 & df_live$Strikes == 0, na.rm = TRUE)
          # Use completed BF (shared calculation)
          bf_use <- calculate_bf(df)
          
          # For Live-specific metrics, always filter to Live regardless of sessionType
          k_live  <- sum(df_live$KorBB == "Strikeout", na.rm = TRUE)
          bb_live <- sum(df_live$KorBB == "Walk",      na.rm = TRUE)
          fps_live <- sum(df_live$Balls == 0 & df_live$Strikes == 0 &
                            df_live$PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"),
                          na.rm = TRUE)
          ea_live  <- sum(
            (df_live$Balls == 0 & df_live$Strikes == 0 & df_live$PitchCall == "InPlay") |
              (df_live$Balls == 0 & df_live$Strikes == 1 & df_live$PitchCall %in% c(
                "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
              )) |
              (df_live$Balls == 1 & df_live$Strikes == 0 & df_live$PitchCall == "InPlay") |
              (df_live$Balls == 1 & df_live$Strikes == 1 & df_live$PitchCall %in% c(
                "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
              )),
            na.rm = TRUE
          )
          
          vmax   <- suppressWarnings(max(as.numeric(df$RelSpeed), na.rm = TRUE)); vmax <- if (is.finite(vmax)) round(vmax, 1) else NA_real_
          ev_all <- nz_mean_local(ifelse(df$SessionType=="Live", df$ExitSpeed, NA_real_))
          la_all <- nz_mean_local(ifelse(df$SessionType=="Live", df$Angle,     NA_real_))
          stuff_all <- round(nz_mean_local(df$`Stuff+`), 1)
          ctrl_all   <- round(nz_mean_local(scores) * 100, 1)
          qp_vals   <- compute_qp_points(df)
          qp_all    <- round(nz_mean_local(qp_vals) * 200, 1)
          qp_pct    <- safe_pct(sum((qp_vals * 200) >= 100, na.rm = TRUE), nrow(df))
          
          tibble::tibble(
            `#`            = nrow(df),
            Usage          = "100%",
            BF             = scalar_num(bf_use),
            Velo           = scalar_num(round(nz_mean_local(df$RelSpeed), 1)),
            Max            = scalar_num(vmax),
            IVB            = scalar_num(round(nz_mean_local(df$InducedVertBreak), 1)),
            HB             = scalar_num(round(nz_mean_local(df$HorzBreak), 1)),
            rTilt          = scalar_chr(convert_to_clock(nz_mean_local(df$ReleaseTilt))),
            bTilt          = scalar_chr(convert_to_clock(nz_mean_local(df$BreakTilt))),
            SpinEff        = { v <- nz_mean_local(df$SpinEfficiency); scalar_chr(if (is.na(v)) "" else paste0(round(v*100,1), "%")) },
            Spin           = scalar_num(round(nz_mean_local(df$SpinRate), 0)),
            Height         = scalar_num(round(nz_mean_local(df$RelHeight), 1)),
            Side           = scalar_num(round(nz_mean_local(df$RelSide), 1)),
            VAA            = scalar_num(round(nz_mean_local(df$VertApprAngle), 1)),
            HAA            = scalar_num(round(nz_mean_local(df$HorzApprAngle), 1)),
            Ext            = scalar_num(round(nz_mean_local(df$Extension), 1)),
            `InZone%`      = { inzone <- (df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
                                            df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP);
            safe_pct(sum(inzone, na.rm = TRUE), sum(!is.na(inzone))) },
            `Comp%`        = { comp <- (df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                                          df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5));
            safe_pct(sum(comp, na.rm = TRUE), sum(!is.na(comp))) },
            `Strike%`      = if (has_pc) safe_pct(strikes, nrow(df)) else "",
            `FPS%`         = safe_pct(fps_live, fps_opp),
            `E+A%`         = safe_pct(ea_live,  fps_opp),
            `QP%`          = qp_pct,
            `K%`           = safe_pct(k_live,   bf_live),
            `BB%`          = safe_pct(bb_live,  bf_live),
            `Whiff%`       = safe_pct(sw, den),
            `CSW%`         = if (has_pc) safe_pct(csw_all, nrow(df)) else "",
            EV             = scalar_num(round(ev_all, 1)),
            LA             = scalar_num(round(la_all, 1)),
            `Stuff+`       = scalar_num(stuff_all),
            `Ctrl+`        = scalar_num(ctrl_all),
            `QP+`          = scalar_num(qp_all),
            `Pitching+`    = scalar_num(round((stuff_all + qp_all)/2, 1))
          )
        }
        
        original_data <- if (identical(mode, "Usage")) filtered_lb_before_pitch_type() else NULL
        
        rows <- lapply(by_player, function(dfi) {
          # Flatten any list-cols that break downstream summaries
          dfi <- dfi %>% dplyr::mutate(dplyr::across(where(is.list), ~unlist(.x)))
          base_row <- build_all_row(dfi)
          coerce_extras_types <- function(df_ex) {
            if (!"IP" %in% names(df_ex)) df_ex$IP <- NA_character_
            df_ex$IP <- as.character(df_ex$IP)
            pct_cols <- intersect(c("GB%","Barrel%"), names(df_ex))
            if (length(pct_cols)) {
              df_ex[pct_cols] <- lapply(df_ex[pct_cols], function(z) {
                z_chr <- as.character(z)
                z_chr[z_chr == ""] <- NA_character_
                z_chr
              })
            }
            num_cols <- intersect(c("BABIP","AVG","SLG","xWOBA","xISO","FIP","WHIP","RV/100"), names(df_ex))
            for (nm in num_cols) df_ex[[nm]] <- suppressWarnings(as.numeric(df_ex[[nm]]))
            df_ex
          }
          extras_all <- compute_process_results(dfi) %>%
            dplyr::filter(PitchType == "All") %>%
            dplyr::select(IP, BABIP, `GB%`, `Barrel%`, AVG, SLG, xWOBA, xISO, FIP, WHIP, `RV/100`) %>%
            coerce_extras_types()
          if (!nrow(extras_all)) {
            extras_all <- tibble::tibble(
              IP = NA_character_, BABIP = NA_real_, `GB%` = NA_real_, `Barrel%` = NA_real_,
              AVG = NA_real_, SLG = NA_real_, xWOBA = NA_real_, xISO = NA_real_,
              FIP = NA_real_, WHIP = NA_real_, `RV/100` = NA_real_
            )
          }
          # normalize GB%/Barrel% to character to avoid type clashes across players
          for (nm in c("GB%","Barrel%")) {
            if (nm %in% names(extras_all)) {
              extras_all[[nm]] <- as.character(extras_all[[nm]])
            }
          }
          out_row <- dplyr::bind_cols(
            tibble::tibble(Player = as.character(dfi[[player_col]][1])),
            base_row,
            extras_all
          )
          if (identical(mode, "Usage")) {
            player_val <- as.character(dfi[[player_col]][1])
            original_player <- if (!is.null(original_data)) {
              original_data[original_data[[player_col]] == player_val, , drop = FALSE]
            } else NULL
            usage_cols <- compute_usage_by_count(dfi, original_player) %>%
              dplyr::filter(tolower(PitchType) == "all") %>%
              dplyr::select(`0-0`,`Behind`,`Even`,`Ahead`,`<2K`,`2K`)
            if (!nrow(usage_cols)) {
              usage_cols <- tibble::tibble(`0-0` = "", Behind = "", Even = "", Ahead = "", `<2K` = "", `2K` = "")
            }
            out_row <- dplyr::bind_cols(out_row, usage_cols)
          }
          out_row
        })
        
        out_tbl <- dplyr::bind_rows(rows) %>% dplyr::relocate(Player)
        if ("IP" %in% names(out_tbl)) {
          out_tbl$IP <- as.character(out_tbl$IP)
        }
        # Reorder columns for custom
        if (identical(mode, "Custom")) {
          order_cols <- unique(c("Player", custom))
          extras <- setdiff(names(out_tbl), order_cols)
          out_tbl <- out_tbl[, c(order_cols, extras), drop = FALSE]
        }
        
        if (identical(mode, "Process")) {
          out_tbl <- tryCatch(
            enforce_process_order(out_tbl),
            error = function(e) {
              message("leaderboard enforce_process_order error: ", conditionMessage(e))
              out_tbl
            }
          )
          out_tbl <- tryCatch(
            fill_all_qp_pct(out_tbl, df),
            error = function(e) {
              message("leaderboard fill_all_qp_pct error: ", conditionMessage(e))
              out_tbl
            }
          )
        }
        if (identical(mode, "Stuff")) {
          out_tbl <- tryCatch(
            enforce_stuff_order(out_tbl),
            error = function(e) {
              message("leaderboard enforce_stuff_order error: ", conditionMessage(e))
              out_tbl
            }
          )
        }
        
        visible_set <- visible_set_for_lb(mode, custom)
        
        if ("Pitching+" %in% names(out_tbl)) {
          suppressWarnings(out_tbl <- out_tbl %>% dplyr::arrange(dplyr::desc(as.numeric(`Pitching+`))))
        }
        
        # Add error handling wrapper for leaderboard table
        build_lb_dt <- function(data, ...) {
          tryCatch(
            datatable_with_colvis(data, ...),
            error = function(e) {
              message("lbTable datatable error [mode=", mode, "]: ", conditionMessage(e))
              message("Columns: ", paste(names(data), collapse = ", "))
              # Return a fallback datatable with error message
              DT::datatable(
                data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
                options = list(dom = 't'), rownames = FALSE
              )
            }
          )
        }
        
        build_lb_dt(
          out_tbl,
          lock            = "Player",
          remember        = FALSE,
          default_visible = intersect(visible_set, names(out_tbl)),
          mode            = mode
        )
      } # End of else block for normal modes
    }, server = FALSE)
    
    # ==========================
    # Leaderboard: Hitting (PLAYER)
    # ==========================
    output$lbHitButtons <- renderUI({
      req(input$domain == "Hitting")
      ct_names <- names(custom_tables())
      tagList(
        div(style = "display:flex; align-items:center; gap:12px;",
            selectInput(
              ns("lbHitMode"), label = NULL,
              choices = c("Results", "Swing Decisions", ct_names, "Custom"),
              selected = "Results", width = "170px"
            )
        ),
        conditionalPanel(
          sprintf("input['%s']==='Custom'", ns("lbHitMode")),
          selectizeInput(
            ns("lbHitCustomCols"), NULL,
            choices = c(
              "PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
              "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA",
              "FPS%","Called%","Chase%","GoZoneSw%","IZswing%","EdgeSwing%","PosSD%"
            ),
            selected = c("PA","AB","AVG","SLG","OBP","OPS"),
            multiple = TRUE, options = list(placeholder = "Pick columns…")
          )
        )
      )
    })
    
    output$lbHitTable <- DT::renderDataTable({
      req(input$domain == "Hitting")
      
      df <- filtered_lb()
      if (!nrow(df)) {
        return(DT::datatable(data.frame(message = "No rows after filters"), rownames = FALSE))
      }
      
      # keep only rows with a Batter name
      df <- df %>% dplyr::filter(!is.na(Batter) & nzchar(Batter))
      if (!nrow(df)) {
        return(DT::datatable(data.frame(message = "No batters for current filters"), rownames = FALSE))
      }
      
      swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
      by_batter <- split(df, df$Batter)
      
      results_rows <- lapply(by_batter, function(dfi) {
        # Terminal rows = completed PA for THIS batter
        is_term_i <- (
          (!is.na(dfi$PlayResult) & dfi$PlayResult != "Undefined") |
            (!is.na(dfi$KorBB) & dfi$KorBB %in% c("Strikeout","Walk"))
        )
        term <- dfi[is_term_i, , drop = FALSE]
        
        # Tallies
        PAt     <- nrow(term)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        SF_all  <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        IBB_all <- sum(term$PlayResult == "IntentionalWalk", na.rm = TRUE)
        H1      <- sum(term$PlayResult == "Single",  na.rm = TRUE)
        H2      <- sum(term$PlayResult == "Double",  na.rm = TRUE)
        H3      <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
        HR      <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        H_all   <- H1 + H2 + H3 + HR
        TB_all  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
        Kct_all <- sum(term$KorBB == "Strikeout" |
                         term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
        BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        ABt     <- PAt - (BBc_all + HBP_all + Sac_all)
        ISO_all <- safe_div(TB_all, ABt) - safe_div(H_all, ABt)
        uBB_all <- BBc_all - IBB_all
        wOBA_all <- {
          num <- 0.690*uBB_all + 0.722*HBP_all + 0.888*H1 + 1.271*H2 + 1.616*H3 + 2.101*HR
          den <- ABt + BBc_all - IBB_all + SF_all + HBP_all
          safe_div(num, den)
        }
        
        swings_all <- sum(!is.na(dfi$PitchCall) & dfi$PitchCall %in% swing_levels, na.rm = TRUE)
        whiffs_all <- sum(dfi$PitchCall == "StrikeSwinging", na.rm = TRUE)
        
        bbe_i <- dfi %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)),
                                       PitchCall == "InPlay")
        EV_i <- nz_mean(bbe_i$ExitSpeed)
        LA_i <- nz_mean(bbe_i$Angle)
        GB_i <- safe_div(sum(bbe_i$TaggedHitType == "GroundBall", na.rm = TRUE),
                         sum(!is.na(bbe_i$TaggedHitType), na.rm = TRUE))
        
        # extras from processor for this batter (prefer "All" row)
        extras_all <- compute_process_results(dfi) %>%
          dplyr::filter(PitchType == "All") %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::summarise(
            xWOBA = nz_mean(xWOBA), xISO = nz_mean(xISO),
            BABIP = nz_mean(BABIP), BarrelFrac = nz_mean(`Barrel%`)
          )
        
        # Barrel% value: from processor OR fallback to flags on batted balls
        barrel_frac <- extras_all$BarrelFrac[1]
        if (is.na(barrel_frac)) {
          barrel_frac <- barrel_share_from_flags(bbe_i)
        }
        
        tibble::tibble(
          Player = as.character(dfi$Batter[1]),
          PA  = PAt,
          AB  = ABt,
          AVG = safe_div(H_all, ABt),
          SLG = safe_div(TB_all, ABt),
          OBP = safe_div(H_all + BBc_all + HBP_all, PAt),
          OPS = NA_real_,
          wOBA = wOBA_all,
          xWOBA = extras_all$xWOBA[1],
          ISO   = ISO_all,
          xISO  = extras_all$xISO[1],
          BABIP = extras_all$BABIP[1],
          `Swing%` = safe_div(swings_all, nrow(dfi)),
          `Whiff%` = safe_div(whiffs_all, swings_all),
          `GB%`    = GB_i,
          `K%`     = safe_div(Kct_all, PAt),
          `BB%`    = safe_div(BBc_all, PAt),
          `Barrel%`= barrel_frac,
          EV = EV_i,
          LA = LA_i
        ) %>% dplyr::mutate(OPS = SLG + OBP)
      })
      
      # Swing Decisions rows per batter
      sd_rows <- lapply(by_batter, function(dfi) {
        inner_half <- 7 / 12
        mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
        mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
        green_xmin <- mid_x - inner_half
        green_xmax <- mid_x + inner_half
        green_ymin <- mid_y - inner_half
        green_ymax <- mid_y + inner_half
        
        df_sd <- dfi %>%
          dplyr::mutate(
            is_swing = !is.na(PitchCall) & PitchCall %in% c("StrikeSwinging","FoulBall","FoulBallFieldable","FoulBallNotFieldable","InPlay"),
            in_green = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
              PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
              PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
            in_zone = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
              PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
              PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
            possd_point = dplyr::case_when(
              in_green & is_swing ~ 2,
              in_green & !is_swing ~ -1,
              in_zone & !in_green & is_swing ~ 1,
              in_zone & !in_green & !is_swing ~ 0,
              !in_zone & is_swing ~ -1,
              !in_zone & !is_swing ~ 1,
              TRUE ~ 0
            )
          )
        
        summarize_sd <- function(dat) {
          total_pitches <- nrow(dat)
          swings <- sum(dat$is_swing, na.rm = TRUE)
          fps_num <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0 &
                           !is.na(dat$PitchCall) & dat$PitchCall %in% c("StrikeSwinging","InPlay","FoulBall","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
          fps_den <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0, na.rm = TRUE)
          called <- sum(!is.na(dat$PitchCall) & dat$PitchCall == "StrikeCalled", na.rm = TRUE)
          chase_num <- sum(dat$is_swing & !dat$in_zone, na.rm = TRUE)
          chase_den <- sum(!dat$in_zone, na.rm = TRUE)
          gozone_sw_num <- sum(dat$is_swing & dat$in_green, na.rm = TRUE)
          gozone_sw_den <- sum(dat$in_green, na.rm = TRUE)
          iz_sw_num <- sum(dat$is_swing & dat$in_zone, na.rm = TRUE)
          iz_sw_den <- sum(dat$in_zone, na.rm = TRUE)
          edge_sw_num <- sum(dat$is_swing & dat$in_zone & !dat$in_green, na.rm = TRUE)
          edge_sw_den <- sum(dat$in_zone & !dat$in_green, na.rm = TRUE)
          possd_points <- sum(dat$possd_point, na.rm = TRUE)
          
          tibble::tibble(
            `Swing%` = safe_div(swings, total_pitches) * 100,
            `FPS%` = safe_div(fps_num, fps_den) * 100,
            `Called%` = safe_div(called, total_pitches) * 100,
            `Chase%` = safe_div(chase_num, chase_den) * 100,
            `GoZoneSw%` = safe_div(gozone_sw_num, gozone_sw_den) * 100,
            `IZswing%` = safe_div(iz_sw_num, iz_sw_den) * 100,
            `EdgeSwing%` = safe_div(edge_sw_num, edge_sw_den) * 100,
            `PosSD%` = safe_div(possd_points, total_pitches) * 100
          )
        }
        
        sd_vals <- summarize_sd(df_sd)
        sd_vals <- sd_vals %>%
          dplyr::mutate(dplyr::across(dplyr::everything(), ~ ifelse(is.finite(.), round(.,1), NA_real_)))
        
        tibble::tibble(
          Player = as.character(dfi$Batter[1])
        ) %>% dplyr::bind_cols(sd_vals)
      })
      
      res_tbl <- dplyr::bind_rows(results_rows)
      sd_tbl  <- dplyr::bind_rows(sd_rows)
      
      res_mode <- resolve_table_mode_global(input$lbHitMode, input$lbHitCustomCols)
      mode   <- res_mode$mode
      custom <- res_mode$cols
      if (mode %in% names(custom_tables())) {
        mode <- "Custom"
        custom <- custom_tables()[[res_mode$mode]]$cols %||% character(0)
      }
      
      if (identical(mode, "Swing Decisions")) {
        out <- sd_tbl
        pct_cols <- c("Swing%","FPS%","Called%","Chase%","GoZoneSw%","IZswing%","EdgeSwing%","PosSD%")
        out[pct_cols] <- lapply(out[pct_cols], function(z) ifelse(is.finite(z), paste0(round(z,1), "%"), ""))
        default_visible <- c("Player", pct_cols)
        if (identical(mode, "Custom")) {
          default_visible <- unique(c("Player", custom))
        }
        return(datatable_with_colvis(
          out,
          lock = "Player",
          remember = FALSE,
          default_visible = intersect(default_visible, names(out)),
          enable_colors = FALSE
        ))
      }
      
      out <- res_tbl
      # coerce numerics (avoid backtick headaches with tidyselect)
      num_cols <- c("PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
                    "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
      out <- out %>%
        dplyr::mutate(
          dplyr::across(dplyr::all_of(num_cols), ~ suppressWarnings(as.numeric(.)))
        )
      
      # EV / LA -> 1 decimal
      out$EV <- ifelse(is.finite(out$EV), round(out$EV, 1), out$EV)
      out$LA <- ifelse(is.finite(out$LA), round(out$LA, 1), out$LA)
      
      # 3-dec rates (no leading 0); percents to 0–100%
      pct_cols  <- c("Swing%","Whiff%","GB%","K%","BB%","Barrel%")
      rate_cols <- c("AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP")
      out[pct_cols]  <- lapply(out[pct_cols],  function(z) ifelse(is.finite(z), paste0(round(z*100,1), "%"), ""))
      out[rate_cols] <- lapply(out[rate_cols], fmt_rate3)
      
      # Default visible columns per mode / custom
      default_visible <- if (identical(mode, "Custom")) {
        unique(c("Player", custom))
      } else {
        c("Player","PA","AB","AVG","SLG","OBP","OPS",
          "wOBA","xWOBA","ISO","xISO","BABIP","GB%","Barrel%",
          "Swing%","Whiff%","K%","BB%","EV","LA")
      }
      
      # Sort by OPS desc by default
      suppressWarnings(out <- out %>% dplyr::arrange(dplyr::desc(as.numeric(OPS))))
      
      # Add error handling wrapper for hitting leaderboard table
      build_lbhit_dt <- function(data, ...) {
        tryCatch(
          datatable_with_colvis(data, ...),
          error = function(e) {
            message("lbHitTable datatable error [mode=", mode, "]: ", conditionMessage(e))
            message("Columns: ", paste(names(data), collapse = ", "))
            # Return a fallback datatable with error message
            DT::datatable(
              data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
              options = list(dom = 't'), rownames = FALSE
            )
          }
        )
      }
      
      if (identical(mode, "Custom")) {
        order_cols <- unique(c("Player", custom))
        extras <- setdiff(names(out), order_cols)
        out <- out[, c(order_cols, extras), drop = FALSE]
      }
      
      pct_cols  <- intersect(c("Swing%","Whiff%","GB%","K%","BB%","Barrel%"), names(out))
      rate_cols <- intersect(c("AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP"), names(out))
      build_lbhit_dt(
        out,
        lock            = "Player",
        remember        = FALSE,
        default_visible = intersect(default_visible, names(out)),
        enable_colors   = FALSE
      )
    }, server = FALSE)
    
    # ==========================
    # Leaderboard: Catching (PLAYER)
    # ==========================
    output$lbCatchButtons <- renderUI({
      ct_names <- names(custom_tables())
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("lbCatchMode"), label = NULL,
                            choices = c("Data", ct_names, "Custom"), selected = "Data", width = "140px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("lbCatchColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']==='Custom'", ns("lbCatchMode")),
          selectizeInput(
            ns("lbCatchCustomCols"), label = NULL,
            choices = c("#","Velo","ExchangeTime","PopTime","SL+"),
            multiple = TRUE,
            options = list(placeholder = "Choose columns…")
          )
        )
      )
    })
    
    output$lbCatchTable <- DT::renderDataTable({
      req(is_active(), input$domain == "Catching")
      
      df_all <- filtered_lb()
      df_all <- df_all %>% dplyr::filter(!is.na(Catcher) & nzchar(Catcher))
      if (!nrow(df_all)) {
        return(DT::datatable(data.frame(Note = "No rows for current filters."), options = list(dom = 't'), rownames = FALSE))
      }
      
      to_num <- function(x) suppressWarnings(as.numeric(x))
      
      # pre-compute take buckets
      takes_all   <- tryCatch({
        pitch_call_safe <- as.character(df_all$PitchCall)
        (!is.na(pitch_call_safe)) & (pitch_call_safe %in% c("StrikeCalled","BallCalled"))
      }, error = function(e) rep(FALSE, nrow(df_all)))
      buckets_all <- inzone_label(df_all$PlateLocSide, df_all$PlateLocHeight)
      
      by_catcher <- split(seq_len(nrow(df_all)), df_all$Catcher)  # split by index for reuse
      
      rows <- lapply(names(by_catcher), function(name) {
        idx <- by_catcher[[name]]
        dfi <- df_all[idx, , drop = FALSE]
        
        # SL+ for this catcher across all takes
        takes   <- takes_all[idx]
        buckets <- buckets_all[idx]
        
        base_tbl <- dplyr::tibble(
          take   = takes,
          bucket = buckets,
          is_cs  = dfi$PitchCall == "StrikeCalled"
        ) |>
          dplyr::filter(take) |>
          dplyr::group_by(bucket) |>
          dplyr::summarise(cs_rate = mean(is_cs, na.rm = TRUE), n = dplyr::n(), .groups = "drop")
        
        overall_rate <- if (nrow(base_tbl) && sum(base_tbl$n) > 0) {
          sum(base_tbl$cs_rate * base_tbl$n) / sum(base_tbl$n)
        } else NA_real_
        
        rate_for_bucket <- function(b) {
          r <- base_tbl$cs_rate[match(b, base_tbl$bucket)]
          ifelse(is.na(r), overall_rate, r)
        }
        
        obs_all <- if (any(takes, na.rm = TRUE)) mean(dfi$PitchCall[takes] == "StrikeCalled", na.rm = TRUE) else NA_real_
        tb      <- table(buckets[takes])
        exp_all <- if (length(tb)) sum(as.numeric(tb) * vapply(names(tb), rate_for_bucket, numeric(1))) / sum(tb) else NA_real_
        sl_all  <- if (is.finite(obs_all) && is.finite(exp_all) && exp_all > 0) round(100 * obs_all / exp_all, 1) else NA_real_
        
        # Throws: PopTime-present
        dft <- dfi |>
          dplyr::mutate(
            ThrowSpeed_num   = to_num(ThrowSpeed),
            ExchangeTime_num = to_num(ExchangeTime),
            PopTime_num      = to_num(PopTime)
          ) |>
          dplyr::filter(is.finite(PopTime_num))
        
        tibble::tibble(
          Player       = name,
          `#`          = nrow(dft),
          Velo         = if (nrow(dft)) round(mean(dft$ThrowSpeed_num,   na.rm = TRUE), 1) else NA_real_,
          ExchangeTime = if (nrow(dft)) round(mean(dft$ExchangeTime_num, na.rm = TRUE), 1) else NA_real_,
          PopTime      = if (nrow(dft)) round(mean(dft$PopTime_num,      na.rm = TRUE), 2) else NA_real_,
          `SL+`        = sl_all
        )
      })
      
      final <- dplyr::bind_rows(rows)
      
      res_mode <- resolve_table_mode_global(input$lbCatchMode, input$lbCatchCustomCols)
      mode <- res_mode$mode
      custom <- res_mode$cols
      default_visible <- if (identical(mode, "Custom")) {
        unique(c("Player", custom))
      } else {
        c("Player","#","Velo","ExchangeTime","PopTime","SL+")
      }
      if (identical(mode, "Custom")) {
        order_cols <- unique(c("Player", custom))
        extras <- setdiff(names(final), order_cols)
        final <- final[, c(order_cols, extras), drop = FALSE]
      }
      
      # Add error handling wrapper for catching leaderboard table
      build_lbcatch_dt <- function(data, ...) {
        tryCatch(
          datatable_with_colvis(data, ...),
          error = function(e) {
            message("lbCatchTable datatable error [mode=", mode, "]: ", conditionMessage(e))
            message("Columns: ", paste(names(data), collapse = ", "))
            # Return a fallback datatable with error message
            DT::datatable(
              data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
              options = list(dom = 't'), rownames = FALSE
            )
          }
        )
      }
      
      build_lbcatch_dt(
        final,
        lock            = "Player",
        remember        = TRUE,
        default_visible = intersect(default_visible, names(final)),
        enable_colors   = FALSE
      )
    }, server = FALSE)
    
  })  # closes moduleServer
}     # closes mod_leader_server

# ==================================
# == Comparison Suite (new module) ==
# ==================================
mod_comp_ui <- function(id, show_header = FALSE) {
  ns <- NS(id)
  fluidPage(
    if (isTRUE(show_header)) {
      fluidRow(
        class = "suite-header",
        column(2, tags$img(src = "PCUlogo.png", height = "100px")),
        column(
          8,
          div(
            style = "height:100%; display:flex; justify-content:center; align-items:flex-start;",
            tags$h1("UNM Comparison Suite", style = "margin-top:25px; font-weight:bold;")
          )
        ),
        column(2, div(style = "text-align:right; margin-top:10px;",
                      tags$img(src = school_logo, height = "80px", alt = school_display_name)))
      )
    },
    sidebarLayout(
      sidebarPanel(
        selectInput(ns("domain"), "Player Type:", choices = c("Pitcher","Hitter","Catcher"), selected = "Pitcher"),
        selectInput(ns("teamType"), "Team:", choices = TEAM_CHOICES, selected = "All"),
        width = 2
      ),
      mainPanel(
        # ---- TWO-PANEL COMPARISON (same layout as Pitching > Comparison Tool) ----
        fluidRow(
          # -------- LEFT PANEL (A) --------
          column(
            6,
            div(style="font-weight:700; text-align:center; margin-bottom:6px;", "Comparison #1"),
            wellPanel(
              selectInput(
                ns("cmpA_sessionType"), "Session Type:",
                choices  = c("All","Bullpen","Live"),
                selected = "Live"
              ),
              dateRangeInput(
                ns("cmpA_dates"), "Date Range:",
                start = max(pitch_data$Date, na.rm = TRUE),
                end   = max(pitch_data$Date, na.rm = TRUE),
                format = "mm/dd/yyyy"
              ),
              selectInput(
                ns("cmpA_chart"), "Select Chart:",
                choices = c("Movement Plot","Release Plot","HeatMap","Location Chart"),
                selected = "HeatMap"
              ),
              conditionalPanel(
                sprintf("input['%s']=='HeatMap'", ns("cmpA_chart")),
                selectInput(
                  ns("cmpA_hmStat"), "Select HeatMap:",
                  choices = c("Frequency","Whiff Rate","Exit Velocity","GB Rate","Contact Rate","Swing Rate","Run Values"),
                  selected = "Frequency"
                )
              ),
              conditionalPanel(
                sprintf("input['%s']=='Location Chart'", ns("cmpA_chart")),
                selectInput(
                  ns("cmpA_result"), "Pitch Results:",
                  choices  = c("All", result_levels),
                  selected = "All",
                  multiple = TRUE
                )
              ),
              # dynamic player select (label & choices depend on Player Type)
              uiOutput(ns("cmpA_player_ui")),
              selectInput(ns("cmpA_hand"),   "Pitcher Hand:", choices = c("All","Left","Right"), selected = "All"),
              selectInput(ns("cmpA_batter"), "Batter Hand:",  choices = c("All","Left","Right"), selected = "All"),
              selectInput(ns("cmpA_qpLocations"), "QP Locations:", choices = c("All", "Yes", "No"), selected = "All"),
              selectInput(
                ns("cmpA_pitchType"),"Pitch Type:",
                choices  = c("All", levels(pitch_data$TaggedPitchType)),
                selected = "All", multiple = TRUE
              ),
              selectInput(
                ns("cmpA_pitchResults"), "Pitch Results:",
                choices  = c("All", result_levels),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpA_countFilter"), "Count:",
                choices = c(
                  "All" = "All",
                  "Even"   = "Even",
                  "Behind" = "Behind",
                  "Ahead"      = "Ahead",
                  "2K Not Full"= "2KNF",
                  "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
                ),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpA_afterCountFilter"), "After Count:",
                choices = c(
                  "All" = "All",
                  "Even"   = "Even",
                  "Behind" = "Behind",
                  "Ahead"      = "Ahead",
                  "2K Not Full"= "2KNF",
                  "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
                ),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpA_zone"),"Zone Location:",
                choices = c("All",
                            "Upper Half","Bottom Half","Left Half","Right Half",
                            "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
                selected = "All",
                multiple = TRUE
              ),
              fluidRow(
                column(6, numericInput(ns("cmpA_veloMin"), "Velocity Min (MPH):", value = NA)),
                column(6, numericInput(ns("cmpA_veloMax"), "Velocity Max (MPH):", value = NA))
              ),
              fluidRow(
                column(6, numericInput(ns("cmpA_ivbMin"), "IVB Min (inches):", value = NA)),
                column(6, numericInput(ns("cmpA_ivbMax"), "IVB Max (inches):", value = NA))
              ),
              fluidRow(
                column(6, numericInput(ns("cmpA_hbMin"), "HB Min (inches):", value = NA)),
                column(6, numericInput(ns("cmpA_hbMax"), "HB Max (inches):", value = NA))
              )
            ),
            # Single switchable plot container (prevents double-render)
            uiOutput(ns("cmpA_plot_ui"))
          ),
          
          # -------- RIGHT PANEL (B) --------
          column(
            6,
            div(style="font-weight:700; text-align:center; margin-bottom:6px;", "Comparison #2"),
            wellPanel(
              selectInput(
                ns("cmpB_sessionType"), "Session Type:",
                choices  = c("All","Bullpen","Live"),
                selected = "Live"
              ),
              dateRangeInput(
                ns("cmpB_dates"), "Date Range:",
                start = max(pitch_data$Date, na.rm = TRUE),
                end   = max(pitch_data$Date, na.rm = TRUE),
                format = "mm/dd/yyyy"
              ),
              selectInput(
                ns("cmpB_chart"), "Select Chart:",
                choices = c("Movement Plot","Release Plot","HeatMap","Location Chart"),
                selected = "HeatMap"
              ),
              conditionalPanel(
                sprintf("input['%s']=='HeatMap'", ns("cmpB_chart")),
                selectInput(
                  ns("cmpB_hmStat"), "Select HeatMap:",
                  choices = c("Frequency","Whiff Rate","Exit Velocity","GB Rate","Contact Rate","Swing Rate","Run Values"),
                  selected = "Frequency"
                )
              ),
              conditionalPanel(
                sprintf("input['%s']=='Location Chart'", ns("cmpB_chart")),
                selectInput(
                  ns("cmpB_result"), "Pitch Results:",
                  choices  = c("All", result_levels),
                  selected = "All",
                  multiple = TRUE
                )
              ),
              uiOutput(ns("cmpB_player_ui")),
              selectInput(ns("cmpB_hand"),   "Pitcher Hand:", choices = c("All","Left","Right"), selected = "All"),
              selectInput(ns("cmpB_batter"), "Batter Hand:",  choices = c("All","Left","Right"), selected = "All"),
              selectInput(ns("cmpB_qpLocations"), "QP Locations:", choices = c("All", "Yes", "No"), selected = "All"),
              selectInput(
                ns("cmpB_pitchType"),"Pitch Type:",
                choices  = c("All", levels(pitch_data$TaggedPitchType)),
                selected = "All", multiple = TRUE
              ),
              selectInput(
                ns("cmpB_pitchResults"), "Pitch Results:",
                choices  = c("All", result_levels),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpB_countFilter"), "Count:",
                choices = c(
                  "All" = "All",
                  "Even"   = "Even",
                  "Behind" = "Behind",
                  "Ahead"      = "Ahead",
                  "2K Not Full"= "2KNF",
                  "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
                ),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpB_afterCountFilter"), "After Count:",
                choices = c(
                  "All" = "All",
                  "Even"   = "Even",
                  "Behind" = "Behind",
                  "Ahead"      = "Ahead",
                  "2K Not Full"= "2KNF",
                  "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
                ),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpB_zone"),"Zone Location:",
                choices = c("All",
                            "Upper Half","Bottom Half","Left Half","Right Half",
                            "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
                selected = "All",
                multiple = TRUE
              ),
              fluidRow(
                column(6, numericInput(ns("cmpB_veloMin"), "Velocity Min (MPH):", value = NA)),
                column(6, numericInput(ns("cmpB_veloMax"), "Velocity Max (MPH):", value = NA))
              ),
              fluidRow(
                column(6, numericInput(ns("cmpB_ivbMin"), "IVB Min (inches):", value = NA)),
                column(6, numericInput(ns("cmpB_ivbMax"), "IVB Max (inches):", value = NA))
              ),
              fluidRow(
                column(6, numericInput(ns("cmpB_hbMin"), "HB Min (inches):", value = NA)),
                column(6, numericInput(ns("cmpB_hbMax"), "HB Max (inches):", value = NA))
              )
            ),
            # Single switchable plot container (prevents double-render)
            uiOutput(ns("cmpB_plot_ui"))
          )
        ),
        
        tags$hr(),
        # ---------- STACKED TABLES ----------
        fluidRow(
          column(
            12,
            div(style="font-weight:700; text-align:center; margin-bottom:6px;", "Comparison #1 Table"),
            div(
              style = "margin: 8px 0;",
              tagList(
                div(style = "display: flex; align-items: center; gap: 15px;",
                    div(style = "flex: 0 0 auto;",
                        selectInput(
                          ns("cmpA_tableMode"), label = NULL,
                          choices = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data","Custom"),
                          selected = "Stuff",
                          width = "120px"
                        )
                    ),
                    div(style = "flex: 0 0 auto;",
                        checkboxInput(
                          ns("cmpA_tableColors"), 
                          label = "Color-Code", 
                          value = TRUE,
                          width = "80px"
                        )
                    ),
                    div(style = "flex: 0 0 auto;",
                        div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Split By:"),
                        selectInput(
                          ns("cmpA_splitBy"), label = NULL,
                          choices = c("Pitch Types", "Batter Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Batter"),
                          selected = "Pitch Types",
                          width = "140px"
                        )
                    )
                ),
                conditionalPanel(
                  sprintf("input['%s']=='Custom'", ns("cmpA_tableMode")),
                  selectInput(ns("cmpA_customSaved"), "Saved Table:", choices = c(""), selected = ""),
                  textInput(ns("cmpA_customName"), "Name:", value = ""),
                  selectizeInput(
                    ns("cmpA_customCols"), label = "Columns (drag to order):",
                    choices  = setdiff(all_table_cols, "Pitch"),
                    multiple = TRUE,
                    options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
                  ),
                  actionButton(ns("cmpA_saveCustom"), "Save / Update", class = "btn-primary btn-sm"),
                  actionButton(ns("cmpA_deleteCustom"), "Delete", class = "btn-danger btn-sm")
                )
              )
            ),
            DT::dataTableOutput(ns("cmpA_table"))
          )
        ),
        br(),
        fluidRow(
          column(
            12,
            div(style="font-weight:700; text-align:center; margin-bottom:6px;", "Comparison #2 Table"),
            div(
              style = "margin: 8px 0;",
              tagList(
                div(style = "display: flex; align-items: center; gap: 15px;",
                    div(style = "flex: 0 0 auto;",
                        selectInput(
                          ns("cmpB_tableMode"), label = NULL,
                          choices = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data","Custom"),
                          selected = "Stuff",
                          width = "120px"
                        )
                    ),
                    div(style = "flex: 0 0 auto;",
                        checkboxInput(
                          ns("cmpB_tableColors"), 
                          label = "Color-Code", 
                          value = TRUE,
                          width = "80px"
                        )
                    ),
                    div(style = "flex: 0 0 auto;",
                        div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Split By:"),
                        selectInput(
                          ns("cmpB_splitBy"), label = NULL,
                          choices = c("Pitch Types", "Batter Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Batter"),
                          selected = "Pitch Types",
                          width = "140px"
                        )
                    )
                ),
                conditionalPanel(
                  sprintf("input['%s']=='Custom'", ns("cmpB_tableMode")),
                  selectInput(ns("cmpB_customSaved"), "Saved Table:", choices = c(""), selected = ""),
                  textInput(ns("cmpB_customName"), "Name:", value = ""),
                  selectizeInput(
                    ns("cmpB_customCols"), label = "Columns (drag to order):",
                    choices  = setdiff(all_table_cols, "Pitch"),
                    multiple = TRUE,
                    options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
                  ),
                  actionButton(ns("cmpB_saveCustom"), "Save / Update", class = "btn-primary btn-sm"),
                  actionButton(ns("cmpB_deleteCustom"), "Delete", class = "btn-danger btn-sm")
                )
              )
            ),
            DT::dataTableOutput(ns("cmpB_table"))
          )
        )
      )
    )
  )
} 

mod_comp_server <- function(id, is_active = shiny::reactive(TRUE), global_date_range = NULL) {
  moduleServer(id, function(input, output, session) {
    # Dark-mode flag that respects root-scope toggle
    is_dark_mode <- reactive({
      dm <- tryCatch({
        rs <- session$rootScope()
        if (!is.null(rs) && !is.null(rs$input$dark_mode)) rs$input$dark_mode else NULL
      }, error = function(...) NULL)
      if (is.null(dm) && !is.null(input$dark_mode)) dm <- input$dark_mode
      isTRUE(dm)
    })
    
    # Sync custom table lists into comparison (namespaced) controls
    observe({
      nms <- names(custom_tables())
      base_modes <- c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data")
      currentA <- isolate(input$cmpA_tableMode)
      currentB <- isolate(input$cmpB_tableMode)
      updateSelectInput(session, "cmpA_tableMode", choices = c(base_modes, nms, "Custom"),
                        selected = currentA)
      updateSelectInput(session, "cmpB_tableMode", choices = c(base_modes, nms, "Custom"),
                        selected = currentB)
      updateSelectInput(session, "cmpA_customSaved", choices = c("", nms),
                        selected = isolate(input$cmpA_customSaved))
      updateSelectInput(session, "cmpB_customSaved", choices = c("", nms),
                        selected = isolate(input$cmpB_customSaved))
    })
    
    # Switch table/split choices to match domain (Pitcher vs Hitter)
    observeEvent(input$domain, {
      dom <- input$domain %||% "Pitcher"
      nms <- names(custom_tables())
      if (dom %in% c("Hitter","Catcher","Pitcher","Pitching","Hitting","Catching")) {
        if (dom %in% c("Hitter","Hitting")) {
          tbl_choices <- c("Results","Swing Decisions", nms, "Custom")
          split_choices <- c("Pitch Types", "Pitcher Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Pitcher")
        } else {
          tbl_choices <- c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data", nms, "Custom")
          split_choices <- c("Pitch Types", "Batter Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Batter")
        }
        updateSelectInput(session, "cmpA_tableMode", choices = tbl_choices,
                          selected = tbl_choices[[1]])
        updateSelectInput(session, "cmpB_tableMode", choices = tbl_choices,
                          selected = tbl_choices[[1]])
        updateSelectInput(session, "cmpA_splitBy", choices = split_choices,
                          selected = split_choices[[1]])
        updateSelectInput(session, "cmpB_splitBy", choices = split_choices,
                          selected = split_choices[[1]])
      }
    }, ignoreInit = TRUE)
    
    # Sync local date input with global date range if available
    if (!is.null(global_date_range)) {
      # Comp module has different date input names (cmpA_dates, cmpB_dates)
      observe({
        if (!is.null(global_date_range()) && length(global_date_range()) == 2) {
          updateDateRangeInput(session, "cmpA_dates", 
                               start = global_date_range()[1], 
                               end = global_date_range()[2])
          updateDateRangeInput(session, "cmpB_dates", 
                               start = global_date_range()[1], 
                               end = global_date_range()[2])
        }
      })
    }
    ns <- session$ns
    tooltip_css <- "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
    
    # ---------- Dynamic player pickers ----------
    .player_label <- function(dom) switch(dom,
                                          Pitcher = "Select Pitcher:",
                                          Hitter  = "Select Hitter:",
                                          Catcher = "Select Catcher:"
    )
    .player_choices <- function(dom) {
      switch(
        dom,
        Pitcher = c("All" = "All", name_map_pitching),
        Hitter  = c("All" = "All", batter_map),
        Catcher = c("All" = "All", catcher_map)
      )
    }
    
    # ---------- Helpers ----------
    collapse_list_cols <- function(dat) {
      if (!nrow(dat)) return(dat)
      dat %>%
        dplyr::mutate(dplyr::across(
          dplyr::where(is.list),
          ~ vapply(., function(x) {
            if (is.null(x)) "" else if (length(x) == 1 && !is.list(x)) as.character(x)
            else paste0(unlist(x), collapse = ", ")
          }, character(1))
        ))
    }
    
    # ---------- Player UIs ----------
    output$cmpA_player_ui <- renderUI({
      lab <- .player_label(input$domain)
      selectInput(ns("cmpA_player"), lab, choices = .player_choices(input$domain), selected = "All")
    })
    output$cmpB_player_ui <- renderUI({
      lab <- .player_label(input$domain)
      selectInput(ns("cmpB_player"), lab, choices = .player_choices(input$domain), selected = "All")
    })
    
    .last_date_for <- function(dom, player, st) {
      df <- pitch_data
      # normalize once
      if (!"SessionType_std" %in% names(df)) {
        df$SessionType_std <- {
          x0 <- tolower(trimws(as.character(df$SessionType)))
          dplyr::case_when(
            grepl("bull", x0)         ~ "Bullpen",
            grepl("live|game|ab", x0) ~ "Live",
            TRUE                      ~ "Other"
          )
        }
      }
      if (!is.null(st) && st != "All") {
        df <- df[df$SessionType_std == st, , drop = FALSE]
      }
      if (isTRUE(player == "All") || is.null(player) || !nzchar(player)) {
        return(suppressWarnings(max(df$Date, na.rm = TRUE)))
      }
      col <- switch(dom, "Pitcher" = "Pitcher", "Hitter" = "Batter", "Catcher" = "Catcher", "Pitcher")
      suppressWarnings(max(df$Date[df[[col]] == player], na.rm = TRUE))
    }
    
    observeEvent(list(input$domain, input$cmpA_player, input$cmpA_sessionType), {
      req(is_active())
      last_date <- .last_date_for(input$domain, input$cmpA_player, input$cmpA_sessionType)
      if (is.finite(last_date)) updateDateRangeInput(session, "cmpA_dates", start = last_date, end = last_date)
    }, ignoreInit = TRUE)
    observeEvent(list(input$domain, input$cmpB_player, input$cmpB_sessionType), {
      req(is_active())
      last_date <- .last_date_for(input$domain, input$cmpB_player, input$cmpB_sessionType)
      if (is.finite(last_date)) updateDateRangeInput(session, "cmpB_dates", start = last_date, end = last_date)
    }, ignoreInit = TRUE)
    
    # ---------- Common filtering helper ----------
    normalize_session_type <- function(x) {
      x0 <- tolower(trimws(as.character(x)))
      dplyr::case_when(
        grepl("bull|prac", x0)         ~ "Bullpen",
        grepl("live|game|ab", x0)      ~ "Live",
        TRUE                           ~ "Other"
      )
    }
    
    .filtered_panel <- function(which = c("A","B")) {
      which <- match.arg(which)
      
      dom_in <- (input[[paste0("cmp", which, "_domain")]] %||% input$domain %||% "Pitcher")
      dom <- if (dom_in %in% c("Pitching","Pitcher")) "Pitcher"
      else if (dom_in %in% c("Hitting","Hitter")) "Hitter"
      else if (dom_in %in% c("Catching","Catcher")) "Catcher"
      else "Pitcher"
      
      dates  <- input[[paste0("cmp", which, "_dates")]]
      hand   <- input[[paste0("cmp", which, "_hand")]]
      bats   <- input[[paste0("cmp", which, "_batter")]]
      zone   <- input[[paste0("cmp", which, "_zone")]]
      ptypes <- input[[paste0("cmp", which, "_pitchType")]]
      qpLoc  <- input[[paste0("cmp", which, "_qpLocations")]]
      pr_res <- input[[paste0("cmp", which, "_pitchResults")]]
      cntSel <- input[[paste0("cmp", which, "_countFilter")]]
      afterSel <- input[[paste0("cmp", which, "_afterCountFilter")]]
      vmin   <- input[[paste0("cmp", which, "_veloMin")]]
      vmax   <- input[[paste0("cmp", which, "_veloMax")]]
      ivbmin <- input[[paste0("cmp", which, "_ivbMin")]]
      ivbmax <- input[[paste0("cmp", which, "_ivbMax")]]
      hbmin  <- input[[paste0("cmp", which, "_hbMin")]]
      hbmax  <- input[[paste0("cmp", which, "_hbMax")]]
      player <- input[[paste0("cmp", which, "_player")]]
      stype  <- input[[paste0("cmp", which, "_sessionType")]]
      
      req(dates)
      if (is.null(ptypes)) ptypes <- "All"
      if (is.null(stype)  || !nzchar(stype)) stype <- "Live"
      
      df <- if (identical(dom, "Pitcher") && exists("pitch_data_pitching")) pitch_data_pitching else pitch_data
      if (!nrow(df)) return(df[0, , drop = FALSE])
      
      # Privacy scoping: Coaches see all, Players see only their own data
      if (exists("user_email") && is.function(user_email) &&
          exists("is_admin")   && is.function(is_admin)   &&
          exists("is_coach")   && is.function(is_coach)   &&
          !is_admin() && !is_coach()) {
        ne <- function(x) tolower(trimws(x))
        ue <- user_email()
        if (!is.na(ue) && "Email" %in% names(df)) {
          df <- dplyr::filter(df, ne(Email) == ne(ue))
        }
      }
      if (!nrow(df)) return(df)
      
      if (!("SessionType_std" %in% names(df))) {
        df$SessionType_std <- normalize_session_type(df$SessionType)
      }
      
      df <- dplyr::filter(df, as.Date(Date) >= as.Date(dates[1]),
                          as.Date(Date) <= as.Date(dates[2]))
      if (!nrow(df)) return(df)
      
      if (!is.null(player) && player != "All") {
        df <- switch(
          dom,
          "Pitcher" = dplyr::filter(df, Pitcher == player),
          "Hitter"  = dplyr::filter(df, Batter  == player),
          "Catcher" = dplyr::filter(df, Catcher == player),
          df
        )
      }
      if (!nrow(df)) return(df)
      
      # Add team filtering
      team_type <- input$teamType %||% "All"
      if (team_type == "Campers") {
        df <- switch(
          dom,
          "Pitcher" = dplyr::filter(df, Pitcher %in% ALLOWED_CAMPERS),
          "Hitter"  = dplyr::filter(df, Batter %in% ALLOWED_CAMPERS),
          "Catcher" = dplyr::filter(df, Catcher %in% ALLOWED_CAMPERS),
          df
        )
      } else if (team_type == TEAM_CODE) {
        # GCU team only
        df <- switch(
          dom,
          "Pitcher" = dplyr::filter(df, Pitcher %in% ALLOWED_PITCHERS),
          "Hitter"  = dplyr::filter(df, Batter %in% ALLOWED_HITTERS),
          "Catcher" = dplyr::filter(df, Catcher %in% ALLOWED_PITCHERS),
          df
        )
      }
      # If team_type == "All", no team filtering is applied
      if (!nrow(df)) return(df)
      
      if (stype != "All") df <- df[df$SessionType_std == stype, , drop = FALSE]
      if (!nrow(df)) return(df)
      
      if (!is.null(hand) && hand != "All") df <- dplyr::filter(df, PitcherThrows == hand)
      if (!is.null(bats) && bats != "All") {
        st_std <- df$SessionType_std
        df <- df %>% dplyr::filter(st_std != "Live" | (st_std == "Live" & BatterSide == bats))
      }
      if (!nrow(df)) return(df)
      
      if (!is.null(zone) && !identical(zone, "All")) {
        df <- enforce_zone(df, zone)
        if (!nrow(df)) return(df)
      }
      
      # Count filters
      if (!is.null(cntSel) && !("All" %in% cntSel)) {
        df <- apply_count_filter(df, cntSel)
        if (!nrow(df)) return(df)
      }
      if (!is.null(afterSel) && !("All" %in% afterSel)) {
        df <- apply_after_count_filter(df, afterSel)
        if (!nrow(df)) return(df)
      }
      
      # Apply QP Locations filter
      if (!is.null(qpLoc) && qpLoc != "All") {
        df <- filter_qp_locations(df, qpLoc)
        if (!nrow(df)) return(df)
      }
      
      nnz <- function(x) !is.null(x) && !is.na(x)
      if (nnz(vmin))   df <- dplyr::filter(df, RelSpeed         >= vmin)
      if (nnz(vmax))   df <- dplyr::filter(df, RelSpeed         <= vmax)
      if (nnz(ivbmin)) df <- dplyr::filter(df, InducedVertBreak >= ivbmin)
      if (nnz(ivbmax)) df <- dplyr::filter(df, InducedVertBreak <= ivbmax)
      if (nnz(hbmin))  df <- dplyr::filter(df, HorzBreak        >= hbmin)
      if (nnz(hbmax))  df <- dplyr::filter(df, HorzBreak        <= hbmax)
      if (!nrow(df)) return(df)
      
      if (!("All" %in% ptypes)) df <- dplyr::filter(df, TaggedPitchType %in% ptypes)
      if (!nrow(df)) return(df)
      
      # Pitch Results filter
      df <- apply_pitch_results_filter(df, pr_res)
      if (!nrow(df)) return(df)
      
      df2 <- compute_stuff_simple(df, base_type = "Fastball", level = "College") %>%
        force_pitch_levels() %>%
        dplyr::mutate(Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels))
      attr(df2, "domain") <- dom
      df2
    }
    
    # ---------- PLOTS ----------
    .movement_girafe <- function(df) {
      if (!nrow(df)) return(NULL)
      dark_on <- is_dark_mode()
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      line_col <- if (dark_on) "#ffffff" else "black"
      cols <- if (exists("colors_for_mode")) colors_for_mode(dark_on) else all_colors
      grid_col <- adjustcolor(if (dark_on) "white" else "black",
                              alpha.f = if (dark_on) 0.18 else 0.12)
      df_i <- df %>% dplyr::mutate(tt = make_hover_tt(.), rid = dplyr::row_number())
      types_chr <- as.character(intersect(names(all_colors), unique(df_i$TaggedPitchType)))
      avg_mov <- df %>%
        dplyr::filter(is.finite(HorzBreak), is.finite(InducedVertBreak)) %>%
        dplyr::group_by(TaggedPitchType) %>%
        dplyr::summarise(
          avg_HorzBreak        = mean(HorzBreak, na.rm = TRUE),
          avg_InducedVertBreak = mean(InducedVertBreak, na.rm = TRUE),
          .groups = "drop"
        )
      p <- ggplot() +
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(HorzBreak, InducedVertBreak,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          alpha = 0.25, size = 4.0, shape = 21, stroke = 0.25
        ) +
        geom_point(
          data = avg_mov,
          aes(avg_HorzBreak, avg_InducedVertBreak, color = TaggedPitchType),
          size = 8
        ) +
        geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
        geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
        coord_cartesian(xlim = c(-25, 25), ylim = c(-25, 25)) +
        scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
        scale_fill_manual(values  = cols[types_chr], limits = types_chr, name = NULL) +
        labs(x = "Horizontal Break (in)", y = "Induced Vertical Break (in)") +
        theme_minimal(base_size = 12) + grid_theme(dark_on) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(color = axis_col),
          axis.text.y = element_text(color = axis_col),
          axis.title.x = element_text(color = axis_col),
          axis.title.y = element_text(color = axis_col),
          axis.ticks = element_blank(),
          panel.grid.major = element_line(color = grid_col),
          panel.grid.minor = element_blank()
        )
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_sizing(rescale = TRUE),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
          ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    }
    output$cmpA_movement <- ggiraph::renderGirafe({ .movement_girafe(.filtered_panel("A")) })
    output$cmpB_movement <- ggiraph::renderGirafe({ .movement_girafe(.filtered_panel("B")) })
    
    .release_plot <- function(df) {
      if (!nrow(df)) return(ggplot() + theme_void())
      axis_th <- get0("axis_theme", ifnotfound = theme())
      dark_on <- is_dark_mode()
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      line_col <- if (dark_on) "#ffffff" else "black"
      grid_col <- adjustcolor(if (dark_on) "white" else "black",
                              alpha.f = if (dark_on) 0.18 else 0.12)
      cols <- if (exists("colors_for_mode")) colors_for_mode(dark_on) else all_colors
      types <- if (exists("ordered_types") && is.function(ordered_types)) {
        ot <- as.character(ordered_types()); ot[ot %in% unique(df$TaggedPitchType)]
      } else as.character(intersect(names(all_colors), unique(df$TaggedPitchType)))
      rp_w <- 4; rp_h <- 0.83
      xs <- seq(-rp_w, rp_w, length.out = 100); ys <- rp_h * (1 - (xs / rp_w)^2)
      mound <- data.frame(x = c(xs, rev(xs)), y = c(ys, rep(0, length(xs))))
      avg <- df %>%
        dplyr::group_by(TaggedPitchType) %>%
        dplyr::summarise(
          avg_RelSide   = mean(RelSide,   na.rm = TRUE),
          avg_RelHeight = mean(RelHeight, na.rm = TRUE),
          .groups = "drop"
        ) %>% dplyr::filter(TaggedPitchType %in% types)
      if (!nrow(avg)) return(ggplot() + theme_void())
      ggplot() +
        geom_polygon(data = mound, aes(x, y), fill = "tan", color = "tan") +
        annotate("rect", xmin = -0.5, xmax = 0.5, ymin = rp_h - 0.05, ymax = rp_h + 0.05, fill = "white") +
        geom_vline(xintercept = 0, color = line_col, size = 0.7) +
        geom_hline(yintercept = 0, color = line_col, size = 0.7) +
        geom_point(data = avg, aes(avg_RelSide, avg_RelHeight, color = TaggedPitchType), size = 4) +
        scale_color_manual(values = cols[types], limits = types, name = NULL) +
        theme_minimal() + axis_th + grid_theme(dark_on) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(color = axis_col),
          axis.text.y = element_text(color = axis_col),
          axis.ticks = element_blank(),
          panel.grid.major = element_line(color = grid_col),
          panel.grid.minor = element_blank(),
          panel.background = element_rect(fill = "transparent", color = NA),
          plot.background = element_rect(fill = "transparent", color = NA)
        ) +
        labs(x = NULL, y = NULL)
    }
    output$cmpA_release <- renderPlot({ .release_plot(.filtered_panel("A")) }, bg = "transparent")
    output$cmpB_release <- renderPlot({ .release_plot(.filtered_panel("B")) }, bg = "transparent")
    
    .kde_grid <- function(x, y, lims = c(-2.5, 2.5, 0, 4.5), n = 200, h = NULL) {
      ok <- is.finite(x) & is.finite(y)
      x <- x[ok]; y <- y[ok]
      if (length(x) < 2 || length(unique(x)) < 2 || length(unique(y)) < 2) {
        return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
      }
      
      # Use adaptive bandwidth based on sample size and spread
      if (is.null(h)) {
        n_pts <- length(x)
        x_sd <- sd(x)
        y_sd <- sd(y)
        h_x <- x_sd * (n_pts^(-1/6)) * 1.2
        h_y <- y_sd * (n_pts^(-1/6)) * 1.2
        h <- c(h_x, h_y)
      }
      
      d <- MASS::kde2d(x, y, n = n, lims = lims, h = h)
      expand.grid(x = d$x, y = d$y) |> transform(z = as.vector(d$z))
    }
    
    .heat_plot <- function(df, stat) {
      render_heatmap_stat(df, stat)
    }
    output$cmpA_heat <- renderPlot({ .heat_plot(.filtered_panel("A"), input$cmpA_hmStat) }, bg = "transparent")
    output$cmpB_heat <- renderPlot({ .heat_plot(.filtered_panel("B"), input$cmpB_hmStat) }, bg = "transparent")
    
    .pitch_girafe <- function(df, sel_results) {
      if (!nrow(df)) return(NULL)
      if (!is.null(sel_results) && length(sel_results) && !("All" %in% sel_results)) {
        keep <- as.character(compute_result(df$PitchCall, df$PlayResult)) %in% sel_results
        df <- df[keep, , drop = FALSE]
      }
      if (!nrow(df)) return(NULL)
      dark_on <- is_dark_mode()
      dom <- attr(df, "domain") %||% "Pitcher"
      if (identical(dom, "Hitter")) {
        # Local copy of hitting location plot (with green box)
        return({
          df_subset <- df
          if (!"Result" %in% names(df_subset)) {
            df_subset$Result <- compute_result(df_subset$PitchCall, df_subset$PlayResult)
          }
          line_col <- if (dark_on) "#ffffff" else "black"
          grid_col <- if (dark_on) "#d1d5db" else "black"
          cols <- colors_for_mode(dark_on)
          hit_result_levels <- names(hit_shape_map)
          df_subset <- df_subset %>%
            dplyr::mutate(
              ResultDisplay = dplyr::case_when(
                Result %in% c("In Play (Out)", "In Play (Hit)") ~ "In Play",
                TRUE ~ as.character(Result)
              )
            )
          df_plot <- df_subset %>%
            dplyr::filter(is.finite(as.numeric(PlateLocSide)), is.finite(as.numeric(PlateLocHeight))) %>%
            dplyr::mutate(
              PlateLocSide = as.numeric(PlateLocSide),
              PlateLocHeight = as.numeric(PlateLocHeight),
              TaggedPitchType = as.character(TaggedPitchType),
              ResultDisplay = dplyr::case_when(
                ResultDisplay %in% hit_result_levels ~ ResultDisplay,
                TRUE ~ NA_character_
              ),
              ResultDisplay = factor(ResultDisplay, levels = hit_result_levels),
              tooltip = paste0(
                "<b>", TaggedPitchType, "</b><br>",
                "PitchCall: ", ifelse(is.na(PitchCall), "—", as.character(PitchCall)), "<br>",
                "Result: ", ifelse(is.na(ResultDisplay), "—", as.character(ResultDisplay)), "<br>",
                "Velo: ", ifelse(is.finite(as.numeric(RelSpeed)), sprintf("%.1f mph", as.numeric(RelSpeed)), "—"), "<br>",
                "EV: ", ifelse(is.finite(as.numeric(ExitSpeed)), sprintf("%.1f mph", as.numeric(ExitSpeed)), "—"), "<br>",
                "LA: ", ifelse(is.finite(as.numeric(Angle)), sprintf("%.1f°", as.numeric(Angle)), "—")
              ),
              rid = dplyr::row_number()
            )
          if (!nrow(df_plot)) {
            p_empty <- ggplot() +
              annotate("text", x = 0, y = 2.5, label = "No pitches", size = 5) +
              theme_void()
            return(girafe_transparent(ggobj = p_empty))
          }
          types_chr <- intersect(names(cols), unique(df_plot$TaggedPitchType))
          if (!length(types_chr)) types_chr <- unique(df_plot$TaggedPitchType)
          col_vals <- cols[types_chr]; col_vals[is.na(col_vals)] <- "gray70"
          home <- data.frame(
            x = c(-0.75, 0.75, 0.75, 0, -0.75),
            y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
          )
          sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
          mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
          mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
          dx <- (ZONE_RIGHT - ZONE_LEFT) / 3
          dy <- (ZONE_TOP - ZONE_BOTTOM) / 3
          grid_vertical <- data.frame(
            x = c(ZONE_LEFT + dx, ZONE_LEFT + 2 * dx),
            ymin = ZONE_BOTTOM,
            ymax = ZONE_TOP
          )
          grid_horizontal <- data.frame(
            y = c(ZONE_BOTTOM + dy, ZONE_BOTTOM + 2 * dy),
            xmin = ZONE_LEFT,
            xmax = ZONE_RIGHT
          )
          inner_half <- 7 / 12
          green_box <- data.frame(
            xmin = mid_x - inner_half,
            xmax = mid_x + inner_half,
            ymin = mid_y - inner_half,
            ymax = mid_y + inner_half
          )
          df_known <- dplyr::filter(df_plot, !is.na(ResultDisplay))
          df_other <- dplyr::filter(df_plot, is.na(ResultDisplay))
          tooltip_css <- "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
          p <- ggplot() +
            geom_polygon(data = home, aes(x, y), inherit.aes = FALSE, fill = NA, color = line_col) +
            geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                      inherit.aes = FALSE, fill = NA, color = line_col) +
            geom_rect(data = green_box,
                      aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                      inherit.aes = FALSE,
                      fill = "#66c87a", alpha = 0.18, color = NA) +
            geom_segment(data = grid_vertical,
                         aes(x = x, xend = x, y = ymin, yend = ymax),
                         inherit.aes = FALSE, color = grid_col, linewidth = 0.4) +
            geom_segment(data = grid_horizontal,
                         aes(x = xmin, xend = xmax, y = y, yend = y),
                         inherit.aes = FALSE, color = grid_col, linewidth = 0.4) +
            ggiraph::geom_point_interactive(
              data = df_other,
              aes(PlateLocSide, PlateLocHeight,
                  color = TaggedPitchType, fill = TaggedPitchType,
                  tooltip = tooltip, data_id = rid),
              size = 4.5, alpha = 0.9, shape = 21, stroke = 0.4
            ) +
            ggiraph::geom_point_interactive(
              data = df_known,
              aes(PlateLocSide, PlateLocHeight,
                  color = TaggedPitchType, fill = TaggedPitchType, shape = ResultDisplay,
                  tooltip = tooltip, data_id = rid),
              size = 5, alpha = 0.95, stroke = 0.8
            ) +
            scale_color_manual(values = col_vals, limits = types_chr, drop = FALSE, name = NULL) +
            scale_fill_manual(values = col_vals, limits = types_chr, drop = FALSE, name = NULL) +
            scale_shape_manual(values = hit_shape_map, drop = TRUE) +
            coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
            theme_void() +
            theme(legend.position = "none")
          
          girafe_transparent(
            ggobj = p,
            options = list(
              ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
              ggiraph::opts_hover(css = "stroke-width:1.5px;"),
              ggiraph::opts_hover_inv(css = "opacity:0.15;")
            )
          )
        })
      }
      types <- if (exists("ordered_types") && is.function(ordered_types)) ordered_types() else
        intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      types_chr <- as.character(types)
      df_i <- df %>%
        dplyr::mutate(
          Result  = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
          tt      = make_hover_tt(.),
          rid     = dplyr::row_number(),
          tt_fill = dplyr::coalesce(colors_for_mode(dark_on)[as.character(TaggedPitchType)], "gray")
        )
      home <- data.frame(x = c(-0.75,0.75,0.75,0.00,-0.75),
                         y = c(1.05,1.05,1.15,1.25,1.15) - 0.5)
      cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      line_col <- if (dark_on) "#ffffff" else "black"
      df_known <- dplyr::filter(df_i, !is.na(Result))
      df_other <- dplyr::filter(df_i,  is.na(Result))
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), inherit.aes = FALSE, fill = NA, color = line_col) +
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  inherit.aes = FALSE, fill = NA, color = line_col, linetype = "dashed") +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  inherit.aes = FALSE, fill = NA, color = line_col) +
        ggiraph::geom_point_interactive(
          data = df_other,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          position = "identity",
          size = 3.2, alpha = 0.9, shape = 16, stroke = 0.3
        ) +
        ggiraph::geom_point_interactive(
          data = df_known,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
              tooltip = tt, data_id = rid),
          position = "identity",
          size = 3.8, alpha = 0.95, stroke = 0.8
        ) +
        scale_color_manual(values = colors_for_mode(dark_on)[types_chr], limits = types_chr, name = NULL) +
        scale_fill_manual(values  = colors_for_mode(dark_on)[types_chr], limits = types_chr, name = NULL) +
        scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
        coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
        theme_void() + theme(legend.position = "none") +
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
          inherit.aes = FALSE, shape = 21, size = 6, alpha = 0.001, stroke = 0
        )
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    }
    output$cmpA_pitch <- ggiraph::renderGirafe({ .pitch_girafe(.filtered_panel("A"), input$cmpA_result) })
    output$cmpB_pitch <- ggiraph::renderGirafe({ .pitch_girafe(.filtered_panel("B"), input$cmpB_result) })
    
    # Switchable plot container (ensures only ONE chart visible per side)
    output$cmpA_plot_ui <- renderUI({
      switch(input$cmpA_chart,
             "Movement Plot" = ggiraph::girafeOutput(ns("cmpA_movement"), height = "480px"),
             "Release Plot"  = plotOutput(ns("cmpA_release"), height = "480px"),
             "HeatMap"       = plotOutput(ns("cmpA_heat"), height = "480px"),
             "Location Chart"= ggiraph::girafeOutput(ns("cmpA_pitch"), height = "480px")
      )
    })
    output$cmpB_plot_ui <- renderUI({
      switch(input$cmpB_chart,
             "Movement Plot" = ggiraph::girafeOutput(ns("cmpB_movement"), height = "480px"),
             "Release Plot"  = plotOutput(ns("cmpB_release"), height = "480px"),
             "HeatMap"       = plotOutput(ns("cmpB_heat"), height = "480px"),
             "Location Chart"= ggiraph::girafeOutput(ns("cmpB_pitch"), height = "480px")
      )
    })
    
    # ---------- TABLES (IDENTICAL to DP / Summary page logic) ----------
    # fallback visible set helper if not global
    if (!exists("visible_set_for")) {
      visible_set_for <- function(mode, custom) {
        base <- c(
          "Pitch","#","Usage","BF","IP","FIP","WHIP","Velo","Max","IVB","HB","rTilt","bTilt","SpinEff","Spin",
          "Height","Side","VAA","HAA","Ext","InZone%","Comp%","Strike%","FPS%","E+A%",
          "K%","BB%","Whiff%","EV","LA","Stuff+","Ctrl+","QP+","Pitching+",
          # Results-specific
          "PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP","GB%","Barrel%","Swing%","Whiff%","K%","BB%","EV","LA"
        )
        if (identical(mode, "Custom") && length(custom)) unique(c("Pitch", custom)) else base
      }
    }
    
    .dp_like_table <<- function(df, mode, custom_cols, enable_colors = TRUE) {
      if (!nrow(df)) {
        return(DT::datatable(
          data.frame(Message = "No data for selected filters"),
          options = list(dom = 't'), rownames = FALSE
        ))
      }
      dom <- attr(df, "domain") %||% "Pitcher"
      split_choice <- attr(df, "split_choice") %||% "Pitch Types"
      split_col_name <- switch(
        split_choice,
        "Pitch Types" = "Pitch",
        "Batter Hand" = if (dom == "Hitter") "Pitcher Hand" else "Batter Hand",
        "Pitcher Hand" = "Pitcher Hand",
        "Count" = "Count",
        "After Count" = "After Count",
        "Velocity" = "Velocity",
        "IVB" = "IVB",
        "HB" = "HB",
        "Batter" = if (dom == "Hitter") "Pitcher" else "Batter",
        "Pitch"
      )
      pitch_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
      df$TaggedPitchType <- df[[pitch_col]]
      df$PitchType <- df$TaggedPitchType
      if (!"SplitColumn" %in% names(df)) {
        df$SplitColumn <- df[[pitch_col]]
      }
      if (!"TaggedPitchType" %in% names(df)) {
        df$TaggedPitchType <- df$PitchType %||% df$Pitch %||% df$SplitColumn
      }
      
      # Hitting-mode tables (Results + Swing Decisions + Custom)
      if (identical(dom, "Hitter")) {
        safe_div_local <- function(num, den) {
          num <- suppressWarnings(as.numeric(num))
          den <- suppressWarnings(as.numeric(den))
          ifelse(is.finite(den) & den > 0 & is.finite(num), num/den, NA_real_)
        }
        nz_mean_local <- function(x) {
          x <- suppressWarnings(as.numeric(x))
          m <- mean(x, na.rm = TRUE)
          if (is.finite(m)) m else NA_real_
        }
        fmt_avg_local <- function(x) {
          z <- ifelse(is.finite(x), sprintf("%.3f", x), NA_character_)
          sub("^0", "", z)
        }
        
        build_results_table_hit <- function(df_src) {
          if (!nrow(df_src)) return(data.frame())
          if (!"SplitColumn" %in% names(df_src)) {
            df_src$SplitColumn <- if ("TaggedPitchType" %in% names(df_src)) {
              as.character(df_src$TaggedPitchType)
            } else {
              "Unknown"
            }
          }
          if (!"TaggedPitchType" %in% names(df_src)) {
            df_src$TaggedPitchType <- df_src$PitchType %||% df_src$Pitch %||% df_src$SplitColumn
          }
          df_src <- df_src %>%
            dplyr::mutate(SplitColumn = dplyr::coalesce(as.character(SplitColumn), "Unknown"))
          
          swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
          is_term <- (
            (!is.na(df_src$PlayResult) & df_src$PlayResult != "Undefined") |
              (!is.na(df_src$KorBB) & df_src$KorBB %in% c("Strikeout","Walk"))
          )
          term <- df_src[is_term, , drop = FALSE]
          
          per_split <- term %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              PA   = dplyr::n(),
              HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
              Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
              SFct = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
              IBBct= sum(PlayResult == "IntentionalWalk", na.rm = TRUE),
              `1B` = sum(PlayResult == "Single",  na.rm = TRUE),
              `2B` = sum(PlayResult == "Double",  na.rm = TRUE),
              `3B` = sum(PlayResult == "Triple",  na.rm = TRUE),
              HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
              Kct  = sum(KorBB == "Strikeout" |
                           PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
              BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
              .groups = "drop"
            ) %>%
            dplyr::mutate(
              AB  = PA - (BBct + HBP + Sac),
              H   = `1B` + `2B` + `3B` + HR,
              TB  = 1*`1B` + 2*`2B` + 3*`3B` + 4*HR,
              AVG = safe_div_local(H, AB),
              SLG = safe_div_local(TB, AB),
              OBP = safe_div_local(H + BBct + HBP, PA),
              OPS = SLG + OBP,
              ISO = SLG - AVG,
              uBB = BBct - IBBct,
              wOBA_num = 0.690*uBB + 0.722*HBP + 0.888*`1B` + 1.271*`2B` + 1.616*`3B` + 2.101*HR,
              wOBA_den = AB + BBct - IBBct + SFct + HBP,
              wOBA = safe_div_local(wOBA_num, wOBA_den)
            )
          
          pitch_totals <- df_src %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              Pitches = dplyr::n(),
              Swings  = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
              Whiffs  = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
              .groups = "drop"
            )
          total_pitches <- sum(pitch_totals$Pitches, na.rm = TRUE)
          
          bbe <- df_src %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
          evla <- bbe %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(EV = nz_mean_local(ExitSpeed), LA = nz_mean_local(Angle), .groups = "drop")
          gb <- bbe %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              `GB%` = safe_div_local(sum(TaggedHitType == "GroundBall", na.rm = TRUE),
                                     sum(!is.na(TaggedHitType),        na.rm = TRUE)),
              .groups = "drop"
            )
          
          parse_pct_prop <- function(x) {
            x_num <- suppressWarnings(as.numeric(sub("%$", "", as.character(x))))
            ifelse(is.finite(x_num), x_num / 100, NA_real_)
          }
          
          extras_raw <- compute_process_results(df_src)
          extras <- extras_raw %>%
            {
              df_proc <- .
              if (!"SplitColumn" %in% names(df_proc) && "PitchType" %in% names(df_proc)) {
                df_proc <- dplyr::rename(df_proc, SplitColumn = PitchType)
              }
              df_proc
            } %>%
            dplyr::mutate(
              xWOBA     = suppressWarnings(as.numeric(xWOBA)),
              xISO      = suppressWarnings(as.numeric(xISO)),
              BABIP     = suppressWarnings(as.numeric(BABIP)),
              `Barrel%` = parse_pct_prop(`Barrel%`)
            ) %>%
            dplyr::select(SplitColumn, xWOBA, xISO, BABIP, `Barrel%`)
          
          res_pt <- per_split %>%
            dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
            dplyr::left_join(evla,         by = "SplitColumn") %>%
            dplyr::left_join(gb,           by = "SplitColumn") %>%
            dplyr::mutate(
              `Swing%` = safe_div_local(Swings, Pitches),
              `Whiff%` = safe_div_local(Whiffs, Swings)
            ) %>%
            dplyr::left_join(extras, by = "SplitColumn") %>%
            dplyr::transmute(
              !!split_col_name := as.character(SplitColumn),
              PA, AB, AVG, SLG, OBP, OPS,
              wOBA, xWOBA,
              ISO, xISO, BABIP,
              `Swing%`, `Whiff%`, `GB%`,
              `K%` = safe_div_local(Kct, PA),
              `BB%` = safe_div_local(BBct, PA),
              `Barrel%`,
              EV, LA
            )
          
          # All-row
          PAt <- nrow(term)
          HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
          Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
          H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
          H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
          H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
          HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
          H   <- H1 + H2 + H3 + HR
          IBB_all <- sum(term$PlayResult == "IntentionalWalk", na.rm = TRUE)
          TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
          Kct_all <- sum(term$KorBB == "Strikeout" |
                           term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
          BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
          ABt <- PAt - (BBc_all + HBP_all + Sac_all)
          swings  <- sum(!is.na(df_src$PitchCall) & df_src$PitchCall %in% swing_levels, na.rm = TRUE)
          whiffs  <- sum(df_src$PitchCall == "StrikeSwinging",                      na.rm = TRUE)
          gbpct_all <- {
            d <- df_src %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
            safe_div_local(sum(d$TaggedHitType == "GroundBall", na.rm = TRUE),
                           sum(!is.na(d$TaggedHitType),         na.rm = TRUE))
          }
          bbe_all <- df_src %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
          
          all_row <- tibble::tibble(
            !!split_col_name := "All",
            PA = PAt,
            AB = ABt,
            AVG = safe_div_local(H, ABt),
            SLG = safe_div_local(TB, ABt),
            OBP = safe_div_local(H + BBc_all + HBP_all, PAt),
            OPS = NA_real_,
            xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
            `Swing%` = safe_div_local(swings, total_pitches),
            `Whiff%` = safe_div_local(whiffs, swings),
            `GB%`    = gbpct_all,
            `K%`     = safe_div_local(Kct_all, PAt),
            `BB%`    = safe_div_local(BBc_all, PAt),
            `Barrel%`= NA_real_,
            EV = nz_mean_local(bbe_all$ExitSpeed),
            LA = nz_mean_local(bbe_all$Angle),
            ISO = SLG - AVG,
            wOBA = {
              uBB_all <- BBc_all - IBB_all
              num <- 0.690*uBB_all + 0.722*HBP_all + 0.888*H1 + 1.271*H2 + 1.616*H3 + 2.101*HR
              den <- ABt + BBc_all - IBB_all + Sac_all + HBP_all
              safe_div_local(num, den)
            }
          ) %>%
            dplyr::mutate(OPS = SLG + OBP)
          
          # Fill All-row process metrics using a single-group compute (avoids unweighted averaging across splits)
          extras_all <- {
            df_all <- df_src
            df_all$SplitColumn <- "All"
            compute_process_results(df_all) %>%
              dplyr::mutate(
                xWOBA     = suppressWarnings(as.numeric(xWOBA)),
                xISO      = suppressWarnings(as.numeric(xISO)),
                BABIP     = suppressWarnings(as.numeric(BABIP)),
                `Barrel%` = parse_pct_prop(`Barrel%`)
              ) %>%
              dplyr::summarise(
                xWOBA = nz_mean_local(xWOBA),
                xISO  = nz_mean_local(xISO),
                BABIP = nz_mean_local(BABIP),
                `Barrel%` = nz_mean_local(`Barrel%`),
                .groups = "drop"
              )
          }
          if (nrow(extras_all)) {
            all_row$xWOBA     <- extras_all$xWOBA[1]
            all_row$xISO      <- extras_all$xISO[1]
            all_row$BABIP     <- extras_all$BABIP[1]
            all_row$`Barrel%` <- extras_all$`Barrel%`[1]
          }
          
          res <- dplyr::bind_rows(res_pt, all_row)
          if (identical(split_choice, "Pitch Types") && split_col_name == "Pitch") {
            ord <- names(all_colors)
            res[[split_col_name]] <- factor(res[[split_col_name]], levels = c(ord, setdiff(res[[split_col_name]], ord)))
            res <- res %>% dplyr::arrange(res[[split_col_name]])
            res[[split_col_name]] <- as.character(res[[split_col_name]])
          }
          res
        }
        
        build_swing_decisions_hit <- function(df_src) {
          if (!nrow(df_src)) {
            return(DT::datatable(
              data.frame(Message = "No data for Swing Decisions"),
              options = list(dom = 't', autoWidth = FALSE), rownames = FALSE
            ))
          }
          if (!"SplitColumn" %in% names(df_src)) {
            df_src$SplitColumn <- if ("TaggedPitchType" %in% names(df_src)) {
              as.character(df_src$TaggedPitchType)
            } else {
              "Unknown"
            }
          }
          df_src <- df_src %>%
            dplyr::mutate(SplitColumn = dplyr::coalesce(as.character(SplitColumn), "Unknown"))
          
          inner_half <- 7 / 12
          mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
          mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
          green_xmin <- mid_x - inner_half
          green_xmax <- mid_x + inner_half
          green_ymin <- mid_y - inner_half
          green_ymax <- mid_y + inner_half
          
          df_sd <- df_src %>%
            dplyr::mutate(
              is_swing = !is.na(PitchCall) & PitchCall %in% c("StrikeSwinging","FoulBall","FoulBallFieldable","FoulBallNotFieldable","InPlay"),
              in_green = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
              in_zone = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
              possd_point = dplyr::case_when(
                in_green & is_swing ~ 2,
                in_green & !is_swing ~ -1,
                in_zone & !in_green & is_swing ~ 1,
                in_zone & !in_green & !is_swing ~ 0,
                !in_zone & is_swing ~ -1,
                !in_zone & !is_swing ~ 1,
                TRUE ~ 0
              )
            )
          
          summarize_sd <- function(dat) {
            total_pitches <- nrow(dat)
            swings <- sum(dat$is_swing, na.rm = TRUE)
            fps_num <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0 &
                             !is.na(dat$PitchCall) & dat$PitchCall %in% c("StrikeSwinging","InPlay","FoulBall","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
            fps_den <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0, na.rm = TRUE)
            called <- sum(!is.na(dat$PitchCall) & dat$PitchCall == "StrikeCalled", na.rm = TRUE)
            chase_num <- sum(dat$is_swing & !dat$in_zone, na.rm = TRUE)
            chase_den <- sum(!dat$in_zone, na.rm = TRUE)
            gozone_sw_num <- sum(dat$is_swing & dat$in_green, na.rm = TRUE)
            gozone_sw_den <- sum(dat$in_green, na.rm = TRUE)
            iz_sw_num <- sum(dat$is_swing & dat$in_zone, na.rm = TRUE)
            iz_sw_den <- sum(dat$in_zone, na.rm = TRUE)
            edge_sw_num <- sum(dat$is_swing & dat$in_zone & !dat$in_green, na.rm = TRUE)
            edge_sw_den <- sum(dat$in_zone & !dat$in_green, na.rm = TRUE)
            possd_points <- sum(dat$possd_point, na.rm = TRUE)
            
            tibble::tibble(
              `Swing%` = safe_div_local(swings, total_pitches) * 100,
              `FPS%` = safe_div_local(fps_num, fps_den) * 100,
              `Called%` = safe_div_local(called, total_pitches) * 100,
              `Chase%` = safe_div_local(chase_num, chase_den) * 100,
              `GoZoneSw%` = safe_div_local(gozone_sw_num, gozone_sw_den) * 100,
              `IZswing%` = safe_div_local(iz_sw_num, iz_sw_den) * 100,
              `EdgeSwing%` = safe_div_local(edge_sw_num, edge_sw_den) * 100,
              `PosSD%` = safe_div_local(possd_points, total_pitches) * 100
            )
          }
          
          swing_decision_by_type <- df_sd %>%
            dplyr::group_by(SplitColumn, .drop = FALSE) %>%
            dplyr::group_modify(~ summarize_sd(.x)) %>%
            dplyr::ungroup() %>%
            dplyr::rename(!!split_col_name := SplitColumn)
          
          all_row <- summarize_sd(df_sd) %>%
            dplyr::mutate(!!split_col_name := "All")
          
          df_swing_decision <- dplyr::bind_rows(swing_decision_by_type, all_row)
          
          if (split_choice == "Pitch Types" && split_col_name %in% names(df_swing_decision)) {
            ord_all <- if (exists("ordered_types") && is.function(ordered_types)) ordered_types() else names(all_colors)
            ord <- ord_all[ord_all %in% as.character(df_swing_decision[[split_col_name]])]
            uniq_vals <- as.character(df_swing_decision[[split_col_name]])
            other <- setdiff(uniq_vals, c(ord, "All"))
            df_swing_decision[[split_col_name]] <- factor(
              df_swing_decision[[split_col_name]],
              levels = c(ord, other, "All")
            )
            df_swing_decision <- df_swing_decision %>%
              dplyr::arrange(.data[[split_col_name]]) %>%
              dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
            all_rows_sd <- df_swing_decision[df_swing_decision[[split_col_name]] == "All", , drop = FALSE]
            other_rows_sd <- df_swing_decision[df_swing_decision[[split_col_name]] != "All", , drop = FALSE]
            df_swing_decision <- dplyr::bind_rows(other_rows_sd, all_rows_sd)
          }
          
          pct_cols_sd <- c("Swing%", "FPS%", "Called%", "Chase%", "GoZoneSw%", "IZswing%", "EdgeSwing%", "PosSD%")
          for (col in pct_cols_sd) if (col %in% names(df_swing_decision)) {
            v <- suppressWarnings(as.numeric(df_swing_decision[[col]]))
            df_swing_decision[[col]] <- ifelse(is.finite(v), paste0(round(v, 1), "%"), "")
          }
          if (identical(split_choice, "Pitch Types") && split_col_name == "Pitch") {
            ord <- names(all_colors)
            df_swing_decision[[split_col_name]] <- factor(df_swing_decision[[split_col_name]], levels = c(ord, setdiff(df_swing_decision[[split_col_name]], ord)))
            df_swing_decision <- df_swing_decision %>% dplyr::arrange(.data[[split_col_name]])
            df_swing_decision[[split_col_name]] <- as.character(df_swing_decision[[split_col_name]])
          }
          
          datatable_with_colvis(
            df_swing_decision,
            lock            = split_col_name,
            remember        = FALSE,
            default_visible = c(split_col_name, pct_cols_sd),
            mode            = NULL,
            enable_colors   = FALSE
          )
        }
        
        # Render hitting table based on mode
        if (identical(mode, "Swing Decisions")) {
          return(build_swing_decisions_hit(df))
        }
        
        results_df <- build_results_table_hit(df)
        if (!nrow(results_df)) {
          return(DT::datatable(
            data.frame(Message = "No data for selected filters"),
            options = list(dom = 't'), rownames = FALSE
          ))
        }
        num_cols <- c("PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
                      "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
        results_df <- results_df %>%
          dplyr::mutate(dplyr::across(dplyr::all_of(num_cols), ~ suppressWarnings(as.numeric(.)))) %>%
          {
            df_tmp <- .
            pct_cols  <- c("Swing%","Whiff%","GB%","K%","BB%","Barrel%")
            rate_cols <- c("AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP")
            for (nm in pct_cols) if (nm %in% names(df_tmp)) df_tmp[[nm]] <- ifelse(is.finite(df_tmp[[nm]]), paste0(round(df_tmp[[nm]]*100,1), "%"), "")
            for (nm in rate_cols) if (nm %in% names(df_tmp)) df_tmp[[nm]] <- ifelse(is.finite(df_tmp[[nm]]), fmt_avg_local(df_tmp[[nm]]), "")
            if ("EV" %in% names(df_tmp)) df_tmp$EV <- ifelse(is.finite(df_tmp$EV), round(df_tmp$EV,1), "")
            if ("LA" %in% names(df_tmp)) df_tmp$LA <- ifelse(is.finite(df_tmp$LA), round(df_tmp$LA,1), "")
            df_tmp
          }
        
        visible_cols_base <- c(split_col_name, "PA", "AB", "AVG", "SLG", "OBP", "OPS", "xWOBA", "xISO", "BABIP",
                               "wOBA", "ISO",
                               "Swing%", "Whiff%", "GB%", "K%", "BB%", "Barrel%", "EV", "LA")
        if (identical(mode, "Custom")) {
          custom_cols <- custom_cols[custom_cols %in% visible_cols_base]
          visible_cols <- unique(c(split_col_name, custom_cols))
          if (length(visible_cols) == 1) visible_cols <- visible_cols_base
        } else {
          visible_cols <- visible_cols_base
        }
        
        return(datatable_with_colvis(
          results_df,
          lock = split_col_name,
          remember = FALSE,
          default_visible = intersect(visible_cols, names(results_df)),
          mode = NULL,
          enable_colors = FALSE
        ))
      }
      
      # --- helpers (copied from your DP page) ---
      nz_mean <- function(x) { x <- suppressWarnings(as.numeric(x)); m <- mean(x, na.rm = TRUE); if (is.finite(m)) m else NA_real_ }
      fmt_avg <- function(x) { z <- ifelse(is.finite(x), sprintf("%.3f", x), NA_character_); sub("^0", "", z) }
      safe_div <- function(num, den) ifelse(den > 0, num/den, NA_real_)
      parse_num <- function(x) {
        if (is.numeric(x)) return(x)
        x1 <- trimws(as.character(x)); x1[x1 == ""] <- NA_character_
        ifelse(grepl("%$", x1), suppressWarnings(as.numeric(sub("%$","",x1)))/100,
               suppressWarnings(as.numeric(x1)))
      }
      ip_fmt <- function(ip_raw) {
        out <- rep("", length(ip_raw))
        ok  <- is.finite(ip_raw) & ip_raw > 0
        outs <- floor(ip_raw[ok]*3 + 1e-8)
        inn  <- outs %/% 3
        rem  <- outs %% 3
        out[ok] <- paste0(inn, ".", rem)
        out
      }
      FIP_C <- if (exists("FIP_CONST")) get("FIP_CONST") else 3.20
      
      if (identical(mode, "Results")) {
        # Ensure SplitColumn exists (should have been created by apply_split_by)
        if (!"SplitColumn" %in% names(df)) {
          df$SplitColumn <- if ("TaggedPitchType" %in% names(df)) {
            as.character(df$TaggedPitchType)
          } else {
            "Unknown"
          }
        }
        
        swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
        is_term <- (
          (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
            (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk"))
        )
        term <- df[is_term, , drop = FALSE]
        
        per_type <- term %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            PA   = dplyr::n(),
            HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
            `1B` = sum(PlayResult == "Single",  na.rm = TRUE),
            `2B` = sum(PlayResult == "Double",  na.rm = TRUE),
            `3B` = sum(PlayResult == "Triple",  na.rm = TRUE),
            HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
            Kct  = sum(KorBB == "Strikeout" |
                         PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
            BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
            .groups = "drop"
          ) %>%
          dplyr::mutate(
            AB  = PA - (BBct + HBP + Sac),
            H   = `1B` + `2B` + `3B` + HR,
            TB  = 1*`1B` + 2*`2B` + 3*`3B` + 4*HR,
            AVG = safe_div(H, AB),
            SLG = safe_div(TB, AB),
            OBP = safe_div(H + BBct + HBP, PA),
            OPS = SLG + OBP
          )
        
        pitch_totals <- df %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            Pitches       = dplyr::n(),
            Swings        = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
            Whiffs        = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
            CalledStrikes = sum(PitchCall == "StrikeCalled",    na.rm = TRUE),
            .groups = "drop"
          )
        total_pitches <- sum(pitch_totals$Pitches, na.rm = TRUE)
        
        scores <- ifelse(
          df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
            df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
          ifelse(
            df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
              df$PlateLocHeight >= (2.65 - 1.5) & df$PlateLocHeight <= (2.65 + 1.5),
            0.73, 0
          )
        )
        sc_by_type <- df %>%
          dplyr::mutate(.scores = scores) %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            StuffP   = round(nz_mean(`Stuff+`), 1),
            CommandP = round(nz_mean(.scores) * 100, 1),
            .groups = "drop"
          ) %>%
          dplyr::mutate(PitchingP = round((StuffP + CommandP)/2, 1))
        
        bbe <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
        evla <- bbe %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(EV = nz_mean(ExitSpeed), LA = nz_mean(Angle), .groups = "drop")
        gb <- bbe %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            `GB%` = safe_div(sum(TaggedHitType == "GroundBall", na.rm = TRUE),
                             sum(!is.na(TaggedHitType),        na.rm = TRUE)),
            .groups = "drop"
          )
        
        extras <- compute_process_results(df) %>%
          dplyr::rename(Pitch = PitchType) %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::select(Pitch, xWOBA, xISO, BABIP, `Barrel%`, `RV/100`)
        
        res_pt <- per_type %>%
          dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
          dplyr::left_join(evla,         by = "SplitColumn") %>%
          dplyr::left_join(gb,           by = "SplitColumn") %>%
          dplyr::mutate(
            `Swing%` = safe_div(Swings, Pitches),
            `Whiff%` = safe_div(Whiffs, Swings),
            `CSW%`   = safe_div(Whiffs + CalledStrikes, Pitches),
            Outs     = (AB - H) + Sac,
            IP_raw   = safe_div(Outs, 3),
            BF       = PA,
            `#`      = Pitches,
            Usage    = ifelse(total_pitches > 0, paste0(round(100*Pitches/total_pitches,1), "%"), ""),
            FIP_tmp  = safe_div(13*HR + 3*(BBct + HBP) - 2*Kct, IP_raw),
            FIP      = ifelse(is.finite(FIP_tmp), round(FIP_tmp + FIP_C, 2), NA_real_),
            WHIP_tmp = safe_div(H + BBct, IP_raw),
            WHIP     = ifelse(is.finite(WHIP_tmp), round(WHIP_tmp, 2), NA_real_)
          ) %>%
          dplyr::left_join(sc_by_type, by = "SplitColumn") %>%
          dplyr::left_join(extras, by = c("SplitColumn" = "Pitch")) %>%
          dplyr::transmute(
            Pitch = as.character(SplitColumn),
            `#`, Usage, BF, `RV/100`, IP = ip_fmt(IP_raw), FIP, WHIP,
            PA, AB, AVG, SLG, OBP, OPS,
            xWOBA, xISO, BABIP,
            `Swing%`, `Whiff%`, `CSW%`, `GB%`,
            `K%` = safe_div(Kct, PA), `BB%` = safe_div(BBct, PA),
            `Barrel%`, EV, LA,
            `Pitching+` = PitchingP
          )
        
        PAt <- nrow(term)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
        H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
        H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
        HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        H   <- H1 + H2 + H3 + HR
        TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
        Kct_all <- sum(term$KorBB == "Strikeout" |
                         term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
        BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        ABt <- PAt - (BBc_all + HBP_all + Sac_all)
        swings  <- sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE)
        whiffs  <- sum(df$PitchCall == "StrikeSwinging",                      na.rm = TRUE)
        gbpct_all <- {
          d <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
          safe_div(sum(d$TaggedHitType == "GroundBall", na.rm = TRUE),
                   sum(!is.na(d$TaggedHitType),         na.rm = TRUE))
        }
        Outs_all <- (ABt - H) + Sac_all
        IP_all   <- safe_div(Outs_all, 3)
        FIP_all  <- {
          tmp <- safe_div(13*HR + 3*(BBc_all + HBP_all) - 2*Kct_all, IP_all)
          ifelse(is.finite(tmp), round(tmp + FIP_C, 2), NA_real_)
        }
        WHIP_all <- {
          tmp <- safe_div(H + BBc_all, IP_all)
          ifelse(is.finite(tmp), round(tmp, 2), NA_real_)
        }
        stuff_all <- round(nz_mean(df$`Stuff+`), 1)
        qp_all    <- round(nz_mean(compute_qp_points(df)) * 200, 1)
        pitc_all  <- round((stuff_all + qp_all) / 2, 1)
        
        all_row <- tibble::tibble(
          Pitch = "All",
          `#`   = nrow(df),
          Usage = "100%",
          BF = PAt,
          IP = ip_fmt(IP_all),
          FIP = FIP_all,
          WHIP = WHIP_all,
          PA = PAt, AB = ABt,
          AVG = safe_div(H, ABt),
          SLG = safe_div(TB, ABt),
          OBP = safe_div(H + BBc_all + HBP_all, PAt),
          OPS = NA_real_,
          xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
          `Swing%` = safe_div(swings, total_pitches),
          `Whiff%` = safe_div(whiffs, swings),
          `GB%`    = gbpct_all,
          `K%`     = safe_div(Kct_all, PAt),
          `BB%`    = safe_div(BBc_all, PAt),
          `Barrel%`= NA_real_,
          EV = nz_mean(bbe$ExitSpeed),
          LA = nz_mean(bbe$Angle),
          `Pitching+` = pitc_all
        )
        all_row$OPS <- all_row$SLG + all_row$OBP
        
        extras_all <- compute_process_results(df) %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::summarise(
            xWOBA     = nz_mean(xWOBA),
            xISO      = nz_mean(xISO),
            BABIP     = nz_mean(BABIP),
            `Barrel%` = nz_mean(`Barrel%`),
            .groups = "drop"
          )
        if (nrow(extras_all)) {
          all_row$xWOBA     <- extras_all$xWOBA[1]
          all_row$xISO      <- extras_all$xISO[1]
          all_row$BABIP     <- extras_all$BABIP[1]
          all_row$`Barrel%` <- extras_all$`Barrel%`[1]
        }
        
        df_out <- dplyr::bind_rows(res_pt, all_row) %>%
          dplyr::mutate(
            dplyr::across(c(PA, AB, AVG, SLG, OBP, OPS, xWOBA, xISO, BABIP,
                            `Swing%`, `Whiff%`, `CSW%`, `GB%`, `K%`, `BB%`, `Barrel%`,
                            EV, LA, FIP, WHIP),
                          ~ suppressWarnings(as.numeric(.)))
          )
        pct_cols  <- c("Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%")
        rate_cols <- c("AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP")
        df_out[pct_cols]  <- lapply(df_out[pct_cols],  function(z) ifelse(is.finite(z), paste0(round(z*100,1), "%"), ""))
        df_out[rate_cols] <- lapply(df_out[rate_cols], function(z) ifelse(is.finite(z), fmt_avg(z), ""))
        df_out$EV   <- ifelse(is.finite(df_out$EV),   round(df_out$EV, 1), "")
        df_out$LA   <- ifelse(is.finite(df_out$LA),   round(df_out$LA, 1), "")
        df_out$FIP  <- ifelse(is.finite(df_out$FIP),  sprintf("%.2f", df_out$FIP), "")
        df_out$WHIP <- ifelse(is.finite(df_out$WHIP), sprintf("%.2f", df_out$WHIP), "")
        
        df_dt <- if (exists("safe_for_dt")) safe_for_dt(df_out) else df_out
        names(df_dt)[names(df_dt) == "Pitch"] <- split_col_name
        is_all <- df_dt[[split_col_name]] == "All"
        for (nm in c("Swing%","Whiff%","CSW%","GB%","K%","BB%")) {
          z <- df_dt[[nm]]
          z[is_all & (is.na(z) | trimws(z) == "")] <- "0.0%"
          df_dt[[nm]] <- z
        }
        
        visible_set <- visible_set_for(mode, custom_cols)
        if (identical(mode, "Custom")) {
          order_cols <- unique(c("Pitch", custom_cols))
          extras <- setdiff(names(df_dt), order_cols)
          df_dt <- df_dt[, c(order_cols, extras), drop = FALSE]
        }
        return(datatable_with_colvis(
          df_dt,
          lock            = split_col_name,
          remember        = FALSE,
          default_visible = intersect(visible_set, names(df_dt)),
          mode            = mode,
          enable_colors   = enable_colors
        ))
      }
      
      # ---- RAW DATA TABLE ----
      if (identical(mode, "Raw Data")) {
        # Helper function for innings pitched calculation
        ip_calculation <- function(pitches_data) {
          outs <- sum(pitches_data$KorBB == "Strikeout", na.rm = TRUE) + 
            sum(pitches_data$PlayResult %in% c("Out", "FieldersChoice", "Error"), na.rm = TRUE)
          innings <- outs / 3
          whole_innings <- floor(innings)
          remaining_outs <- outs %% 3
          if (remaining_outs == 0) {
            return(paste0(whole_innings, ".0"))
          } else {
            return(paste0(whole_innings, ".", remaining_outs))
          }
        }
        
        # Use SplitColumn if available (from split_by), otherwise TaggedPitchType
        group_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
        
        raw_per_type <- df %>%
          dplyr::group_by(!!rlang::sym(group_col)) %>%
          dplyr::summarise(
            IP = ip_calculation(dplyr::cur_data_all()),
            P = dplyr::n(),
            BF = calculate_bf(dplyr::cur_data_all()),
            H = sum(PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE),
            XBH = sum(PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE),
            Barrels = sum(ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, na.rm = TRUE),
            BB = sum(KorBB == "Walk", na.rm = TRUE),
            HBP = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            K = sum(KorBB == "Strikeout", na.rm = TRUE),
            Whiffs = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
            .groups = "drop"
          )
        
        # Rename the grouping column to split_col_name
        names(raw_per_type)[names(raw_per_type) == group_col] <- split_col_name
        
        # If split by Pitch Types, order them properly
        if (split_choice == "Pitch Types" && split_col_name == "Pitch") {
          # Define standard pitch order
          pitch_order <- c("Fastball", "Sinker", "Cutter", "Slider", "Sweeper", 
                           "Curveball", "ChangeUp", "Splitter", "Knuckleball", "Other")
          raw_per_type <- raw_per_type %>%
            dplyr::mutate(!!rlang::sym(split_col_name) := factor(
              !!rlang::sym(split_col_name), 
              levels = c(pitch_order, setdiff(unique(!!rlang::sym(split_col_name)), pitch_order))
            )) %>%
            dplyr::arrange(!!rlang::sym(split_col_name)) %>%
            dplyr::mutate(!!rlang::sym(split_col_name) := as.character(!!rlang::sym(split_col_name)))
        }
        
        # All row calculations
        all_ip <- ip_calculation(df)
        all_p <- nrow(df)
        all_bf <- calculate_bf(df)
        all_h <- sum(df$PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
        all_xbh <- sum(df$PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE)
        all_barrels <- sum(df$ExitSpeed >= 95 & df$Angle >= 10 & df$Angle <= 35, na.rm = TRUE)
        all_bb <- sum(df$KorBB == "Walk", na.rm = TRUE)
        all_hbp <- sum(df$PlayResult == "HitByPitch", na.rm = TRUE)
        all_k <- sum(df$KorBB == "Strikeout", na.rm = TRUE)
        all_whiffs <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
        
        # Calculate P/IP and P/BF for All row only
        # Convert IP from "X.Y" format to decimal (X + Y/3)
        ip_decimal <- if (all_ip != "0.0") {
          parts <- strsplit(all_ip, "\\.")[[1]]
          as.numeric(parts[1]) + as.numeric(parts[2])/3
        } else 0
        
        p_per_ip <- if (ip_decimal > 0) as.character(round(all_p / ip_decimal, 1)) else ""
        p_per_bf <- if (all_bf > 0) as.character(round(all_p / all_bf, 1)) else ""
        
        # Create all_row dynamically with split column name
        all_row_data <- list(
          IP = all_ip,
          P = all_p,
          BF = all_bf,
          `P/IP` = p_per_ip,
          `P/BF` = p_per_bf,
          H = all_h,
          XBH = all_xbh,
          Barrels = all_barrels,
          BB = all_bb,
          HBP = all_hbp,
          K = all_k,
          Whiffs = all_whiffs
        )
        all_row_data[[split_col_name]] <- "All"
        all_row <- tibble::as_tibble(all_row_data)
        
        # Add empty P/IP and P/BF columns to per-type data
        raw_per_type$`P/IP` <- ""
        raw_per_type$`P/BF` <- ""
        
        # Reorder columns to match desired layout with dynamic split column name
        col_order <- c(split_col_name, "IP", "P", "BF", "P/IP", "P/BF", "H", "XBH", "Barrels", "BB", "HBP", "K", "Whiffs")
        raw_per_type <- raw_per_type[, col_order]
        
        df_raw <- dplyr::bind_rows(raw_per_type, all_row)
        
        # Column already renamed above, no need to rename again
        visible_set <- names(df_raw)
        table_cache <- df_raw
        return(datatable_with_colvis(
          df_raw,
          lock            = split_col_name,
          remember        = FALSE,
          default_visible = visible_set,
          mode            = mode,
          enable_colors   = FALSE
        ))
      }
      
      # ---- NON-Results modes (match DP page) ----
      # QP+ per pitch type
      qp_by_type <- df %>%
        dplyr::group_by(TaggedPitchType) %>%
        dplyr::summarise(
          `QP+` = {
            vals <- compute_qp_points(dplyr::cur_data_all())
            vals <- suppressWarnings(as.numeric(vals))
            round(mean(vals, na.rm = TRUE) * 200, 1)
          },
          .groups = "drop"
        )
      
      summ <- safe_make_summary(df)
      summ <- dplyr::mutate(summ,
                            ReleaseTilt = as.character(ReleaseTilt),
                            BreakTilt   = as.character(BreakTilt)
      )
      if (!("QP+" %in% names(summ))) {
        summ <- summ %>% dplyr::left_join(qp_by_type, by = c("PitchType" = "TaggedPitchType"))
      }
      
      
      
      # Percent-ish columns: if they already end with "%", keep; else format smartly
      pct_cols <- c("SpinEff","InZonePercent","CompPercent","KPercent","BBPercent",
                    "FPSPercent","EAPercent","QPPercent","StrikePercent","SwingPercent","WhiffPercent")
      for (nm in pct_cols) if (nm %in% names(summ)) {
        x <- summ[[nm]]
        if (is.numeric(x)) {
          # scale: treat <=1.5 as proportions (0–1), otherwise already percent-like
          scale100 <- if (all(!is.na(x)) && max(x, na.rm = TRUE) <= 1.5) 100 else 1
          summ[[nm]] <- ifelse(is.finite(x), paste0(round(x * scale100, 1), "%"), "")
        } else {
          x <- as.character(x)
          has_pct <- grepl("%$", x)
          if (!all(has_pct | is.na(x) | x == "")) {
            v <- suppressWarnings(as.numeric(x))
            scale100 <- if (all(!is.na(v)) && max(v, na.rm = TRUE) <= 1.5) 100 else 1
            fmt <- ifelse(is.finite(v), paste0(round(v * scale100, 1), "%"), x)
            x[!has_pct] <- fmt[!has_pct]
          }
          summ[[nm]] <- x
        }
      }
      
      
      # Percent-like columns (DP page expects strings with %)
      for (nm in c("SpinEff","InZonePercent","CompPercent","KPercent","BBPercent",
                   "FPSPercent","EAPercent","QPPercent","StrikePercent","SwingPercent","WhiffPercent")) {
        if (nm %in% names(summ) && !is.character(summ[[nm]])) {
          # SpinEff is stored as a rate (0–1) in many builds, same pctify works
          summ[[nm]] <- pctify(summ[[nm]])
        }
      }
      
      scores <- ifelse(
        df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
          df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
        ifelse(
          df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
            df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5),
          0.73, 0
        )
      )
      has_pc  <- sum(!is.na(df$PitchCall)) > 0
      strikes <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
      sw      <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
      den     <- sum(df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
      csw_all <- sum(df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
      bf_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
      fps_opp <- bf_live
      k_live  <- sum(df$SessionType == "Live" & df$KorBB == "Strikeout",        na.rm = TRUE)
      bb_live <- sum(df$SessionType == "Live" & df$KorBB == "Walk",             na.rm = TRUE)
      fps_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0 &
                        df$PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
      ea_live  <- sum(df$SessionType == "Live" & (
        (df$Balls == 0 & df$Strikes == 0 & df$PitchCall == "InPlay") |
          (df$Balls == 0 & df$Strikes == 1 & df$PitchCall %in% c(
            "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
          )) |
          (df$Balls == 1 & df$Strikes == 0 & df$PitchCall == "InPlay") |
          (df$Balls == 1 & df$Strikes == 1 & df$PitchCall %in% c(
            "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
          ))
      ),
      na.rm = TRUE
      )
      
      vmax   <- suppressWarnings(max(as.numeric(df$RelSpeed), na.rm = TRUE)); vmax <- if (is.finite(vmax)) round(vmax, 1) else NA_real_
      ev_all <- nz_mean(ifelse(df$SessionType=="Live", df$ExitSpeed, NA_real_))
      la_all <- nz_mean(ifelse(df$SessionType=="Live", df$Angle,     NA_real_))
      stuff_all <- round(nz_mean(df$`Stuff+`), 1)
      ctrl_all   <- round(nz_mean(scores) * 100, 1)
      qp_all    <- round(nz_mean(compute_qp_points(df)) * 200, 1)
      
      df_table <- dplyr::bind_rows(
        summ,
        tibble::tibble(
          PitchType     = "All",
          PitchCount    = nrow(df),
          Usage         = "100%",
          Overall       = "100%",
          BF            = bf_live,
          Velo_Avg      = round(nz_mean(df$RelSpeed), 1),
          Velo_Max      = vmax,
          IVB           = round(nz_mean(df$InducedVertBreak), 1),
          HB            = round(nz_mean(df$HorzBreak), 1),
          ReleaseTilt   = convert_to_clock(nz_mean(df$ReleaseTilt)),
          BreakTilt     = convert_to_clock(nz_mean(df$BreakTilt)),
          SpinEff       = {
            spineff_val <- nz_mean(df$SpinEfficiency)
            if (is.finite(spineff_val)) paste0(round(spineff_val * 100, 1), "%") else ""
          },
          SpinRate      = round(nz_mean(df$SpinRate), 0),
          RelHeight     = round(nz_mean(df$RelHeight), 1),
          RelSide       = round(nz_mean(df$RelSide), 1),
          VertApprAngle = round(nz_mean(df$VertApprAngle), 1),
          HorzApprAngle = round(nz_mean(df$HorzApprAngle), 1),
          Extension     = round(nz_mean(df$Extension), 1),
          InZonePercent = { inzone <- (df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
                                         df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP)
          safe_pct(sum(inzone, na.rm=TRUE), sum(!is.na(inzone))) },
          CompPercent   = { comp <- (df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                                       df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5))
          safe_pct(sum(comp, na.rm=TRUE), sum(!is.na(comp))) },
          KPercent      = safe_pct(k_live, bf_live),
          BBPercent     = safe_pct(bb_live, bf_live),
          FPSPercent    = safe_pct(fps_live, fps_opp),
          EAPercent     = safe_pct(ea_live, fps_opp),
          StrikePercent = if (has_pc) safe_pct(strikes, nrow(df)) else "",
          SwingPercent  = safe_pct(sum(!is.na(df$PitchCall) & df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","FoulBall","InPlay"), na.rm = TRUE), nrow(df)),
          WhiffPercent  = safe_pct(sw, den),
          EV = ev_all, LA = la_all,
          `Stuff+` = stuff_all, `Ctrl+` = ctrl_all, `QP+` = qp_all
        ) %>% dplyr::mutate(`Pitching+` = round((`Stuff+` + `QP+`)/2, 1))
      ) %>%
        dplyr::rename(
          Pitch  = PitchType,
          `#`    = PitchCount,
          Velo   = Velo_Avg,
          Max    = Velo_Max,
          rTilt  = ReleaseTilt,
          bTilt  = BreakTilt,
          Spin   = SpinRate,
          Height = RelHeight,
          Side   = RelSide,
          Ext    = Extension,
          `InZone%` = InZonePercent,
          `Comp%`   = CompPercent,
          `K%`      = KPercent,
          `BB%`     = BBPercent,
          `FPS%`    = FPSPercent,
          `E+A%`    = EAPercent,
          `QP%`     = QPPercent,
          `Strike%` = StrikePercent,
          `Swing%`  = SwingPercent,
          `Whiff%`  = WhiffPercent,
          VAA       = VertApprAngle,
          HAA       = HorzApprAngle
        ) %>%
        dplyr::mutate(Pitch = as.character(Pitch)) %>%
        dplyr::select(
          Pitch, `#`, Usage, BF,
          Velo, Max, IVB, HB, rTilt, bTilt, SpinEff, Spin, Height, Side, VAA, HAA, Ext,
          `InZone%`, `Comp%`, `Strike%`, `Swing%`, `FPS%`, `E+A%`, `QP%`, `K%`, `BB%`, `Whiff%`, EV, LA,
          `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
        ) %>%
        dplyr::mutate(
          SpinEff = {
            val <- suppressWarnings(as.numeric(SpinEff))
            ifelse(is.na(val), "", paste0(round(val * 100, 1), "%"))
          },
          EV = ifelse(is.na(as.numeric(EV)), "", round(as.numeric(EV), 1)),
          LA = ifelse(is.na(as.numeric(LA)), "", round(as.numeric(LA), 1))
        )
      # --- Standardize decimals like DP: 1 decimal for most, 0 for Spin (RPM) ---
      round1 <- intersect(c("Velo","Max","IVB","HB","Height","Side","VAA","HAA","Ext"), names(df_table))
      for (nm in round1) {
        z <- suppressWarnings(as.numeric(df_table[[nm]]))
        df_table[[nm]] <- ifelse(is.finite(z), round(z, 1), df_table[[nm]])
      }
      
      if ("Spin" %in% names(df_table)) {
        z <- suppressWarnings(as.numeric(df_table$Spin))
        df_table$Spin <- ifelse(is.finite(z), round(z, 0), df_table$Spin)
      }
      
      extras <- compute_process_results(df, mode) %>%
        dplyr::rename(Pitch = PitchType) %>%
        dplyr::mutate(Pitch = as.character(Pitch))
      df_table <- df_table %>% dplyr::left_join(extras, by = "Pitch")
      if (all(c("BF","RV/100") %in% names(df_table))) {
        df_table <- df_table %>% dplyr::relocate(`RV/100`, .after = BF)
      }
      if (identical(mode, "Usage")) {
        usage_extras <- compute_usage_by_count(df) %>%
          dplyr::rename(Pitch = PitchType) %>%
          dplyr::mutate(Pitch = as.character(Pitch)) %>%
          dplyr::select(Pitch, `0-0`,`Behind`,`Even`,`Ahead`,`<2K`,`2K`)
        df_table <- df_table %>% dplyr::left_join(usage_extras, by = "Pitch")
      }
      
      df_table <- collapse_list_cols(df_table)
      is_date_like <- function(x) inherits(x, c("Date","POSIXct","POSIXt","difftime"))
      date_like <- vapply(df_table, is_date_like, logical(1))
      if (any(date_like)) df_table[date_like] <- lapply(df_table[date_like], as.character)
      df_table <- as.data.frame(df_table, stringsAsFactors = FALSE, check.names = FALSE)
      df_table <- fill_all_qp_pct(df_table, df)
      
      if (all(c("Whiff%","CSW%") %in% names(df_table))) {
        df_table <- df_table %>% dplyr::relocate(`CSW%`, .after = `Whiff%`)
      }
      if ("Pitching+" %in% names(df_table)) {
        df_table <- df_table %>% dplyr::relocate(`Pitching+`, .after = dplyr::last_col())
      }
      
      df_table <- enforce_process_order(df_table)
      df_table <- enforce_stuff_order(df_table)
      
      # Before renaming "Pitch" to split_col_name, check if split_col_name already exists
      # If it does (e.g., "IVB" or "HB"), remove the original column to avoid duplicates
      if (split_col_name %in% names(df_table) && split_col_name != "Pitch") {
        # Remove the pre-existing column (the measurement column like IVB or HB)
        df_table <- df_table %>% dplyr::select(-dplyr::all_of(split_col_name))
      }
      
      names(df_table)[names(df_table) == "Pitch"] <- split_col_name
      if (identical(mode, "Custom")) {
        order_cols <- unique(c(split_col_name, custom_cols))
        extras <- setdiff(names(df_table), order_cols)
        df_table <- df_table[, c(order_cols, extras), drop = FALSE]
      }
      visible_set <- visible_set_for(mode, custom_cols)
      # ALWAYS replace "Pitch" with split_col_name in visible_set, not just for Custom mode
      if (split_col_name != "Pitch") {
        visible_set <- gsub("^Pitch$", split_col_name, visible_set)
      }
      datatable_with_colvis(
        df_table,
        lock            = split_col_name,
        remember        = FALSE,
        default_visible = intersect(visible_set, names(df_table)),
        mode            = mode,
        enable_colors   = enable_colors
      )
    }
    
    # Custom table save/load within module
    observeEvent(input$cmpA_customSaved, {
      nm <- input$cmpA_customSaved
      if (!nzchar(nm)) return()
      ct <- custom_tables()
      if (!nm %in% names(ct)) return()
      cols <- ct[[nm]]$cols %||% character(0)
      updateTextInput(session, "cmpA_customName", value = nm)
      updateSelectizeInput(session, "cmpA_customCols", selected = cols)
    }, ignoreInit = TRUE)
    observeEvent(input$cmpA_saveCustom, {
      nm <- trimws(input$cmpA_customName %||% "")
      cols <- input$cmpA_customCols %||% character(0)
      if (!nzchar(nm) || !length(cols)) {
        showNotification("Please enter a name and choose at least one column.", type = "warning")
        return()
      }
      ct <- custom_tables()
      ct[[nm]] <- list(cols = cols)
      custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
      updateSelectInput(session, "cmpA_customSaved", choices = c("", names(ct)), selected = nm)
      showNotification(paste("Saved custom table", nm), type = "message")
    }, ignoreInit = TRUE)
    observeEvent(input$cmpA_deleteCustom, {
      nm <- input$cmpA_customSaved
      if (!nzchar(nm)) return()
      ct <- custom_tables()
      if (nm %in% names(ct)) {
        ct[[nm]] <- NULL
        custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
        updateSelectInput(session, "cmpA_customSaved", choices = c("", names(ct)), selected = "")
        showNotification(paste("Deleted custom table", nm), type = "message")
      }
    }, ignoreInit = TRUE)
    
    observeEvent(input$cmpB_customSaved, {
      nm <- input$cmpB_customSaved
      if (!nzchar(nm)) return()
      ct <- custom_tables()
      if (!nm %in% names(ct)) return()
      cols <- ct[[nm]]$cols %||% character(0)
      updateTextInput(session, "cmpB_customName", value = nm)
      updateSelectizeInput(session, "cmpB_customCols", selected = cols)
    }, ignoreInit = TRUE)
    observeEvent(input$cmpB_saveCustom, {
      nm <- trimws(input$cmpB_customName %||% "")
      cols <- input$cmpB_customCols %||% character(0)
      if (!nzchar(nm) || !length(cols)) {
        showNotification("Please enter a name and choose at least one column.", type = "warning")
        return()
      }
      ct <- custom_tables()
      ct[[nm]] <- list(cols = cols)
      custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
      updateSelectInput(session, "cmpB_customSaved", choices = c("", names(ct)), selected = nm)
      showNotification(paste("Saved custom table", nm), type = "message")
    }, ignoreInit = TRUE)
    observeEvent(input$cmpB_deleteCustom, {
      nm <- input$cmpB_customSaved
      if (!nzchar(nm)) return()
      ct <- custom_tables()
      if (nm %in% names(ct)) {
        ct[[nm]] <- NULL
        custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
        updateSelectInput(session, "cmpB_customSaved", choices = c("", names(ct)), selected = "")
        showNotification(paste("Deleted custom table", nm), type = "message")
      }
    }, ignoreInit = TRUE)
    
    output$cmpA_table <- DT::renderDataTable({
      res <- resolve_table_mode_global(input$cmpA_tableMode, input$cmpA_customCols)
      df_panel <- .filtered_panel("A")
      dom_attr <- attr(df_panel, "domain")
      df_tbl <- apply_split_by(df_panel, input$cmpA_splitBy %||% "Pitch Types")
      attr(df_tbl, "domain") <- dom_attr
      tryCatch(
        .dp_like_table(df_tbl, res$mode, res$cols,
                       enable_colors = isTRUE(input$cmpA_tableColors)),
        error = function(e) {
          message("cmpA_table datatable error: ", conditionMessage(e))
          DT::datatable(
            data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
            options = list(dom = 't'), rownames = FALSE
          )
        }
      )
    })
    output$cmpB_table <- DT::renderDataTable({
      res <- resolve_table_mode_global(input$cmpB_tableMode, input$cmpB_customCols)
      df_panel <- .filtered_panel("B")
      dom_attr <- attr(df_panel, "domain")
      df_tbl <- apply_split_by(df_panel, input$cmpB_splitBy %||% "Pitch Types")
      attr(df_tbl, "domain") <- dom_attr
      tryCatch(
        .dp_like_table(df_tbl, res$mode, res$cols,
                       enable_colors = isTRUE(input$cmpB_tableColors)),
        error = function(e) {
          message("cmpB_table datatable error: ", conditionMessage(e))
          DT::datatable(
            data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
            options = list(dom = 't'), rownames = FALSE
          )
        }
      )
    })
  })
}

# ==================================
# == Correlations Suite ==
# ==================================

# Correlations UI
correlations_ui <- function() {
  fluidPage(
    tags$head(
      tags$style(HTML("
        .correlation-sidebar {
          background-color: #f8f9fa;
          border-right: 1px solid #dee2e6;
          padding: 20px;
          min-height: 100vh;
        }
        .correlation-main {
          padding: 20px;
        }
        .correlation-chart {
          border: 1px solid #dee2e6;
          border-radius: 5px;
          padding: 15px;
          background-color: transparent;
        }
        .correlation-controls {
          margin-bottom: 20px;
        }
        /* Dark mode overrides */
        body.theme-dark .correlation-sidebar {
          background-color: transparent !important;
          border-color: rgba(255,255,255,0.08) !important;
          color: #e5e7eb !important;
        }
        body.theme-dark .correlation-main {
          background: transparent !important;
          color: #e5e7eb !important;
        }
        body.theme-dark .correlation-chart {
          background: transparent !important;
          border-color: rgba(255,255,255,0.12) !important;
          box-shadow: 0 2px 14px rgba(0,0,0,0.35);
        }
        body.theme-dark #corr_summary,
        body.theme-dark #corr_data_table,
        body.theme-dark .correlation-controls label {
          color: #e5e7eb !important;
        }
        body.theme-dark .correlation-controls .form-control,
        body.theme-dark .correlation-controls .selectize-input {
          background: #0f172a !important;
          color: #e5e7eb !important;
          border-color: #1f2937 !important;
        }
      "))
    ),
    fluidRow(
      # Sidebar with controls
      column(3, class = "correlation-sidebar",
             h4("Correlation Analysis Settings"),
             
             # Domain selection
             div(class = "correlation-controls",
                 selectInput("corr_domain", "Domain:",
                             choices = c("Pitching", "Hitting", "Catching"),
                             selected = "Pitching")
             ),
             
             # Team selection
             div(class = "correlation-controls",
                 selectInput("corr_teamType", "Team:",
                             choices = TEAM_CHOICES,
                             selected = "All")
             ),
             
             # Date range
             div(class = "correlation-controls",
                 dateRangeInput("corr_date_range", "Date Range:",
                                start = max(pitch_data$Date, na.rm = TRUE),
                                end = max(pitch_data$Date, na.rm = TRUE),
                                format = "yyyy-mm-dd")
             ),
             
             # Player selection
             div(class = "correlation-controls",
                 selectInput("corr_player", "Select Player:",
                             choices = NULL,
                             multiple = TRUE)
             ),
             
             # Pitch type selection
             div(class = "correlation-controls",
                 selectInput("corr_pitch_type", "Pitch Type:",
                             choices = c("All" = "all"),
                             selected = "all",
                             multiple = TRUE)
             ),
             
             # Stuff+ Base Pitch option
             div(class = "correlation-controls",
                 selectInput("corr_stuff_base", "Stuff+ Base Pitch:",
                             choices = NULL)
             ),
             
             # Variable selection
             div(class = "correlation-controls",
                 selectInput("corr_var_x", "X Variable:",
                             choices = NULL)
             ),
             
             div(class = "correlation-controls",
                 selectInput("corr_var_y", "Y Variable:",
                             choices = NULL)
             ),
             
             # Aggregation level
             div(class = "correlation-controls",
                 radioButtons("corr_aggregation", "Data Level:",
                              choices = c("Player Averages" = "averages",
                                          "Individual Pitches" = "pitches"),
                              selected = "averages")
             ),
             
             # Analysis button
             div(class = "correlation-controls",
                 actionButton("corr_analyze", "Run Correlation Analysis",
                              class = "btn-primary btn-block")
             )
      ),
      
      # Main panel with results
      column(9, class = "correlation-main",
             div(id = "correlations-content",
                 h3("Correlation Analysis Results"),
                 
                 # Results summary
                 div(id = "corr_summary",
                     uiOutput("corr_summary_ui")
                 ),
                 
                 # Correlation chart
                 div(class = "correlation-chart",
                     plotOutput("corr_plot", height = "500px")
                 ),
                 
                 br(),
                 
                 # Data table
                 div(
                   h4("Data Used in Analysis"),
                   DT::dataTableOutput("corr_data_table")
                 )
             ) # Close correlations-content div
      )
    )
  )
}

# ----------------------------------------
# Custom Reports UI / Server (new suite)
# ----------------------------------------
custom_reports_ui <- function(id) {
  ns <- NS(id)
  fluidPage(
    shinyjs::useShinyjs(),  # Enable shinyjs
    div(
      class = "creports-root",
      # Floating show sidebar button (only visible when sidebar is hidden)
      div(id = ns("show_sidebar_btn"), style = "display:none; position:fixed; top:10px; left:10px; z-index:2000;",
          actionButton(ns("show_sidebar"), "Show Sidebar", class = "btn-primary btn-sm")
      ),
      fluidRow(
        # Sidebar with toggle button
        column(3, id = ns("sidebar_column"),
               div(style = "position:relative;",
                   actionButton(ns("toggle_sidebar"), "Hide Sidebar", 
                                class = "btn-sm btn-secondary", 
                                style = "position:absolute; right:5px; top:5px; z-index:1000;"),
                   h4("Report Setup"),
                   textInput(ns("report_title"), "Report Title", ""),
                   selectInput(ns("report_type"), "Report Type:", choices = c("Pitching","Hitting"), selected = "Pitching"),
                   selectInput(ns("report_scope"), "Scope:", choices = c("Single Player","Multi-Player"), selected = "Single Player"),
                   # Single Player mode - show player selector
                   conditionalPanel(
                     sprintf("input['%s'] == 'Single Player'", ns("report_scope")),
                     selectizeInput(ns("report_players"), "Players:", choices = NULL, multiple = TRUE)
                   ),
                   # Multi-Player mode - note about row assignments
                   conditionalPanel(
                     sprintf("input['%s'] == 'Multi-Player'", ns("report_scope")),
                     div(style = "background-color:#f0f0f0; padding:10px; border-radius:5px; margin-bottom:10px;",
                         tags$strong("Multi-Player Mode:"),
                         tags$br(),
                         "Each row = 1 player"
                     ),
                     # Player dropdowns for each possible row (only show up to current row count)
                     uiOutput(ns("multi_player_selectors"))
                   ),
                   selectInput(ns("report_rows"), "Rows:", choices = 1:15, selected = 1),
                   selectInput(ns("report_cols"), "Columns:", choices = 1:5, selected = 1),
                   selectInput(ns("saved_report"), "Saved Reports:", choices = c(""), selected = ""),
                   uiOutput(ns("report_global_toggle")),
                   div(style = "display: flex; gap: 5px;",
                       actionButton(ns("new_report"), "New Report", class = "btn-success btn-sm"),
                       actionButton(ns("save_report"), "Save Report", class = "btn-primary btn-sm"),
                       actionButton(ns("delete_report"), "Delete Report", class = "btn-danger btn-sm")
                   )
               )
        ),
        column(9, id = ns("main_column"),
               uiOutput(ns("report_header")),
               uiOutput(ns("report_canvas"))
        )
      )
    )
  )
}

custom_reports_server <- function(id) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    is_admin_fun <- get0("is_admin", mode = "function", inherits = TRUE)
    is_admin_local <- reactive({
      if (is.null(is_admin_fun)) return(FALSE)
      val <- try(is_admin_fun(), silent = TRUE)
      if (inherits(val, "try-error")) FALSE else isTRUE(val)
    })
    
    output$report_global_toggle <- renderUI({
      if (!isTRUE(is_admin_local())) return(NULL)
      checkboxInput(ns("report_global"), "Share with all schools (admin)", value = FALSE)
    })
    
    # Sidebar toggle
    sidebar_visible <- reactiveVal(TRUE)
    observeEvent(input$toggle_sidebar, {
      sidebar_visible(!sidebar_visible())
      if (sidebar_visible()) {
        shinyjs::show("sidebar_column")
        shinyjs::hide("show_sidebar_btn")
        shinyjs::removeClass(selector = paste0("#", ns("main_column")), class = "col-sm-12")
        shinyjs::addClass(selector = paste0("#", ns("main_column")), class = "col-sm-9")
        updateActionButton(session, "toggle_sidebar", label = "Hide Sidebar")
      } else {
        shinyjs::hide("sidebar_column")
        shinyjs::show("show_sidebar_btn")
        shinyjs::removeClass(selector = paste0("#", ns("main_column")), class = "col-sm-9")
        shinyjs::addClass(selector = paste0("#", ns("main_column")), class = "col-sm-12")
      }
    })
    
    # Show sidebar button click
    observeEvent(input$show_sidebar, {
      sidebar_visible(TRUE)
      shinyjs::show("sidebar_column")
      shinyjs::hide("show_sidebar_btn")
      shinyjs::removeClass(selector = paste0("#", ns("main_column")), class = "col-sm-12")
      shinyjs::addClass(selector = paste0("#", ns("main_column")), class = "col-sm-9")
      updateActionButton(session, "toggle_sidebar", label = "Hide Sidebar")
    })
    
    observe({
      updateSelectInput(session, "saved_report", choices = c("", names(custom_reports_store())))
    })
    
    # Populate players based on type (for Single Player mode)
    observeEvent(input$report_type, {
      if (input$report_type == "Pitching") {
        players <- sort(unique(stats::na.omit(c(pitch_data_pitching$Pitcher, pitch_data$Pitcher))))
      } else {
        # For hitting, get batters from pitch_data
        batters <- unique(stats::na.omit(as.character(pitch_data$Batter)))
        batters <- batters[nzchar(batters)]  # Remove empty strings
        players <- sort(batters)
      }
      
      # Update the main player selector (Single Player mode) - add "All" option
      updateSelectizeInput(session, "report_players",
                           choices = c("All", players),
                           selected = "All",  # Default to All
                           server = TRUE)
      
      # Update all row player selectors (Multi-Player mode) - add "All" option
      for (r in 1:15) {
        selector_id <- paste0("row_player_", r)
        updateSelectizeInput(session, selector_id,
                             choices = c("", "All", players),
                             server = TRUE)
      }
    }, ignoreInit = FALSE)
    
    # Load saved report
    observeEvent(input$saved_report, {
      nm <- input$saved_report
      if (!nzchar(nm)) return()
      cr <- custom_reports_store()
      if (!nm %in% names(cr)) return()
      rep <- cr[[nm]]
      if (isTRUE(is_admin_local())) {
        updateCheckboxInput(session, "report_global", value = identical(rep$school_code, GLOBAL_SCOPE))
      }
      
      # Set loading flag to prevent observe block from overwriting
      loading_report(TRUE)
      
      # FIRST: Update current_cells with saved data (before UI changes)
      update_reports_grid(rep$cells %||% list())
      
      # THEN: Update all UI elements (this will trigger renderUI which reads from current_cells)
      updateTextInput(session, "report_title", value = rep$title %||% "")
      updateSelectInput(session, "report_type", selected = rep$type %||% "Pitching")
      updateSelectInput(session, "report_scope", selected = rep$scope %||% "Single Player")
      updateSelectizeInput(session, "report_players", selected = rep$players %||% character(0))
      updateSelectInput(session, "report_rows", selected = rep$rows %||% 1)
      updateSelectInput(session, "report_cols", selected = rep$cols %||% 1)
      
      # After a delay, explicitly update filter inputs and player selectors
      # This ensures they get the saved values even if the UI already exists
      later::later(function() {
        cells <- rep$cells %||% list()
        rows <- rep$rows %||% 1
        cols <- rep$cols %||% 1
        scope <- rep$scope %||% "Single Player"
        
        # FIRST: Always show controls when loading a report
        # This ensures filter controls are visible so we can update them
        for (r in seq_len(rows)) {
          for (c in seq_len(cols)) {
            cell_id <- paste0("r", r, "c", c)
            updateCheckboxInput(session, paste0("cell_show_controls_", cell_id), value = TRUE)
          }
        }
        
        # THEN: Wait a bit for controls to render, then update filter values
        later::later(function() {
          # Update row player inputs in Multi-Player mode
          if (scope == "Multi-Player") {
            for (r in seq_len(rows)) {
              player_val <- cells[[paste0("row_", r, "_player")]]
              if (!is.null(player_val) && length(player_val) == 1 && !is.na(player_val) && player_val != "") {
                updateSelectizeInput(session, paste0("row_player_", r), selected = player_val)
              }
            }
          }
          
          # Update filter inputs for each cell
          for (r in seq_len(rows)) {
            for (c in seq_len(cols)) {
              cell_id <- paste0("r", r, "c", c)
              saved_cell <- cells[[cell_id]]
              if (!is.null(saved_cell)) {
                # Update filter inputs if they have saved values
                if (!is.null(saved_cell$dates) && length(saved_cell$dates) == 2) {
                  updateDateRangeInput(session, paste0("cell_dates_", cell_id), 
                                       start = saved_cell$dates[1], end = saved_cell$dates[2])
                }
                if (!is.null(saved_cell$session) && length(saved_cell$session) == 1 && !is.na(saved_cell$session) && saved_cell$session != "") {
                  updateSelectInput(session, paste0("cell_session_", cell_id), selected = saved_cell$session)
                }
                if (!is.null(saved_cell$pitch_types) && length(saved_cell$pitch_types) > 0) {
                  updateSelectizeInput(session, paste0("cell_pitch_types_", cell_id), selected = saved_cell$pitch_types)
                }
                if (!is.null(saved_cell$batter_side) && length(saved_cell$batter_side) == 1 && !is.na(saved_cell$batter_side) && saved_cell$batter_side != "") {
                  updateSelectInput(session, paste0("cell_batter_side_", cell_id), selected = saved_cell$batter_side)
                }
                if (!is.null(saved_cell$pitcher_hand) && length(saved_cell$pitcher_hand) == 1 && !is.na(saved_cell$pitcher_hand) && saved_cell$pitcher_hand != "") {
                  updateSelectInput(session, paste0("cell_pitcher_hand_", cell_id), selected = saved_cell$pitcher_hand)
                }
                if (!is.null(saved_cell$results) && length(saved_cell$results) > 0) {
                  updateSelectInput(session, paste0("cell_results_", cell_id), selected = saved_cell$results)
                }
                if (!is.null(saved_cell$qp) && length(saved_cell$qp) == 1 && !is.na(saved_cell$qp) && saved_cell$qp != "") {
                  updateSelectInput(session, paste0("cell_qp_", cell_id), selected = saved_cell$qp)
                }
                if (!is.null(saved_cell$count) && length(saved_cell$count) > 0) {
                  updateSelectInput(session, paste0("cell_count_", cell_id), selected = saved_cell$count)
                }
                if (!is.null(saved_cell$after_count) && length(saved_cell$after_count) > 0) {
                  updateSelectInput(session, paste0("cell_after_count_", cell_id), selected = saved_cell$after_count)
                }
                if (!is.null(saved_cell$zone) && length(saved_cell$zone) > 0) {
                  updateSelectInput(session, paste0("cell_zone_", cell_id), selected = saved_cell$zone)
                }
                if (!is.null(saved_cell$velo_min) && length(saved_cell$velo_min) == 1 && !is.na(saved_cell$velo_min)) {
                  updateNumericInput(session, paste0("cell_velo_min_", cell_id), value = saved_cell$velo_min)
                }
                if (!is.null(saved_cell$velo_max) && length(saved_cell$velo_max) == 1 && !is.na(saved_cell$velo_max)) {
                  updateNumericInput(session, paste0("cell_velo_max_", cell_id), value = saved_cell$velo_max)
                }
                if (!is.null(saved_cell$ivb_min) && length(saved_cell$ivb_min) == 1 && !is.na(saved_cell$ivb_min)) {
                  updateNumericInput(session, paste0("cell_ivb_min_", cell_id), value = saved_cell$ivb_min)
                }
                if (!is.null(saved_cell$ivb_max) && length(saved_cell$ivb_max) == 1 && !is.na(saved_cell$ivb_max)) {
                  updateNumericInput(session, paste0("cell_ivb_max_", cell_id), value = saved_cell$ivb_max)
                }
                if (!is.null(saved_cell$hb_min) && length(saved_cell$hb_min) == 1 && !is.na(saved_cell$hb_min)) {
                  updateNumericInput(session, paste0("cell_hb_min_", cell_id), value = saved_cell$hb_min)
                }
                if (!is.null(saved_cell$hb_max) && length(saved_cell$hb_max) == 1 && !is.na(saved_cell$hb_max)) {
                  updateNumericInput(session, paste0("cell_hb_max_", cell_id), value = saved_cell$hb_max)
                }
              }
            }
          }          # Clear the loading flag after all updates are done
          loading_report(FALSE)
        }, delay = 0.5)  # 0.5 second delay for controls to render
      }, delay = 1.5)  # 1.5 second initial delay
    }, ignoreInit = TRUE)
    
    # Render player selectors in sidebar for Multi-Player mode
    output$multi_player_selectors <- renderUI({
      req(input$report_scope == "Multi-Player")
      rows <- as.integer(input$report_rows)
      if (is.na(rows) || rows < 1) return(NULL)
      
      players <- if (input$report_type == "Pitching") {
        sort(unique(stats::na.omit(c(pitch_data_pitching$Pitcher, pitch_data$Pitcher))))
      } else {
        sort(unique(stats::na.omit(c(pitch_data$Batter, pitch_data_pitching$Batter))))
      }
      
      cells <- current_cells()
      
      lapply(1:rows, function(r) {
        selectizeInput(
          ns(paste0("row_player_", r)),
          paste0("Row ", r, " Player:"),
          choices = c("", "All", players),
          selected = cells[[paste0("row_", r, "_player")]] %||% "",
          width = "100%"
        )
      })
    })
    
    # Header showing report title + players
    output$report_header <- renderUI({
      title_txt <- trimws(input$report_title)
      
      # Helper function to format player names from "Last, First" to "First Last"
      format_player_name <- function(p) {
        if (grepl(",", p)) {
          parts <- strsplit(p, ",\\s*")[[1]]
          if (length(parts) == 2) {
            paste(parts[2], parts[1])  # First Last
          } else {
            p
          }
        } else {
          p
        }
      }
      
      # Build player label based on mode - DON'T show player names in Multi-Player
      player_lbl <- if (input$report_scope == "Multi-Player") {
        NULL  # Don't show player names in Multi-Player mode
      } else {
        # Single Player mode
        players <- input$report_players %||% character(0)
        if (length(players) > 0) {
          formatted_players <- sapply(players, format_player_name)
          paste(formatted_players, collapse = " | ")
        } else {
          "No players selected"
        }
      }
      
      tagList(
        h3(style = "margin-top:0; margin-bottom:4px; text-align:center;", 
           if (nzchar(title_txt)) title_txt else "Custom Report"),
        if (!is.null(player_lbl)) {
          div(style = "font-weight:600; margin-bottom:10px; text-align:center;", player_lbl)
        }
      )
    })
    
    # Save report
    observeEvent(input$save_report, {
      nm <- trimws(input$report_title)
      if (!nzchar(nm)) {
        showNotification("Please enter a report title.", type = "warning")
        return()
      }
      cells <- isolate(current_cells())
      scope <- if (isTRUE(is_admin_local()) && isTRUE(input$report_global)) GLOBAL_SCOPE else current_school()
      rep <- list(
        title = nm,
        type = input$report_type,
        scope = input$report_scope,
        players = input$report_players,
        rows = as.integer(input$report_rows),
        cols = as.integer(input$report_cols),
        cells = cells,
        school_code = scope
      )
      cr <- custom_reports_store()
      cr[[nm]] <- rep
      custom_reports_store(cr); save_custom_reports(cr)
      updateSelectInput(session, "saved_report", choices = c("", names(cr)), selected = nm)
      showNotification("Report saved.", type = "message")
    }, ignoreInit = TRUE)
    
    # Delete
    observeEvent(input$delete_report, {
      nm <- input$saved_report
      if (!nzchar(nm)) return()
      cr <- custom_reports_store()
      if (nm %in% names(cr)) {
        cr[[nm]] <- NULL
        custom_reports_store(cr); save_custom_reports(cr)
        updateSelectInput(session, "saved_report", choices = c("", names(cr)), selected = "")
        showNotification("Report deleted.", type = "message")
      }
    }, ignoreInit = TRUE)
    
    # New Report - clear everything for fresh start
    observeEvent(input$new_report, {
      # Clear all cells
      current_cells(list())
      
      # Reset to defaults
      updateTextInput(session, "report_title", value = "")
      updateSelectInput(session, "report_type", selected = "Pitching")
      updateSelectInput(session, "report_scope", selected = "Single Player")
      updateSelectizeInput(session, "report_players", selected = character(0))
      updateSelectInput(session, "report_rows", selected = 1)
      updateSelectInput(session, "report_cols", selected = 1)
      updateSelectInput(session, "saved_report", selected = "")
      if (isTRUE(is_admin_local())) updateCheckboxInput(session, "report_global", value = FALSE)
      
      showNotification("New report created. Start building!", type = "message")
    }, ignoreInit = TRUE)
    
    # Grid state
    current_cells <- reactiveVal(list())
    loading_report <- reactiveVal(FALSE)  # Flag to prevent observe from overwriting during load
    update_reports_grid <- function(cells_list) {
      current_cells(cells_list)
    }
    
    # Build per-cell filter UI based on "Filters to show"
    output_filters_for_cell <- function(cell_id) {
      renderUI({
        # Get saved values from current_cells if available
        cells <- current_cells()
        saved_cell <- cells[[cell_id]] %||% list()
        
        # Check input first, then saved cell data for filter_select
        sel <- input[[paste0("cell_filter_select_", cell_id)]] %||% saved_cell$filter_select %||% character(0)
        
        out <- list()
        if ("Dates" %in% sel) {
          all_dates <- c(pitch_data_pitching$Date, pitch_data$Date)
          d_min <- suppressWarnings(min(all_dates, na.rm = TRUE))
          d_max <- suppressWarnings(max(all_dates, na.rm = TRUE))
          if (!is.finite(d_min)) d_min <- Sys.Date() - 30
          if (!is.finite(d_max)) d_max <- Sys.Date()
          
          # Preserve existing date range - check input first, then saved cell data
          existing_dates <- input[[paste0("cell_dates_", cell_id)]] %||% saved_cell$dates %||% NULL
          start_date <- if (!is.null(existing_dates) && length(existing_dates) >= 1) existing_dates[1] else d_max - 30
          end_date <- if (!is.null(existing_dates) && length(existing_dates) >= 2) existing_dates[2] else d_max
          
          out <- c(out, list(
            dateRangeInput(ns(paste0("cell_dates_", cell_id)), "Dates:",
                           start = start_date, end = end_date, min = d_min, max = d_max,
                           format = "mm/dd/yyyy")
          ))
        }
        if ("Session Type" %in% sel) {
          existing_session <- input[[paste0("cell_session_", cell_id)]] %||% saved_cell$session %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_session_", cell_id)), "Session Type:",
                        choices = c("All","Bullpen","Live"), 
                        selected = if (!is.null(existing_session)) existing_session else "All")
          ))
        }
        if ("Pitch Types" %in% sel) {
          pts <- if (input$report_type == "Pitching") {
            sort(unique(as.character(pitch_data_pitching$TaggedPitchType)))
          } else {
            sort(unique(as.character(pitch_data$TaggedPitchType)))
          }
          existing_types <- input[[paste0("cell_pitch_types_", cell_id)]] %||% saved_cell$pitch_types %||% NULL
          out <- c(out, list(
            selectizeInput(ns(paste0("cell_pitch_types_", cell_id)), "Pitch Types:",
                           choices = c("All", pts), multiple = TRUE, 
                           selected = if (!is.null(existing_types)) existing_types else "All")
          ))
        }
        if ("Batter Hand" %in% sel) {
          existing_batter <- input[[paste0("cell_batter_side_", cell_id)]] %||% saved_cell$batter_side %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_batter_side_", cell_id)), "Batter Hand:",
                        choices = c("All","Left","Right"), 
                        selected = if (!is.null(existing_batter)) existing_batter else "All")
          ))
        }
        if ("Pitcher Hand" %in% sel) {
          existing_pitcher <- input[[paste0("cell_pitcher_hand_", cell_id)]] %||% saved_cell$pitcher_hand %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_pitcher_hand_", cell_id)), "Pitcher Hand:",
                        choices = c("All","Left","Right"), 
                        selected = if (!is.null(existing_pitcher)) existing_pitcher else "All")
          ))
        }
        if ("Pitch Results" %in% sel) {
          existing_results <- input[[paste0("cell_results_", cell_id)]] %||% saved_cell$results %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_results_", cell_id)), "Pitch Results:",
                        choices = c("All", result_levels), 
                        selected = if (!is.null(existing_results)) existing_results else "All", 
                        multiple = TRUE)
          ))
        }
        if ("QP Locations" %in% sel) {
          existing_qp <- input[[paste0("cell_qp_", cell_id)]] %||% saved_cell$qp %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_qp_", cell_id)), "QP Locations:",
                        choices = c("All","Yes","No"), 
                        selected = if (!is.null(existing_qp)) existing_qp else "All")
          ))
        }
        if ("Count" %in% sel) {
          existing_count <- input[[paste0("cell_count_", cell_id)]] %||% saved_cell$count %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_count_", cell_id)), "Count:",
                        choices = c("All","Even","Behind","Ahead","2KNF",
                                    "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
                        selected = if (!is.null(existing_count)) existing_count else "All", 
                        multiple = TRUE)
          ))
        }
        if ("After Count" %in% sel) {
          existing_after <- input[[paste0("cell_after_count_", cell_id)]] %||% saved_cell$after_count %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_after_count_", cell_id)), "After Count:",
                        choices = c("All","Even","Behind","Ahead","2KNF",
                                    "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
                        selected = if (!is.null(existing_after)) existing_after else "All", 
                        multiple = TRUE)
          ))
        }
        if ("Zone Location" %in% sel) {
          existing_zone <- input[[paste0("cell_zone_", cell_id)]] %||% saved_cell$zone %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_zone_", cell_id)), "Zone Location:",
                        choices = c("All",
                                    "Upper Half","Bottom Half","Left Half","Right Half",
                                    "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
                        selected = if (!is.null(existing_zone)) existing_zone else "All", 
                        multiple = TRUE)
          ))
        }
        if ("Velo Min/Max" %in% sel) {
          existing_vmin <- input[[paste0("cell_velo_min_", cell_id)]] %||% saved_cell$velo_min %||% NULL
          existing_vmax <- input[[paste0("cell_velo_max_", cell_id)]] %||% saved_cell$velo_max %||% NULL
          out <- c(out, list(
            numericInput(ns(paste0("cell_velo_min_", cell_id)), "Velo Min", 
                         value = if (!is.null(existing_vmin)) existing_vmin else NA),
            numericInput(ns(paste0("cell_velo_max_", cell_id)), "Velo Max", 
                         value = if (!is.null(existing_vmax)) existing_vmax else NA)
          ))
        }
        if ("IVB Min/Max" %in% sel) {
          existing_ivbmin <- input[[paste0("cell_ivb_min_", cell_id)]] %||% saved_cell$ivb_min %||% NULL
          existing_ivbmax <- input[[paste0("cell_ivb_max_", cell_id)]] %||% saved_cell$ivb_max %||% NULL
          out <- c(out, list(
            numericInput(ns(paste0("cell_ivb_min_", cell_id)), "IVB Min", 
                         value = if (!is.null(existing_ivbmin)) existing_ivbmin else NA),
            numericInput(ns(paste0("cell_ivb_max_", cell_id)), "IVB Max", 
                         value = if (!is.null(existing_ivbmax)) existing_ivbmax else NA)
          ))
        }
        if ("HB Min/Max" %in% sel) {
          existing_hbmin <- input[[paste0("cell_hb_min_", cell_id)]] %||% saved_cell$hb_min %||% NULL
          existing_hbmax <- input[[paste0("cell_hb_max_", cell_id)]] %||% saved_cell$hb_max %||% NULL
          out <- c(out, list(
            numericInput(ns(paste0("cell_hb_min_", cell_id)), "HB Min", 
                         value = if (!is.null(existing_hbmin)) existing_hbmin else NA),
            numericInput(ns(paste0("cell_hb_max_", cell_id)), "HB Max", 
                         value = if (!is.null(existing_hbmax)) existing_hbmax else NA)
          ))
        }
        if (length(out)) {
          div(style = "display: flex; flex-wrap: wrap; gap: 10px;",
              lapply(out, function(item) {
                div(style = "flex: 0 1 auto; min-width: 150px;", item)
              })
          )
        } else {
          div("No filters selected")
        }
      })
    }
    
    # When grid size changes, preserve existing cell data
    observeEvent(list(input$report_rows, input$report_cols), {
      rows <- suppressWarnings(as.integer(input$report_rows))
      cols <- suppressWarnings(as.integer(input$report_cols))
      if (is.null(rows) || length(rows)==0 || is.na(rows) || rows < 1) return()
      if (is.null(cols) || length(cols)==0 || is.na(cols) || cols < 1) return()
      # Don't clear current_cells - just keep existing data
      # This allows cells to persist when adding more rows/cols
    })
    
    # Render filter controls for each cell (only when grid size changes)
    observeEvent(list(input$report_rows, input$report_cols), {
      rows <- suppressWarnings(as.integer(input$report_rows))
      cols <- suppressWarnings(as.integer(input$report_cols))
      if (is.null(rows) || length(rows)==0 || is.na(rows) || rows < 1) return()
      if (is.null(cols) || length(cols)==0 || is.na(cols) || cols < 1) return()
      for (r in seq_len(rows)) for (c in seq_len(cols)) {
        local({
          rid <- r; cid <- c
          cell_id <- paste0("r", rid, "c", cid)
          output[[paste0("cell_filters_", cell_id)]] <- output_filters_for_cell(cell_id)
        })
      }
    }, ignoreInit = FALSE)
    
    # UI for grid
    output$report_canvas <- renderUI({
      rows <- as.integer(input$report_rows); cols <- as.integer(input$report_cols)
      cells <- isolate(current_cells())  # Use isolate to prevent re-rendering on cell changes
      is_multi_player <- input$report_scope == "Multi-Player"
      
      # Helper function to format player names from "Last, First" to "First Last"
      format_player_name <- function(player_name) {
        if (is.null(player_name) || !nzchar(player_name)) return("")
        if (grepl(",", player_name)) {
          parts <- strsplit(player_name, ",\\s*")[[1]]
          if (length(parts) == 2) {
            return(paste(parts[2], parts[1]))  # First Last
          }
        }
        player_name
      }
      
      grid <- lapply(seq_len(rows), function(r) {
        # For Multi-Player mode, add player name before the row of charts
        player_name_row <- NULL
        if (is_multi_player) {
          row_player <- input[[paste0("row_player_", r)]]
          if (!is.null(row_player) && nzchar(row_player)) {
            formatted_name <- format_player_name(row_player)
            player_name_row <- div(
              style = "font-size:18px; font-weight:bold; margin-bottom:10px; margin-top:15px; padding-left:15px;",
              formatted_name
            )
          }
        }
        
        # Build cells for this row
        row_cells <- lapply(seq_len(cols), function(cn) {
          cell_id <- paste0("r", r, "c", cn)
          sel <- cells[[cell_id]] %||% list(
            type = "", 
            filter = "Pitch Types", 
            title = "",
            show_controls = TRUE,
            table_mode = "Stuff",
            table_custom_cols = character(0),
            color = TRUE,
            heat_stat = "Frequency",
            filter_select = c("Dates","Session Type","Pitch Types")
          )
          width <- if (cols == 1) 8 else if (cols == 2) 6 else if (cols == 3) 4 else if (cols == 4) 3 else 2
          offset <- if (cols == 1 && cn == 1) 2 else 0
          
          # In Multi-Player mode, rows 2+ use row 1's settings
          is_controlled_row <- is_multi_player && r > 1
          
          column(
            width = width, offset = offset,
            div(class = "creport-cell",
                # Always create controls to preserve state, but hide them for rows 2+ in Multi-Player mode
                # Title and show controls toggle
                div(style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;",
                    if (!is_controlled_row) {
                      # Row 1 or Single-Player mode: show checkbox
                      checkboxInput(ns(paste0("cell_show_controls_", cell_id)), "Show controls", 
                                    value = sel$show_controls %||% TRUE, width = "120px")
                    }
                ),
                # Controls container - always render but hide with CSS for rows 2+
                div(
                  id = ns(paste0("cell_controls_container_", cell_id)),
                  style = if (is_controlled_row) "display:none;" else "",  # Hide for rows 2+ using CSS
                  conditionalPanel(
                    condition = if (is_controlled_row) "false" else sprintf("input['%s']", ns(paste0("cell_show_controls_", cell_id))),
                    div(
                      # Title input - only visible when controls are shown
                      textInput(ns(paste0("cell_title_", cell_id)), "Chart Title:", 
                                value = sel$title %||% "", placeholder = "Enter chart title..."),
                      selectInput(ns(paste0("cell_type_", cell_id)), "Content:", 
                                  choices = c("", "Movement Plot", "Release Plot", "Location Plot", "Heatmap", "Summary Table", "Spray Chart"),
                                  selected = sel$type),
                      conditionalPanel(
                        sprintf("input['%s'] == 'Summary Table'", ns(paste0("cell_type_", cell_id))),
                        tagList(
                          selectInput(ns(paste0("cell_table_mode_", cell_id)), "Table:", 
                                      choices = if (input$report_type == "Hitting") c("Results","Swing Decisions","Custom") else c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data",
                                                                                                                                   names(custom_tables()), "Custom"),
                                      selected = {
                                        ch <- if (input$report_type == "Hitting") c("Results","Swing Decisions","Custom") else c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data",
                                                                                                                                names(custom_tables()), "Custom")
                                        if (!is.null(sel$table_mode) && sel$table_mode %in% ch) sel$table_mode else ch[[1]]
                                      }),
                          selectInput(ns(paste0("cell_filter_", cell_id)), "Split By:", 
                                      choices = c("Pitch Types","Batter Hand","Pitcher Hand","Count","After Count","Velocity","IVB","HB","Batter"),
                                      selected = sel$filter),
                          checkboxInput(ns(paste0("cell_color_", cell_id)), "Color-Code", value = sel$color %||% TRUE),
                          conditionalPanel(
                            condition = sprintf("input['%s']=='Custom' && input['%s']=='Hitting'", 
                                                ns(paste0("cell_table_mode_", cell_id)), ns("report_type")),
                            selectizeInput(
                              ns(paste0("cell_table_custom_cols_", cell_id)),
                              "Columns (drag to order):",
                              choices = c("PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP",
                                          "Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%","EV","LA"),
                              selected = sel$table_custom_cols %||% c("PA","AB","AVG","SLG","OBP","OPS","Swing%","Whiff%"),
                              multiple = TRUE,
                              options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
                            )
                          )
                        )
                      ),
                      conditionalPanel(
                        sprintf("input['%s'] == 'Heatmap'", ns(paste0("cell_type_", cell_id))),
                        selectInput(ns(paste0("cell_heat_stat_", cell_id)), "Heatmap Type:",
                                    choices = c("Frequency","Whiff Rate","Exit Velocity","GB Rate","Contact Rate","Swing Rate","Run Values"),
                                    selected = sel$heat_stat %||% "Frequency")
                      ),
                      # Per-cell filters (collapsed set)
                      selectizeInput(
                        ns(paste0("cell_filter_select_", cell_id)),
                        "Filters to show:",
                        choices = c("Dates","Session Type","Pitch Types","Batter Hand","Pitcher Hand","Pitch Results","QP Locations",
                                    "Count","After Count","Zone Location","Velo Min/Max","IVB Min/Max","HB Min/Max"),
                        selected = sel$filter_select %||% c("Dates","Session Type","Pitch Types"),
                        multiple = TRUE,
                        options = list(plugins = list("remove_button"))
                      ),
                      uiOutput(ns(paste0("cell_filters_", cell_id)))
                    )
                  )
                ),
                # Title display - non-reactive div updated via JavaScript
                div(
                  id = ns(paste0("cell_title_display_", cell_id)),
                  style = "text-align:center; margin-bottom:10px; font-weight:bold;",
                  ""  # Empty initially, updated via JS
                ),
                # Cell output - always rendered
                uiOutput(ns(paste0("cell_output_", cell_id)))
            )
          )
        })
        
        # Return player name (if Multi-Player) followed by the row of charts
        tagList(player_name_row, fluidRow(row_cells))
      })
      
      tagList(grid)
    })
    
    # Observe cell selections and update stored state (throttle to prevent excessive updates)
    observe({
      # Don't update if we're currently loading a saved report
      if (loading_report()) return()
      
      rows <- as.integer(input$report_rows); cols <- as.integer(input$report_cols)
      
      # Validate that rows and cols are valid integers
      if (length(rows) == 0 || length(cols) == 0) return()
      if (is.na(rows) || is.na(cols)) return()
      if (rows < 1 || cols < 1) return()
      
      cells <- isolate(current_cells())  # Use isolate to prevent dependency loops
      
      # Save row players in Multi-Player mode
      if (input$report_scope == "Multi-Player") {
        for (r in seq_len(rows)) {
          player_input <- input[[paste0("row_player_", r)]]
          # Only update if input exists, otherwise preserve existing value
          if (!is.null(player_input)) {
            cells[[paste0("row_", r, "_player")]] <- player_input
          }
        }
      }
      
      for (r in seq_len(rows)) {
        for (c in seq_len(cols)) {
          id <- paste0("r", r, "c", c)
          
          # Get existing cell data or create new
          existing_cell <- cells[[id]] %||% list()
          
          # Helper function to update value only if input exists, otherwise keep existing
          update_if_exists <- function(input_val, existing_val, default_val = NULL) {
            if (!is.null(input_val)) input_val
            else if (!is.null(existing_val)) existing_val
            else default_val
          }
          
          # Save ALL cell settings, preserving existing values if inputs don't exist yet
          cells[[id]] <- list(
            type = update_if_exists(input[[paste0("cell_type_", id)]], existing_cell$type, ""),
            filter = update_if_exists(input[[paste0("cell_filter_", id)]], existing_cell$filter, "Pitch Types"),
            title = update_if_exists(input[[paste0("cell_title_", id)]], existing_cell$title, ""),
            show_controls = update_if_exists(input[[paste0("cell_show_controls_", id)]], existing_cell$show_controls, TRUE),
            table_mode = update_if_exists(input[[paste0("cell_table_mode_", id)]], existing_cell$table_mode, "Stuff"),
            table_custom_cols = update_if_exists(input[[paste0("cell_table_custom_cols_", id)]], existing_cell$table_custom_cols, character(0)),
            color = update_if_exists(input[[paste0("cell_color_", id)]], existing_cell$color, TRUE),
            heat_stat = update_if_exists(input[[paste0("cell_heat_stat_", id)]], existing_cell$heat_stat, "Frequency"),
            filter_select = update_if_exists(input[[paste0("cell_filter_select_", id)]], existing_cell$filter_select, c("Dates","Session Type","Pitch Types")),
            # Save all filter values - preserve existing if input doesn't exist
            dates = update_if_exists(input[[paste0("cell_dates_", id)]], existing_cell$dates),
            session = update_if_exists(input[[paste0("cell_session_", id)]], existing_cell$session),
            pitch_types = update_if_exists(input[[paste0("cell_pitch_types_", id)]], existing_cell$pitch_types),
            batter_side = update_if_exists(input[[paste0("cell_batter_side_", id)]], existing_cell$batter_side),
            pitcher_hand = update_if_exists(input[[paste0("cell_pitcher_hand_", id)]], existing_cell$pitcher_hand),
            results = update_if_exists(input[[paste0("cell_results_", id)]], existing_cell$results),
            qp = update_if_exists(input[[paste0("cell_qp_", id)]], existing_cell$qp),
            count = update_if_exists(input[[paste0("cell_count_", id)]], existing_cell$count),
            after_count = update_if_exists(input[[paste0("cell_after_count_", id)]], existing_cell$after_count),
            zone = update_if_exists(input[[paste0("cell_zone_", id)]], existing_cell$zone),
            velo_min = update_if_exists(input[[paste0("cell_velo_min_", id)]], existing_cell$velo_min),
            velo_max = update_if_exists(input[[paste0("cell_velo_max_", id)]], existing_cell$velo_max),
            ivb_min = update_if_exists(input[[paste0("cell_ivb_min_", id)]], existing_cell$ivb_min),
            ivb_max = update_if_exists(input[[paste0("cell_ivb_max_", id)]], existing_cell$ivb_max),
            hb_min = update_if_exists(input[[paste0("cell_hb_min_", id)]], existing_cell$hb_min),
            hb_max = update_if_exists(input[[paste0("cell_hb_max_", id)]], existing_cell$hb_max)
          )
          # Keep UI in sync with stored state
        }
      }
      current_cells(cells)
    }) %>% throttle(500)  # Reduced throttle for better responsiveness
    
    # Helper: get filtered dataset for player(s) for a given cell
    # This is now a pure function that will be cached via bindCache in the reactive
    get_cell_data <- function(cell_id, players, report_type, dates, session, pitch_types, 
                              batter_side, pitcher_hand, results, qp, count, after_count, 
                              zone, velo_min, velo_max, ivb_min, ivb_max, hb_min, hb_max) {
      if (is.null(players) || length(players) == 0) return(data.frame())
      
      # Handle "All" selection - get all data for that report type
      if (report_type == "Pitching") {
        if ("All" %in% players || identical(players, "All")) {
          df <- pitch_data_pitching  # All pitchers
        } else {
          df <- pitch_data_pitching %>% dplyr::filter(Pitcher %in% players)
        }
        
        # Apply three-tier filtering for players (admins and coaches see all)
        tryCatch({
          if (!is_admin() && !is_coach()) {
            ue <- user_email()
            if (!is.na(ue)) {
              df <- df %>% dplyr::filter(norm_email(Email) == norm_email(ue))
            }
          }
        }, error = function(e) {
          # Silently handle if is_admin/is_coach not available
        })
      } else {
        # For Hitting: filter by Batter, ensure Batter column exists and has data
        if (!"Batter" %in% names(pitch_data)) {
          message("Batter column not found in pitch_data")
          return(data.frame())
        }
        if ("All" %in% players || identical(players, "All")) {
          df <- pitch_data %>% dplyr::filter(!is.na(Batter), nzchar(as.character(Batter)))  # All batters
        } else {
          df <- pitch_data %>% 
            dplyr::filter(!is.na(Batter), nzchar(as.character(Batter)), Batter %in% players)
        }
        
        # Apply three-tier filtering for players (admins and coaches see all)
        tryCatch({
          if (!is_admin() && !is_coach()) {
            ue <- user_email()
            if (!is.na(ue)) {
              df <- df %>% dplyr::filter(norm_email(Email) == norm_email(ue))
            }
          }
        }, error = function(e) {
          # Silently handle if is_admin/is_coach not available
        })
      }
      
      # Apply all filters efficiently
      if (!is.null(dates) && length(dates) == 2) {
        df <- df %>% dplyr::filter(Date >= dates[1], Date <= dates[2])
      }
      if (!is.null(session) && session != "All") df <- df %>% dplyr::filter(SessionType %in% session)
      if (!is.null(pitch_types) && length(pitch_types) && !("All" %in% pitch_types)) df <- df %>% dplyr::filter(TaggedPitchType %in% pitch_types)
      if (!is.null(batter_side) && batter_side != "All") df <- df %>% dplyr::filter(BatterSide == batter_side)
      if (!is.null(pitcher_hand) && pitcher_hand != "All") df <- df %>% dplyr::filter(PitcherThrows == pitcher_hand)
      df <- apply_pitch_results_filter(df, results)
      if (!is.null(qp) && qp != "All") df <- filter_qp_locations(df, qp)
      df <- apply_count_filter(df, count)
      df <- apply_after_count_filter(df, after_count)
      df <- enforce_zone(df, zone)
      nnz <- function(x) !is.null(x) && suppressWarnings(is.finite(as.numeric(x)))
      if (nnz(velo_min))   df <- df %>% dplyr::filter(RelSpeed >= as.numeric(velo_min))
      if (nnz(velo_max))   df <- df %>% dplyr::filter(RelSpeed <= as.numeric(velo_max))
      if (nnz(ivb_min)) df <- df %>% dplyr::filter(InducedVertBreak >= as.numeric(ivb_min))
      if (nnz(ivb_max)) df <- df %>% dplyr::filter(InducedVertBreak <= as.numeric(ivb_max))
      if (nnz(hb_min))  df <- df %>% dplyr::filter(HorzBreak >= as.numeric(hb_min))
      if (nnz(hb_max))  df <- df %>% dplyr::filter(HorzBreak <= as.numeric(hb_max))
      
      # Calculate Stuff+ if not present (using same method as other pages)
      if (!"Stuff+" %in% names(df) || all(is.na(df$`Stuff+`))) {
        df <- tryCatch({
          compute_stuff_simple(df, base_type = "Fastball", level = "College")
        }, error = function(e) {
          message("Could not compute Stuff+ in custom reports: ", e$message)
          df$`Stuff+` <- NA_real_
          df
        })
      }
      
      df
    }
    
    # Wrapper that extracts inputs and calls cached function
    get_cell_data_wrapper <- function(cell_id) {
      # Determine which player(s) to use
      players <- if (input$report_scope == "Multi-Player") {
        # Extract row number from cell_id (e.g., "r1c2" -> row 1)
        row_num <- as.integer(sub("r(\\d+)c.*", "\\1", cell_id))
        row_player <- input[[paste0("row_player_", row_num)]]
        if (is.null(row_player) || !nzchar(row_player)) {
          return(data.frame())  # No player selected for this row
        }
        row_player
      } else {
        # Single Player mode - use main player selector
        input$report_players
      }
      
      # Allow "All" or empty to pass through, but require something
      if (is.null(players) || (length(players) == 1 && !nzchar(players))) {
        return(data.frame())
      }
      
      # In Multi-Player mode, use Row 1's filters for all rows (but keep each row's own player)
      # Extract row and column from cell_id
      row_num <- as.integer(sub("r(\\d+)c.*", "\\1", cell_id))
      col_num <- as.integer(sub("r\\d+c(\\d+)", "\\1", cell_id))
      
      # Determine which cell's filters to use
      filter_cell_id <- if (input$report_scope == "Multi-Player" && row_num > 1) {
        # Use row 1, same column for filters
        paste0("r1c", col_num)
      } else {
        # Use this cell's own filters
        cell_id
      }
      
      get_cell_data(
        cell_id = cell_id,
        players = players,
        report_type = input$report_type,
        dates = input[[paste0("cell_dates_", filter_cell_id)]],
        session = input[[paste0("cell_session_", filter_cell_id)]] %||% "All",
        pitch_types = input[[paste0("cell_pitch_types_", filter_cell_id)]],
        batter_side = input[[paste0("cell_batter_side_", filter_cell_id)]],
        pitcher_hand = input[[paste0("cell_pitcher_hand_", filter_cell_id)]],
        results = input[[paste0("cell_results_", filter_cell_id)]],
        qp = input[[paste0("cell_qp_", filter_cell_id)]],
        count = input[[paste0("cell_count_", filter_cell_id)]],
        after_count = input[[paste0("cell_after_count_", filter_cell_id)]],
        zone = input[[paste0("cell_zone_", filter_cell_id)]],
        velo_min = input[[paste0("cell_velo_min_", filter_cell_id)]],
        velo_max = input[[paste0("cell_velo_max_", filter_cell_id)]],
        ivb_min = input[[paste0("cell_ivb_min_", filter_cell_id)]],
        ivb_max = input[[paste0("cell_ivb_max_", filter_cell_id)]],
        hb_min = input[[paste0("cell_hb_min_", filter_cell_id)]],
        hb_max = input[[paste0("cell_hb_max_", filter_cell_id)]]
      )
    }
    
    # Simple visuals
    render_cell <- function(cell_id) {
      # In Multi-Player mode, use Row 1's chart type and settings for all rows
      # Extract row and column from cell_id
      row_num <- as.integer(sub("r(\\d+)c.*", "\\1", cell_id))
      col_num <- as.integer(sub("r\\d+c(\\d+)", "\\1", cell_id))
      
      # Determine which cell's settings to use
      settings_cell_id <- if (input$report_scope == "Multi-Player" && row_num > 1) {
        # Use row 1, same column for settings
        paste0("r1c", col_num)
      } else {
        # Use this cell's own settings
        cell_id
      }
      
      tsel <- input[[paste0("cell_type_", settings_cell_id)]] %||% ""
      fsel <- input[[paste0("cell_filter_", settings_cell_id)]] %||% "Pitch Types"
      out_id <- paste0("cell_render_", cell_id)
      tooltip_css_local <- if (exists("tooltip_css", inherits = TRUE)) tooltip_css else
        "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
      # Dark-mode helper
      is_dark_mode_local <- function() {
        dm <- NULL
        # prefer root scope to pick up global toggle
        dm <- tryCatch({
          rs <- session$rootScope()
          if (!is.null(rs) && !is.null(rs$input$dark_mode)) rs$input$dark_mode else NULL
        }, error = function(...) NULL)
        if (is.null(dm) && !is.null(input$dark_mode)) dm <- input$dark_mode
        isTRUE(dm)
      }
      # clear previous output so switching types always re-renders
      output[[out_id]] <- renderUI({ NULL })
      if (!nzchar(tsel)) {
        output[[out_id]] <- renderUI({ NULL })
        return(NULL)
      }
      df <- get_cell_data_wrapper(cell_id)
      if (!nrow(df)) {
        output[[out_id]] <- renderUI({ div("No data") })
        return(uiOutput(ns(out_id)))
      }
      if (tsel == "Summary Table") {
        df <- apply_split_by(df, fsel)
        split_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
        df$SplitColumn <- df[[split_col]]
      }
      
      if (tsel == "Movement Plot") {
        df_mv <- df %>% dplyr::filter(is.finite(HorzBreak), is.finite(InducedVertBreak))
        if (!"Stuff+" %in% names(df_mv) && "StuffPlus" %in% names(df_mv)) df_mv$`Stuff+` <- df_mv$StuffPlus
        output[[out_id]] <- ggiraph::renderGirafe({
          if (!nrow(df_mv)) return(NULL)
          dark_on <- is_dark_mode_local()
          axis_col <- if (dark_on) "#e5e7eb" else "black"
          line_col <- if (dark_on) "#ffffff" else "black"
          grid_col <- adjustcolor(if (dark_on) "white" else "black",
                                  alpha.f = if (dark_on) 0.18 else 0.12)
          cols <- colors_for_mode(dark_on)
          df_mv <- df_mv %>%
            dplyr::mutate(
              SplitColumn = .data[[if ("SplitColumn" %in% names(df_mv)) "SplitColumn" else "TaggedPitchType"]],
              tt = make_hover_tt(.),
              rid = dplyr::row_number()
            )
          types_chr <- as.character(intersect(names(cols), unique(df_mv$SplitColumn)))
          avg <- df_mv %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              avg_HB   = mean(HorzBreak, na.rm = TRUE),
              avg_IVB  = mean(InducedVertBreak, na.rm = TRUE),
              avg_velo = mean(RelSpeed, na.rm = TRUE),
              avg_stuff= if ("Stuff+" %in% names(df_mv)) mean(`Stuff+`, na.rm = TRUE) else NA_real_,
              n_obs    = dplyr::n(),
              .groups = "drop"
            ) %>%
            dplyr::mutate(
              tt = paste0(SplitColumn,
                          "<br>Velo: ", round(avg_velo,1), " mph",
                          "<br>IVB: ", round(avg_IVB,1), " in",
                          "<br>HB: ", round(avg_HB,1), " in",
                          ifelse(is.finite(avg_stuff), paste0("<br>Stuff+: ", round(avg_stuff,1)), ""),
                          "<br>Pitches: ", n_obs),
              data_id = SplitColumn
            )
          p <- ggplot() +
            ggiraph::geom_point_interactive(
              data = df_mv,
              aes(HorzBreak, InducedVertBreak, color = SplitColumn, fill = SplitColumn, tooltip = tt, data_id = rid),
              alpha = 0.25, size = 4, shape = 21, stroke = 0.25
            ) +
            ggiraph::geom_point_interactive(
              data = avg,
              aes(avg_HB, avg_IVB, color = SplitColumn, tooltip = tt, data_id = data_id),
              size = 8, show.legend = FALSE
            ) +
            geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
            geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
            coord_cartesian(xlim = c(-25,25), ylim = c(-25,25)) +
            scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
            scale_fill_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
            theme_minimal() + axis_theme + grid_theme(dark_on) +
            theme(legend.position = "none",
                  axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
                  axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
                  axis.ticks = element_blank(),
                  panel.grid.major = element_line(color = grid_col),
                  panel.grid.minor = element_blank())
          girafe_transparent(
            ggobj = p,
            width_svg = 8, height_svg = 6.5,
            options = list(
              ggiraph::opts_sizing(rescale = TRUE),
              ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css_local),
              ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
              ggiraph::opts_hover_inv(css = "opacity:0.15;")
            )
          )
        })
        return(ggiraph::girafeOutput(ns(out_id), height = "280px"))
      } else if (tsel == "Release Plot") {
        output[[out_id]] <- ggiraph::renderGirafe({
          df$SplitColumn <- df[[if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"]]
          df <- df %>% dplyr::filter(is.finite(RelSide), is.finite(RelHeight))
          if (!nrow(df)) return(NULL)
          dark_on <- is_dark_mode_local()
          axis_col <- if (dark_on) "#e5e7eb" else "black"
          line_col <- if (dark_on) "#ffffff" else "black"
          grid_col <- adjustcolor(if (dark_on) "white" else "black",
                                  alpha.f = if (dark_on) 0.18 else 0.12)
          cols <- colors_for_mode(dark_on)
          
          types_chr <- intersect(names(cols), as.character(unique(df$SplitColumn)))
          types_chr <- types_chr[types_chr %in% names(cols)]
          
          sess_lbl <- {
            ss <- unique(df$SessionType)
            if (length(ss) == 1) ss else "All Sessions"
          }
          
          rp_w <- 4; rp_h <- 0.83
          xs <- seq(-rp_w, rp_w, length.out = 100)
          ys <- rp_h * (1 - (xs / rp_w)^2)
          mound <- data.frame(x = c(xs, rev(xs)), y = c(ys, rep(0, length(xs))))
          
          avg <- df %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              avg_RelSide    = mean(RelSide,    na.rm = TRUE),
              avg_RelHeight  = mean(RelHeight,  na.rm = TRUE),
              avg_Extension  = mean(Extension,  na.rm = TRUE),
              .groups = "drop"
            ) %>%
            dplyr::filter(SplitColumn %in% types_chr) %>%
            dplyr::mutate(
              SplitColumn = factor(SplitColumn, levels = types_chr),
              tt = paste0(
                "Session: ", sess_lbl,
                "<br>Height: ", sprintf("%.1f ft", avg_RelHeight),
                "<br>Side: ", sprintf("%.1f ft", avg_RelSide),
                "<br>Extension: ", sprintf("%.1f ft", avg_Extension)
              )
            )
          
          y_max <- max(6, suppressWarnings(max(df$RelHeight, na.rm = TRUE) + 0.2))
          
          p <- ggplot() +
            geom_polygon(data = mound, aes(x, y), fill = if (dark_on) "transparent" else "tan", color = "tan") +
            annotate("rect", xmin = -0.5, xmax = 0.5, ymin = rp_h - 0.05, ymax = rp_h + 0.05, fill = "white") +
            geom_vline(xintercept = 0, color = line_col, size = 0.7) +
            geom_hline(yintercept = 0, color = line_col, size = 0.7) +
            ggiraph::geom_point_interactive(
              data = avg,
              aes(x = avg_RelSide, y = avg_RelHeight,
                  color = SplitColumn, tooltip = tt, data_id = SplitColumn),
              size = 8, show.legend = FALSE
            ) +
            scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
            scale_y_continuous(limits = c(0, y_max), breaks = seq(0, ceiling(y_max), by = 1)) +
            theme_minimal() + axis_theme + grid_theme(dark_on) +
            labs(x = NULL, y = NULL) +
            theme(
              legend.position = "none",
              axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
              axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
              axis.ticks = element_blank(),
              panel.grid.major = element_line(color = grid_col),
              panel.grid.minor = element_blank(),
              panel.background = element_rect(fill = "transparent", color = NA),
              plot.background = element_rect(fill = "transparent", color = NA)
            )
          
          girafe_transparent(
            ggobj = p,
            width_svg = 8, height_svg = 6.5,
            options = list(
              ggiraph::opts_sizing(rescale = TRUE),
              ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css_local),
              ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
              ggiraph::opts_hover_inv(css = "opacity:0.15;")
            )
          )
        })
        return(ggiraph::girafeOutput(ns(out_id), height = "280px"))
      } else if (tsel == "Location Plot") {
        output[[out_id]] <- ggiraph::renderGirafe({
          df_loc <- df %>% dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
          if (!nrow(df_loc)) return(NULL)
          dark_on <- is_dark_mode_local()
          line_col <- if (dark_on) "#ffffff" else "black"
          grid_col <- if (dark_on) "#d1d5db" else "black"
          cols <- colors_for_mode(dark_on)
          
          # Use different location plots based on report type
          if (input$report_type == "Hitting") {
            # Use Hitting suite location plot with green box
            if (!"Result" %in% names(df_loc)) {
              df_loc$Result <- compute_result(df_loc$PitchCall, df_loc$PlayResult)
            }
            
            # Use hit_shape_map levels for the hitting suite
            hit_result_levels <- names(hit_shape_map)
            
            df_loc <- df_loc %>%
              dplyr::mutate(
                ResultDisplay = dplyr::case_when(
                  Result %in% c("In Play (Out)", "In Play (Hit)") ~ "In Play",
                  TRUE ~ as.character(Result)
                )
              )
            
            df_plot <- df_loc %>%
              dplyr::mutate(
                TaggedPitchType = as.character(TaggedPitchType),
                ResultDisplay = dplyr::case_when(
                  ResultDisplay %in% hit_result_levels ~ ResultDisplay,
                  TRUE ~ NA_character_
                ),
                ResultDisplay = factor(ResultDisplay, levels = hit_result_levels),
                tooltip = paste0(
                  "<b>", TaggedPitchType, "</b><br>",
                  "PitchCall: ", ifelse(is.na(PitchCall), "—", as.character(PitchCall)), "<br>",
                  "Result: ", ifelse(is.na(ResultDisplay), "—", as.character(ResultDisplay)), "<br>",
                  "Velo: ", ifelse(is.finite(as.numeric(RelSpeed)), sprintf("%.1f mph", as.numeric(RelSpeed)), "—"), "<br>",
                  "EV: ", ifelse(is.finite(as.numeric(ExitSpeed)), sprintf("%.1f mph", as.numeric(ExitSpeed)), "—"), "<br>",
                  "LA: ", ifelse(is.finite(as.numeric(Angle)), sprintf("%.1f°", as.numeric(Angle)), "—")
                ),
                rid = dplyr::row_number()
              )
            
            types_chr <- intersect(names(cols), unique(df_plot$TaggedPitchType))
            if (!length(types_chr)) types_chr <- unique(df_plot$TaggedPitchType)
            col_vals <- cols[types_chr]; col_vals[is.na(col_vals)] <- "gray70"
            
            home <- data.frame(
              x = c(-0.75, 0.75, 0.75, 0, -0.75),
              y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
            )
            sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
            mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
            mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
            dx <- (ZONE_RIGHT - ZONE_LEFT) / 3
            dy <- (ZONE_TOP - ZONE_BOTTOM) / 3
            grid_vertical <- data.frame(
              x = c(ZONE_LEFT + dx, ZONE_LEFT + 2 * dx),
              ymin = ZONE_BOTTOM,
              ymax = ZONE_TOP
            )
            grid_horizontal <- data.frame(
              y = c(ZONE_BOTTOM + dy, ZONE_BOTTOM + 2 * dy),
              xmin = ZONE_LEFT,
              xmax = ZONE_RIGHT
            )
            inner_half <- 7 / 12  # 7 inches converted to feet
            green_box <- data.frame(
              xmin = mid_x - inner_half,
              xmax = mid_x + inner_half,
              ymin = mid_y - inner_half,
              ymax = mid_y + inner_half
            )
            
            df_known <- dplyr::filter(df_plot, !is.na(ResultDisplay))
            df_other <- dplyr::filter(df_plot, is.na(ResultDisplay))
            
            p <- ggplot() +
              geom_polygon(data = home, aes(x, y), inherit.aes = FALSE, fill = NA, color = line_col) +
              geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                        inherit.aes = FALSE, fill = NA, color = line_col) +
              geom_rect(data = green_box,
                        aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                        inherit.aes = FALSE,
                        fill = "#4CAF50", alpha = 0.15, color = "#4CAF50", linetype = "dashed", linewidth = 0.75) +
              geom_segment(data = grid_vertical,
                           aes(x = x, xend = x, y = ymin, yend = ymax),
                           inherit.aes = FALSE, color = grid_col, linetype = "solid") +
              geom_segment(data = grid_horizontal,
                           aes(y = y, yend = y, x = xmin, xend = xmax),
                           inherit.aes = FALSE, color = grid_col, linetype = "solid") +
              ggiraph::geom_point_interactive(
                data = df_other,
                aes(PlateLocSide, PlateLocHeight,
                    color = TaggedPitchType, fill = TaggedPitchType,
                    tooltip = tooltip, data_id = rid),
                size = 4.0, alpha = 0.85, shape = 16, stroke = 0.6
              ) +
              ggiraph::geom_point_interactive(
                data = df_known,
                aes(PlateLocSide, PlateLocHeight,
                    color = TaggedPitchType, fill = TaggedPitchType, shape = ResultDisplay,
                    tooltip = tooltip, data_id = rid),
                size = 4.0, alpha = 0.85, stroke = 0.8
              ) +
              scale_color_manual(values = col_vals, limits = types_chr, name = NULL) +
              scale_fill_manual(values = col_vals, limits = types_chr, name = NULL) +
              scale_shape_manual(values = hit_shape_map, drop = TRUE, name = NULL) +
              coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
              theme_void() + theme(legend.position = "none")
            
            girafe_transparent(
              ggobj = p,
              options = list(
                ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css_local),
                ggiraph::opts_hover(css = "stroke-width:1.5px;"),
                ggiraph::opts_hover_inv(css = "opacity:0.15;")
              )
            )
          } else {
            # Use Pitching suite location plot (original)
            df_loc <- df_loc %>%
              dplyr::mutate(
                SplitColumn = .data[[if ("SplitColumn" %in% names(df_loc)) "SplitColumn" else "TaggedPitchType"]],
                Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
                tt = make_hover_tt(.),
                rid = dplyr::row_number(),
                tt_fill = dplyr::coalesce(cols[as.character(SplitColumn)], "gray")
              )
            df_known <- df_loc %>% dplyr::filter(!is.na(Result))
            df_other <- df_loc %>% dplyr::filter(is.na(Result))
            types_chr <- as.character(intersect(names(cols), unique(df_loc$SplitColumn)))
            home <- data.frame(x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
                               y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5)
            cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
            sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
            p <- ggplot() +
              geom_polygon(data = home, aes(x, y), fill = NA, color = "black", inherit.aes = FALSE) +
              geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                        fill = NA, color = "black", linetype = "dashed", inherit.aes = FALSE) +
              geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                        fill = NA, color = "black", inherit.aes = FALSE) +
              ggiraph::geom_point_interactive(
                data = df_other,
                aes(PlateLocSide, PlateLocHeight,
                    color = SplitColumn, fill = SplitColumn,
                    tooltip = tt, data_id = rid),
                position = "identity",
                size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
              ) +
              ggiraph::geom_point_interactive(
                data = df_known,
                aes(PlateLocSide, PlateLocHeight,
                    color = SplitColumn, fill = SplitColumn, shape = Result,
                    tooltip = tt, data_id = rid),
                position = "identity",
                size = 4.0, alpha = 0.95, stroke = 0.8
              ) +
              scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
              scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
              scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
              coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
              theme_void() + theme(legend.position = "none") +
              ggiraph::geom_point_interactive(
                data = df_loc,
                aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
                shape = 21, size = 6, alpha = 0.001, stroke = 0, inherit.aes = FALSE
              )
            girafe_transparent(
              ggobj = p,
              options = list(
                ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css_local),
                ggiraph::opts_hover(css = "stroke-width:1.5px;"),
                ggiraph::opts_hover_inv(css = "opacity:0.15;")
              )
            )
          }
        })
        return(ggiraph::girafeOutput(ns(out_id), height = "280px"))
      } else if (tsel == "Heatmap") {
        output[[out_id]] <- renderPlot({
          df_loc <- df
          if (!nrow(df_loc)) {
            plot.new(); title("No data"); return(invisible())
          }
          
          # Apply Pitch Results filter for heatmap too (use settings_cell_id for filter)
          df_loc <- apply_pitch_results_filter(df_loc, input[[paste0("cell_results_", settings_cell_id)]])
          
          if (!nrow(df_loc)) {
            plot.new(); title("No data after filters"); return(invisible())
          }
          
          # Heatmap type selection
          hm_stat <- input[[paste0("cell_heat_stat_", settings_cell_id)]] %||% "Frequency"
          plot_obj <- render_heatmap_stat(df_loc, hm_stat)
          print(plot_obj)
          return(invisible())
          
          # Use advanced Pitching Suite heatmap implementation
          if (hm_stat == "Frequency") {
            grid <- make_kde_grid(df_loc$PlateLocSide, df_loc$PlateLocHeight, n = 200)
            
            if (!nrow(grid)) return(ggplot() + theme_void())
            
            # Normalize KDE values to 0-100 scale
            grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "Pitch Frequency",
                             scale_limits = c(0, 80)))
          }
          
          # Filter to valid location data for non-Frequency stats
          df_loc <- df_loc %>% dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
          if (!nrow(df_loc)) {
            plot.new(); title("No location data"); return(invisible())
          }
          
          if (hm_stat == "Whiff Rate") {
            swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                              "FoulBallNotFieldable", "InPlay")
            swing_mask  <- df_loc$PitchCall %in% swing_events
            val <- ifelse(swing_mask, ifelse(df_loc$PitchCall == "StrikeSwinging", 1, 0), NA_real_)
            grid <- make_kde_mean_grid(df_loc$PlateLocSide, df_loc$PlateLocHeight, val)
            if (!nrow(grid)) return(ggplot() + theme_void())
            breaks <- c(seq(0, 50, length.out = HEAT_BINS + 1), Inf)
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                             breaks = breaks, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "Whiff Rate %",
                             scale_limits = c(0, 50)))
          }
          
          if (hm_stat == "GB Rate") {
            df_bip <- df_loc %>%
              filter(SessionType == "Live", 
                     PitchCall == "InPlay",
                     !is.na(TaggedHitType))
            
            if (nrow(df_bip) < 3) {
              plot.new(); title("Insufficient Live BIP data"); return(invisible())
            }
            
            val <- ifelse(df_bip$TaggedHitType == "GroundBall", 1, 0)
            grid <- make_kde_mean_grid(df_bip$PlateLocSide, df_bip$PlateLocHeight, val)
            if (!nrow(grid)) return(ggplot() + theme_void())
            
            breaks <- c(-Inf, seq(0, 70, length.out = HEAT_BINS + 1), Inf)
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                             breaks = breaks, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "GB Rate %",
                             scale_limits = c(0, 70)))
          }
          
          if (hm_stat == "Contact Rate") {
            # Contact Rate = 100% - Whiff Rate (guaranteed perfect opposite colors)
            swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                              "FoulBallNotFieldable", "InPlay")
            swing_mask  <- df_loc$PitchCall %in% swing_events
            val <- ifelse(swing_mask, ifelse(df_loc$PitchCall == "StrikeSwinging", 0, 1), NA_real_)
            grid <- make_kde_mean_grid(df_loc$PlateLocSide, df_loc$PlateLocHeight, val)
            if (!nrow(grid)) return(ggplot() + theme_void())
            grid$z <- pmin(pmax(grid$z * 100, 50), 100)
            breaks <- seq(50, 100, length.out = HEAT_BINS + 1)
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                             breaks = breaks, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "Contact Rate %",
                             scale_limits = c(50, 100)))
          }
          
          if (hm_stat == "Swing Rate") {
            swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                              "FoulBallNotFieldable", "InPlay")
            
            val <- ifelse(df_loc$PitchCall %in% swing_events, 1, 0)
            grid <- make_kde_mean_grid(df_loc$PlateLocSide, df_loc$PlateLocHeight, val)
            if (!nrow(grid)) return(ggplot() + theme_void())
            breaks <- seq(20, 80, length.out = HEAT_BINS + 1)
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                             breaks = breaks, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "Swing Rate %",
                             scale_limits = c(20, 80)))
          }
          
          if (hm_stat == "Exit Velocity") {
            df_bip <- dplyr::filter(
              df_loc, 
              SessionType == "Live",
              PitchCall == "InPlay",
              is.finite(PlateLocSide), 
              is.finite(PlateLocHeight),
              is.finite(ExitSpeed)
            )
            
            if (!nrow(df_bip)) return(ggplot() + theme_void())
            
            grid <- make_kde_mean_grid(df_bip$PlateLocSide, df_bip$PlateLocHeight, df_bip$ExitSpeed)
            if (!nrow(grid)) return(ggplot() + theme_void())
            breaks <- seq(60, 110, length.out = HEAT_BINS + 1)
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                             breaks = breaks, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "Exit Velocity (mph)",
                             scale_limits = c(60, 110)))
          }
          
          # Default fallback
          ggplot() + theme_void()
        }, bg = "transparent")
        return(plotOutput(ns(out_id), height = "280px"))
      } else if (tsel == "Summary Table") {
        output[[out_id]] <- DT::renderDataTable({
          # Add tryCatch wrapper for entire table rendering to handle filter transitions
          tryCatch({
            df_tbl <- df
            
            is_hitting_mode <- !is.null(input$report_type) && input$report_type == "Hitting"
            
            if (is_hitting_mode) {
              mode_choice <- input[[paste0("cell_table_mode_", settings_cell_id)]] %||% "Results"
              fmt_avg_local <- function(x) {
                x <- suppressWarnings(as.numeric(x))
                s <- ifelse(is.finite(x), sprintf("%.3f", x), "")
                sub("^0\\.", ".", s)
              }
              if (!"SplitColumn" %in% names(df_tbl)) df_tbl$SplitColumn <- df_tbl$TaggedPitchType
              split_choice <- fsel
              df_tbl <- apply_split_by(df_tbl, split_choice)
              if (!"SplitColumn" %in% names(df_tbl) && split_col_name %in% names(df_tbl)) {
                df_tbl$SplitColumn <- df_tbl[[split_col_name]]
              }
              
              split_col_name <- switch(
                split_choice,
                "Pitch Types" = "Pitch",
                "Pitcher Hand" = "Pitcher Hand",
                "Count" = "Count",
                "After Count" = "After Count",
                "Velocity" = "Velocity",
                "IVB" = "InducedVert",
                "HB" = "HorzBreak",
                "Pitcher" = "Pitcher",
                "Pitch"  # default
              )
              
              if (!nrow(df_tbl)) return(data.frame(Message = "No data"))
              
              swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
              safe_terminal_check <- function(play_result, korbb) {
                play_ok <- !is.na(play_result) & play_result != "Undefined"
                korbb_ok <- !is.na(korbb) & korbb %in% c("Strikeout","Walk")
                return(play_ok | korbb_ok)
              }
              
              is_terminal <- safe_terminal_check(df_tbl$PlayResult, df_tbl$KorBB)
              term <- df_tbl[is_terminal, , drop = FALSE]
              
              if (nrow(term) == 0) {
                return(DT::datatable(
                  data.frame(Message = "No completed plate appearances in selected data"),
                  options = list(dom = 't', autoWidth = FALSE), rownames = FALSE
                ))
              }
              
              # Helper: Results table (same as hitting suite)
              # Local helper for safe division (match hitting suite)
              safe_div_local <- function(num, den) {
                num <- suppressWarnings(as.numeric(num))
                den <- suppressWarnings(as.numeric(den))
                ifelse(is.finite(den) & den != 0 & is.finite(num), num/den, NA_real_)
              }
              
              build_results_table <- function(df_src) {
                per_type <- term %>%
                  dplyr::group_by(SplitColumn) %>%
                  dplyr::summarise(
                    PA   = dplyr::n(),
                    HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
                    Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
                    H1 = sum(PlayResult == "Single",  na.rm = TRUE),
                    H2 = sum(PlayResult == "Double",  na.rm = TRUE),
                    H3 = sum(PlayResult == "Triple",  na.rm = TRUE),
                    HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
                    Kct  = sum(KorBB == "Strikeout" |
                                 PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
                    BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
                    .groups = "drop"
                  ) %>%
                  dplyr::mutate(
                    AB  = PA - (BBct + HBP + Sac),
                    H   = H1 + H2 + H3 + HR,
                    TB  = 1*H1 + 2*H2 + 3*H3 + 4*HR,
                    AVG = dplyr::if_else(AB > 0, H / AB, 0),
                    SLG = dplyr::if_else(AB > 0, TB / AB, 0),
                    OBP = dplyr::if_else(PA > 0, (H + BBct + HBP) / PA, 0),
                    OPS = SLG + OBP
                  )
                
                pitch_totals <- df_src %>%
                  dplyr::group_by(SplitColumn) %>%
                  dplyr::summarise(
                    Pitches = dplyr::n(),
                    Swings  = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
                    Whiffs  = sum(!is.na(PitchCall) & PitchCall == "StrikeSwinging", na.rm = TRUE),
                    .groups = "drop"
                  )
                
                bbe <- df_src %>%
                  dplyr::filter(
                    !is.na(SessionType),
                    grepl("live|game|ab", tolower(SessionType)), 
                    !is.na(PitchCall),
                    PitchCall == "InPlay"
                  )
                
                evla <- if (nrow(bbe) > 0) {
                  bbe %>%
                    dplyr::group_by(SplitColumn) %>%
                    dplyr::summarise(
                      EV = mean(ExitSpeed, na.rm = TRUE), 
                      LA = mean(Angle, na.rm = TRUE),
                      GBpct = sum(!is.na(TaggedHitType) & TaggedHitType == "GroundBall", na.rm = TRUE) / sum(!is.na(TaggedHitType), na.rm = TRUE),
                      .groups = "drop"
                    )
                } else {
                  data.frame(SplitColumn = character(0), EV = numeric(0), LA = numeric(0), GBpct = numeric(0))
                }
                
                out <- per_type %>%
                  dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
                  dplyr::left_join(evla, by = "SplitColumn") %>%
                  dplyr::mutate(
                    `Swing%` = dplyr::if_else(Pitches > 0, Swings / Pitches, 0),
                    `Whiff%` = dplyr::if_else(Swings > 0, Whiffs / Swings, 0),
                    `GB%` = dplyr::coalesce(GBpct, 0),
                    `K%` = dplyr::if_else(PA > 0, Kct / PA, 0),
                    `BB%` = dplyr::if_else(PA > 0, BBct / PA, 0)
                  ) %>%
                  dplyr::transmute(
                    !!split_col_name := as.character(SplitColumn),
                    PA, AB, AVG, SLG, OBP, OPS,
                    xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
                    `Swing%`, `Whiff%`, `GB%`, `K%`, `BB%`, `Barrel%` = NA_real_, EV, LA
                  )
                
                # Process extras (xWOBA/xISO/BABIP/Barrel%) from compute_process_results
                extras_raw <- compute_process_results(df_src)
                if ("PitchType" %in% names(extras_raw)) {
                  extras <- extras_raw %>%
                    dplyr::rename(!!split_col_name := PitchType) %>%
                    dplyr::mutate(
                      xWOBA     = suppressWarnings(as.numeric(xWOBA)),
                      xISO      = suppressWarnings(as.numeric(xISO)),
                      BABIP     = suppressWarnings(as.numeric(BABIP)),
                      `Barrel%` = suppressWarnings(as.numeric(`Barrel%`))
                    ) %>%
                    dplyr::select(.data[[split_col_name]], xWOBA, xISO, BABIP, `Barrel%`)
                } else {
                  extras <- tibble::tibble(
                    !!split_col_name := character(0),
                    xWOBA = numeric(0), xISO = numeric(0), BABIP = numeric(0), `Barrel%` = numeric(0)
                  )
                }
                
                # Barrel% per split (fallback to ensure non-blank)
                barrels_df <- df_src %>%
                  dplyr::group_by(SplitColumn) %>%
                  dplyr::summarise(
                    BarrelPct = safe_div_local(
                      sum(SessionType == "Live" & PitchCall == "InPlay" &
                            is.finite(ExitSpeed) & is.finite(Angle) &
                            ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, na.rm = TRUE),
                      sum(SessionType == "Live" & PitchCall == "InPlay", na.rm = TRUE)
                    ),
                    .groups = "drop"
                  ) %>%
                  dplyr::rename(!!split_col_name := SplitColumn)
                
                # ALL row
                PAt <- nrow(term)
                HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
                Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
                H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
                H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
                H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
                HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
                H   <- H1 + H2 + H3 + HR
                TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
                Kct_all <- sum(term$KorBB == "Strikeout" |
                                 term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
                BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
                ABt <- PAt - (BBc_all + HBP_all + Sac_all)
                
                swings_all  <- sum(!is.na(df_src$PitchCall) & df_src$PitchCall %in% swing_levels, na.rm = TRUE)
                whiffs_all  <- sum(df_src$PitchCall == "StrikeSwinging", na.rm = TRUE)
                total_pitches <- nrow(df_src)
                
                bbe_all <- df_src %>% dplyr::filter(
                  !is.na(SessionType),
                  grepl("live|game|ab", tolower(SessionType)), 
                  !is.na(PitchCall),
                  PitchCall == "InPlay"
                )
                
                gbpct_all <- safe_div_local(sum(bbe_all$TaggedHitType == "GroundBall", na.rm = TRUE),
                                            sum(!is.na(bbe_all$TaggedHitType), na.rm = TRUE))
                
                all_row <- tibble::tibble(
                  !!split_col_name := "All",
                  PA = PAt,
                  AB = ABt,
                  AVG = safe_div_local(H, ABt),
                  SLG = safe_div_local(TB, ABt),
                  OBP = safe_div_local(H + BBc_all + HBP_all, PAt),
                  OPS = NA_real_,
                  xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
                  `Swing%` = safe_div_local(swings_all, total_pitches),
                  `Whiff%` = safe_div_local(whiffs_all, swings_all),
                  `GB%` = gbpct_all,
                  `K%` = safe_div_local(Kct_all, PAt),
                  `BB%` = safe_div_local(BBc_all, PAt),
                  `Barrel%` = NA_real_,
                  EV = nz_mean(bbe_all$ExitSpeed),
                  LA = nz_mean(bbe_all$Angle)
                ) %>%
                  dplyr::mutate(OPS = SLG + OBP)
                
                # All-row extras
                extras_all <- compute_process_results(df_src) %>%
                  dplyr::summarise(
                    xWOBA     = nz_mean(suppressWarnings(as.numeric(xWOBA))),
                    xISO      = nz_mean(suppressWarnings(as.numeric(xISO))),
                    BABIP     = nz_mean(suppressWarnings(as.numeric(BABIP))),
                    `Barrel%` = nz_mean(suppressWarnings(as.numeric(`Barrel%`))),
                    .groups = "drop"
                  )
                if (nrow(extras_all)) {
                  all_row$xWOBA     <- extras_all$xWOBA[1]
                  all_row$xISO      <- extras_all$xISO[1]
                  all_row$BABIP     <- extras_all$BABIP[1]
                  all_row$`Barrel%` <- extras_all$`Barrel%`[1]
                }
                # All-row Barrel% fallback
                all_barrel_frac <- safe_div_local(
                  sum(df_src$SessionType == "Live" & df_src$PitchCall == "InPlay" &
                        is.finite(df_src$ExitSpeed) & is.finite(df_src$Angle) &
                        df_src$ExitSpeed >= 95 & df_src$Angle >= 10 & df_src$Angle <= 35, na.rm = TRUE),
                  sum(df_src$SessionType == "Live" & df_src$PitchCall == "InPlay", na.rm = TRUE)
                )
                if (is.finite(all_barrel_frac)) {
                  all_row$`Barrel%` <- all_barrel_frac
                }
                
                res <- dplyr::bind_rows(out, all_row)
                # Join per-type extras and barrel fallback
                if (nrow(extras)) {
                  res <- res %>% dplyr::left_join(extras, by = split_col_name, suffix = c("", ".ext"))
                }
                if (nrow(barrels_df)) {
                  res <- res %>% dplyr::left_join(barrels_df, by = split_col_name)
                  res$`Barrel%` <- dplyr::coalesce(res$BarrelPct, res$`Barrel%`)
                  res$BarrelPct <- NULL
                }
                if ("xWOBA.ext" %in% names(res)) {
                  res <- res %>%
                    dplyr::mutate(
                      xWOBA     = dplyr::coalesce(xWOBA.ext, xWOBA),
                      xISO      = dplyr::coalesce(xISO.ext,  xISO),
                      BABIP     = dplyr::coalesce(BABIP.ext, BABIP),
                      `Barrel%` = dplyr::coalesce(`Barrel%.ext`, `Barrel%`)
                    ) %>%
                    dplyr::select(-dplyr::ends_with(".ext"))
                }
                
                # Enforce pitch order if splitting by Pitch Types
                if (identical(split_choice, "Pitch Types") && split_col_name == "Pitch") {
                  ord <- names(all_colors)
                  res[[split_col_name]] <- factor(res[[split_col_name]], levels = c(ord, setdiff(res[[split_col_name]], ord)))
                  res <- res %>% dplyr::arrange(res[[split_col_name]])
                  res[[split_col_name]] <- as.character(res[[split_col_name]])
                }
                
                res
              }
              
              # Helper: Swing Decision table (same as hitting suite)
              build_swing_decisions <- function(df_src) {
                if (!nrow(df_src)) {
                  return(DT::datatable(
                    data.frame(Message = "No data for Swing Decisions"),
                    options = list(dom = 't', autoWidth = FALSE), rownames = FALSE
                  ))
                }
                df_src <- df_src %>%
                  dplyr::mutate(SplitColumn = dplyr::coalesce(as.character(SplitColumn), "Unknown"))
                
                inner_half <- 7 / 12
                mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
                mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
                green_xmin <- mid_x - inner_half
                green_xmax <- mid_x + inner_half
                green_ymin <- mid_y - inner_half
                green_ymax <- mid_y + inner_half
                
                df_sd <- df_src %>%
                  dplyr::mutate(
                    is_swing = !is.na(PitchCall) & PitchCall %in% swing_levels,
                    in_green = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                      PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                      PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
                    in_zone = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                      PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                      PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
                    possd_point = dplyr::case_when(
                      in_green & is_swing ~ 2,
                      in_green & !is_swing ~ -1,
                      in_zone & !in_green & is_swing ~ 1,
                      in_zone & !in_green & !is_swing ~ 0,
                      !in_zone & is_swing ~ -1,
                      !in_zone & !is_swing ~ 1,
                      TRUE ~ 0
                    )
                  )
                
                summarize_sd <- function(dat) {
                  total_pitches <- nrow(dat)
                  swings <- sum(dat$is_swing, na.rm = TRUE)
                  fps_num <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0 &
                                   !is.na(dat$PitchCall) & dat$PitchCall %in% c("StrikeSwinging","InPlay","FoulBall","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
                  fps_den <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0, na.rm = TRUE)
                  called <- sum(!is.na(dat$PitchCall) & dat$PitchCall == "StrikeCalled", na.rm = TRUE)
                  chase_num <- sum(dat$is_swing & !dat$in_zone, na.rm = TRUE)
                  chase_den <- sum(!dat$in_zone, na.rm = TRUE)
                  gozone_sw_num <- sum(dat$is_swing & dat$in_green, na.rm = TRUE)
                  gozone_sw_den <- sum(dat$in_green, na.rm = TRUE)
                  iz_sw_num <- sum(dat$is_swing & dat$in_zone, na.rm = TRUE)
                  iz_sw_den <- sum(dat$in_zone, na.rm = TRUE)
                  edge_sw_num <- sum(dat$is_swing & dat$in_zone & !dat$in_green, na.rm = TRUE)
                  edge_sw_den <- sum(dat$in_zone & !dat$in_green, na.rm = TRUE)
                  possd_points <- sum(dat$possd_point, na.rm = TRUE)
                  
                  tibble::tibble(
                    `Swing%` = safe_div_local(swings, total_pitches) * 100,
                    `FPS%` = safe_div_local(fps_num, fps_den) * 100,
                    `Called%` = safe_div_local(called, total_pitches) * 100,
                    `Chase%` = safe_div_local(chase_num, chase_den) * 100,
                    `GoZoneSw%` = safe_div_local(gozone_sw_num, gozone_sw_den) * 100,
                    `IZswing%` = safe_div_local(iz_sw_num, iz_sw_den) * 100,
                    `EdgeSwing%` = safe_div_local(edge_sw_num, edge_sw_den) * 100,
                    `PosSD%` = safe_div_local(possd_points, total_pitches) * 100
                  )
                }
                
                swing_decision_by_type <- df_sd %>%
                  dplyr::group_by(SplitColumn, .drop = FALSE) %>%
                  dplyr::group_modify(~ summarize_sd(.x)) %>%
                  dplyr::ungroup() %>%
                  dplyr::rename(!!split_col_name := SplitColumn)
                
                all_row <- summarize_sd(df_sd) %>%
                  dplyr::mutate(!!split_col_name := "All")
                
                df_swing_decision <- dplyr::bind_rows(swing_decision_by_type, all_row)
                
                pct_cols_sd <- c("Swing%", "FPS%", "Called%", "Chase%", "GoZoneSw%", "IZswing%", "EdgeSwing%", "PosSD%")
                for (col in pct_cols_sd) if (col %in% names(df_swing_decision)) {
                  v <- suppressWarnings(as.numeric(df_swing_decision[[col]]))
                  df_swing_decision[[col]] <- ifelse(is.finite(v), paste0(round(v, 1), "%"), "")
                }
                if (identical(split_choice, "Pitch Types") && split_col_name == "Pitch") {
                  ord <- names(all_colors)
                  df_swing_decision[[split_col_name]] <- factor(df_swing_decision[[split_col_name]], levels = c(ord, setdiff(df_swing_decision[[split_col_name]], ord)))
                  df_swing_decision <- df_swing_decision %>% dplyr::arrange(.data[[split_col_name]])
                  df_swing_decision[[split_col_name]] <- as.character(df_swing_decision[[split_col_name]])
                }
                
                datatable_with_colvis(
                  df_swing_decision,
                  lock            = split_col_name,
                  remember        = FALSE,
                  default_visible = c(split_col_name, pct_cols_sd),
                  mode            = NULL,
                  enable_colors   = FALSE
                )
              }
              
              if (identical(mode_choice, "Swing Decisions")) {
                return(build_swing_decisions(df_tbl))
              }
              
              results_df <- build_results_table(df_tbl)
              num_cols <- c("PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP",
                            "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
              results_df <- results_df %>%
                dplyr::mutate(dplyr::across(dplyr::all_of(num_cols), ~ suppressWarnings(as.numeric(.)))) %>%
                {
                  df_tmp <- .
                  pct_cols  <- c("Swing%","Whiff%","GB%","K%","BB%","Barrel%")
                  rate_cols <- c("AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP")
                  for (nm in pct_cols) if (nm %in% names(df_tmp)) df_tmp[[nm]] <- ifelse(is.finite(df_tmp[[nm]]), paste0(round(df_tmp[[nm]]*100,1), "%"), "")
                  for (nm in rate_cols) if (nm %in% names(df_tmp)) df_tmp[[nm]] <- ifelse(is.finite(df_tmp[[nm]]), fmt_avg_local(df_tmp[[nm]]), "")
                  if ("EV" %in% names(df_tmp)) df_tmp$EV <- ifelse(is.finite(df_tmp$EV), round(df_tmp$EV,1), "")
                  if ("LA" %in% names(df_tmp)) df_tmp$LA <- ifelse(is.finite(df_tmp$LA), round(df_tmp$LA,1), "")
                  df_tmp
                }
              
              visible_cols_base <- c(split_col_name, "PA", "AB", "AVG", "SLG", "OBP", "OPS", "xWOBA", "xISO", "BABIP",
                                     "Swing%", "Whiff%", "GB%", "K%", "BB%", "Barrel%", "EV", "LA")
              if (identical(mode_choice, "Custom")) {
                custom_cols <- input[[paste0("cell_table_custom_cols_", settings_cell_id)]] %||% visible_cols_base[-1]
                custom_cols <- custom_cols[custom_cols %in% visible_cols_base]
                visible_cols <- unique(c(split_col_name, custom_cols))
              } else {
                visible_cols <- visible_cols_base
              }
              
              datatable_with_colvis(
                results_df,
                lock = split_col_name,
                remember = FALSE,
                default_visible = intersect(visible_cols, names(results_df)),
                mode = NULL,
                enable_colors = FALSE
              )
            } else {
              # PITCHING MODE: Use existing logic
              if (!"Strike" %in% names(df_tbl)) df_tbl$Strike <- 0
              if (!"Whiff" %in% names(df_tbl))  df_tbl$Whiff  <- 0
              if (!"SplitColumn" %in% names(df_tbl)) df_tbl$SplitColumn <- df_tbl$TaggedPitchType
              split_choice <- fsel
              df_tbl <- apply_split_by(df_tbl, split_choice)
              if (identical(split_choice, "Pitch Types")) {
                ord <- names(all_colors)
                df_tbl$SplitColumn <- as.character(df_tbl$SplitColumn)
                extra <- setdiff(unique(df_tbl$SplitColumn), ord)
                df_tbl$SplitColumn <- factor(df_tbl$SplitColumn, levels = c(ord, extra))
                df_tbl$SplitColumn <- as.character(df_tbl$SplitColumn)
              }
              attr(df_tbl, "split_choice") <- split_choice
              if (!"SplitColumn" %in% names(df_tbl)) df_tbl$SplitColumn <- df_tbl$TaggedPitchType
              if (!nrow(df_tbl)) return(data.frame(Message = "No data"))
              
              # resolve table mode, including saved customs
              mode_choice <- input[[paste0("cell_table_mode_", settings_cell_id)]] %||% "Stuff"
              res_mode <- resolve_table_mode_global(mode_choice, NULL)
              mode <- res_mode$mode
              custom_cols <- res_mode$cols
              enable_colors <- isTRUE(input[[paste0("cell_color_", settings_cell_id)]])
              
              # Use the global .dp_like_table function (defined in main server, populated by comparison suite)
              if (exists(".dp_like_table", inherits = TRUE) && is.function(.dp_like_table)) {
                .dp_like_table(df_tbl, mode, custom_cols, enable_colors = enable_colors)
              } else {
                # Fallback: show message
                DT::datatable(
                  data.frame(Message = "Table builder loading. Please refresh if this persists."),
                  options = list(dom = 't', autoWidth = FALSE), rownames = FALSE
                )
              }
            }
          }, error = function(e) {
            # If any error during rendering, show a helpful message
            message("Error rendering custom reports table: ", e$message)
            DT::datatable(
              data.frame(Message = paste("Error rendering table:", e$message)),
              options = list(dom = 't', autoWidth = FALSE), rownames = FALSE
            )
          })
        })
        return(DT::dataTableOutput(ns(out_id)))
      } else if (tsel == "Spray Chart") {
        output[[out_id]] <- ggiraph::renderGirafe({
          # Different data filtering based on report type
          if (input$report_type == "Pitching") {
            # For pitching: show where batters hit off this pitcher
            df_spray <- df %>% dplyr::filter(!is.na(Batter))
          } else {
            # For hitting: show where this batter hit the ball
            df_spray <- df
          }
          
          if (!nrow(df_spray)) return(NULL)
          dark_on <- is_dark_mode_local()
          cols <- colors_for_mode(dark_on)
          field_fill  <- if (dark_on) "transparent" else "#f3f5f7"
          field_alpha <- if (dark_on) 0 else 0.6
          foul_line_col <- if (dark_on) "#e5e7eb" else "grey50"
          fence_col  <- if (dark_on) "#9ca3af" else "grey40"
          infield_col <- if (dark_on) "#cbd5e1" else "grey70"
          text_col   <- if (dark_on) "#e5e7eb" else "black"
          
          # Accept any live-like session text
          st <- tolower(trimws(as.character(df_spray$SessionType)))
          live_mask <- grepl("live|game|ab", st)
          
          # Require in-play with numeric distance/direction
          dist_num <- suppressWarnings(as.numeric(df_spray$Distance))
          dir_num  <- suppressWarnings(as.numeric(df_spray$Direction))
          ok <- which(live_mask & df_spray$PitchCall == "InPlay" &
                        is.finite(dist_num) & is.finite(dir_num))
          
          # --- Field geometry (±45°, 330/370/400/370/330) ---
          fence_pts <- data.frame(deg = c(-45,-22.5,0,22.5,45),
                                  r   = c(330,370,400,370,330))
          deg_seq <- seq(-45, 45, length.out = 301)
          r_seq   <- stats::spline(fence_pts$deg, fence_pts$r, xout = deg_seq)$y
          fence   <- data.frame(x = r_seq * sin(deg_seq*pi/180),
                                y = r_seq * cos(deg_seq*pi/180))
          fl_l <- data.frame(x = c(0, 330*sin(-45*pi/180)),
                             y = c(0, 330*cos(-45*pi/180)))
          fl_r <- data.frame(x = c(0, 330*sin( 45*pi/180)),
                             y = c(0, 330*cos( 45*pi/180)))
          th_in <- seq(-45, 45, length.out = 121)
          infield <- data.frame(x = 95 * sin(th_in*pi/180),
                                y = 95 * cos(th_in*pi/180))
          # home plate (simple)
          home <- data.frame(
            x = c(-0.75, 0.75, 0.75, 0, -0.75),
            y = c( 1.05, 1.05, 1.15, 1.25, 1.15) - 2.0
          )
          
          # If nothing to plot, show field + message
          if (!length(ok)) {
            p_empty <- ggplot() +
              geom_polygon(data = home, aes(x, y), fill = NA, color = foul_line_col) +
              geom_path(data = fence, aes(x, y), color = fence_col, linewidth = 0.8) +
              geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                           fill = field_fill, color = NA, alpha = field_alpha) +
              geom_path(data = fl_l, aes(x, y), color = foul_line_col) +
              geom_path(data = fl_r, aes(x, y), color = foul_line_col) +
              geom_path(data = infield, aes(x, y), color = infield_col) +
              annotate("text", x = 0, y = 200, label = "No balls in play for current filters", size = 5, color = text_col) +
              coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
              theme_void()
            return(girafe_transparent(ggobj = p_empty))
          }
          
          # --- Points to plot ---
          bbe <- df_spray[ok, , drop = FALSE]
          bbe$Distance  <- dist_num[ok]
          bbe$Direction <- dir_num[ok]
          
          # Fixed mapping: raw Direction ±75 -> on-field ±45 (foul lines)
          FOUL_DEG_RAW  <- 90    # raw "down the line"
          FOUL_DEG_GEOM <- 110    # field drawing foul line angle
          angle_scale   <- FOUL_DEG_GEOM / FOUL_DEG_RAW
          
          # Polar (0° = CF, +RF, −LF) → cartesian
          th     <- bbe$Direction * angle_scale * pi/180
          bbe$x  <- bbe$Distance * sin(th)
          bbe$y  <- bbe$Distance * cos(th)
          
          # Outcome colors
          outcome <- dplyr::case_when(bbe$PlayResult %in% hit_levels ~ bbe$PlayResult, TRUE ~ "Out")
          bbe$Outcome <- factor(outcome, levels = c("Out", hit_levels))
          outcome_cols <- if (dark_on) {
            c("Single"="#34d399","Double"="#60a5fa","Triple"="#c084fc","HomeRun"="#f87171","Out"="#e5e7eb")
          } else {
            c("Single"="#1fab54","Double"="#1f77b4","Triple"="#7b1fa2","HomeRun"="#d62728","Out"="#222222")
          }
          
          # Tooltip + tooltip fill by pitch type color
          bbe <- bbe %>%
            dplyr::mutate(
              rid     = dplyr::row_number(),
              tt      = paste0(
                "EV: ", ifelse(is.finite(ExitSpeed), sprintf("%.1f", ExitSpeed), "—"), " mph\n",
                "LA: ", ifelse(is.finite(Angle),     sprintf("%.1f", Angle),     "—"), "°\n",
                "Distance: ", ifelse(is.finite(Distance), paste0(sprintf("%.0f", Distance), " ft"), "—"), "\n",
                "Pitch: ", TaggedPitchType, "\n",
                "Result: ", PlayResult
              ),
              tt_fill = dplyr::coalesce(cols[as.character(TaggedPitchType)], "gray80")
            )
          
          p <- ggplot() +
            geom_polygon(data = home, aes(x, y), fill = NA, color = foul_line_col) +
            geom_path(data = fence, aes(x, y), color = fence_col, linewidth = 0.8) +
            geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                         fill = field_fill, color = NA, alpha = field_alpha) +
            geom_path(data = fl_l, aes(x, y), color = foul_line_col) +
            geom_path(data = fl_r, aes(x, y), color = foul_line_col) +
            geom_path(data = infield, aes(x, y), color = infield_col) +
            
            ggiraph::geom_point_interactive(
              data = bbe,
              aes(x, y, color = Outcome, tooltip = tt, data_id = rid),
              size = 2.8, alpha = 0.95
            ) +
            ggiraph::geom_point_interactive( # invisible hover pad to color tooltip bg by pitch type
              data = bbe,
              aes(x, y, tooltip = tt, data_id = rid, fill = I(tt_fill)),
              shape = 21, size = 8, alpha = 0.001, stroke = 0, inherit.aes = FALSE
            ) +
            scale_color_manual(values = outcome_cols, name = "Result") +
            coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
            theme_void() + theme(
              legend.position = "bottom",
              legend.direction = "horizontal",
              legend.box = "horizontal",
              legend.margin = margin(t = -4, r = 0, b = -12, l = 0),
              legend.box.margin = margin(t = -6, r = 0, b = -14, l = 0),
              plot.margin = margin(t = 0, r = 0, b = -16, l = 0),
              legend.text = element_text(size = 11, face = "bold", color = text_col),
              legend.title = element_text(color = text_col),
              legend.background = element_rect(fill = "transparent", color = NA),
              legend.box.background = element_rect(fill = "transparent", color = NA),
              legend.key = element_rect(fill = "transparent", color = NA)
            )
          
          girafe_transparent(
            ggobj = p,
            options = list(
              ggiraph::opts_sizing(rescale = TRUE),
              ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css_local),
              ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
              ggiraph::opts_hover_inv(css = "opacity:0.15;")
            )
          )
        })
        return(ggiraph::girafeOutput(ns(out_id), height = "280px"))
      }
      output[[out_id]] <- renderUI({ div("Unsupported selection") })
      uiOutput(ns(out_id))
    }
    
    # Outputs for each cell (optimized to only create observers once per cell)
    cells_with_render_observers <- reactiveVal(character(0))
    
    observeEvent(list(input$report_rows, input$report_cols), {
      rows <- as.integer(input$report_rows); cols <- as.integer(input$report_cols)
      
      # Validate that rows and cols are valid integers
      if (length(rows) == 0 || length(cols) == 0) return()
      if (is.na(rows) || is.na(cols)) return()
      if (rows < 1 || cols < 1) return()
      
      existing_render <- cells_with_render_observers()
      
      for (r in seq_len(rows)) {
        for (c in seq_len(cols)) {
          cell_id <- paste0("r", r, "c", c)
          
          # Only create observer if we haven't already
          if (!cell_id %in% existing_render) {
            local({
              id <- cell_id
              
              # Use reactive to cache expensive computations
              cell_data <- reactive({
                # Only re-compute when these specific inputs change
                # NOTE: Do NOT include cell_title here - it causes re-render on every keystroke
                input[[paste0("cell_type_", id)]]
                input[[paste0("cell_filter_", id)]]
                input[[paste0("cell_table_mode_", id)]]
                
                # Isolate to prevent reactive dependencies on filters
                list(
                  type = input[[paste0("cell_type_", id)]],
                  filter = input[[paste0("cell_filter_", id)]],
                  mode = input[[paste0("cell_table_mode_", id)]]
                )
              }) %>% debounce(300)  # Slightly increased for stability
              
              # Update title display using delayed shinyjs::html (throttled to prevent focus loss)
              # In Multi-Player mode, rows 2+ use Row 1's title
              observe({
                # Determine which title to use
                is_multi_player <- input$report_scope == "Multi-Player"
                
                # Extract row and column from cell_id (format: "r1c2")
                row_num <- as.integer(sub("r(\\d+)c\\d+", "\\1", id))
                col_num <- as.integer(sub("r\\d+c(\\d+)", "\\1", id))
                
                # For rows 2+ in Multi-Player mode, use Row 1's title
                if (is_multi_player && row_num > 1) {
                  title_cell_id <- paste0("r1c", col_num)
                  title_val <- input[[paste0("cell_title_", title_cell_id)]]
                } else {
                  title_val <- input[[paste0("cell_title_", id)]]
                }
                
                shinyjs::delay(50, {
                  shinyjs::html(
                    id = paste0("cell_title_display_", id),
                    html = title_val %||% ""
                  )
                })
              })
              
              output[[paste0("cell_output_", id)]] <- renderUI({
                # Get cell data (triggers on chart type/filter/mode changes only)
                cd <- cell_data()
                
                # Render the chart (title is separate, updated via shinyjs)
                render_cell(id)
              })
            })
            existing_render <- c(existing_render, cell_id)
          }
        }
      }
      cells_with_render_observers(existing_render)
    }, ignoreInit = FALSE)
  })
}

# ==================================
# == Player Plans Suite ==
# ==================================

# Player Plans UI
player_plans_ui <- function() {
  fluidPage(
    tags$head(
      tags$style(HTML("
        .goal-container {
          border: 1px solid #ddd;
          border-radius: 5px;
          padding: 15px;
          margin: 10px 0;
          background-color: #f9f9f9;
          position: relative;
        }
        .goal-description {
          min-height: 80px;
          padding: 10px;
          background-color: white;
          border: 1px solid #e0e0e0;
          border-radius: 3px;
          margin-bottom: 15px;
        }
        /* Fixed checkbox positioning */
        .goal-checkbox {
          position: absolute !important;
          top: 8px !important;
          right: 8px !important;
          z-index: 999 !important;
          margin: 0 !important;
          padding: 0 !important;
        }
        .goal-checkbox .checkbox {
          margin: 0 !important;
          min-height: auto !important;
        }
        .goal-checkbox .checkbox input[type='checkbox'] {
          margin: 0 !important;
        }
      "))
    ),
    
    div(
      class = "pp-root",
      sidebarLayout(
        sidebarPanel(
          width = 3,
          h4("Player Plans"),
          selectInput("pp_player_select", "Select Player:",
                      choices = NULL,
                      selected = NULL),
          
          selectInput("pp_session_type", "Session Type:",
                      choices = c("All", "Bullpen", "Live"),
                      selected = "All"),
          
          dateRangeInput("pp_date_range", "Date Range:",
                         start = Sys.Date() - 30,
                         end = Sys.Date(),
                         format = "mm/dd/yyyy"),
          
          hr(),
          
          # Goal 1
          h5("Goal #1"),
          selectInput("pp_goal1_type", "Goal Type:",
                      choices = c("", "Stuff", "Execution"),
                      selected = ""),
          
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Stuff'",
            selectInput("pp_goal1_stuff_category", "Category:",
                        choices = c("", "Velocity", "Movement"),
                        selected = "")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Stuff' && input.pp_goal1_stuff_category == 'Velocity'",
            selectInput("pp_goal1_velocity_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal1_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Stuff' && input.pp_goal1_stuff_category == 'Movement'",
            selectInput("pp_goal1_movement_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal1_movement_type", "Movement Type:",
                        choices = c("IVB", "HB"),
                        selected = NULL,
                        multiple = TRUE),
            selectInput("pp_goal1_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Stuff'",
            selectInput("pp_goal1_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Movement Plot", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Stuff' && input.pp_goal1_chart_view == 'Movement Plot'",
            selectInput("pp_goal1_movement_display", "Movement Plot View:",
                        choices = c("Averages Only", "Averages and Pitches",
                                    "Target Shapes Only", "Target Shapes and Pitches"),
                        selected = c("Averages and Pitches"),
                        multiple = TRUE),
            actionButton("pp_goal1_target_settings", "Target Shapes Settings",
                         class = "btn-default btn-sm")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Execution'",
            selectInput("pp_goal1_execution_stat", "Stat:",
                        choices = c("", "FPS%", "E+A%", "InZone%", "Strike%", 
                                    "Comp%", "Ctrl+", "QP+", "QP%", "Whiff%", "CSW%"),
                        selected = ""),
            selectInput("pp_goal1_execution_pitch", "Pitch Type:",
                        choices = c("All"),
                        selected = "All",
                        multiple = TRUE),
            selectInput("pp_goal1_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All"),
            selectInput("pp_goal1_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Heatmap", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          
          # Target section for Goal 1
          conditionalPanel(
            condition = "input.pp_goal1_type != ''",
            hr(),
            h6("Target:"),
            fluidRow(
              column(4,
                     selectInput("pp_goal1_target_direction", NULL,
                                 choices = c("", ">", "<"),
                                 selected = "")
              ),
              column(8,
                     textInput("pp_goal1_target_value", NULL,
                               placeholder = "Enter target value",
                               value = "")
              )
            )
          ),
          
          hr(),
          
          # Goal 2
          h5("Goal #2"),
          selectInput("pp_goal2_type", "Goal Type:",
                      choices = c("", "Stuff", "Execution"),
                      selected = ""),
          
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Stuff'",
            selectInput("pp_goal2_stuff_category", "Category:",
                        choices = c("", "Velocity", "Movement"),
                        selected = "")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Stuff' && input.pp_goal2_stuff_category == 'Velocity'",
            selectInput("pp_goal2_velocity_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal2_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Stuff' && input.pp_goal2_stuff_category == 'Movement'",
            selectInput("pp_goal2_movement_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal2_movement_type", "Movement Type:",
                        choices = c("IVB", "HB"),
                        selected = NULL,
                        multiple = TRUE),
            selectInput("pp_goal2_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Stuff'",
            selectInput("pp_goal2_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Movement Plot", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Stuff' && input.pp_goal2_chart_view == 'Movement Plot'",
            selectInput("pp_goal2_movement_display", "Movement Plot View:",
                        choices = c("Averages Only", "Averages and Pitches",
                                    "Target Shapes Only", "Target Shapes and Pitches"),
                        selected = c("Averages and Pitches"),
                        multiple = TRUE),
            actionButton("pp_goal2_target_settings", "Target Shapes Settings",
                         class = "btn-default btn-sm")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Execution'",
            selectInput("pp_goal2_execution_stat", "Stat:",
                        choices = c("", "FPS%", "E+A%", "InZone%", "Strike%", 
                                    "Comp%", "Ctrl+", "QP+", "QP%", "Whiff%", "CSW%"),
                        selected = ""),
            selectInput("pp_goal2_execution_pitch", "Pitch Type:",
                        choices = c("All"),
                        selected = "All",
                        multiple = TRUE),
            selectInput("pp_goal2_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All"),
            selectInput("pp_goal2_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Heatmap", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          
          # Target section for Goal 2
          conditionalPanel(
            condition = "input.pp_goal2_type != ''",
            hr(),
            h6("Target:"),
            fluidRow(
              column(4,
                     selectInput("pp_goal2_target_direction", NULL,
                                 choices = c("", ">", "<"),
                                 selected = "")
              ),
              column(8,
                     textInput("pp_goal2_target_value", NULL,
                               placeholder = "Enter target value",
                               value = "")
              )
            )
          ),
          
          hr(),
          
          # Goal 3
          h5("Goal #3"),
          selectInput("pp_goal3_type", "Goal Type:",
                      choices = c("", "Stuff", "Execution"),
                      selected = ""),
          
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Stuff'",
            selectInput("pp_goal3_stuff_category", "Category:",
                        choices = c("", "Velocity", "Movement"),
                        selected = "")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Stuff' && input.pp_goal3_stuff_category == 'Velocity'",
            selectInput("pp_goal3_velocity_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal3_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Stuff' && input.pp_goal3_stuff_category == 'Movement'",
            selectInput("pp_goal3_movement_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal3_movement_type", "Movement Type:",
                        choices = c("IVB", "HB"),
                        selected = NULL,
                        multiple = TRUE),
            selectInput("pp_goal3_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Stuff'",
            selectInput("pp_goal3_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Movement Plot", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Stuff' && input.pp_goal3_chart_view == 'Movement Plot'",
            selectInput("pp_goal3_movement_display", "Movement Plot View:",
                        choices = c("Averages Only", "Averages and Pitches",
                                    "Target Shapes Only", "Target Shapes and Pitches"),
                        selected = c("Averages and Pitches"),
                        multiple = TRUE),
            actionButton("pp_goal3_target_settings", "Target Shapes Settings",
                         class = "btn-default btn-sm")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Execution'",
            selectInput("pp_goal3_execution_stat", "Stat:",
                        choices = c("", "FPS%", "E+A%", "InZone%", "Strike%", 
                                    "Comp%", "Ctrl+", "QP+", "QP%", "Whiff%", "CSW%"),
                        selected = ""),
            selectInput("pp_goal3_execution_pitch", "Pitch Type:",
                        choices = c("All"),
                        selected = "All",
                        multiple = TRUE),
            selectInput("pp_goal3_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All"),
            selectInput("pp_goal3_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Heatmap", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          
          # Target section for Goal 3
          conditionalPanel(
            condition = "input.pp_goal3_type != ''",
            hr(),
            h6("Target:"),
            fluidRow(
              column(4,
                     selectInput("pp_goal3_target_direction", NULL,
                                 choices = c("", ">", "<"),
                                 selected = "")
              ),
              column(8,
                     textInput("pp_goal3_target_value", NULL,
                               placeholder = "Enter target value",
                               value = "")
              )
            )
          )
        ),
        
        mainPanel(
          width = 9,
          div(id = "player-plans-content",
              # PDF Download Button
              # Content goes here
              
              # Header section with logos and title
              fluidRow(
                column(2,
                       div(style = "text-align: left; padding-top: 20px;",
                           tags$img(src = "PCUlogo.png", style = "height: 80px; max-width: 100%;")
                       )
                ),
                column(8,
                       div(style = "text-align: center; padding: 20px 0;",
                           h2(strong("Player Development Plan"), style = "margin-bottom: 10px;"),
                           h3(strong(textOutput("pp_player_name", inline = TRUE)), style = "margin-bottom: 5px;"),
                           h5(em(textOutput("pp_date_range_display", inline = TRUE)), style = "margin: 0;")
                       )
                ),
                column(2,
                       div(style = "text-align: right; padding-top: 30px;",
                           tags$img(src = school_logo, style = "height: 40px; max-width: 100%;", alt = school_display_name)
                       )
                )
              ),
              hr(),
              uiOutput("pp_dynamic_goals"),
              br(),
              # View Completed Goals button
              fluidRow(
                column(12,
                       div(style = "text-align: center; margin: 20px 0;",
                           actionButton("pp_view_completed", "View Completed Goals", 
                                        class = "btn-info", style = "margin-right: 10px;"),
                           span(textOutput("pp_completed_count", inline = TRUE), 
                                style = "font-size: 14px; color: #666;")
                       )
                )
              ),
              br(),
              fluidRow(
                column(12,
                       div(style = "text-align: center;",
                           h4(strong("Notes"))
                       ),
                       textAreaInput("pp_general_notes", label = NULL,
                                     placeholder = "Enter general notes for this player plan...",
                                     rows = 4, width = "100%")
                )
              )
          ) # Close player-plans-content div
        )
      ),
      
      # JavaScript for localStorage persistence
      tags$script(HTML("
      // Save player plans to localStorage
      Shiny.addCustomMessageHandler('savePlayerPlans', function(plans) {
        try {
          localStorage.setItem('playerPlans', JSON.stringify(plans));
          console.log('Saved player plans to localStorage');
        } catch(e) {
          console.error('Error saving to localStorage:', e);
        }
      });
      
      // Load player plans from localStorage
      Shiny.addCustomMessageHandler('loadPlayerPlans', function(message) {
        try {
          var savedPlans = localStorage.getItem('playerPlans');
          if (savedPlans) {
            var plans = JSON.parse(savedPlans);
            Shiny.setInputValue('loadedPlayerPlans', plans);
            console.log('Loaded player plans from localStorage');
          } else {
            console.log('No saved plans found in localStorage');
          }
        } catch(e) {
          console.error('Error loading from localStorage:', e);
        }
      });
      
      // Save completed goals to localStorage
      Shiny.addCustomMessageHandler('saveCompletedGoals', function(goals) {
        try {
          localStorage.setItem('completedGoals', JSON.stringify(goals));
          console.log('Saved completed goals to localStorage');
        } catch(e) {
          console.error('Error saving completed goals to localStorage:', e);
        }
      });
      
      // Load completed goals from localStorage
      Shiny.addCustomMessageHandler('loadCompletedGoals', function(message) {
        try {
          var savedGoals = localStorage.getItem('completedGoals');
          if (savedGoals) {
            var goals = JSON.parse(savedGoals);
            Shiny.setInputValue('loadedCompletedGoals', goals);
            console.log('Loaded completed goals from localStorage');
          } else {
            console.log('No saved completed goals found in localStorage');
          }
        } catch(e) {
          console.error('Error loading completed goals from localStorage:', e);
        }
      });
    ")),
      
      # Add custom CSS for the modal
      tags$style(HTML("
      .modal-dialog {
        max-width: 800px;
      }
      .goal-completion-checkbox {
        margin-top: 5px;
      }
      "))
    )
  )
}
# ==================================
# == AUTHENTICATION SETUP ==
# ==================================

# Using shinyapps.io native authentication instead of shinymanager
# Three-tier access system:
# 1. Admins - see all data + admin features
# 2. Coaches - see all data, no admin features  
# 3. Players - see only their own data (matched via lookup_table.csv)

admin_emails <- c(
  "jgaynor@pitchingcoachu.com",
  "ahalverson@pitchingcoachu.com"
)

# Coach emails - defined per-school via `config/school_config.R`
# Players are identified by their email being in the lookup_table.csv Email column
# They will only see data where Email matches their login email


ui <- tagList(
  # --- Custom navbar colors & styling ---
  tags$head(
    # Apple iOS home screen icon
    tags$link(rel = "apple-touch-icon", href = "PCUlogo.png"),
    tags$link(rel = "apple-touch-icon", sizes = "152x152", href = "PCUlogo.png"),
    tags$link(rel = "apple-touch-icon", sizes = "180x180", href = "PCUlogo.png"),
    tags$link(rel = "apple-touch-icon", sizes = "167x167", href = "PCUlogo.png"),
    # Standard favicon
    tags$link(rel = "icon", type = "image/png", href = "PCUlogo.png"),
    # Apple mobile web app settings
    tags$meta(name = "apple-mobile-web-app-capable", content = "yes"),
    tags$meta(name = "apple-mobile-web-app-status-bar-style", content = "black-translucent"),
    tags$meta(name = "apple-mobile-web-app-title", content = "PCU Dashboard"),
    
    tags$script(HTML("
      document.addEventListener('DOMContentLoaded', function() {
        var checkbox = document.querySelector('.dark-toggle input#dark_mode');
        if (!checkbox) return;
        var sync = function() {
          var state = !!checkbox.checked;
          if (window.Shiny && Shiny.setInputValue) {
            Shiny.setInputValue('dark_mode', state, {priority: 'event'});
          }
        };
        checkbox.addEventListener('change', sync);
        sync();
      });
    ")),
    tags$script(HTML("
      // Add a simple dropdown mirror for the top navbar tabs (mobile only)
      document.addEventListener('DOMContentLoaded', function() {
        var buildSelect = function() {
          var nav = document.querySelector('#top .navbar-nav');
          if (!nav) return;
          var links = Array.prototype.slice.call(nav.querySelectorAll('a'));
          if (!links.length || document.getElementById('topNavSelect')) return;
          var select = document.createElement('select');
          select.id = 'topNavSelect';
          select.className = 'form-control nav-dropdown';
          links.forEach(function(link) {
            var opt = document.createElement('option');
            var val = (link.getAttribute('data-value') || link.textContent || '').trim();
            opt.value = val;
            opt.textContent = (link.textContent || '').trim();
            if (link.parentElement && link.parentElement.classList.contains('active')) opt.selected = true;
            select.appendChild(opt);
          });
          select.addEventListener('change', function() {
            var target = links.find(function(l) {
              var val = (l.getAttribute('data-value') || l.textContent || '').trim();
              return val === select.value;
            });
            if (target) target.click();
          });
          var container = document.querySelector('#top .navbar-header') || nav.parentNode;
          if (container) {
            container.parentNode.insertBefore(select, container.nextSibling);
          } else {
            nav.parentNode.insertBefore(select, nav);
          }
          $(document).on('shown.bs.tab', '#top .navbar-nav a', function(e) {
            var val = ($(e.target).data('value') || $(e.target).text() || '').trim();
            $('#topNavSelect').val(val);
          });
        };
        buildSelect();
        // fallback for late nav rendering
        setTimeout(buildSelect, 300);
      });
    ")),
    tags$script(HTML("
      // Add dropdown mirrors for inner tabsets (suite pages) - mobile-friendly
      document.addEventListener('DOMContentLoaded', function() {
        var ensureSidebarDock = function() {
          // Prefer the accordion body under Filters
          var body = document.querySelector('.sidebar .sidebar-accordion-body');
          if (body) return body;
          // If accordion exists but body not yet created (unlikely), build one
          var accordion = document.querySelector('.sidebar .sidebar-accordion');
          if (accordion && !accordion.querySelector('.sidebar-accordion-body')) {
            var b = document.createElement('div');
            b.className = 'sidebar-accordion-body';
            accordion.appendChild(b);
            return b;
          }
          return null;
        };
        var placeWrapper = function(nav, wrapper) {
          if (!nav || !wrapper) return;
          var target = null;
          var mobile = window.innerWidth <= 768;
          if (mobile) {
            var row = nav.closest('.row');
            target = row ? row.querySelector('.sidebar-accordion-body') : null;
            if (!target) target = ensureSidebarDock();
            if (!target) target = document.querySelector('.sidebar .sidebar-accordion-body');
          }
          if (target) {
            wrapper.classList.add('inner-nav-in-sidebar');
            if (wrapper.parentNode !== target) {
              target.insertBefore(wrapper, target.firstChild);
            } else if (wrapper !== target.firstChild) {
              target.insertBefore(wrapper, target.firstChild);
            }
          } else if (nav.parentNode) {
            wrapper.classList.remove('inner-nav-in-sidebar');
            if (wrapper.parentNode !== nav.parentNode) {
              nav.parentNode.insertBefore(wrapper, nav);
            } else if (wrapper.nextSibling !== nav) {
              nav.parentNode.insertBefore(wrapper, nav);
            }
          }
        };
        var enhance = function(nav) {
          if (window.innerWidth <= 768) return; // show native tabs on mobile; no dropdown mirror
          if (!nav || nav.dataset.hasSelect) return;
          var links = Array.prototype.slice.call(nav.querySelectorAll('a'));
          if (!links.length) return;
          var sel = document.createElement('select');
          sel.className = 'form-control inner-nav-dropdown';
          links.forEach(function(link) {
            var opt = document.createElement('option');
            var href = (link.getAttribute('href') || '').replace('#','');
            opt.value = href;
            opt.textContent = (link.textContent || '').trim();
            if (link.parentElement && link.parentElement.classList.contains('active')) opt.selected = true;
            sel.appendChild(opt);
          });
          sel.addEventListener('change', function() {
            var target = links.find(function(l) {
              var href = (l.getAttribute('href') || '').replace('#','');
              return href === sel.value;
            });
            if (target) target.click();
          });
          var wrapper = document.createElement('div');
          wrapper.className = 'inner-nav-wrap';
          wrapper.appendChild(sel);
          nav._innerSelectWrapper = wrapper;
          placeWrapper(nav, wrapper);
          // Re-check placement after other mobile transforms run
          setTimeout(function() { placeWrapper(nav, wrapper); }, 150);
          window.addEventListener('resize', function() { placeWrapper(nav, wrapper); });
          $(nav).on('shown.bs.tab', 'a', function(e) {
            var href = ($(e.target).attr('href') || '').replace('#','');
            sel.value = href;
          });
          nav.dataset.hasSelect = '1';
        };
        var init = function() {
          // standard tabsets
          document.querySelectorAll('.tabbable > .nav.nav-tabs').forEach(function(nav){
            if (!nav.dataset.hasSelect) enhance(nav);
            else if (nav._innerSelectWrapper) placeWrapper(nav, nav._innerSelectWrapper);
          });
          // fallback: any nav-tabs missing a select
          document.querySelectorAll('.nav.nav-tabs').forEach(function(nav){
            if (!nav.dataset.hasSelect) enhance(nav);
            else if (nav._innerSelectWrapper) placeWrapper(nav, nav._innerSelectWrapper);
          });
        };
        init();
        // Re-run when DOM mutates (late-rendered tabsets)
        var mo = new MutationObserver(function() {
          clearTimeout(mo._debounce);
          mo._debounce = setTimeout(init, 120);
        });
        mo.observe(document.body, {childList: true, subtree: true});
        document.addEventListener('shiny:recalculating', function() { setTimeout(init, 200); });
      });
    ")),
    tags$script(HTML("
      // Mobile sidebar: replace full panel with a single dropdown accordion
      document.addEventListener('DOMContentLoaded', function() {
        var transform = function(sidebar) {
          if (!sidebar || sidebar.dataset.mobileAccordion) return;
          if (window.innerWidth > 768) return;
          var details = document.createElement('details');
          details.className = 'sidebar-accordion';
          var summary = document.createElement('summary');
          summary.textContent = 'Filters';
          summary.className = 'sidebar-accordion-summary';
          var body = document.createElement('div');
          body.className = 'sidebar-accordion-body';
          while (sidebar.firstChild) {
            body.appendChild(sidebar.firstChild);
          }
          details.appendChild(summary);
          details.appendChild(body);
          sidebar.appendChild(details);
          sidebar.dataset.mobileAccordion = '1';
        };
        var init = function() {
          document.querySelectorAll('.sidebar').forEach(transform);
        };
        init();
        window.addEventListener('resize', function() {
          // Do not rebuild; only apply on first mobile render to avoid moving nodes back and forth
        });
        document.addEventListener('shiny:recalculating', function() { setTimeout(init, 200); });
      });
    ")),
    # Custom authentication disabled - no need for token persistence
    tags$style(HTML(colorize_css("
      /* ===== MODERN PROFESSIONAL DESIGN ===== */
      
      /* Global Styles */
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
      
      body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%);
        color: #1a202c;
        font-size: 14px;
      }
      
      /* ===== NAVBAR DESIGN ===== */
      .navbar-inverse { 
        background: linear-gradient(135deg, #000000 0%, #1a1a1a 50%, #2d2d2d 100%);
        border: none;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        min-height: 70px;
      }
      .navbar { 
        position: relative; 
        border-radius: 0;
        margin-bottom: 0;
      }

      /* Brand area with two logos side-by-side */
      .navbar-inverse .navbar-brand {
        color: #ffffff !important;
        font-weight: 800;
        font-size: 24px;
        letter-spacing: -0.5px;
        display: flex;
        align-items: center;
        gap: 12px;
        padding-top: 15px;
        padding-bottom: 15px;
        transition: all 0.3s ease;
      }
      .navbar-inverse .navbar-brand:hover {
        transform: translateY(-2px);
      }
      .navbar-inverse .navbar-brand .brand-logo {
        height: 40px;
        display: inline-block;
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
      }
      .navbar-inverse .navbar-brand .brand-title {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      /* PCU logo on the far right */
      .navbar .pcu-right {
        position: absolute;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        height: 50px;
        display: block;
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
      }
      @media (max-width: 768px) {
        .navbar .pcu-right { display: none; }
        .navbar-inverse .navbar-brand { font-size: 18px; }
      .navbar-inverse .navbar-brand .brand-logo { height: 32px; }
      /* Mobile nav: show original tabs (scrollable) plus dropdown */
      .navbar-inverse .navbar-nav { display: flex; overflow-x: auto; white-space: nowrap; }
      .navbar-inverse .navbar-nav > li { float: none; display: inline-block; }
      #topNavSelect, .nav-dropdown { display: block; width: 100%; max-width: none; }
      /* Sidebar: show accordion dropdown only on mobile */
      .sidebar-dropdown-wrap { display: none; }
        .sidebar { display: block !important; }
        .sidebar details.sidebar-accordion { display: block; }
        .sidebar .well { padding: 0; border: none; box-shadow: none; background: transparent; }
        .sidebar .sidebar-accordion-body .well { padding: 16px; }
        /* Prevent thin charts/tables: allow horizontal scroll when needed */
        .plotly { overflow-x: auto !important; }
        .plotly .main-svg { overflow: visible !important; }
        .plotly .legend, .plotly .infolayer { overflow: visible !important; }
        .plot-container { overflow: auto !important; padding-bottom: 12px; }
        .girafe_container_std, .ggiraph-container { overflow: auto !important; }
        .dataTables_wrapper { overflow-x: auto !important; width: 100% !important; }
        /* Hide desktop sidebar toggle button on mobile */
        #pitchingSidebarToggle { display: none !important; }
        /* Allow Plotly legends to scroll on small screens */
        .plotly .legend {
          max-height: 65vh;
          overflow-y: auto !important;
          white-space: normal !important;
          max-width: 100% !important;
          position: relative !important;
        }
      .plotly .legend .scrollbox { overflow: visible !important; }
      /* Let static legend plots breathe on mobile */
      .legend-plot-wrap { width: 100%; overflow-x: auto; }
      #summary_legend, #summary_result_legend { min-height: 140px !important; }
    }

      /* Tab Navigation - Modern pill style */
      .navbar-inverse .navbar-nav {
        margin-top: 8px;
      }
      .navbar-inverse .navbar-nav > li > a { 
        color: rgba(255, 255, 255, 0.85) !important;
        font-weight: 600;
        font-size: 15px;
        padding: 10px 20px;
        margin: 0 4px;
        border-radius: 12px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }
      .navbar-inverse .navbar-nav > li > a::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(227,82,5,0.18) 0%, rgba(255,140,26,0.12) 100%);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .navbar-inverse .navbar-nav > li > a:hover::before {
        opacity: 1;
      }
      .navbar-inverse .navbar-nav > li > a:hover,
      .navbar-inverse .navbar-nav > li > a:focus { 
        color: #ffffff !important;
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      }

      /* Active tab - vibrant gradient */
      .navbar-inverse .navbar-nav > .active > a,
      .navbar-inverse .navbar-nav > .active > a:hover,
      .navbar-inverse .navbar-nav > .active > a:focus {
        color: #ffffff !important;
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        box-shadow: 0 4px 15px rgba(227, 82, 5, 0.4);
        transform: translateY(-2px);
      }
      /* Charts/graphs: keep backgrounds transparent globally */
      .plot-container, .plotly, .plotly .main-svg, .plotly .svg-container { background: transparent !important; }
      .plotly .cartesianlayer .bg, .plotly .draglayer, .plotly .bglayer rect { fill: transparent !important; }
      .plotly .polar > g, .plotly .ternary > g { fill: transparent !important; }
      .girafe_container svg, .ggiraph-container svg, canvas { background: transparent !important; }
      /* Nuke ggiraph’s white rect background in light mode */
      body:not(.theme-dark) .girafe_container svg rect.bg,
      body:not(.theme-dark) .ggiraph-container svg rect.bg {
        fill: transparent !important;
      }
      /* Remove default white panel rects in girafe outputs */
      body:not(.theme-dark) .girafe_container svg rect[fill='#FFFFFF'],
      body:not(.theme-dark) .girafe_container svg rect[fill='#ffffff'],
      body:not(.theme-dark) .girafe_container svg rect[fill='#fff'],
      body:not(.theme-dark) .girafe_container svg rect[fill='white'],
      body:not(.theme-dark) .ggiraph-container svg rect[fill='#FFFFFF'],
      body:not(.theme-dark) .ggiraph-container svg rect[fill='#ffffff'],
      body:not(.theme-dark) .ggiraph-container svg rect[fill='#fff'],
      body:not(.theme-dark) .ggiraph-container svg rect[fill='white'] {
        fill: transparent !important;
        stroke: none !important;
      }
      /* Force plot images and canvases transparent */
      .shiny-plot-output img,
      .shiny-plot-output canvas,
      .shiny-image-output img {
        background: transparent !important;
        background-color: transparent !important;
      }
      /* Light mode: transparent plot surfaces + no shadows */
      body:not(.theme-dark) .shiny-plot-output,
      body:not(.theme-dark) .plotly,
      body:not(.theme-dark) .html-widget,
      body:not(.theme-dark) .ggiraph-container,
      body:not(.theme-dark) .girafe_container {
        background: transparent !important;
        box-shadow: none !important;
        border: none !important;
      }
      /* Light mode: remove white panels behind plots/graphs (everywhere except sidebar) */
      body:not(.theme-dark) .well,
      body:not(.theme-dark) .panel {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      /* Light mode: ensure main content areas are transparent */
      body:not(.theme-dark) .col-sm-9,
      body:not(.theme-dark) .main-panel,
      body:not(.theme-dark) .tab-content,
      body:not(.theme-dark) .tab-pane {
        background: transparent !important;
      }
      /* Light mode: force sidebarLayout panels transparent */
      body:not(.theme-dark) .sidebarLayout,
      body:not(.theme-dark) .sidebarPanel,
      body:not(.theme-dark) .mainPanel,
      body:not(.theme-dark) .container-fluid,
      body:not(.theme-dark) .row {
        background: transparent !important;
      }
      /* Light mode: all divs inside main content transparent */
      body:not(.theme-dark) .col-sm-9 > div,
      body:not(.theme-dark) .main-panel > div,
      body:not(.theme-dark) .tab-pane > div {
        background: transparent !important;
      }
      /* Light mode: specific plot IDs (matching dark mode approach) */
      body:not(.theme-dark) #heatPlot,
      body:not(.theme-dark) #heatPlot canvas,
      body:not(.theme-dark) #heatPlot img,
      body:not(.theme-dark) #pitchPlot,
      body:not(.theme-dark) #pitchPlot canvas,
      body:not(.theme-dark) #pitchPlot img,
      body:not(.theme-dark) #heatmapPlot,
      body:not(.theme-dark) #heatmapPlot canvas,
      body:not(.theme-dark) #heatmapPlot img,
      body:not(.theme-dark) #veloTrendPlot,
      body:not(.theme-dark) #veloTrendPlot canvas,
      body:not(.theme-dark) #veloTrendPlot img,
      body:not(.theme-dark) #summary_heatZonePlot,
      body:not(.theme-dark) #summary_heatZonePlot canvas,
      body:not(.theme-dark) #summary_heatZonePlot img,
      body:not(.theme-dark) #summary_legend,
      body:not(.theme-dark) #summary_legend canvas,
      body:not(.theme-dark) #summary_legend img,
      body:not(.theme-dark) #heatmapsHeatPlot,
      body:not(.theme-dark) #heatmapsHeatPlot canvas,
      body:not(.theme-dark) #heatmapsHeatPlot img,
      body:not(.theme-dark) #cmpA_heat,
      body:not(.theme-dark) #cmpA_heat canvas,
      body:not(.theme-dark) #cmpA_heat img,
      body:not(.theme-dark) #cmpB_heat,
      body:not(.theme-dark) #cmpB_heat canvas,
      body:not(.theme-dark) #cmpB_heat img,
      body:not(.theme-dark) #corr_plot,
      body:not(.theme-dark) #corr_plot canvas,
      body:not(.theme-dark) #corr_plot img,
      body:not(.theme-dark) #campSummaryHeatZonePlot,
      body:not(.theme-dark) #campSummaryHeatZonePlot canvas,
      body:not(.theme-dark) #campSummaryHeatZonePlot img,
      body:not(.theme-dark) #campSummaryLegend,
      body:not(.theme-dark) #campSummaryLegend canvas,
      body:not(.theme-dark) #campSummaryLegend img,
      body:not(.theme-dark) #summary_result_legend,
      body:not(.theme-dark) #summary_result_legend canvas,
      body:not(.theme-dark) #summary_result_legend img,
      body:not(.theme-dark) #result_key,
      body:not(.theme-dark) #result_key canvas,
      body:not(.theme-dark) #result_key img,
      body:not(.theme-dark) #pitch_type_key,
      body:not(.theme-dark) #pitch_type_key canvas,
      body:not(.theme-dark) #pitch_type_key img {
        background: transparent !important;
      }
      /* Keep sidebar styling intact in light mode */
      body:not(.theme-dark) .sidebar .well,
      body:not(.theme-dark) .col-sm-3 .well,
      body:not(.theme-dark) .col-sm-4 .well,
      body:not(.theme-dark) .sidebar .panel {
        background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%) !important;
        border: none !important;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08) !important;
        border-left: 4px solid #e35205 !important;
      }
      /* Tables: allow full width */
      .dataTables_wrapper { width: 100% !important; }
      /* Optional navbar dropdown mirror */
      .nav-dropdown {
        margin: 6px 0 10px 0;
        max-width: 360px;
        font-weight: 700;
        font-size: 17px;
        padding: 12px 14px;
        min-height: 48px;
        line-height: 1.4;
      }
      /* Inner tabset dropdown mirror */
      .inner-nav-wrap { margin: 8px 0 12px 0; display: none; }
      .inner-nav-dropdown { width: 100%; font-weight: 800; font-size: 17px; padding: 22px 18px; min-height: 76px; line-height: 1.45; letter-spacing: 0.2px; }
      /* Sidebar dropdown */
      .sidebar-dropdown-wrap { margin: 8px 0 8px 0; display: none; }
      .sidebar-dropdown { width: 100%; font-weight: 700; font-size: 17px; padding: 12px 14px; min-height: 48px; line-height: 1.4; }
      .sidebar-accordion { border: 1px solid #e2e8f0; border-radius: 12px; background: #fff; box-shadow: 0 4px 12px rgba(0,0,0,0.06); }
      .sidebar-accordion-summary { padding: 14px; font-weight: 800; font-size: 16px; cursor: pointer; }
      .sidebar-accordion-body { padding: 12px; }
      
      /* ===== SIDEBAR DESIGN ===== */
      .well {
        background: #ffffff;
        border: none;
        border-radius: 16px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        padding: 24px;
        margin-bottom: 20px;
      }
      
      .sidebar .well, .col-sm-3 .well, .col-sm-4 .well {
        background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
        border-left: 4px solid #e35205;
      }
      
      /* Form Controls - Modern inputs */
      .form-control, .selectize-input {
        border: 2px solid #e2e8f0;
        border-radius: 10px;
        padding: 10px 14px;
        font-size: 14px;
        transition: all 0.3s ease;
        background: #ffffff;
      }
      .form-control:focus, .selectize-input.focus {
        border-color: #e35205;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        outline: none;
      }
      
      .form-group label {
        font-weight: 600;
        color: #2d3748;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
      }
      
      /* Select dropdowns */
      .selectize-dropdown {
        border: 2px solid #e2e8f0;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        margin-top: 4px;
      }
      .selectize-dropdown-content .option {
        padding: 10px 14px;
        transition: all 0.2s ease;
      }
      .selectize-dropdown-content .option:hover,
      .selectize-dropdown-content .option.active {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        color: white;
      }
      
      /* Date inputs */
      .shiny-date-range-input .input-daterange input {
        border-radius: 10px;
        border: 2px solid #e2e8f0;
      }
      
      /* ===== TAB PANELS (Secondary navigation) ===== */
      .nav-tabs {
        border-bottom: 2px solid #e2e8f0;
        margin-bottom: 20px;
      }
      .nav-tabs > li > a {
        border: none;
        border-radius: 12px 12px 0 0;
        color: #4a5568;
        font-weight: 600;
        padding: 12px 24px;
        margin-right: 4px;
        transition: all 0.3s ease;
        position: relative;
      }
      .nav-tabs > li > a:hover {
        background: linear-gradient(135deg, rgba(227,82,5,0.12) 0%, rgba(255,140,26,0.08) 100%);
        color: #e35205;
        border: none;
      }
      .nav-tabs > li.active > a,
      .nav-tabs > li.active > a:hover,
      .nav-tabs > li.active > a:focus {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        color: white;
        border: none;
        box-shadow: 0 -2px 10px rgba(227, 82, 5, 0.3);
      }
      /* Dark mode tabs (page-level) */
      body.theme-dark .nav-tabs {
        border-color: rgba(255,255,255,0.18);
      }
      body.theme-dark .nav-tabs > li > a {
        color: rgba(229, 231, 235, 0.88);
        background: rgba(255,255,255,0.04);
        border: 1px solid rgba(255,255,255,0.08);
      }
      body.theme-dark .nav-tabs > li > a:hover {
        background: rgba(255,255,255,0.10);
        color: #ffffff;
        border-color: rgba(255,255,255,0.14);
      }
      body.theme-dark .nav-tabs > li.active > a,
      body.theme-dark .nav-tabs > li.active > a:hover,
      body.theme-dark .nav-tabs > li.active > a:focus {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        color: #ffffff;
        border: none;
        box-shadow: 0 -2px 12px rgba(227,82,5,0.35);
      }
      
      /* ===== BUTTONS ===== */
      .btn {
        border-radius: 10px;
        font-weight: 600;
        padding: 10px 20px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }
      .btn:active {
        transform: translateY(0);
      }
      
      .btn-primary {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        color: white;
      }
      .btn-primary:hover, .btn-primary:focus {
        background: linear-gradient(135deg, #ff8c1a 0%, #e35205 100%);
        color: white;
      }
      
      .btn-default {
        background: white;
        color: #4a5568;
        border: 2px solid #e2e8f0;
      }
      .btn-default:hover {
        background: #f7fafc;
        border-color: #e35205;
        color: #e35205;
      }
      
      /* Add Note button */
      #openNote {
        border-radius: 50%;
        padding: 12px 14px;
        font-size: 18px;
        box-shadow: 0 4px 20px rgba(85, 43, 154, 0.4);
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
      }
      #openNote:hover {
        box-shadow: 0 6px 25px rgba(85, 43, 154, 0.6);
        transform: translateY(-3px) scale(1.05);
      }
      
      /* ===== TABLES ===== */
      .dataTables_wrapper {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
      }
      .dataTable thead th {
        background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #404040 100%);
        color: white;
        font-weight: 600;
        padding: 14px 10px;
        border: none;
        text-transform: uppercase;
        font-size: 12px;
        letter-spacing: 0.5px;
      }
      .dataTable tbody tr {
        transition: all 0.2s ease;
      }
      .dataTable tbody tr:hover {
        background: rgba(102, 126, 234, 0.05);
        transform: scale(1.01);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      }
      .dataTable tbody td {
        padding: 12px 10px;
        border-bottom: 1px solid #f0f0f0;
      }
      
      /* ===== PANELS & CARDS ===== */
      .panel {
        border: none;
        border-radius: 12px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
        overflow: hidden;
      }
      .panel-default > .panel-heading {
        background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
        border: none;
        color: #2d3748;
        font-weight: 700;
        padding: 16px 20px;
        border-bottom: 2px solid #e2e8f0;
      }
      .panel-body {
        padding: 20px;
      }
      
      /* ===== PLOTS & CHARTS ===== */
      .shiny-plot-output, .plotly, .html-widget {
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
        background: transparent;
      }
      
      /* ===== PAGE CONTAINER ===== */
      .container-fluid {
        padding: 20px 30px;
      }
      
      /* ===== LOADING ANIMATION ===== */
      .shiny-output-error { color: #e53e3e; }
      .shiny-output-error:before { content: '⚠ '; }
      
      /* Custom scrollbar */
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      ::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #ff8c1a 0%, #e35205 100%);
      }

      /* ===== DARK MODE OVERRIDES ===== */
      body.theme-dark {
        background: radial-gradient(circle at 20% 20%, #0d1224 0%, #0a0f1d 45%, #060910 100%);
        color: #e5e7eb;
      }
      body.theme-dark .navbar-inverse {
        background: linear-gradient(135deg, #0b0f19 0%, #0f172a 100%);
        box-shadow: 0 6px 24px rgba(0,0,0,0.5);
      }
      body.theme-dark .navbar-inverse .navbar-brand .brand-title {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      body.theme-dark .navbar-inverse .navbar-nav > li > a {
        color: rgba(229, 231, 235, 0.9) !important;
      }
      body.theme-dark .navbar-inverse .navbar-nav > li > a:hover,
      body.theme-dark .navbar-inverse .navbar-nav > li > a:focus {
        color: #ffffff !important;
        background: rgba(255,255,255,0.08);
        box-shadow: 0 4px 12px rgba(0,0,0,0.35);
      }
      /* Dark mode: keep sidebars transparent (mobile + desktop) */
      body.theme-dark .sidebar,
      body.theme-dark .sidebar .well,
      body.theme-dark .col-sm-3 .well,
      body.theme-dark .col-sm-4 .well,
      body.theme-dark .sidebar .panel,
      body.theme-dark .sidebar-accordion,
      body.theme-dark .sidebar-accordion-body {
        background: transparent !important;
        box-shadow: none !important;
        border: none !important;
      }
      body.theme-dark .sidebar .well .form-control,
      body.theme-dark .sidebar .well .selectize-input {
        background: rgba(255,255,255,0.06) !important;
      }
      body.theme-dark .navbar-inverse .navbar-nav > .active > a,
      body.theme-dark .navbar-inverse .navbar-nav > .active > a:hover,
      body.theme-dark .navbar-inverse .navbar-nav > .active > a:focus {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        box-shadow: 0 6px 18px rgba(102,126,234,0.45);
      }
      body.theme-dark .container-fluid {
        background: transparent !important;
      }
      body.theme-dark .well,
      body.theme-dark .panel {
        background: rgba(15,23,42,0.9) !important;
        border: 1px solid #1f2937 !important;
        box-shadow: 0 6px 24px rgba(0,0,0,0.45);
        color: #e5e7eb !important;
      }
      body.theme-dark .panel-default > .panel-heading {
        background: linear-gradient(135deg, #111827 0%, #0b1220 100%) !important;
        color: #e5e7eb !important;
        border: none !important;
      }
      body.theme-dark .form-control,
      body.theme-dark .selectize-input {
        background: #0f172a !important;
        color: #e5e7eb !important;
        border: 1px solid #1f2937 !important;
        box-shadow: none !important;
      }
      body.theme-dark .form-control:focus,
      body.theme-dark .selectize-input.focus {
        border-color: #ff8c1a !important;
        box-shadow: 0 0 0 3px rgba(118, 75, 162, 0.25) !important;
      }
      body.theme-dark .form-group label {
        color: #e5e7eb !important;
      }
      body.theme-dark .btn-default {
        background: #0f172a !important;
        color: #e5e7eb !important;
        border: 1px solid #1f2937 !important;
      }
      body.theme-dark .btn-primary {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%) !important;
        color: #fff !important;
        box-shadow: 0 4px 14px rgba(102,126,234,0.35);
      }
      body.theme-dark .dataTables_wrapper {
        background: rgba(15,23,42,0.9) !important;
        color: #e5e7eb !important;
      }
      body.theme-dark .dataTable tbody tr:hover {
        background: rgba(102,126,234,0.08) !important;
        box-shadow: 0 2px 10px rgba(0,0,0,0.35) !important;
      }
      body.theme-dark .shiny-plot-output,
      body.theme-dark .plotly,
      body.theme-dark .html-widget {
        background: transparent !important;
        box-shadow: 0 2px 16px rgba(0,0,0,0.35);
      }
      /* Wipe embedded white rects in svg/png */
      body.theme-dark svg rect[fill='#FFFFFF'],
      body.theme-dark svg rect[fill='#ffffff'],
      body.theme-dark svg rect[fill='#fff'] {
        fill: transparent !important;
        stroke: none !important;
      }
      body.theme-dark #summary_heatZonePlot,
      body.theme-dark #summary_heatZonePlot canvas,
      body.theme-dark #summary_heatZonePlot img,
      body.theme-dark #summary_legend,
      body.theme-dark #summary_legend canvas,
      body.theme-dark #summary_legend img {
        background: transparent !important;
      }
      body.theme-dark #heatmapsHeatPlot,
      body.theme-dark #heatmapsHeatPlot canvas,
      body.theme-dark #heatmapsHeatPlot img,
      body.theme-dark #cmpA_heat,
      body.theme-dark #cmpA_heat canvas,
      body.theme-dark #cmpA_heat img,
      body.theme-dark #cmpB_heat,
      body.theme-dark #cmpB_heat canvas,
      body.theme-dark #cmpB_heat img {
        background: transparent !important;
      }
      /* Toggle switch styling */
      .dark-toggle { display:flex; align-items:center; gap:10px; }
      .dark-toggle .switch-label { display:flex; align-items:center; gap:10px; margin:0; cursor:pointer; }
      .dark-toggle input#dark_mode { display:none; }
      .dark-toggle .switch-track {
        position: relative; width: 50px; height: 26px;
        background: #4b5563; border-radius: 13px; transition: background 0.2s ease;
        box-shadow: inset 0 0 4px rgba(0,0,0,0.35);
      }
      .dark-toggle .switch-thumb {
        position: absolute; top: 3px; left: 3px; width: 20px; height: 20px;
        background: #fff; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        transition: transform 0.2s ease;
      }
      .dark-toggle input#dark_mode:checked + .switch-track { background: #ff8c1a; }
      .dark-toggle input#dark_mode:checked + .switch-track .switch-thumb { transform: translateX(24px); }
      .dark-toggle .switch-text { font-weight:600; color:#e5e7eb; }
      
      /* Dropdowns (selectize + native) – scoped to dark mode; purple highlight for selected item */
      body.theme-dark .selectize-input,
      body.theme-dark .selectize-control.single .selectize-input,
      body.theme-dark select.form-control {
        background: #0f172a !important;
        color: #e5e7eb !important;
        border: 1px solid #1f2937 !important;
        box-shadow: none !important;
      }
      body.theme-dark .selectize-input input { color: #e5e7eb !important; }
      body.theme-dark .selectize-input > .item {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%) !important;
        color: #fff !important;
        border-radius: 6px;
        padding: 2px 6px;
      }
      body.theme-dark .selectize-dropdown {
        background: #0f172a !important;
        color: #e5e7eb !important;
        border-color: #1f2937 !important;
      }
      body.theme-dark .selectize-dropdown .option { color: #e5e7eb !important; }
      body.theme-dark .selectize-dropdown .option:hover,
      body.theme-dark .selectize-dropdown .option.active {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%) !important;
        color: #fff !important;
      }
      
      /* Custom Reports cell container */
      .creport-cell {
        background: #ffffff;
        border: 2px solid #000;
        padding: 15px;
        margin-bottom: 15px;
        border-radius: 6px;
      }
      body.theme-dark .creport-cell {
        background: rgba(15,23,42,0.9) !important;
        border: 1px solid #1f2937 !important;
        box-shadow: 0 4px 18px rgba(0,0,0,0.35);
        color: #e5e7eb;
      }
      body.theme-dark .creport-cell h4,
      body.theme-dark .creport-cell h5,
      body.theme-dark .creport-cell label,
      body.theme-dark .creport-cell input,
      body.theme-dark .creport-cell select,
      body.theme-dark .creport-cell .form-control {
        color: #e5e7eb !important;
        background-color: #0f172a !important;
        border-color: #1f2937 !important;
      }
      
      /* Player Plans & Custom Reports root containers */
      .pp-root, .creports-root { background: transparent !important; }
      .pp-root .container-fluid,
      .creports-root .container-fluid {
        background: transparent !important;
      }
      /* Dark-mode forcing for Custom Reports layout */
      body.theme-dark .creports-root .panel,
      body.theme-dark .creports-root .well,
      body.theme-dark .creports-root .form-group,
      body.theme-dark .creports-root .tab-content,
      body.theme-dark .creports-root .tab-pane,
      body.theme-dark .creports-root .row,
      body.theme-dark .creports-root .col-sm-3,
      body.theme-dark .creports-root .col-sm-9 {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      body.theme-dark .creports-root .form-control {
        background: #0f172a !important;
        color: #e5e7eb !important;
        border: 1px solid #1f2937 !important;
      }
      body.theme-dark .creports-root .girafe_container svg,
      body.theme-dark .creports-root canvas {
        background: transparent !important;
      }
      body.theme-dark #creports-sidebar_column .well,
      body.theme-dark #creports-main_column .well {
        background: radial-gradient(circle at top left, #1f2937 0%, #0f172a 60%, #0b0f19 100%) !important;
        border-left: 4px solid #ff8c1a !important;
        color: #e5e7eb !important;
      }
      body.theme-dark #creports-main_column .panel,
      body.theme-dark #creports-sidebar_column .panel {
        background: #0f172a !important;
        color: #e5e7eb !important;
        box-shadow: 0 2px 12px rgba(0,0,0,0.35);
      }
      
      /* Player Plans container dark mode */
      body.theme-dark .pp-root {
        background: transparent !important;
      }
      body.theme-dark .pp-root .goal-container {
        background: rgba(15,23,42,0.85) !important;
        border: 1px solid #1f2937 !important;
        box-shadow: 0 4px 20px rgba(0,0,0,0.35);
        color: #e5e7eb;
      }
      body.theme-dark .pp-root .goal-description {
        background: rgba(17,24,39,0.9) !important;
        border-color: #1f2937 !important;
        color: #e5e7eb !important;
      }
      body.theme-dark .pp-root .panel,
      body.theme-dark .pp-root .well {
        background: rgba(15,23,42,0.9) !important;
        color: #e5e7eb !important;
        box-shadow: 0 2px 12px rgba(0,0,0,0.35);
      }
      body.theme-dark .pp-root .girafe_container svg,
      body.theme-dark .pp-root canvas {
        background: transparent !important;
      }
      /* Make black strokes/lines white in dark mode (axes/strike zones) */
      body.theme-dark svg rect[stroke='black'],
      body.theme-dark svg line[stroke='black'],
      body.theme-dark svg path[stroke='black'] {
        stroke: #ffffff !important;
      }
      /* Also flip pure-black fills to white in dark mode (fastball dots/legend) */
      body.theme-dark svg [fill='black'],
      body.theme-dark svg [fill='#000'],
      body.theme-dark svg [fill='#000000'] {
        fill: #ffffff !important;
      }
      /* Subtle gridlines in dark mode */
      body.theme-dark .panel.grid.major,
      body.theme-dark line.panel.grid.major,
      body.theme-dark polyline.panel.grid.major,
      body.theme-dark path.panel.grid.major {
        stroke: rgba(255,255,255,0.18) !important;
      }
      body.theme-dark .panel.grid.minor,
      body.theme-dark line.panel.grid.minor,
      body.theme-dark polyline.panel.grid.minor,
      body.theme-dark path.panel.grid.minor {
        stroke: rgba(255,255,255,0.08) !important;
      }
      /* Catch default ggplot grid strokes */
      body.theme-dark svg line[stroke='#ebebeb'],
      body.theme-dark svg line[stroke='#E5E5E5'],
      body.theme-dark svg line[stroke='#d9d9d9'],
      body.theme-dark svg path[stroke='#ebebeb'],
      body.theme-dark svg path[stroke='#E5E5E5'],
      body.theme-dark svg path[stroke='#d9d9d9'] {
        stroke: rgba(255,255,255,0.18) !important;
      }
      /* Axis text/ticks in dark mode */
      body.theme-dark .axis text,
      body.theme-dark g.tick text,
      body.theme-dark text {
        fill: #e5e7eb !important;
      }
      body.theme-dark .axis line,
      body.theme-dark g.tick line {
        stroke: rgba(255,255,255,0.4) !important;
      }
      /* Legend readability in dark mode */
      body.theme-dark g.legend text,
      body.theme-dark [aria-label='legend'] text,
      body.theme-dark g[class*='legend'] text {
        fill: #ffffff !important;
      }
      body.theme-dark g.legend rect,
      body.theme-dark [aria-label='legend'] rect {
        fill: transparent !important;
        stroke: transparent !important;
      }
      /* Inline toggle styling */
      .inline-toggle {
        background: rgba(0,0,0,0.35);
        border-radius: 12px;
        padding: 8px 12px;
        width: fit-content;
      }
      /* Modal text readable on light modal backgrounds */
      body.theme-dark .modal-content,
      body.theme-dark .modal-body,
      body.theme-dark .modal-title {
        color: #000000 !important;
      }
    ", accent_color, accent_secondary_color, background_color, background_secondary_color)))
  ),
  
  # --- Global click handler for Notes → jump back to saved view ---
  tags$script(HTML("
    document.addEventListener('click', function(e){
      var a = e.target.closest('a.note-jump'); if(!a) return;
      e.preventDefault();
      Shiny.setInputValue('noteJump', {
        suite: a.dataset.suite || '', page: a.dataset.page || '',
        pitcher: a.dataset.pitcher || '', sess: a.dataset.sess || '',
        ds: a.dataset.ds || '', de: a.dataset.de || '', nonce: Math.random()
      }, {priority:'event'});
    }, true);
  ")),
  
  tags$script(HTML("
  // Avoid double-binding by namespacing and unbinding first
  $(document).off('click.pcuOpenMedia', 'a.open-media')
    .on('click.pcuOpenMedia', 'a.open-media', function(e){
      e.preventDefault();
      var url = $(this).data('url') || $(this).attr('href') || '';
      var typ = (($(this).data('type') || 'auto') + '').toLowerCase();
      if(!url) return;
      Shiny.setInputValue('open_media', {url: url, type: typ, nonce: Math.random()}, {priority:'event'});
    });
  ")),
  
  shinyjs::useShinyjs(),
  
  tags$style(HTML(colorize_css("
    /* Custom note button - already styled in main CSS */
    #openNote.btn-note {
      background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
      border: none;
      color: #fff;
    }
    #openNote.btn-note:hover,
    #openNote.btn-note:focus,
    #openNote.btn-note:active,
    #openNote.btn-note:active:focus {
      background: linear-gradient(135deg, #ff8c1a 0%, #e35205 100%);
      border: none;
      color: #fff;
      outline: none;
    }
    /* Make the # column look like a link */
    td.clickable-cell, td.clickable-cell a, .pitch-count-link {
      color: #0d6efd !important;
      text-decoration: underline;
      cursor: pointer;
    }
    td.clickable-cell:hover, td.clickable-cell a:hover, .pitch-count-link:hover {
      color: #0a58ca !important;
    }
  ", accent_color, accent_secondary_color, background_color, background_secondary_color))),
  # --- Floating "Add Note" button (top-right, all pages) ---
  absolutePanel(
    style = "background:transparent; border:none; box-shadow:none; z-index:2000;",
    actionButton("openNote", label = NULL, icon = icon("sticky-note"),
                 class = "btn btn-note", title = "Add Note"),
    top = 60, right = 12, width = 50, fixed = TRUE, draggable = FALSE
  ),
  navbarPage(
    title = tagList(
      tags$img(src = school_logo, class = "brand-logo", alt = school_display_name),
      tags$span("Dashboard", class = "brand-title"),
      tags$img(src = "PCUlogo.png", class = "pcu-right", alt = "PCU")
    ),
    id = "top",
    inverse = TRUE,
    tabPanel("Pitching",   value = "Pitching",   pitch_ui()),
    tabPanel("Hitting",    value = "Hitting",    mod_hit_ui("hit")),
    tabPanel("Catching",   value = "Catching",   mod_catch_ui("catch")),
    tabPanel("Leaderboard", value = "Leaderboard", mod_leader_ui("leader")),
    tabPanel("Comparison Tool", value = "Comparison Suite", mod_comp_ui("comp")),
    tabPanel("Correlations", value = "Correlations", correlations_ui()),
    tabPanel("Custom Reports", value = "Custom Reports", custom_reports_ui("creports")),
    tabPanel("Player Plans", value = "Player Plans", player_plans_ui()),
    tabPanel("Notes", value = "Notes",
             fluidPage(
               br(),
               DT::dataTableOutput("notesTable")
             )
    )
  )
)

# Custom authentication disabled - using shinyapps.io native authentication


# Server logic
server <- function(input, output, session) {
  
  # Get user email from shinyapps.io authentication
  # In shinyapps.io, session$user contains the authenticated user's email
  user_email <- reactive({
    # Try to get email from session
    email <- session$user
    
    # If no session user (running locally), return NA
    if (is.null(email) || !nzchar(email)) {
      return(NA_character_)
    }
    
    as.character(email)
  })
  
  # Check if current user is admin (only jgaynor@pitchingcoachu.com)
  is_admin <- reactive({
    u <- user_email()
    !is.na(u) && u %in% admin_emails
  })
  
  # Check if current user is a coach (can see all data)
  is_coach <- reactive({
    u <- user_email()
    !is.na(u) && tolower(trimws(u)) %in% tolower(trimws(coach_emails))
  })
  
  # Helper to normalize email for comparison
  norm_email <- function(x) tolower(trimws(as.character(x)))
  
  # Initialize database on startup
  init_modifications_db()
  # keep custom table choices in sync
  observe({
    custom_tables()
    update_custom_table_choices(session)
  })
  
  # Theme toggle (light/dark)
  observeEvent(input$dark_mode, {
    if (isTRUE(input$dark_mode)) {
      shinyjs::addClass(selector = "body", class = "theme-dark")
    } else {
      shinyjs::removeClass(selector = "body", class = "theme-dark")
    }
  }, ignoreInit = TRUE)
  
  # Helper to resolve table mode (supports saved custom tables)
  resolve_table_mode <- function(mode_in, custom_cols_in) {
    ct <- custom_tables()
    if (!is.null(mode_in) && mode_in %in% names(ct)) {
      cols <- ct[[mode_in]]$cols %||% character(0)
      return(list(mode = "Custom", cols = cols))
    }
    list(mode = mode_in %||% "Stuff", cols = custom_cols_in %||% character(0))
  }
  
  # Shared table builder function for Summary/DP/Comparison/Custom Reports
  # This ensures consistent table formatting across all suites
  .dp_like_table <<- function(df, mode, custom_cols, enable_colors = TRUE) {
    # Note: The full implementation is in mod_comp_server
    # This is a placeholder that will be overwritten when comparison suite loads
    # But ensures the function exists globally
    if (!nrow(df)) {
      return(DT::datatable(
        data.frame(Message = "No data for selected filters"),
        options = list(dom = 't'), rownames = FALSE
      ))
    }
    # If this gets called before comparison suite initializes, show message
    DT::datatable(
      data.frame(Message = "Loading table builder..."),
      options = list(dom = 't'), rownames = FALSE
    )
  }

  # ---- Video helpers (PCU-style modal with metrics/compare/multi-angle) ----
  guess_video_type <- function(name_or_url) {
    nm <- tolower(as.character(name_or_url %||% ""))
    if (grepl("\\.mp4(\\?.*)?$", nm)) "video/mp4"
    else if (grepl("\\.mov(\\?.*)?$", nm)) "video/quicktime"
    else "video"
  }

  # Map a clip name to a served URL, respecting subfolders by source (Edger/Behind/Side)
  # Robust to extension case (.MOV/.MP4) and container swaps.
  video_url_for <- function(clip, source = NULL) {
    # Normalize input
    if (is.null(clip) || length(clip) == 0) return("")
    clip_chr <- trimws(as.character(clip)[1])
    if (!nzchar(clip_chr)) return("")
    
    # If a full URL was stored, use it as-is (Cloudinary, S3, etc.)
    if (grepl("^https?://", clip_chr)) return(clip_chr)
    
    # Base directory configured by addResourcePath(...) at startup
    vdir <- getOption("PCU_VIDEOS_DIR", NA_character_)
    if (is.na(vdir) || !nzchar(vdir)) return("")
    
    # Build candidate filenames with case and container variants
    make_candidates <- function(fname) {
      # Split name and extension (case-insensitive)
      ext0  <- tools::file_ext(fname)              # may be "" or "MOV" etc.
      base0 <- if (nzchar(ext0)) sub(sprintf("\\.%s$", ext0), "", fname, ignore.case = TRUE) else fname
      
      # Try both containers if none or if it's mov/mp4
      if (!nzchar(ext0) || grepl("^(?i)(mov|mp4)$", ext0)) {
        exts <- c("mov", "mp4")                    # try MOV & MP4
      } else {
        exts <- ext0                               # unknown ext -> just use given
      }
      
      # Case variants for base and ext
      bases <- unique(c(base0, tolower(base0), toupper(base0)))
      extsL <- unique(c(exts, tolower(exts), toupper(exts)))
      
      # If original had an extension, include the original string as-is first
      cand <- character(0)
      if (nzchar(ext0)) cand <- c(cand, fname)
      
      # Then all base×ext combinations (both lower/upper ext)
      for (b in bases) for (e in extsL) cand <- c(cand, paste0(b, ".", e))
      
      # If there was no extension at all, also include bare bases (some users store raw names)
      if (!nzchar(ext0)) cand <- c(cand, bases)
      
      unique(cand)
    }
    
    # Helper: construct served URL under /videos/... and ensure the file exists on disk
    make_url_if_exists <- function(path_parts, fname) {
      abs_path <- do.call(file.path, c(list(vdir), as.list(path_parts), list(fname)))
      if (file.exists(abs_path)) {
        prefix <- paste(c("videos", path_parts), collapse = "/")
        return(paste0(prefix, "/", utils::URLencode(fname)))
      }
      ""
    }
    
    # Optional source → subfolder mapping
    src_map <- c(Edger = "Edger", Behind = "Behind", Side = "Side")
    
    # 1) If a source was given (Edger/Behind/Side), try videos/<Source>/<file>
    if (!is.null(source) && nzchar(source)) {
      subdir <- src_map[[as.character(source)]]
      if (!is.null(subdir)) {
        for (nm in make_candidates(clip_chr)) {
          url <- make_url_if_exists(subdir, nm)
          if (nzchar(url)) return(url)
        }
      }
    }
    
    # 2) Backward compatibility: try root videos/<file> (no subfolder)
    for (nm in make_candidates(clip_chr)) {
      url <- make_url_if_exists(character(0), nm)
      if (nzchar(url)) return(url)
    }
    
    ""
  }

  fmt_num <- function(digits = 1, unit = "") {
    function(x) {
      x_num <- suppressWarnings(as.numeric(x))
      if (length(x_num) == 0 || all(is.na(x_num))) return("\u2014")
      v <- x_num[1]; if (is.na(v)) return("\u2014")
      out <- format(round(v, digits), nsmall = digits, trim = TRUE)
      if (nzchar(unit)) paste0(out, unit) else out
    }
  }
  
  fmt_pct <- function(digits = 1) {
    function(x) {
      x_num <- suppressWarnings(as.numeric(x))
      if (length(x_num) == 0 || all(is.na(x_num))) return("\u2014")
      v <- x_num[1]; if (is.na(v)) return("\u2014")
      if (v <= 1) v <- v * 100
      paste0(format(round(v, digits), nsmall = digits), "%")
    }
  }
  
  metric_val <- function(row, col, fmt = NULL) {
    v <- tryCatch(row[[col]], error = function(e) NULL)
    if (is.null(v) || length(v) == 0) return(tags$span(style="opacity:.6;", "\u2014"))
    v1 <- v[1]
    
    if (is.null(fmt)) {
      txt <- as.character(v1)
      if (!nzchar(txt)) tags$span(style="opacity:.6;", "\u2014") else txt
    } else {
      out <- tryCatch(fmt(v1), error = function(e) "\u2014")
      if (!nzchar(as.character(out))) tags$span(style="opacity:.6;", "\u2014") else out
    }
  }
  
  # 180° = 12:00, 270° = 3:00, 0° = 6:00, 90° = 9:00
  # If already "H:MM", pass through unchanged.
  deg_to_clock <- function(x) {
    if (is.character(x) && length(x) && grepl("^\\s*\\d{1,2}:\\d{2}\\s*$", x[1])) {
      return(trimws(x[1]))
    }
    d <- suppressWarnings(as.numeric(x))
    if (length(d) == 0 || is.na(d)) return("\u2014")
    a <- (d + 180) %% 360
    hour   <- floor(a / 30)
    minute <- round((a %% 30) / 30 * 60)
    if (minute == 60) { minute <- 0; hour <- hour + 1 }
    hour <- hour %% 12; if (hour == 0) hour <- 12
    sprintf("%d:%02d", hour, minute)
  }

  # --- helpers ---
  format_name_first_last <- function(x) {
    s <- as.character(x %||% "")
    if (!nzchar(s)) return("\u2014")
    # If "Last, First", flip it
    if (grepl(",", s, fixed = TRUE)) {
      parts <- trimws(strsplit(s, ",", fixed = TRUE)[[1]])
      if (length(parts) >= 2) return(paste(parts[2], parts[1]))
    }
    s
  }

  # Helpers (keep these near your other helpers)
  get_first_col <- function(row, candidates) {
    for (nm in candidates) if (!is.null(row[[nm]])) return(row[[nm]])
    NULL
  }

  metric_row <- function(label, value_html) {
    # Bold ONLY the label, value regular. Center the whole line.
    tags$div(
      style = "margin:6px 0; text-align:center;",
      tags$span(style="font-weight:800;", paste0(label, ": ")),
      tags$span(style="font-weight:600;", value_html)
    )
  }

  metric_value_only <- function(value_html) {
    # No label; show value bold & centered (for Velocity/Spin)
    tags$div(style = "margin:6px 0; text-align:center; font-weight:800;", value_html)
  }

  # --- panel ---
  build_metrics_panel <- function(row) {
    # Name (First Last) and Date
    name_text <- format_name_first_last(
      row[["Pitcher"]] %||% row[["pitcher_name"]] %||% row[["PlayerName"]] %||% "\u2014"
    )
    raw_date <- row[["GameDate"]] %||% row[["Date"]] %||% row[["datetime"]] %||% NA
    date_text <- (function(x) {
      d <- suppressWarnings(as.Date(x))
      if (!is.na(d)) return(format(d, "%-m/%-d/%y"))
      px <- suppressWarnings(as.POSIXct(x, tz = "UTC"))
      if (!is.na(px)) return(format(as.Date(px), "%-m/%-d/%y"))
      "\u2014"
    })(raw_date)
    
    # Metrics (ordered as requested)
    pitch_type <- as.character(row[["TaggedPitchType"]] %||% "\u2014")
    
    velo_val <- metric_val(row, "RelSpeed", fmt_num(1, " mph"))              # value only
    ivb_val  <- metric_val(row, "InducedVertBreak", fmt_num(1, "\""))
    hb_val   <- metric_val(row, "HorzBreak",        fmt_num(1, "\""))
    spin_val <- metric_val(row, "SpinRate",         fmt_num(0, " rpm"))       # value only
    
    se_col   <- get_first_col(row, c("SpinEfficiency", "SpinEff", "SpinEffPct"))
    spin_eff <- {
      if (is.null(se_col)) tags$span("\u2014") else {
        val <- tryCatch(se_col, error = function(e) NA)
        if (is.null(val)) tags$span("\u2014") else tags$span(fmt_pct(1)(val))
      }
    }
    
    tilt_src <- get_first_col(row, c("BreakTilt", "bTilt", "ReleaseTilt", "rTilt"))
    btilt    <- tags$span(deg_to_clock(tilt_src))
    
    # Use RelHeight / RelSide (1 decimal)
    height_v <- metric_val(row, "RelHeight", fmt_num(1, ""))
    side_v   <- metric_val(row, "RelSide",   fmt_num(1, ""))
    
    tags$div(
      # Header: name & date centered and bold
      tags$div(style = "font-weight:900; font-size:1.15rem; text-align:center;", name_text),
      tags$div(style = "font-weight:800; opacity:.9; text-align:center; margin-bottom:6px;", date_text),
      tags$hr(),
      # Metrics (stacked)
      tags$div(
        style = "text-align:center;",
        # Pitch Type (value only)
        tags$div(style = "font-weight:900; margin:8px 0;", pitch_type),
        # Velocity (value only)
        metric_value_only(velo_val),
        # IVB / HB with bold titles
        metric_row("IVB",  ivb_val),
        metric_row("HB",   hb_val),
        # Spin (value only)
        metric_value_only(spin_val),
        # SpinEff / bTilt / Height / Side with bold titles
        metric_row("SpinEff", spin_eff),
        metric_row("bTilt",   btilt),
        metric_row("Height",  height_v),
        metric_row("Side",    side_v)
      )
    )
  }

  show_pitch_video_modal_multi <- function(row, right_ui = NULL, dataset = NULL, dataset_idx = NA_integer_) {
    data_full <- dataset
    if (is.null(data_full)) {
      data_full <- tryCatch(as.data.frame(row, stringsAsFactors = FALSE), error = function(e) NULL)
      if (is.null(data_full) || !nrow(data_full)) {
        data_full <- data.frame()
      }
      dataset_idx <- 1L
    }
    data_full <- as.data.frame(data_full, stringsAsFactors = FALSE)
    start_idx <- suppressWarnings(as.integer(dataset_idx))
    if (!is.finite(start_idx) || start_idx < 1L) {
      rn <- rownames(row)
      if (length(rn)) {
        start_idx <- suppressWarnings(as.integer(rn[1]))
      }
      if (!is.finite(start_idx) || start_idx < 1L) start_idx <- 1L
    }
    lbl <- tryCatch(as.character(row$TaggedPitchType)[1], error = function(e) NULL)
    show_pitch_video_sequence(
      rows = data_full,
      label = lbl,
      start_index = start_idx,
      compare_pool = data_full,
      primary_pool_idx = start_idx
    )
  }

  # Bigger video (4fr) | narrower metrics (1fr) | centered logo low in metrics column
  show_pitch_video_modal <- function(video_url, mime_type = "video", right_ui = NULL) {
    has_video <- nzchar(video_url)
    
    # Video (or placeholder)
    video_core <- if (has_video) {
      tags$video(
        src = video_url, controls = NA, autoplay = NA, type = mime_type,
        style = "width:100%; max-height:78vh; background:#000;"
      )
    } else {
      tags$div(
        "No video available",
        style = paste(
          "display:flex; align-items:center; justify-content:center;",
          "width:100%; max-height:78vh; height:60vh;",
          "background:#0b0b0b; color:#fff; font-weight:700; border-radius:8px;"
        )
      )
    }
    
    # Right pane: metrics (scrollable) + logo centered at bottom
    right_pane <- if (is.null(right_ui)) NULL else {
      tags$div(
        style = paste(
          "display:flex; flex-direction:column;",
          "max-height:78vh; min-height:48vh;",
          "text-align:center; padding:0;"         # no extra bottom padding
        ),
        # Metrics content fills available space; no bottom padding so logo sits lower
        tags$div(style = "overflow:auto; flex:1 1 auto; padding:0 0 4px 0;", right_ui),
        # Logo: centered and nudged closer to the bottom
        tags$img(
          src = "PCUlogo.png", alt = "PCU",
          style = paste(
            "align-self:center;",                  # center horizontally
            "margin-top:auto; margin-bottom:2px;", # push to bottom and tuck close
            "width:72px; height:auto; opacity:0.95;",
            "filter: drop-shadow(0 1px 2px rgba(0,0,0,.6));",
            "pointer-events:none; user-select:none;"
          )
        )
      )
    }
    
    body <- if (is.null(right_pane)) {
      video_core
    } else {
      tags$div(
        style = paste(
          "display:grid;",
          "grid-template-columns: 4fr 1fr;",    # wider video, narrower metrics
          "gap:24px; align-items:start;"
        ),
        video_core,
        right_pane
      )
    }

    modal_css <- tags$style(HTML(
      ".modal-dialog.pseq-wide{width:96%;max-width:1400px;}"
    ))
    showModal(tagList(modal_css, modalDialog(body, easyClose = TRUE, footer = NULL, size = "l", class = "pseq-wide")))
  }

  # Normalize ggiraph selection to a single integer (use the MOST RECENT click)
  safe_selected <- function(x) {
    if (is.null(x) || length(x) == 0) return(NA_integer_)
    # ggiraph may send a vector (c("23","17")) or a comma string "23,17"
    x_last <- x[[length(x)]]                 # take last element if vector
    s <- as.character(x_last %||% "")
    parts <- strsplit(s, ",", fixed = TRUE)[[1]]
    s_last <- trimws(parts[length(parts)])   # take last token if comma-separated
    suppressWarnings(as.integer(s_last))
  }

  pitch_rows_for_label <- function(df, label, split_choice = NULL) {
    if (is.null(df) || !nrow(df)) return(df[0, , drop = FALSE])
    lbl <- label %||% ""
    lbl <- trimws(as.character(lbl))
    if (!nzchar(lbl) || tolower(lbl) %in% c("all", "all pitches", "total", "totals")) return(df)
    
    if (!is.null(split_choice)) {
      df_split <- tryCatch(apply_split_by(df, split_choice), error = function(e) df)
      if (!is.null(df_split$SplitColumn)) {
        matches <- df_split[df_split$SplitColumn == lbl, , drop = FALSE]
        if (!nrow(matches)) {
          matches <- df_split[tolower(df_split$SplitColumn) == tolower(lbl), , drop = FALSE]
        }
        if (nrow(matches)) return(matches)
      }
    }
    
    tp <- tryCatch(trimws(as.character(df$TaggedPitchType)), error = function(e) character(nrow(df)))
    matches <- df[tp == lbl, , drop = FALSE]
    if (!nrow(matches)) {
      lbl_clean <- trimws(sub("\\s*\\(.*\\)$", "", lbl))
      matches <- df[tp == lbl_clean, , drop = FALSE]
    }
    if (!nrow(matches)) {
      matches <- df[tolower(tp) == tolower(lbl), , drop = FALSE]
    }
    matches
  }

  pitch_abbrev_for <- function(pt) {
    pt_chr <- trimws(as.character(pt %||% ""))
    if (!nzchar(pt_chr)) return("")
    mapping <- c(
      "Fastball" = "FB", "Four-Seam Fastball" = "FB", "4-Seam Fastball" = "FB",
      "Sinker" = "SK", "Two-Seam Fastball" = "SK", "2-Seam Fastball" = "SK",
      "Cutter" = "CT", "Cut Fastball" = "CT",
      "Curveball" = "CB", "Curve" = "CB", "Knuckle Curve" = "CB",
      "Slider" = "SL",
      "Sweeper" = "SW",
      "ChangeUp" = "CH", "Change Up" = "CH", "Changeup" = "CH",
      "Splitter" = "SP", "Split Finger" = "SP", "Split-Finger" = "SP",
      "Knuckleball" = "KN", "Knuckle Ball" = "KN",
      "Gyro" = "SL", "Slurve" = "SL"
    )
    out <- mapping[pt_chr]
    if (!is.na(out)) return(out)
    parts <- strsplit(pt_chr, "[^A-Za-z]+")[[1]]
    parts <- parts[nzchar(parts)]
    if (!length(parts)) return(toupper(substr(pt_chr, 1, 2)))
    abbr <- paste0(substring(parts, 1, 1), collapse = "")
    toupper(substr(abbr, 1, 3))
  }

  format_initial_last <- function(name_chr) {
    nm <- trimws(as.character(name_chr %||% ""))
    if (!nzchar(nm)) return("")
    nm_fmt <- format_name_first_last(nm)
    parts <- strsplit(trimws(nm_fmt), "\\s+")[[1]]
    parts <- parts[nzchar(parts)]
    if (!length(parts)) return(nm_fmt)
    if (length(parts) == 1) return(parts)
    paste0(substr(parts[1], 1, 1), ". ", paste(parts[-1], collapse = " "))
  }

  make_pitch_option_label <- function(row, idx = NA_integer_) {
    if (is.null(row) || !nrow(row)) return("Pitch")
    date_val <- tryCatch(as.Date(row$Date[1]), error = function(e) NA)
    date_txt <- if (inherits(date_val, "Date") && !is.na(date_val)) format(date_val, "%m/%d/%y") else ""
    name_raw <- row$Pitcher[1] %||% row$PitcherName[1] %||% row$PlayerName[1]
    name_txt <- format_initial_last(name_raw)
    pt_txt <- pitch_abbrev_for(row$TaggedPitchType[1])
    velo_val <- suppressWarnings(as.numeric(row$RelSpeed[1]))
    ivb_val  <- suppressWarnings(as.numeric(row$InducedVertBreak[1]))
    hb_val   <- suppressWarnings(as.numeric(row$HorzBreak[1]))
    velo_txt <- if (is.finite(velo_val)) sprintf("%.1f mph", velo_val) else ""
    ivb_txt  <- if (is.finite(ivb_val)) sprintf("%.1f\"", ivb_val) else ""
    hb_txt   <- if (is.finite(hb_val)) sprintf("%.1f\"", hb_val) else ""
    idx_txt  <- if (is.finite(idx)) paste0("#", idx) else ""
    parts <- c(date_txt, name_txt, pt_txt, velo_txt, ivb_txt, hb_txt, idx_txt)
    paste(parts[nzchar(parts)], collapse = " | ")
  }

  show_pitch_video_sequence <- function(rows, label = NULL, start_index = 1,
                                        compare_pool = NULL, primary_pool_idx = NA_integer_) {
    rows_df <- tryCatch(as.data.frame(rows), error = function(e) NULL)
    if (is.null(rows_df) || !nrow(rows_df)) {
      showModal(modalDialog("No video available for this selection.", easyClose = TRUE, footer = NULL))
      return(invisible(FALSE))
    }

    rows_df <- as.data.frame(rows_df, stringsAsFactors = FALSE)
    if (is.null(rownames(rows_df))) rownames(rows_df) <- as.character(seq_len(nrow(rows_df)))
    n_total <- nrow(rows_df)
    clip1 <- tryCatch(as.character(rows_df$VideoClip),  error = function(e) rep("", n_total))
    clip2 <- tryCatch(as.character(rows_df$VideoClip2), error = function(e) rep("", n_total))
    clip3 <- tryCatch(as.character(rows_df$VideoClip3), error = function(e) rep("", n_total))
    has_video <- nzchar(clip1) | nzchar(clip2) | nzchar(clip3)
    rows_vid <- rows_df[has_video, , drop = FALSE]
    video_positions <- which(has_video)
    if (!nrow(rows_vid)) {
      showModal(modalDialog("No videos available for this selection.", easyClose = TRUE, footer = NULL))
      return(invisible(FALSE))
    }
    pool_df <- if (!is.null(compare_pool)) {
      tryCatch(as.data.frame(compare_pool, stringsAsFactors = FALSE), error = function(e) NULL)
    } else rows_df
    if (is.null(pool_df)) pool_df <- rows_df[0, , drop = FALSE]
    if (is.null(rownames(pool_df))) rownames(pool_df) <- as.character(seq_len(nrow(pool_df)))

    pool_clip1 <- tryCatch(as.character(pool_df$VideoClip),  error = function(e) rep("", nrow(pool_df)))
    pool_clip2 <- tryCatch(as.character(pool_df$VideoClip2), error = function(e) rep("", nrow(pool_df)))
    pool_clip3 <- tryCatch(as.character(pool_df$VideoClip3), error = function(e) rep("", nrow(pool_df)))
    pool_has_video <- nzchar(pool_clip1) | nzchar(pool_clip2) | nzchar(pool_clip3)
    pool_video_idx <- which(pool_has_video)
    compare_available <- length(pool_video_idx) > 1

    match_start <- match(suppressWarnings(as.integer(start_index)), video_positions)
    if (is.na(match_start) || match_start < 1L) match_start <- 1L
    if (match_start > nrow(rows_vid)) match_start <- nrow(rows_vid)

    camera_display_labels <- c("Camera 1", "Camera 2", "Camera 3")
    camera_source_map <- setNames(c("Edger", "Behind", "Side"), camera_display_labels)
    make_pitch_label <- function(dat, idx = NA_integer_) make_pitch_option_label(dat, idx)

    collect_urls <- function(row) {
      if (is.null(row) || !nrow(row)) return(list())
      clips <- c(
        "Camera 1" = tryCatch(as.character(row$VideoClip)[1],  error = function(e) ""),
        "Camera 2" = tryCatch(as.character(row$VideoClip2)[1], error = function(e) ""),
        "Camera 3" = tryCatch(as.character(row$VideoClip3)[1], error = function(e) "")
      )
      clips <- clips[nzchar(clips)]
      if (!length(clips)) return(list())
      urls <- lapply(names(clips), function(display) {
        clip <- clips[[display]]
        source_tag <- camera_source_map[[display]] %||% display
        video_url_for(clip, source = source_tag)
      })
      names(urls) <- names(clips)
      urls[vapply(urls, nzchar, logical(1))]
    }

    metrics_block <- function(content) {
      if (is.null(content)) return(NULL)
      tags$div(
        style = paste(
          "display:flex;flex-direction:column;",
          "max-height:68vh;min-height:40vh;",
          "text-align:center;padding:0;"
        ),
        tags$div(style = "overflow:auto;flex:1 1 auto;padding:0 0 4px 0;", content),
        tags$img(
          src = "PCUlogo.png", alt = "PCU",
          style = paste(
            "align-self:center;margin-top:auto;margin-bottom:2px;",
            "width:72px;height:auto;opacity:0.95;",
            "filter:drop-shadow(0 1px 2px rgba(0,0,0,.6));",
            "pointer-events:none;user-select:none;"
          )
        )
      )
    }

    default_secondary_for <- function(primary_idx) {
      if (!length(pool_video_idx)) return(NA_integer_)
      candidates <- pool_video_idx
      if (is.finite(primary_idx)) candidates <- candidates[candidates != primary_idx]
      if (!length(candidates)) candidates <- pool_video_idx
      candidates[1]
    }

    idx <- reactiveVal(match_start)
    cam_sel <- reactiveVal("")
    compare_mode <- reactiveVal(FALSE)
    secondary_idx <- reactiveVal(NA_integer_)
    cmp_cam_sel <- reactiveVal("")

    uid_base  <- paste0("pseq_", as.integer((as.numeric(Sys.time()) * 1000) %% 1e9))
    video_id  <- paste0(uid_base, "_video")
    next_id   <- paste0(uid_base, "_next")
    prev_id   <- paste0(uid_base, "_prev")
    cam_prefix <- paste0(uid_base, "_cam")
    primary_video_id   <- paste0(uid_base, "_video_primary")
    secondary_video_id <- paste0(uid_base, "_video_secondary")
    compare_toggle_id  <- paste0(uid_base, "_compare")
    primary_select_id  <- paste0(uid_base, "_primary_select")
    compare_select_id  <- paste0(uid_base, "_compare_select")
    cmp_cam_prefix     <- paste0(uid_base, "_cmpcam")
    primary_slider_id  <- paste0(uid_base, "_slider_primary")
    secondary_slider_id <- paste0(uid_base, "_slider_secondary")
    sync_slider_id     <- paste0(uid_base, "_slider_sync")
    primary_play_id    <- paste0(uid_base, "_play_primary")
    primary_pause_id   <- paste0(uid_base, "_pause_primary")
    secondary_play_id  <- paste0(uid_base, "_play_secondary")
    secondary_pause_id <- paste0(uid_base, "_pause_secondary")
    sync_play_id       <- paste0(uid_base, "_play_sync")
    sync_pause_id      <- paste0(uid_base, "_pause_sync")
    download_single_id <- paste0(uid_base, "_download_single")
    download_all_id    <- paste0(uid_base, "_download_all")

    current_row <- reactive({
      i <- idx()
      if (!is.finite(i)) i <- 1L
      i <- max(1L, min(nrow(rows_vid), i))
      rows_vid[i, , drop = FALSE]
    })

    current_urls <- reactive(collect_urls(current_row()))

    primary_pool_idx_reactive <- reactive({
      if (!nrow(pool_df)) return(NA_integer_)
      row <- current_row()
      if (is.null(row) || !nrow(row)) return(NA_integer_)
      rn <- rownames(row)
      if (length(rn)) {
        match_idx <- match(rn[1], rownames(pool_df))
        if (is.finite(match_idx)) return(match_idx)
      }
      if (is.finite(primary_pool_idx) && primary_pool_idx >= 1L && primary_pool_idx <= nrow(pool_df)) {
        return(primary_pool_idx)
      }
      if (length(pool_video_idx)) pool_video_idx[1] else 1L
    })

    cmp_current_row <- reactive({
      idx_val <- secondary_idx()
      if (!is.finite(idx_val) || !nrow(pool_df)) return(NULL)
      if (idx_val < 1L || idx_val > nrow(pool_df)) return(NULL)
      if (!pool_has_video[idx_val]) return(NULL)
      pool_df[idx_val, , drop = FALSE]
    })

    cmp_urls <- reactive(collect_urls(cmp_current_row()))

    cam_names <- camera_display_labels

    slugify <- function(text, fallback = "pitch") {
      txt <- trimws(as.character(text %||% ""))
      if (!nzchar(txt)) txt <- fallback
      slug <- gsub("[^A-Za-z0-9]+", "-", txt)
      slug <- gsub("-+", "-", slug)
      slug <- gsub("(^-)|(-$)", "", slug)
      slug <- tolower(slug)
      if (!nzchar(slug)) tolower(fallback) else slug
    }

    file_ext_from_url <- function(url, default = ".mp4") {
      if (!nzchar(url)) return(default)
      clean <- sub("\\?.*$", "", url)
      ext <- tools::file_ext(clean)
      if (!nzchar(ext)) default else paste0(".", tolower(ext))
    }

    download_source_to <- function(url, dest) {
      if (!nzchar(url)) stop("No source URL available", call. = FALSE)
      dir.create(dirname(dest), recursive = TRUE, showWarnings = FALSE)
      if (grepl("^https?://", url, ignore.case = TRUE)) {
        req <- httr2::request(url)
        tryCatch({
          httr2::req_perform(req, path = dest)
          TRUE
        }, error = function(e) stop(sprintf("Failed to download %s", basename(url)), call. = FALSE))
      } else {
        rel <- sub("^/+", "", url)
        rel <- utils::URLdecode(rel)
        vdir <- getOption("PCU_VIDEOS_DIR", NA_character_)
        if (is.na(vdir) || !nzchar(vdir)) {
          stop("Local video directory is not configured", call. = FALSE)
        }
        parts <- strsplit(rel, "/", fixed = TRUE)[[1]]
        if (length(parts) && identical(parts[1], "videos")) parts <- parts[-1]
        abs_path <- do.call(file.path, c(list(vdir), as.list(parts)))
        if (!length(parts) || !file.exists(abs_path)) {
          stop("Video file not found on server", call. = FALSE)
        }
        if (!file.copy(abs_path, dest, overwrite = TRUE)) {
          stop("Unable to copy video file", call. = FALSE)
        }
        TRUE
      }
    }

    observeEvent(current_urls(), {
      urls <- current_urls()
      cur  <- cam_sel()
      if (!length(urls)) {
        cam_sel("")
      } else if (!nzchar(cur) || !(cur %in% names(urls))) {
        cam_sel(names(urls)[1])
      }
    }, ignoreNULL = FALSE, priority = 1)

    observeEvent(cmp_urls(), {
      urls <- cmp_urls()
      cur <- cmp_cam_sel()
      if (!length(urls)) {
        cmp_cam_sel("")
      } else if (!nzchar(cur) || !(cur %in% names(urls))) {
        cmp_cam_sel(names(urls)[1])
      }
    }, ignoreNULL = FALSE, priority = 1)

    for (nm in cam_names) local({
      src <- nm
      observeEvent(input[[paste0(cam_prefix, "_", src)]], {
        urls <- current_urls()
        if (length(urls) && !is.null(urls[[src]]) && nzchar(urls[[src]])) {
          cam_sel(src)
        }
      }, ignoreNULL = TRUE)
    })

    for (nm in cam_names) local({
      src <- nm
      observeEvent(input[[paste0(cmp_cam_prefix, "_", src)]], {
        urls <- cmp_urls()
        if (length(urls) && !is.null(urls[[src]]) && nzchar(urls[[src]])) {
          cmp_cam_sel(src)
        }
      }, ignoreNULL = TRUE)
    })

    observeEvent(input[[next_id]], {
      cur <- idx()
      if (is.finite(cur) && cur < nrow(rows_vid)) idx(cur + 1L)
    }, ignoreNULL = TRUE)

    observeEvent(input[[prev_id]], {
      cur <- idx()
      if (is.finite(cur) && cur > 1) idx(cur - 1L)
    }, ignoreNULL = TRUE)

    observeEvent(input[[compare_toggle_id]], {
      if (!compare_available) return()
      compare_mode(!compare_mode())
    }, ignoreNULL = TRUE)

    observeEvent(compare_mode(), {
      if (compare_mode()) {
        primary_idx <- primary_pool_idx_reactive()
        secondary_idx(default_secondary_for(primary_idx))
        if (compare_available && is.finite(primary_idx)) {
          updateSelectizeInput(session, primary_select_id, selected = as.character(primary_idx))
        }
      } else {
        secondary_idx(NA_integer_)
      }
    }, ignoreNULL = TRUE)

    observeEvent(idx(), {
      if (!compare_available) return()
      if (!compare_mode()) return()
      primary_idx <- primary_pool_idx_reactive()
      current_sec <- secondary_idx()
      if (!is.finite(current_sec) || !pool_has_video[current_sec] || identical(current_sec, primary_idx)) {
        secondary_idx(default_secondary_for(primary_idx))
      }
      if (is.finite(primary_idx)) {
        updateSelectizeInput(session, primary_select_id, selected = as.character(primary_idx))
      }
    }, ignoreNULL = TRUE)

    observeEvent(secondary_idx(), {
      if (!compare_available) return()
      if (!compare_mode()) return()
      val <- secondary_idx()
      updateSelectizeInput(session, compare_select_id,
                           selected = if (is.finite(val)) as.character(val) else NULL)
    }, ignoreNULL = FALSE)

    observeEvent(input[[primary_select_id]], {
      if (!compare_available) return()
      if (!compare_mode()) return()
      val <- suppressWarnings(as.integer(input[[primary_select_id]]))
      if (!is.finite(val)) return()
      target_idx <- match(val, video_positions)
      if (is.finite(target_idx)) idx(target_idx)
    }, ignoreNULL = TRUE)

    observeEvent(input[[compare_select_id]], {
      if (!compare_available) return()
      val <- suppressWarnings(as.integer(input[[compare_select_id]]))
      if (is.finite(val) && val >= 1L && val <= nrow(pool_df) && pool_has_video[val]) {
        secondary_idx(val)
      }
    }, ignoreNULL = TRUE)

    output[[download_single_id]] <- downloadHandler(
      filename = function() {
        row <- current_row()
        idx_val <- primary_pool_idx_reactive()
        label <- make_pitch_option_label(row, idx_val)
        cam <- cam_sel()
        if (!nzchar(cam)) cam <- "video"
        urls <- current_urls()
        url <- urls[[cam]] %||% ""
        ext <- file_ext_from_url(url)
        paste0(slugify(label, fallback = "pitch"), "-", tolower(cam), ext)
      },
      content = function(file) {
        urls <- current_urls()
        sel <- cam_sel()
        if (!length(urls) || !nzchar(sel) || is.null(urls[[sel]]) || !nzchar(urls[[sel]])) {
          stop("No video available for download", call. = FALSE)
        }
        download_source_to(urls[[sel]], file)
      }
    )

    output[[download_all_id]] <- downloadHandler(
      filename = function() {
        base <- if (!is.null(label) && nzchar(label)) label else "selection"
        paste0(slugify(base, fallback = "pitch"), "-videos.zip")
      },
      content = function(file) {
        if (!length(pool_video_idx)) {
          stop("No videos available in this filter", call. = FALSE)
        }
        rows_all <- pool_df[pool_video_idx, , drop = FALSE]
        if (!nrow(rows_all)) {
          stop("No videos available in this filter", call. = FALSE)
        }
        tmpdir <- tempfile("pseq_dl_")
        dir.create(tmpdir, recursive = TRUE, showWarnings = FALSE)
        on.exit(unlink(tmpdir, recursive = TRUE, force = TRUE), add = TRUE)
        
        saved <- character(0)
        done_map <- character(0)
        
        for (pos in seq_along(pool_video_idx)) {
          idx_val <- pool_video_idx[pos]
          row_now <- pool_df[idx_val, , drop = FALSE]
          slug <- slugify(make_pitch_option_label(row_now, idx_val), fallback = sprintf("pitch-%03d", idx_val))
          urls <- collect_urls(row_now)
          if (!length(urls)) next
          for (cam in names(urls)) {
            url <- urls[[cam]]
            if (!nzchar(url)) next
            key <- paste(url, cam, sep = "::")
            if (key %in% done_map) next
            done_map <- c(done_map, key)
            ext <- file_ext_from_url(url)
            dest_name <- sprintf("%03d_%s_%s%s", pos, slug, tolower(cam), ext)
            dest_path <- file.path(tmpdir, dest_name)
            download_source_to(url, dest_path)
            saved <- c(saved, dest_path)
          }
        }
        
        if (!length(saved)) {
          stop("No downloadable videos were found", call. = FALSE)
        }
        
        zipfile <- normalizePath(file, mustWork = FALSE)
        oldwd <- getwd()
        setwd(tmpdir)
        on.exit(setwd(oldwd), add = TRUE)
        utils::zip(zipfile = zipfile, files = basename(saved))
      }
    )

    output[[video_id]] <- renderUI({
      i <- idx()
      if (!is.finite(i)) i <- 1L
      i <- max(1L, min(nrow(rows_vid), i))
      row <- rows_vid[i, , drop = FALSE]
      urls <- current_urls()
      sel <- cam_sel()
      if ((!nzchar(sel) || !(sel %in% names(urls))) && length(urls)) {
        sel <- names(urls)[1]
      }
      url <- if (length(urls) && nzchar(sel) && !is.null(urls[[sel]])) urls[[sel]] else ""
      if (nzchar(url)) {
        cache_tag <- as.integer(as.numeric(Sys.time()))
        url <- paste0(url, if (grepl("\\?", url)) "&" else "?", "v=", cache_tag)
      }
      
      right <- build_metrics_panel(row)
      seq_txt <- sprintf("%d of %d", i, nrow(rows_vid))
      
      compare_btn_label <- if (isTRUE(compare_mode())) tagList(icon("video"), "Single View") else tagList(icon("columns"), "Side-by-Side")
      compare_btn <- actionButton(
        compare_toggle_id,
        label = compare_btn_label,
        class = "btn btn-sm btn-outline-secondary",
        style = "min-width:128px;font-weight:600;",
        disabled = if (compare_available) NULL else "disabled"
      )
      
      download_controls <- tags$div(
        style = "display:flex;justify-content:center;gap:12px;margin-bottom:12px;flex-wrap:wrap;",
        downloadButton(
          download_single_id,
          label = tagList(icon("download"), "Download Pitch"),
          class = "btn btn-sm btn-outline-secondary"
        ),
        downloadButton(
          download_all_id,
          label = tagList(icon("file-archive"), "Download Filter"),
          class = "btn btn-sm btn-outline-secondary",
          title = "Downloads all available camera angles in this filter as a ZIP"
        )
      )
      
      header <- tags$div(
        style = "display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px;",
        actionButton(
          prev_id,
          label = tagList(icon("chevron-left"), "Prev"),
          class = "btn-light btn-sm",
          style = "min-width:92px;",
          disabled = if (i <= 1) "disabled" else NULL
        ),
        tags$div(
          style = "flex:1;text-align:center;",
          tags$div(style = "font-size:0.9rem;font-weight:600;opacity:0.75;", seq_txt)
        ),
        actionButton(
          next_id,
          label = tagList("Next", icon("chevron-right")),
          class = "btn-light btn-sm",
          style = "min-width:92px;",
          disabled = if (i >= nrow(rows_vid)) "disabled" else NULL
        )
      )
      
      cam_buttons <- lapply(cam_names, function(src) {
        u <- urls[[src]]
        if (is.null(u) || !nzchar(u)) return(NULL)
        btn_class <- if (identical(sel, src)) "btn-sm btn-primary" else "btn-sm btn-outline-secondary"
        actionButton(
          paste0(cam_prefix, "_", src),
          label = src,
          class = btn_class,
          style = "min-width:82px;font-weight:600;"
        )
      })
      cam_buttons <- Filter(Negate(is.null), cam_buttons)
      cam_row <- if (length(cam_buttons)) {
        tags$div(
          style = "display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px;justify-content:center;",
          cam_buttons
        )
      } else NULL
      
      video_style <- if (isTRUE(compare_mode())) "width:100%;max-height:60vh;background:#000;" else "width:100%;max-height:78vh;background:#000;"
      placeholder_style <- if (isTRUE(compare_mode()))
        "display:flex;align-items:center;justify-content:center;width:100%;max-height:60vh;height:44vh;background:#0b0b0b;color:#fff;font-weight:700;border-radius:8px;"
      else
        "display:flex;align-items:center;justify-content:center;width:100%;max-height:78vh;height:60vh;background:#0b0b0b;color:#fff;font-weight:700;border-radius:8px;"
      
      video_core <- if (nzchar(url)) {
        tags$video(
          id = primary_video_id,
          src = url,
          controls = NA,
          autoplay = NA,
          type = guess_video_type(url),
          style = video_style
        )
      } else {
        tags$div("No video available", style = placeholder_style)
      }
      
      compare_choices <- if (compare_available) {
        labs <- vapply(pool_video_idx, function(idx_val) make_pitch_option_label(pool_df[idx_val, , drop = FALSE], idx_val), character(1))
        stats::setNames(as.character(pool_video_idx), labs)
      } else character(0)
      
      if (!isTRUE(compare_mode())) {
        right_pane <- metrics_block(right)
        main_layout <- if (is.null(right_pane)) {
          video_core
        } else {
          tags$div(
            style = paste(
              "display:grid;",
              "grid-template-columns:4fr 1fr;",
              "gap:24px;align-items:start;"
            ),
            video_core,
            right_pane
          )
        }
        
        tagList(
          header,
          tags$div(style = "display:flex;justify-content:center;margin-bottom:10px;", compare_btn),
          cam_row,
          download_controls,
          main_layout
        )
      } else {
        cmp_row <- cmp_current_row()
        cmp_sel <- cmp_cam_sel()
        cmp_urls_now <- cmp_urls()
        if ((!nzchar(cmp_sel) || !(cmp_sel %in% names(cmp_urls_now))) && length(cmp_urls_now)) {
          cmp_sel <- names(cmp_urls_now)[1]
        }
        cmp_url <- if (length(cmp_urls_now) && nzchar(cmp_sel) && !is.null(cmp_urls_now[[cmp_sel]])) cmp_urls_now[[cmp_sel]] else ""
        if (nzchar(cmp_url)) {
          cache_tag <- as.integer(as.numeric(Sys.time()))
          cmp_url <- paste0(cmp_url, if (grepl("\\?", cmp_url)) "&" else "?", "v=", cache_tag)
        }
        
        cmp_cam_buttons <- lapply(cam_names, function(src) {
          u <- cmp_urls_now[[src]]
          if (is.null(u) || !nzchar(u)) return(NULL)
          btn_class <- if (identical(cmp_sel, src)) "btn-sm btn-primary" else "btn-sm btn-outline-secondary"
          actionButton(
            paste0(cmp_cam_prefix, "_", src),
            label = src,
            class = btn_class,
            style = "min-width:82px;font-weight:600;"
          )
        })
        cmp_cam_buttons <- Filter(Negate(is.null), cmp_cam_buttons)
        cmp_cam_row <- if (length(cmp_cam_buttons)) {
          tags$div(
            style = "display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px;justify-content:center;",
            cmp_cam_buttons
          )
        } else NULL
        
        cmp_video_core <- if (nzchar(cmp_url)) {
          tags$video(
            id = secondary_video_id,
            src = cmp_url,
            controls = NA,
            autoplay = NA,
            type = guess_video_type(cmp_url),
            style = video_style
          )
        } else {
          tags$div("Select a pitch", style = placeholder_style)
        }
        
        left_metrics_block <- metrics_block(right)
        right_metrics_block <- metrics_block(if (!is.null(cmp_row)) build_metrics_panel(cmp_row) else NULL)
        
        primary_selected_val <- primary_pool_idx_reactive()
        secondary_selected_val <- secondary_idx()
        
        selector <- if (compare_available) {
          tags$div(
            style = "display:flex;justify-content:center;gap:16px;margin-bottom:12px;flex-wrap:wrap;",
            tags$div(
              style = "display:flex;flex-direction:column;min-width:220px;gap:4px;",
              tags$label("Primary Pitch", `for` = primary_select_id, style = "margin:0;font-weight:600;"),
              selectizeInput(
                primary_select_id,
                label = NULL,
                choices = compare_choices,
                selected = {
                  if (is.finite(primary_selected_val)) as.character(primary_selected_val)
                  else if (length(compare_choices)) compare_choices[[1]] else NULL
                },
                options = list(placeholder = "Choose primary pitch")
              )
            ),
            tags$div(
              style = "display:flex;flex-direction:column;min-width:220px;gap:4px;",
              tags$label("Secondary Pitch", `for` = compare_select_id, style = "margin:0;font-weight:600;"),
              selectizeInput(
                compare_select_id,
                label = NULL,
                choices = compare_choices,
                selected = {
                  if (is.finite(secondary_selected_val)) as.character(secondary_selected_val)
                  else if (length(compare_choices)) compare_choices[[1]] else NULL
                },
                options = list(placeholder = "Choose secondary pitch")
              )
            )
          )
        } else NULL
        
        primary_controls <- if (compare_available) {
          tags$div(
            style = "display:flex;align-items:center;gap:10px;margin-bottom:8px;flex-wrap:wrap;justify-content:center;",
            actionButton(primary_play_id, label = "Play", icon = icon("play"), class = "btn btn-sm btn-outline-secondary"),
            actionButton(primary_pause_id, label = "Pause", icon = icon("pause"), class = "btn btn-sm btn-outline-secondary"),
            tags$input(
              id = primary_slider_id,
              type = "range",
              min = "0",
              max = "1",
              step = "0.01",
              value = "0",
              style = "flex:1 1 260px;min-width:220px;"
            )
          )
        } else NULL
        
        secondary_controls <- if (compare_available) {
          tags$div(
            style = "display:flex;align-items:center;gap:10px;margin-bottom:8px;flex-wrap:wrap;justify-content:center;",
            actionButton(secondary_play_id, label = "Play", icon = icon("play"), class = "btn btn-sm btn-outline-secondary"),
            actionButton(secondary_pause_id, label = "Pause", icon = icon("pause"), class = "btn btn-sm btn-outline-secondary"),
            tags$input(
              id = secondary_slider_id,
              type = "range",
              min = "0",
              max = "1",
              step = "0.01",
              value = "0",
              style = "flex:1 1 260px;min-width:220px;"
            )
          )
        } else NULL
        
        sync_controls <- if (compare_available) {
          tags$div(
            style = "display:flex;align-items:center;gap:12px;margin:-4px 0 12px 0;flex-wrap:wrap;justify-content:center;",
            tags$label(
              "Sync Scrub",
              `for` = sync_slider_id,
              style = "margin:0;font-weight:600;min-width:96px;text-align:right;"
            ),
            tags$input(
              id = sync_slider_id,
              type = "range",
              min = "0",
              max = "1",
              step = "0.01",
              value = "0",
              style = "flex:1 1 360px;min-width:260px;"
            ),
            actionButton(sync_play_id, label = "Play", icon = icon("play"), class = "btn btn-sm btn-outline-secondary"),
            actionButton(sync_pause_id, label = "Pause", icon = icon("pause"), class = "btn btn-sm btn-outline-secondary")
          )
        } else NULL
        
        left_col <- tags$div(
          style = "display:flex;flex-direction:column;gap:10px;",
          cam_row,
          primary_controls,
          video_core,
          left_metrics_block
        )
        
        right_col <- tags$div(
          style = "display:flex;flex-direction:column;gap:10px;",
          cmp_cam_row,
          secondary_controls,
          cmp_video_core,
          right_metrics_block
        )
        
        control_script <- if (compare_available) {
          tags$script(HTML(sprintf(
            "(function(){\n  var configs = [\n    {videoId:'%s', sliderId:'%s', playId:'%s', pauseId:'%s'},\n    {videoId:'%s', sliderId:'%s', playId:'%s', pauseId:'%s'}\n  ];\n  var syncSlider = document.getElementById('%s');\n  var syncPlayBtn = document.getElementById('%s');\n  var syncPauseBtn = document.getElementById('%s');\n  var syncUpdating = false;\n\n  function playSafe(video){\n    if (!video) return;\n    try {\n      var p = video.play();\n      if (p && typeof p.catch === 'function') p.catch(function(){});\n    } catch(e){}\n  }\n\n  function pauseSafe(video){\n    if (!video) return;\n    try { video.pause(); } catch(e){}\n  }\n\n  function updateSyncRange(){\n    if (!syncSlider) return;\n    var maxDur = Infinity;\n    configs.forEach(function(cfg){\n      if (!cfg.video) return;\n      var d = cfg.video.duration;\n      if (isFinite(d) && d > 0 && d < maxDur) maxDur = d;\n    });\n    if (!isFinite(maxDur) || maxDur === Infinity){\n      syncSlider.disabled = true;\n    } else {\n      syncSlider.max = maxDur;\n      syncSlider.disabled = false;\n    }\n  }\n\n  function updateSyncValue(){\n    if (!syncSlider || syncUpdating) return;\n    var minTime = Infinity;\n    configs.forEach(function(cfg){\n      if (!cfg.video) return;\n      var t = cfg.video.currentTime;\n      if (isFinite(t) && t < minTime) minTime = t;\n    });\n    if (minTime !== Infinity) syncSlider.value = minTime;\n  }\n\n  configs.forEach(function(cfg){\n    cfg.video = document.getElementById(cfg.videoId);\n    cfg.slider = document.getElementById(cfg.sliderId);\n    cfg.playBtn = document.getElementById(cfg.playId);\n    cfg.pauseBtn = document.getElementById(cfg.pauseId);\n    if (!cfg.video) return;\n    var video = cfg.video;\n    var slider = cfg.slider;\n    var updating = false;\n\n    function setRange(){\n      if (!slider) return;\n      if (isFinite(video.duration) && video.duration > 0){\n        slider.max = video.duration;\n        slider.disabled = false;\n      } else {\n        slider.disabled = true;\n      }\n    }\n\n    video.addEventListener('loadedmetadata', function(){\n      setRange();\n      updateSyncRange();\n      if (slider) slider.value = video.currentTime || 0;\n      updateSyncValue();\n    });\n\n    video.addEventListener('timeupdate', function(){\n      if (updating) return;\n      setRange();\n      if (slider) slider.value = video.currentTime || 0;\n      updateSyncRange();\n      updateSyncValue();\n    });\n\n    if (slider){\n      slider.addEventListener('input', function(){\n        updating = true;\n        var val = parseFloat(slider.value) || 0;\n        try { video.currentTime = val; } catch(e){}\n      });\n      slider.addEventListener('change', function(){\n        updating = false;\n      });\n    }\n\n    if (cfg.playBtn){\n      cfg.playBtn.addEventListener('click', function(){\n        playSafe(video);\n      });\n    }\n\n    if (cfg.pauseBtn){\n      cfg.pauseBtn.addEventListener('click', function(){\n        pauseSafe(video);\n      });\n    }\n  });\n\n  if (syncSlider){\n    syncSlider.addEventListener('input', function(){\n      syncUpdating = true;\n      var val = parseFloat(syncSlider.value) || 0;\n      var actual = Infinity;\n      configs.forEach(function(cfg){\n        if (!cfg.video) return;\n        var target = val;\n        var dur = cfg.video.duration;\n        if (isFinite(dur) && dur > 0 && target > dur) target = dur;\n        try { cfg.video.currentTime = target; } catch(e){}\n        if (cfg.slider) cfg.slider.value = target;\n        var ct = cfg.video.currentTime;\n        if (isFinite(ct) && ct < actual) actual = ct;\n      });\n      if (actual !== Infinity) syncSlider.value = actual;\n    });\n    syncSlider.addEventListener('change', function(){\n      syncUpdating = false;\n    });\n    updateSyncRange();\n    updateSyncValue();\n  }\n\n  if (syncPlayBtn){\n    syncPlayBtn.addEventListener('click', function(){\n      configs.forEach(function(cfg){ playSafe(cfg.video); });\n    });\n  }\n\n  if (syncPauseBtn){\n    syncPauseBtn.addEventListener('click', function(){\n      configs.forEach(function(cfg){ pauseSafe(cfg.video); });\n    });\n  }\n})();",
            primary_video_id, primary_slider_id, primary_play_id, primary_pause_id,
            secondary_video_id, secondary_slider_id, secondary_play_id, secondary_pause_id,
            sync_slider_id, sync_play_id, sync_pause_id)))
        } else NULL
        
        tagList(
          header,
          tags$div(style = "display:flex;justify-content:center;margin-bottom:10px;", compare_btn),
          selector,
          sync_controls,
          download_controls,
          tags$div(
            style = "display:grid;grid-template-columns:1fr 1fr;gap:24px;align-items:start;",
            left_col,
            right_col
          ),
          control_script
        )
      }
    })

    modal_css <- tags$style(HTML(
      ".modal-dialog.pseq-wide{width:96%;max-width:1400px;}"
    ))
    showModal(tagList(modal_css, modalDialog(uiOutput(video_id), easyClose = TRUE, footer = NULL, size = "l", class = "pseq-wide")))
    invisible(TRUE)
  }

  open_pitch_edit_modal <- function(rows) {
    if (is.null(rows) || !nrow(rows)) return(invisible(FALSE))
    selected_pitches <- rows
    available_pitchers <- sort(unique(pitch_data_pitching$Pitcher))
    pitcher_choices <- sort(unique(c(available_pitchers, as.character(selected_pitches$Pitcher))))
    
    showModal(modalDialog(
      title = paste("Edit Pitch Type for", nrow(selected_pitches), "pitch(es)"),
      selectInput("new_pitch_type", "New Pitch Type:",
                  choices = c("Fastball", "Sinker", "Cutter", "Slider", "Sweeper", 
                              "Curveball", "ChangeUp", "Splitter", "Knuckleball"),
                  selected = selected_pitches$TaggedPitchType[1]),
      selectInput("new_pitcher", "Assign To Pitcher:",
                  choices = pitcher_choices,
                  selected = selected_pitches$Pitcher[1]),
      br(),
      strong("Selected Pitches:"),
      br(),
      if (nrow(selected_pitches) <= 10) {
        div(
          lapply(1:nrow(selected_pitches), function(i) {
            p <- selected_pitches[i, ]
            div(sprintf("Pitch %d: %s - %s (%.1f mph, HB: %.1f, IVB: %.1f)",
                        i, p$TaggedPitchType, p$Date, 
                        p$RelSpeed %||% 0, p$HorzBreak %||% 0, p$InducedVertBreak %||% 0))
          })
        )
      } else {
        div(sprintf("%d pitches selected (too many to display individually)", nrow(selected_pitches)))
      },
      footer = tagList(
        modalButton("Cancel"),
        actionButton("confirm_pitch_edit", "Save Changes", class = "btn-primary")
      ),
      easyClose = FALSE
    ))
    
    session$userData$selected_for_edit <- selected_pitches
    invisible(TRUE)
  }

  open_clip_from_df_and_index <- function(df, idx_raw, label = NULL) {
    idx <- safe_selected(idx_raw)
    n <- nrow(df)
    if (!is.finite(idx) || is.na(idx) || n < 1L || idx < 1L || idx > n) return(invisible(FALSE))
    if (identical(input$pitch_click_action, "edit")) {
      return(open_pitch_edit_modal(df[idx, , drop = FALSE]))
    }
    row <- df[idx, , drop = FALSE]
    show_pitch_video_modal_multi(row, dataset = df, dataset_idx = idx)
    invisible(TRUE)
  }

  handle_table_video_click <- function(info, cache, table_label = NULL) {
    if (is.null(info)) return(invisible(FALSE))
    col_raw <- info$col %||% info$column
    row_raw <- info$row %||% info$rows
    if (is.null(col_raw) || is.null(row_raw)) return(invisible(FALSE))
    col_idx <- suppressWarnings(as.integer(col_raw))
    row_idx <- suppressWarnings(as.integer(row_raw))
    if (is.finite(col_idx)) col_idx <- col_idx + 1L  # DT supplies 0-based column index
    if (is.finite(row_idx) && row_idx < 1L) row_idx <- row_idx + 1L
    
    if (is.null(cache)) return(invisible(FALSE))
    if (inherits(cache, "data.frame")) {
      df_tbl <- cache
      meta <- list()
    } else if (is.list(cache)) {
      df_tbl <- cache$table %||% cache$data %||% cache
      meta <- cache
    } else {
      return(invisible(FALSE))
    }
    
    if (is.null(df_tbl) || !nrow(df_tbl)) return(invisible(FALSE))
    if (!is.finite(col_idx) || col_idx < 1 || col_idx > ncol(df_tbl)) return(invisible(FALSE))
    if (!is.finite(row_idx) || row_idx < 1 || row_idx > nrow(df_tbl)) return(invisible(FALSE))
    
    col_name <- names(df_tbl)[col_idx]
    if (!identical(col_name, "#")) return(invisible(FALSE))
    
    label_col <- meta$label_column %||% {
      if ("Pitch" %in% names(df_tbl)) "Pitch"
      else if ("Player" %in% names(df_tbl)) "Player"
      else names(df_tbl)[1]
    }
    if (!label_col %in% names(df_tbl)) label_col <- names(df_tbl)[1]
    pitch_label <- tryCatch(as.character(df_tbl[row_idx, label_col])[1], error = function(e) "")
    pitch_label <- trimws(pitch_label)
    
    rows <- NULL
    if (!is.null(meta$source)) {
      rows <- pitch_rows_for_label(meta$source, pitch_label, meta$split_choice %||% NULL)
    }
    if ((is.null(rows) || !nrow(rows)) && !is.null(meta$fallback_source)) {
      rows <- pitch_rows_for_label(meta$fallback_source, pitch_label, meta$split_choice %||% NULL)
    }
    if (is.null(rows) || !nrow(rows)) {
      df_all <- filtered_data()
      if (!is.null(df_all) && nrow(df_all)) {
        rows <- pitch_rows_for_label(df_all, pitch_label, meta$split_choice %||% NULL)
      }
    }
    
    if (is.null(rows) || !nrow(rows)) {
      showModal(modalDialog("No pitches found for this table row.", easyClose = TRUE, footer = NULL))
      return(invisible(FALSE))
    }
    
    rows <- as.data.frame(rows, stringsAsFactors = FALSE)
    if (is.null(rownames(rows))) {
      rownames(rows) <- as.character(seq_len(nrow(rows)))
    }
    
    if (identical(input$pitch_click_action, "edit")) {
      open_pitch_edit_modal(rows)
      return(invisible(TRUE))
    }
    
    start_idx <- 1L
    show_pitch_video_sequence(
      rows,
      label = if (nzchar(pitch_label)) pitch_label else table_label,
      start_index = start_idx,
      compare_pool = rows,
      primary_pool_idx = start_idx
    )
    invisible(TRUE)
  }
  
  # Target Shapes Data Storage - load or create CSV
  target_shapes_file <- "target_shapes.csv"
  target_shapes <- reactiveVal()
  target_shapes_version <- reactiveVal(0)  # Trigger for re-rendering
  target_shapes_global <- target_shapes  # alias for module-wide access
  
  # Reactive storage for modal rows (pitch types the user wants to configure)
  target_shape_rows <- reactiveVal(
    tibble::tibble(
      PitchType = character(),
      IVB = numeric(),
      HB = numeric(),
      RowID = character(),
      IsCustom = logical()
    )
  )
  target_shape_pitch_types <- reactiveVal(character())

  # Load existing target shapes or create empty dataframe
  loaded_shapes <- load_target_shapes_db()
  if (is.null(loaded_shapes)) {
    if (file.exists(target_shapes_file)) {
      loaded_shapes <- tryCatch({
        read.csv(target_shapes_file, stringsAsFactors = FALSE)
      }, error = function(e) {
        data.frame(Pitcher = character(), PitchType = character(), 
                   IVB_Target = numeric(), HB_Target = numeric(), 
                   IsCustom = logical(), stringsAsFactors = FALSE)
      })
    } else {
      loaded_shapes <- data.frame(Pitcher = character(), PitchType = character(), 
                                  IVB_Target = numeric(), HB_Target = numeric(), 
                                  IsCustom = logical(), stringsAsFactors = FALSE)
    }
  }
  target_shapes(loaded_shapes)
  
  # Helper to compute target from top Stuff+ without persisting
  calc_default_target_shape <- function(pitcher_name, pitch_type, date_range = NULL) {
    if (is.null(pitcher_name) || pitcher_name == "All" || is.null(pitch_type)) return(NULL)
    data <- pitch_data_pitching
    if (!"Stuff+" %in% names(data)) return(NULL)
    pitch_data_filtered <- data %>%
      dplyr::filter(Pitcher == pitcher_name, TaggedPitchType == pitch_type)
    if (!is.null(date_range) && length(date_range) == 2) {
      pitch_data_filtered <- pitch_data_filtered %>%
        dplyr::filter(Date >= date_range[1], Date <= date_range[2])
    }
    pitch_data_filtered <- pitch_data_filtered %>%
      dplyr::filter(!is.na(`Stuff+`), !is.na(InducedVertBreak), !is.na(HorzBreak))
    if (nrow(pitch_data_filtered) == 0) return(NULL)
    n_pitches <- min(10, nrow(pitch_data_filtered))
    top_pitches <- pitch_data_filtered %>%
      dplyr::arrange(desc(`Stuff+`)) %>%
      dplyr::slice(1:n_pitches)
    list(
      IVB = mean(top_pitches$InducedVertBreak, na.rm = TRUE),
      HB = mean(top_pitches$HorzBreak, na.rm = TRUE),
      count = n_pitches
    )
  }

  # Helper for safe numeric row IDs
  make_target_row_id <- function(pitch_type, existing = character()) {
    base <- gsub("[^A-Za-z0-9]", "_", pitch_type)
    base <- gsub("_+", "_", base)
    base <- gsub("^_+|_+$", "", base)
    if (!nzchar(base)) base <- "pitch"
    candidate <- base
    counter <- 1L
    while (candidate %in% existing) {
      counter <- counter + 1L
      candidate <- paste0(base, "_", counter)
    }
    candidate
  }
  
  # Function to save target shapes to CSV
  save_target_shapes <- function() {
    tryCatch({
      save_target_shapes_db(target_shapes())
      # simple CSV backup
      write.csv(target_shapes(), target_shapes_file, row.names = FALSE)
    }, error = function(e) {
      message("Error saving target shapes: ", e$message)
    })
  }
  
  # Function to get target shape for a pitcher/pitch type
  # Returns list with IVB_Target and HB_Target
  get_target_shape <- function(pitcher_name, pitch_type, date_range = NULL, auto_save = TRUE) {
    if (is.null(pitcher_name) || pitcher_name == "All" || is.null(pitch_type)) {
      return(NULL)
    }
    
    shapes_df <- target_shapes()
    
    # Check if custom target exists
    existing <- shapes_df[shapes_df$Pitcher == pitcher_name & 
                            shapes_df$PitchType == pitch_type, ]
    
    if (nrow(existing) > 0) {
      return(list(IVB = existing$IVB_Target[1], 
                  HB = existing$HB_Target[1],
                  IsCustom = existing$IsCustom[1]))
    }
    
    defaults <- calc_default_target_shape(pitcher_name, pitch_type, date_range)
    if (is.null(defaults)) return(NULL)
    
    message(sprintf("Auto-calculated target for %s %s: IVB=%.2f, HB=%.2f (from %d pitches)", 
                    pitcher_name, pitch_type, defaults$IVB, defaults$HB, defaults$count))
    
    if (isTRUE(auto_save)) {
      new_row <- data.frame(
        Pitcher = pitcher_name,
        PitchType = pitch_type,
        IVB_Target = defaults$IVB,
        HB_Target = defaults$HB,
        IsCustom = FALSE,
        stringsAsFactors = FALSE
      )
      shapes_df <- rbind(shapes_df, new_row)
      target_shapes(shapes_df)
      save_target_shapes()
      target_shapes_version(target_shapes_version() + 1L)
    }
    
    list(IVB = defaults$IVB, HB = defaults$HB, IsCustom = FALSE)
  }
  
  # Function to set custom target shape
  set_target_shape <- function(pitcher_name, pitch_type, ivb, hb) {
    shapes_df <- target_shapes()
    
    # Remove existing entry if present
    shapes_df <- shapes_df[!(shapes_df$Pitcher == pitcher_name & 
                               shapes_df$PitchType == pitch_type), ]
    
    # Add new entry
    new_row <- data.frame(
      Pitcher = pitcher_name,
      PitchType = pitch_type,
      IVB_Target = ivb,
      HB_Target = hb,
      IsCustom = TRUE,
      stringsAsFactors = FALSE
    )
    
    shapes_df <- rbind(shapes_df, new_row)
    target_shapes(shapes_df)
    save_target_shapes()
    target_shapes_version(target_shapes_version() + 1L)
  }
  
  # Function to reset target shape to default (remove custom)
  reset_target_shape <- function(pitcher_name, pitch_type, date_range = NULL) {
    shapes_df <- target_shapes()
    
    # Remove existing entry
    shapes_df <- shapes_df[!(shapes_df$Pitcher == pitcher_name & 
                               shapes_df$PitchType == pitch_type), ]
    target_shapes(shapes_df)
    save_target_shapes()
    target_shapes_version(target_shapes_version() + 1L)
    
    calc_default_target_shape(pitcher_name, pitch_type, date_range)
  }
  
  # Global persistent date range - initializes to most recent date on startup
  global_date_range <- reactiveVal()
  
  # Initialize global date range on startup
  observe({
    if (is.null(global_date_range())) {
      if (exists("pitch_data") && nrow(pitch_data) > 0) {
        max_date <- max(pitch_data$Date, na.rm = TRUE)
        global_date_range(c(max_date, max_date))
      } else {
        global_date_range(c(Sys.Date(), Sys.Date()))
      }
    }
  })
  
  # Update global date range when main input changes
  observeEvent(input$dates, {
    if (!is.null(input$dates) && length(input$dates) == 2) {
      # Only update if the dates are actually different to prevent loops
      current_global <- global_date_range()
      if (is.null(current_global) || 
          !identical(as.Date(input$dates), as.Date(current_global))) {
        global_date_range(input$dates)
      }
    }
  })
  
  # Sync date range input with global value - only when global changes
  observe({
    global_dates <- global_date_range()
    if (!is.null(global_dates) && !is.null(input$dates)) {
      # Only update UI if the values are actually different to prevent loops
      if (!identical(as.Date(input$dates), as.Date(global_dates))) {
        updateDateRangeInput(session, "dates", 
                             start = global_dates[1], 
                             end = global_dates[2])
      }
    }
  })
  
  # Reactive value to store modified pitch data with edits persisted
  modified_pitch_data <- reactiveVal()
  
  # Reactive value to track modification statistics
  modification_stats <- reactiveVal(list(applied_count = 0, total_modifications = 0))
  
  # Function to load modifications with feedback
  load_modifications <- function(force_reload = FALSE, verbose = TRUE) {
    if (force_reload || check_data_freshness()) {
      if (verbose) {
        showNotification("Checking for stored pitch type modifications...", 
                         type = "message", duration = 2)
      }
      
      result <- load_pitch_modifications_db(pitch_data_pitching, verbose = verbose)
      modified_pitch_data(result$data)
      modification_stats(list(
        applied_count = result$applied_count,
        total_modifications = result$total_modifications
      ))
      
      if (verbose && result$applied_count > 0) {
        showNotification(
          sprintf("Applied %d of %d stored pitch type modifications", 
                  result$applied_count, result$total_modifications),
          type = "message", duration = 5
        )
      } else if (verbose && result$total_modifications > 0) {
        showNotification(
          sprintf("Warning: %d stored modifications could not be applied (pitches not found)", 
                  result$total_modifications - result$applied_count),
          type = "warning", duration = 5
        )
      }
    } else {
      # No new data, just load normally if not already loaded
      current_data <- tryCatch(modified_pitch_data(), error = function(e) NULL)
      if (is.null(current_data)) {
        result <- load_pitch_modifications_db(pitch_data_pitching, verbose = FALSE)
        modified_pitch_data(result$data)
        modification_stats(list(
          applied_count = result$applied_count,
          total_modifications = result$total_modifications
        ))
      }
    }
  }
  
  # Load modifications on startup
  load_modifications(force_reload = FALSE, verbose = TRUE)
  
  # Add a reactive timer to check for data updates every 30 seconds
  autoCheck <- reactiveTimer(30000)  # 30 seconds
  
  observe({
    autoCheck()
    load_modifications(force_reload = FALSE, verbose = FALSE)
  })
  
  # Manual refresh button observer
  observeEvent(input$refreshModifications, {
    showNotification("Manually refreshing pitch type modifications...", 
                     type = "message", duration = 2)
    load_modifications(force_reload = TRUE, verbose = TRUE)
  })
  
  output$downloadPitchMods <- downloadHandler(
    filename = function() paste0("pitch_type_modifications_", format(Sys.Date(), "%Y%m%d"), ".csv"),
    content = function(file) {
      db_path <- init_modifications_db()
      con <- tryCatch(dbConnect(SQLite(), db_path), error = function(e) e)
      if (inherits(con, "error")) {
        export_path <- get_modifications_export_path()
        if (file.exists(export_path)) {
          file.copy(export_path, file, overwrite = TRUE)
        } else {
          readr::write_csv(data.frame(message = "No pitch edits saved yet"), file)
        }
        return()
      }
      on.exit(dbDisconnect(con), add = TRUE)
      mods <- try(dbGetQuery(con, "SELECT * FROM modifications ORDER BY created_at"), silent = TRUE)
      if (inherits(mods, "try-error") || !nrow(mods)) {
        readr::write_csv(data.frame(message = "No pitch edits saved yet"), file)
      } else {
        readr::write_csv(mods, file)
      }
    }
  )
  
  # Status text output
  output$modificationStatusText <- renderText({
    stats <- modification_stats()
    if (stats$total_modifications > 0) {
      sprintf("%d edits stored, %d applied", 
              stats$total_modifications, stats$applied_count)
    } else {
      "No stored edits"
    }
  })
  
  session_label_from <- function(df) {
    s <- unique(na.omit(as.character(df$SessionType)))
    if (length(s) == 1) s else "All"
  }
  
  observeEvent(input$open_media, {
    info <- input$open_media
    url  <- info$url %||% ""
    typ  <- tolower(info$type %||% "auto")
    if (!nzchar(url)) return()
    
    is_img <- grepl("image", typ) || grepl("\\.(png|jpe?g|gif|webp)$", url, ignore.case = TRUE)
    is_pdf <- grepl("pdf", typ)   || grepl("\\.pdf(\\?.*)?$", url, ignore.case = TRUE)
    
    ui <- if (is_img) {
      tags$div(
        style = "text-align:center;",
        tags$img(src = url, style = "max-width:100%; height:auto;")
      )
    } else if (is_pdf) {
      # Prefer native inline render; works with Cloudinary “raw” PDFs
      tags$div(
        style = "width:100%;",
        # Primary: <object> (best cross-browser)
        tags$object(
          data  = url,
          type  = "application/pdf",
          style = "width:100%; height:70vh; border:0;",
          # Fallback inside <object>: <embed> (Safari sometimes prefers it)
          tags$embed(
            src   = url,
            type  = "application/pdf",
            style = "width:100%; height:70vh; border:0;"
          )
        ),
        # Always offer a direct link as a graceful fallback
        tags$div(
          style = "margin-top:8px;",
          tags$a(href = url, target = "_blank", rel = "noopener noreferrer",
                 "Open original PDF in a new tab")
        )
      )
    } else {
      tags$video(
        src = url, controls = NA, autoplay = NA,
        style = "width:100%; max-height:70vh; background:#000;"
      )
    }
    
    showModal(modalDialog(ui, easyClose = TRUE, footer = NULL, size = "l"))
  })
  
  # Safety: ensure noteJumping exists before any observer uses it
  noteJumping <- get0("noteJumping", mode = "function", inherits = TRUE)
  if (is.null(noteJumping)) noteJumping <- shiny::reactiveVal(FALSE)
  
  # forces the Notes DT to re-render when bumped
  notes_version <- reactiveVal(0L)
  
  # whenever user switches to the Notes tab, refresh the table
  observeEvent(input$top, {
    if (identical(input$top, "Notes")) {
      notes_version(isolate(notes_version()) + 1L)
    }
  }, ignoreInit = TRUE)
  
  # user_email and is_admin are now defined at the start of server function
  # (removed duplicate definitions here)
  
  tooltip_css <- "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
  
  # --- Helpers to read the current suite & page (subtab) ---
  current_suite <- reactive({ input$top %or% "Pitching" })   # navbarPage id   (exists)  # :contentReference[oaicite:5]{index=5}
  
  current_page <- reactive({
    s <- current_suite()
    if (identical(s, "Pitching")) {
      input$tabs %or% "Summary"                                   # pitching tabset id  # :contentReference[oaicite:6]{index=6}
    } else if (identical(s, "Hitting")) {
      input[["hit-tabs"]] %or% "Data and Performance"             # module ns → hit-tabs
    } else if (identical(s, "Catching")) {
      input[["catch-tabs"]] %or% "Data and Performance"           # module ns → catch-tabs  # :contentReference[oaicite:7]{index=7}
    } else if (identical(s, "Leaderboard")) {
      input[["leader-tabs"]] %or% "Pitching"
    } else if (identical(s, "Comparison Suite") || identical(s, "Comparison Tool")) {
      input[["comp-tabs"]] %or% "Compare"
    } else {
      ""
    }
  })
  
  # --- your existing user_email() works for Author (email) ---
  # we’ll just reuse it.  # :contentReference[oaicite:8]{index=8}
  
  # --- Open modal to create a new note ---
  observeEvent(input$openNote, {
    # pull current filters
    ds <- input$dates[1]; de <- input$dates[2]
    pit <- input$pitcher %or% "All"
    st  <- input$sessionType %or% "All"
    sui <- current_suite()
    pag <- current_page()
    
    # a preview line for the modal
    preview <- paste0(
      fmt_mdy(ds), " – ", fmt_mdy(de),
      " • ", pit,
      " • ", sui, if (nzchar(pag)) paste0(" / ", pag) else ""
    )
    
    showModal(modalDialog(
      title = "Add Note",
      tagList(
        div(style="margin-bottom:6px; font-size:12px; opacity:.7;",
            "Context to be saved: ", preview),
        
        textAreaInput("note_text", NULL, width = "100%", height = "150px",
                      placeholder = "Type your note here…"),
        
        fileInput(
          "note_media", "Attach photo/video/PDF (optional):",
          accept = c("image/*", "video/*", "application/pdf", ".pdf"),
          buttonLabel = "Choose file…", placeholder = "No file selected"
        )
      ),
      footer = tagList(
        modalButton("Cancel"),
        actionButton("save_note", "Save", class = "btn btn-primary",
                     onclick = "this.disabled = true; this.innerText = 'Saving…';")
      ),
      easyClose = TRUE
    ))
  }, ignoreInit = TRUE)
  
  
  
  # --- Build Notes table ---
  notes_reload <- function() {
    rows <- tryCatch(notes_api_list(), error = function(e) {
      showNotification(paste("Could not load notes:", e$message), type="error"); list()
    })
    if (!length(rows)) {
      return(DT::datatable(data.frame(Message="No notes yet"), options=list(dom='t'), rownames=FALSE))
    }
    
    df <- as.data.frame(rows, stringsAsFactors = FALSE, check.names = FALSE)
    
    # Sort newest first by created_at_utc (robust)
    ct  <- parse_utc_datetime(df$created_at_utc)
    ord <- order(ct, decreasing = TRUE)
    df  <- df[ord, , drop = FALSE]
    ct  <- ct[ord]
    
    # Split Suite::Subpage
    page2 <- ifelse(is.na(df$page), "", df$page)
    sp    <- strsplit(page2, "::", fixed = TRUE)
    suite <- vapply(sp, function(x) if (length(x)) x[[1]] else "", character(1))
    subpg <- vapply(sp, function(x) if (length(x) >= 2) x[[2]] else "", character(1))
    
    ds   <- fmt_mdy(as.Date(df$date_start))
    de   <- fmt_mdy(as.Date(df$date_end))
    pit  <- ifelse(is.na(df$pitcher) | df$pitcher == "", "All", df$pitcher)
    sess <- ifelse(is.na(df$session_type) | df$session_type == "", "All", df$session_type)
    
    lbl <- paste0(ds, " – ", de, " • ", pit, " • ", suite, ifelse(nzchar(subpg), paste0(" / ", subpg), ""))
    
    suite_attr <- htmltools::htmlEscape(suite)
    page_attr  <- htmltools::htmlEscape(subpg)
    pit_attr   <- htmltools::htmlEscape(pit)
    sess_attr  <- htmltools::htmlEscape(sess)
    ds_attr    <- htmltools::htmlEscape(as.character(as.Date(df$date_start)))
    de_attr    <- htmltools::htmlEscape(as.character(as.Date(df$date_end)))
    txt_attr   <- htmltools::htmlEscape(lbl)
    
    filter_html <- sprintf(
      '<a href="#" class="note-jump" data-suite="%s" data-page="%s" data-pitcher="%s" data-sess="%s" data-ds="%s" data-de="%s">%s</a>',
      suite_attr, page_attr, pit_attr, sess_attr, ds_attr, de_attr, txt_attr
    )
    
    # --- Attachment extraction (unescape first) ---
    note_raw <- html_unescape(df$note_text %||% "")
    
    # First try to grab the exact anchor we generated on save
    anchor_pat <- '<a[^>]*class=(["\\\'])open-media\\1[^>]*>.*?</a>'
    m <- regexpr(anchor_pat, note_raw, perl = TRUE, ignore.case = TRUE)
    att_html <- ifelse(
      m > 0,
      substring(note_raw, m, m + attr(m, "match.length") - 1),
      ""
    )
    
    # Fallback: if no <a class="open-media">…</a>, build one from any media-looking URL in the text
    url_matches <- gregexpr("https?://[^\\s\"'>]+", note_raw, perl = TRUE)
    urls_list   <- regmatches(note_raw, url_matches)
    for (i in seq_along(att_html)) {
      if (nzchar(att_html[i])) next
      u <- urls_list[[i]]
      if (!length(u)) next
      # Prefer obvious media URLs; otherwise take the first URL
      # Prefer obvious media URLs; include pdf as well
      cand <- u[grep("\\.(png|jpe?g|gif|webp|mp4|mov|webm|mkv|pdf)(\\?.*)?$", u, ignore.case = TRUE)]
      if (!length(cand)) cand <- u[1]
      
      # Set link type so the viewer knows how to render
      typ <- if (grepl("\\.(png|jpe?g|gif|webp)$", cand[1], ignore.case = TRUE)) {
        "image"
      } else if (grepl("\\.pdf(\\?.*)?$", cand[1], ignore.case = TRUE)) {
        "pdf"
      } else {
        "video"
      }
      
      url_safe <- htmltools::htmlEscape(cand[1])
      att_html[i] <- sprintf('<a href="%1$s" class="open-media" data-url="%1$s" data-type="%2$s">Open attachment</a>', url_safe, typ)
    }
    
    # Plain-note display (strip the attachment anchor and any other tags)
    note_plain <- note_raw
    note_plain <- gsub(anchor_pat, "", note_plain, perl = TRUE, ignore.case = TRUE)
    note_plain <- gsub("<[^>]+>", "", note_plain, perl = TRUE)
    note_plain <- trimws(note_plain)
    
    show <- data.frame(
      Author     = df$author_email,
      Date       = fmt_mdy(as.Date(ct)),
      Filter     = filter_html,   # clickable jump
      Note       = note_plain,    # safe, plain text
      Attachment = att_html,      # clickable "Open attachment"
      stringsAsFactors = FALSE
    )
    
    DT::datatable(
      show,
      # Escape Author, Date, Note; leave Filter & Attachment unescaped so links work
      escape   = c(1, 2, 4),
      rownames = FALSE,
      options  = list(pageLength = 25, order = list(list(1, "desc")))
    )
  }
  
  
  
  output$notesTable <- DT::renderDataTable({
    notes_version()                 # keep the refresh trigger
    
    out <- notes_reload()
    
    # If notes_reload() already returns a datatable/htmlwidget, just return it
    if (inherits(out, "htmlwidget") || inherits(out, "datatables")) {
      return(out)
    }
    
    # Otherwise, treat it as a data.frame and build the table here
    out <- as.data.frame(out, stringsAsFactors = FALSE, check.names = FALSE)
    
    DT::datatable(
      out,
      escape   = FALSE,             # needed so the "Open attachment" link renders
      rownames = FALSE,
      options  = list(dom = 'Bfrtip', pageLength = 10)
    )
  })
  
  # Optional: render even when hidden so it refreshes when you click into Notes
  outputOptions(output, "notesTable", suspendWhenHidden = FALSE)
  
  
  
  # --- When a note’s Filter is clicked, jump to that view ---
  # Requires: later
  observeEvent(input$noteJump, {
    x <- input$noteJump
    noteJumping(TRUE)  # pause auto-date logic
    
    updateTabsetPanel(session, "top", selected = x$suite)
    
    later::later(function() {
      if (nzchar(x$sess))    updateSelectInput(session, "sessionType", selected = x$sess)
      if (nzchar(x$pitcher)) updateSelectInput(session, "pitcher",      selected = x$pitcher)
      if (nzchar(x$ds) && nzchar(x$de))
        updateDateRangeInput(session, "dates", start = as.Date(x$ds), end = as.Date(x$de))
      # sub-tabs by suite
      if (identical(x$suite, "Pitching")) {
        if (nzchar(x$page)) updateTabsetPanel(session, "tabs", selected = x$page)
      } else if (identical(x$suite, "Hitting")) {
        if (nzchar(x$page)) updateTabsetPanel(session, "hit-tabs", selected = x$page)
      } else if (identical(x$suite, "Catching")) {
        if (nzchar(x$page)) updateTabsetPanel(session, "catch-tabs", selected = x$page)
      } else if (identical(x$suite, "Leaderboard")) {
        if (nzchar(x$page)) updateTabsetPanel(session, "leader-tabs", selected = x$page)
      } else if (identical(x$suite, "Comparison Suite") || identical(x$suite, "Comparison Tool")) {
        if (nzchar(x$page)) updateTabsetPanel(session, "comp-tabs", selected = x$page)
      }
      later::later(function() noteJumping(FALSE), delay = 0.6)
    }, delay = 0.3)
  }, ignoreInit = TRUE)
  
  # Set date once on startup
  observeEvent(TRUE, {
    req(input$sessionType, input$pitcher)
    df_base <- if (input$sessionType == "All") pitch_data_pitching else
      dplyr::filter(pitch_data_pitching, SessionType == input$sessionType)
    
    last_date <- if (input$pitcher == "All") {
      max(df_base$Date, na.rm = TRUE)
    } else {
      mx <- max(df_base$Date[df_base$Pitcher == input$pitcher], na.rm = TRUE)
      if (is.finite(mx)) mx else max(df_base$Date, na.rm = TRUE)
    }
    if (is.finite(last_date)) {
      updateDateRangeInput(session, "dates", start = last_date, end = last_date)
    }
  }, once = TRUE)
  
  # Update date only when the *user* changes pitcher (and not during a note jump)
  # Now respects global date range persistence instead of resetting to last date
  observeEvent(input$pitcher, {
    if (isTRUE(noteJumping())) return()
    req(input$pitcher)
    
    # If we have a global date range set, use it instead of resetting to last date
    if (!is.null(global_date_range())) {
      # Only update if the dates are actually different to prevent loops
      current_input <- input$dates
      global_dates <- global_date_range()
      if (is.null(current_input) || 
          !identical(as.Date(current_input), as.Date(global_dates))) {
        updateDateRangeInput(session, "dates", 
                             start = global_dates[1], 
                             end = global_dates[2])
      }
    } else {
      # Only fall back to last date if no global date range is set
      last_date <- if (input$pitcher == "All") {
        max(pitch_data_pitching$Date, na.rm = TRUE)
      } else {
        max(pitch_data_pitching$Date[pitch_data_pitching$Pitcher == input$pitcher], na.rm = TRUE)
      }
      if (is.finite(last_date)) {
        updateDateRangeInput(session, "dates", start = last_date, end = last_date)
        # Update global date range with this new value
        global_date_range(c(last_date, last_date))
      }
    }
  }, ignoreInit = TRUE)
  
  
  # define once near top of server() if not already
  note_saving <- reactiveVal(FALSE)
  
  # single, guarded save handler
  observeEvent(input$save_note, {
    if (isTRUE(note_saving())) return(invisible(NULL))  # prevents double fires
    note_saving(TRUE); on.exit(note_saving(FALSE), add = TRUE)
    
    removeModal()
    
    # --- base note text ---
    # if you don't have %or%, use your existing %||%
    note <- input$note_text %or% ""
    if (!nzchar(note)) {
      showNotification("Note is empty—nothing saved.", type = "warning")
      return()
    }
    
    # ---- optional media upload ---- (PATCHED)
    media_html <- ""
    if (!is.null(input$note_media) && nzchar(input$note_media$datapath)) {
      if (!nzchar(CLOUDINARY_CLOUD_NAME) || !nzchar(CLOUDINARY_UPLOAD_PRESET)) {
        showNotification("Attachment not saved: Cloudinary is not configured.", type = "error")
      } else {
        up <- tryCatch(
          upload_media_cloudinary(input$note_media$datapath),
          error = function(e) {
            showNotification(paste("Attachment upload failed:", e$message), type = "error")
            NULL
          }
        )
        if (!is.null(up) && !is.null(up$url) && nzchar(up$url)) {
          if (grepl("\\.pdf(\\?.*)?$", up$url, ignore.case = TRUE) ||
              grepl("pdf", (up$type %||% ""), ignore.case = TRUE) ||
              (grepl("raw", (up$type %||% ""), ignore.case = TRUE) && grepl("\\.pdf(\\?.*)?$", up$url, ignore.case = TRUE))) {
            mtype <- "pdf"
          } else if (grepl("image", up$type, ignore.case = TRUE) ||
                     grepl("\\.(png|jpe?g|gif|webp)$", up$url, ignore.case = TRUE)) {
            mtype <- "image"
          } else {
            mtype <- "video"
          }
          media_html <- sprintf(
            '<br><a href="%s" class="open-media" data-url="%s" data-type="%s">Open attachment</a>',
            htmltools::htmlEscape(up$url), htmltools::htmlEscape(up$url), mtype
          )
        }
      }
    }
    
    # append the attachment link (if any) to the note text
    if (nzchar(media_html)) note <- paste0(note, media_html)
    
    # --- context for the note ---
    ds <- input$dates[1]; de <- input$dates[2]
    pit <- input$pitcher     %or% "All"
    st  <- input$sessionType %or% "All"
    sui <- current_suite();  pag <- current_page()
    page_combo <- paste0(sui, "::", pag %or% "")
    
    # --- save via API ---
    ok <- tryCatch({
      notes_api_add(
        author_email = user_email(),
        team         = "osu",
        page_combo   = page_combo,
        pitcher      = pit,
        session_type = st,
        date_start   = ds,
        date_end     = de,
        note_text    = note          # <-- use the augmented text here
      )
      TRUE
    }, error = function(e) {
      showNotification(paste("Notes: save failed (", e$message, ")"), type = "error")
      FALSE
    })
    
    if (isTRUE(ok)) {
      # bump trigger so the Notes table refreshes
      notes_version(isolate(notes_version()) + 1L)
      if (identical(input$top, "Notes")) {
        notes_version(isolate(notes_version()) + 1L)
      }
      showNotification("Note saved.", type = "message")
    }
  }, ignoreInit = TRUE)
  
  
  observeEvent(input$countFilter, {
    sel <- input$countFilter
    if (is.null(sel) || !length(sel)) {
      updateSelectInput(session, "countFilter", selected = "All")
    } else if ("All" %in% sel && length(sel) > 1) {
      updateSelectInput(session, "countFilter", selected = setdiff(sel, "All"))
    }
  }, ignoreInit = TRUE)
  
  # Deep-link support: /?tab=Hitting
  observeEvent(TRUE, {
    qs <- shiny::parseQueryString(session$clientData$url_search)  # Shiny exposes this in session$clientData
    if (!is.null(qs$tab)) updateNavbarPage(session, "top", selected = qs$tab)
  }, once = TRUE)  # session$clientData reference: docs.posit.co/shiny session reference
  # (Note: Shiny exposes url_* in session$clientData.) :contentReference[oaicite:2]{index=2}
  
  # Mount the new modules (lazy-run only when their tab is active)
  mod_hit_server("hit",     is_active = reactive(input$top == "Hitting"), global_date_range = global_date_range)
  mod_catch_server("catch", is_active = reactive(input$top == "Catching"), global_date_range = global_date_range)
  mod_leader_server("leader", is_active = reactive(input$top == "Leaderboard"), global_date_range = global_date_range)
  mod_comp_server("comp",   is_active = reactive(input$top == "Comparison Suite"), global_date_range = global_date_range)
  
  
  # Buttons above Summary table
  output$summaryTableButtons <- renderUI({
    # preserve current selection if it exists; default to "Stuff"
    ct_names <- names(custom_tables())
    sel <- isolate(input$summaryTableMode)
    if (is.null(sel)) sel <- "Stuff"
    split_sel <- isolate(input$summarySplitBy)
    if (is.null(split_sel)) split_sel <- "Pitch Types"
    
    tagList(
      div(style = "display: flex; align-items: center; gap: 15px;",
          div(style = "flex: 0 0 auto;",
              div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Tables:"),
              selectInput(
                "summaryTableMode", label = NULL,
                choices = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data", ct_names, "Batted Ball Data", "Custom"),
                selected = sel,
                width = "120px"
              )
          ),
          div(style = "flex: 0 0 auto;",
              checkboxInput(
                "summaryTableColors", 
                label = "Color-Code", 
                value = TRUE,
                width = "80px"
              )
          ),
          div(style = "flex: 0 0 auto;",
              div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Split By:"),
              selectInput(
                "summarySplitBy", label = NULL,
                choices = c("Pitch Types", "Batter Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Batter"),
                selected = split_sel,
                width = "140px"
              )
          )
      ),
      # show the picker purely on the client; avoids re-render loops
      conditionalPanel(
        "input.summaryTableMode=='Custom'",
        tagList(
          selectInput("summaryCustomSaved", "Saved Table:", choices = c("", names(custom_tables())), selected = ""),
          textInput("summaryCustomName", "Name:", value = ""),
          selectizeInput(
            "summaryCustomCols", label = "Columns (drag to order):",
            choices  = setdiff(all_table_cols, "Pitch"),
            multiple = TRUE,
            options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
          ),
          if (isTRUE(is_admin())) {
            checkboxInput("summaryCustomGlobal", "Share with all schools (admin)", value = FALSE)
          },
          actionButton("summarySaveCustom", "Save / Update", class = "btn-primary btn-sm"),
          actionButton("summaryDeleteCustom", "Delete", class = "btn-danger btn-sm")
        )
      )
    )
  })
  
  
  # Buttons above Data & Performance table
  output$dpTableButtons <- renderUI({
    # preserve current selection if it exists; default to "Stuff"
    ct_names <- names(custom_tables())
    sel <- isolate(input$dpTableMode)
    if (is.null(sel)) sel <- "Stuff"
    split_sel <- isolate(input$dpSplitBy)
    if (is.null(split_sel)) split_sel <- "Pitch Types"
    
    tagList(
      div(style = "display: flex; align-items: center; gap: 15px;",
          div(style = "flex: 0 0 auto;",
              div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Tables:"),
              selectInput(
                "dpTableMode", label = NULL,
                choices = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data", ct_names, "Batted Ball Data", "Custom"),
                selected = sel,
                width = "120px"
              )
          ),
          div(style = "flex: 0 0 auto;",
              checkboxInput(
                "dpTableColors", 
                label = "Color-Code", 
                value = TRUE,
                width = "80px"
              )
          ),
          div(style = "flex: 0 0 auto;",
              div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Split By:"),
              selectInput(
                "dpSplitBy", label = NULL,
                choices = c("Pitch Types", "Batter Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Batter"),
                selected = split_sel,
                width = "140px"
              )
          )
      ),
      # show the picker purely on the client; avoids re-render loops
      conditionalPanel(
        "input.dpTableMode=='Custom'",
        tagList(
          selectInput("dpCustomSaved", "Saved Table:", choices = c("", names(custom_tables())), selected = ""),
          textInput("dpCustomName", "Name:", value = ""),
          selectizeInput(
            "dpCustomCols", label = "Columns (drag to order):",
            choices  = setdiff(all_table_cols, "Pitch"),
            multiple = TRUE,
            options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
          ),
          if (isTRUE(is_admin())) {
            checkboxInput("dpCustomGlobal", "Share with all schools (admin)", value = FALSE)
          },
          actionButton("dpSaveCustom", "Save / Update", class = "btn-primary btn-sm"),
          actionButton("dpDeleteCustom", "Delete", class = "btn-danger btn-sm")
        )
      )
    )
  })
  
  
  
  output$leaderboardButtons <- renderUI({
    sel <- isolate(input$leaderboardMode)
    if (is.null(sel)) sel <- "Stuff"
    
    tagList(
      radioButtons(
        "leaderboardMode", label = NULL,
        choices  = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data","Custom"),
        selected = sel,
        inline   = TRUE
      ),
      conditionalPanel(
        "input.leaderboardMode=='Custom'",
        selectizeInput(
          "leaderboardCustomCols", label = NULL,
          choices  = setdiff(all_table_cols, "Pitch"),
          multiple = TRUE,
          options  = list(placeholder = "Choose columns to show…")
        )
      )
    )
  })
  
  # 1) Pitcher selector
  output$pitcher_ui <- renderUI({
    req(input$sessionType, input$teamType)
    
    df_base <- if (input$sessionType == "All") pitch_data_pitching else
      dplyr::filter(pitch_data_pitching, SessionType == input$sessionType)
    
    # Apply team filtering to get the available pitchers
    if (input$teamType == "Campers") {
      df_base <- dplyr::filter(df_base, Pitcher %in% ALLOWED_CAMPERS)
    } else if (input$teamType == TEAM_CODE) {
      # Filter to only GCU allowed pitchers (exclude campers)
      df_base <- dplyr::filter(df_base, Pitcher %in% ALLOWED_PITCHERS)
    }
    # If "All" is selected, df_base already contains all pitchers
    
    # Create name map for the filtered dataset
    raw_names_team <- sort(unique(df_base$Pitcher))
    display_names_team <- ifelse(
      grepl(",", raw_names_team),
      vapply(strsplit(raw_names_team, ",\\s*"), function(x) paste(x[2], x[1]), ""),
      raw_names_team
    )
    name_map_team <- setNames(raw_names_team, display_names_team)
    
    # Determine which pitchers the user can see:
    # - Admins: all pitchers
    # - Coaches: all pitchers  
    # - Players: only pitchers where Email matches their login email
    if (is_admin() || is_coach()) {
      # Coaches and admins see all pitchers in filtered dataset
      sel_raw <- unique(df_base$Pitcher) %>% na.omit()
    } else {
      # Players see only their own data (matched by email)
      sel_raw <- unique(df_base$Pitcher[norm_email(df_base$Email) == norm_email(user_email())]) %>% na.omit()
    }
    
    # Admins AND coaches get the "All" option
    if (is_admin() || is_coach()) {
      # Check if current selection is still valid, otherwise default to "All"
      current_selection <- isolate(input$pitcher)
      if (is.null(current_selection) || !(current_selection %in% c("All", raw_names_team))) {
        current_selection <- "All"
      }
      
      selectInput(
        "pitcher", "Select Pitcher:",
        choices  = c("All" = "All", name_map_team),
        selected = current_selection
      )
    } else if (length(sel_raw) > 0) {
      # Players see only their pitchers (filtered by email)
      # Use the team-specific name map, but only show their pitchers
      player_display_names <- display_names_team[raw_names_team %in% sel_raw]
      player_map <- setNames(sel_raw, player_display_names)
      
      selectInput("pitcher", "Select Pitcher:", 
                  choices = player_map, 
                  selected = sel_raw[1])
    } else {
      selectInput("pitcher", "Select Pitcher:", 
                  choices = "No data", 
                  selected = "No data")
    }
  })
  
  
  observeEvent(list(input$sessionType, input$teamType), {
    req(input$sessionType, input$teamType)
    
    df_base <- if (input$sessionType == "All") pitch_data_pitching else
      dplyr::filter(pitch_data_pitching, SessionType == input$sessionType)
    
    # Apply team filtering
    if (input$teamType == "Campers") {
      df_base <- dplyr::filter(df_base, Pitcher %in% ALLOWED_CAMPERS)
    } else if (input$teamType == TEAM_CODE) {
      df_base <- dplyr::filter(df_base, Pitcher %in% ALLOWED_PITCHERS)
    }
    # If "All" is selected, don't filter - show all data
    
    last_date <- if (is.null(input$pitcher) || input$pitcher == "All") {
      max(df_base$Date, na.rm = TRUE)
    } else {
      ld <- max(df_base$Date[df_base$Pitcher == input$pitcher], na.rm = TRUE)
      if (is.finite(ld)) ld else max(df_base$Date, na.rm = TRUE)
    }
    updateDateRangeInput(session, "dates", start = last_date, end = last_date)
  }, ignoreInit = TRUE)
  
  # 2) Filtered data
  filtered_data <- reactive({
    req(input$sessionType, input$hand, input$zoneLoc, input$inZone, input$qpLocations, input$teamType)
    
    is_valid_dates <- function(d) !is.null(d) && length(d) == 2 && all(is.finite(d))
    nnz <- function(x) !is.null(x) && !is.na(x)
    
    if (!is_valid_dates(input$dates)) return(modified_pitch_data()[0, , drop = FALSE])
    
    pitch_types <- if (is.null(input$pitchType) || !length(input$pitchType)) "All" else input$pitchType
    
    # Session type - use modified data instead of original
    df <- if (identical(input$sessionType, "All")) modified_pitch_data()
    else dplyr::filter(modified_pitch_data(), SessionType == input$sessionType)
    
    # ⛔️ Team filtering - Filter by team selection ⛔️
    if (!is.null(input$teamType)) {
      if (input$teamType == "Campers") {
        # Filter to only allowed campers
        df <- dplyr::filter(df, Pitcher %in% ALLOWED_CAMPERS)
      }
      # If "GCU" is selected, use the existing data (already filtered to ALLOWED_PITCHERS)
    }
    
    # ⛔️ Drop warmups & blank pitch types
    if ("TaggedPitchType" %in% names(df)) {
      df <- df %>%
        dplyr::mutate(.tpt = trimws(as.character(TaggedPitchType))) %>%
        dplyr::filter(!is.na(.tpt) & nzchar(.tpt)) %>%
        dplyr::select(-.tpt)
    }
    if ("PitchSession" %in% names(df)) {
      df <- dplyr::filter(df, is.na(PitchSession) | PitchSession != "Warmup")
    }
    
    # Live-only BatterSide
    if (!is.null(input$batterSide) && input$batterSide != "All") {
      df <- df %>% dplyr::filter(SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide))
    }
    
    # Dates
    df <- dplyr::filter(df, Date >= input$dates[1], Date <= input$dates[2])
    
    # Pitcher & hand
    pick <- input$pitcher
    if (!is.null(pick) && pick != "All" && pick != "No data") {
      # Filter by exact pitcher name match
      df <- dplyr::filter(df, Pitcher == pick)
      # If no data after filtering, might be a name format mismatch - log warning
      if (nrow(df) == 0) {
        message("Warning: No data found for pitcher '", pick, "'. Available pitchers: ", 
                paste(unique(pitch_data_pitching$Pitcher)[1:min(5, length(unique(pitch_data_pitching$Pitcher)))], collapse = ", "))
      }
    }
    
    # Opponent Hitter filter
    hitter_pick <- input$oppHitter
    if (!is.null(hitter_pick) && hitter_pick != "All") {
      df <- dplyr::filter(df, Batter == hitter_pick)
    }
    
    if (!is.null(input$hand) && input$hand != "All")       df <- dplyr::filter(df, PitcherThrows == input$hand)
    
    # Spatial & count
    df <- enforce_zone(df, input$zoneLoc)
    df <- enforce_inzone(df, input$inZone)
    df <- filter_qp_locations(df, input$qpLocations)
    df <- apply_count_filter(df, input$countFilter)
    df <- apply_after_count_filter(df, input$afterCountFilter)
    df <- apply_pitch_results_filter(df, input$pitchResults)
    
    # With Video filter
    if (!is.null(input$withVideo) && input$withVideo != "All") {
      vid1 <- nzchar(ifelse(is.na(df$VideoClip),  "", df$VideoClip))
      vid2 <- nzchar(ifelse(is.na(df$VideoClip2), "", df$VideoClip2))
      vid3 <- nzchar(ifelse(is.na(df$VideoClip3), "", df$VideoClip3))
      has_video <- vid1 | vid2 | vid3
      if (identical(input$withVideo, "Yes")) {
        df <- dplyr::filter(df, has_video)
      } else if (identical(input$withVideo, "No")) {
        df <- dplyr::filter(df, !has_video)
      }
    }
    
    # Numeric ranges
    if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed         >= input$veloMin)
    if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed         <= input$veloMax)
    if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
    if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
    if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak        >= input$hbMin)
    if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak        <= input$hbMax)
    
    # Pitch-number window
    df <- df %>% dplyr::arrange(Date) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
    if (nnz(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
    if (nnz(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
    
    # Per-user visibility: Coaches see all, Players see only their own data
    if (!is_admin() && !is_coach()) {
      ue <- user_email()
      if (!is.na(ue)) df <- dplyr::filter(df, norm_email(Email) == norm_email(ue))
    }
    
    if (!nrow(df)) return(df[0, , drop = FALSE])
    
    # Derived fields
    df2 <- compute_stuff_simple(df, base_type = input$stuffBase, level = input$stuffLevel) %>%
      force_pitch_levels() %>%
      dplyr::mutate(Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels))
    
    # Pitch type after derive
    if (!("All" %in% pitch_types)) df2 <- dplyr::filter(df2, TaggedPitchType %in% pitch_types)
    
    df2
  })
  
  # 3) helper for ordered types
  ordered_types <- function() {
    intersect(names(all_colors), unique(filtered_data()$TaggedPitchType))
  }
  
  # 4) Leaderboard data
  leaderboard_data <- reactive({
    req(input$sessionType, input$dates, input$hand, input$zoneLoc, input$inZone, input$qpLocations)
    
    # protect against NULL during app init
    pitch_types <- if (is.null(input$pitchType)) "All" else input$pitchType
    
    # first, honor Session Type
    df <- if (input$sessionType == "All") pitch_data_pitching else
      dplyr::filter(pitch_data_pitching, SessionType == input$sessionType)
    
    # Live-only BatterSide filter
    if (!is.null(input$batterSide) && input$batterSide != "All") {
      df <- df %>% dplyr::filter(
        SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide)
      )
    }
    
    # existing filters...
    df <- df %>% dplyr::filter(Date >= input$dates[1], Date <= input$dates[2])
    picks <- input$pitcher
    if (!is.null(picks) && length(picks) && !("All" %in% picks)) {
      df <- dplyr::filter(df, Pitcher %in% picks)
    }
    if (input$hand != "All")    df <- dplyr::filter(df, PitcherThrows == input$hand)
    
    df <- enforce_zone(df, input$zoneLoc)
    df <- enforce_inzone(df, input$inZone)
    df <- filter_qp_locations(df, input$qpLocations)
    df <- apply_count_filter(df, input$countFilter)
    df <- apply_pitch_results_filter(df, input$pitchResults)
    if (!is.na(input$veloMin)) df <- dplyr::filter(df, RelSpeed >= input$veloMin)
    if (!is.na(input$veloMax)) df <- dplyr::filter(df, RelSpeed <= input$veloMax)
    if (!is.na(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
    if (!is.na(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
    if (!is.na(input$hbMin))   df <- dplyr::filter(df, HorzBreak >= input$hbMin)
    if (!is.na(input$hbMax))   df <- dplyr::filter(df, HorzBreak <= input$hbMax)
    
    # With Video filter (leaderboard)
    if (!is.null(input$withVideo) && input$withVideo != "All") {
      vid1 <- nzchar(ifelse(is.na(df$VideoClip),  "", df$VideoClip))
      vid2 <- nzchar(ifelse(is.na(df$VideoClip2), "", df$VideoClip2))
      vid3 <- nzchar(ifelse(is.na(df$VideoClip3), "", df$VideoClip3))
      has_video <- vid1 | vid2 | vid3
      if (identical(input$withVideo, "Yes")) {
        df <- dplyr::filter(df, has_video)
      } else if (identical(input$withVideo, "No")) {
        df <- dplyr::filter(df, !has_video)
      }
    }
    
    df <- df %>% dplyr::arrange(Date) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
    if (!is.na(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
    if (!is.na(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
    
    if (!is_admin()) {
      ue <- user_email()
      if (!is.na(ue)) df <- dplyr::filter(df, Email == ue)
    }
    
    
    df2 <- compute_stuff_simple(df, input$stuffBase, input$stuffLevel) %>%
      force_pitch_levels() %>%
      dplyr::mutate(Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels))
    
    if (!("All" %in% pitch_types)) df2 <- dplyr::filter(df2, TaggedPitchType %in% pitch_types)
    df2
  })
  
  format_trend_value <- function(x, digits = 1) {
    if (!length(x) || all(is.na(x))) return(rep(NA_character_, length(x)))
    out <- round(x, digits)
    out[!is.finite(out)] <- NA
    out
  }
  
  trend_girafe_plot <- function(dat, title, ylab, digits = 1) {
    if (!nrow(dat)) return(NULL)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    
    date_levels <- unique(fmt_date(dat$Date))
    dat <- dplyr::mutate(dat, Date_f = factor(fmt_date(Date), levels = date_levels))
    
    # Build tooltip text
    dat <- dat %>%
      dplyr::mutate(
        total_pitches = if ("total_pitches" %in% names(.)) total_pitches else NA_real_,
        value_disp    = format_trend_value(value, digits = digits),
        data_id_val   = if ("SessionType" %in% names(.)) paste0(Date_f, "_", SessionType) else as.character(Date_f),
        tooltip = paste0(
          if ("SessionType" %in% names(.)) paste0("Session: ", SessionType, "<br/>") else "",
          "Date: ", fmt_date(Date), "<br/>",
          title, ": ", ifelse(is.na(value_disp), "—", value_disp), "<br/>",
          "Pitches: ", ifelse(is.na(total_pitches), "—", total_pitches)
        )
      )
    
    if ("SessionType" %in% names(dat)) {
      p <- ggplot(dat, aes(Date_f, value, group = SessionType, color = SessionType,
                           tooltip = tooltip, data_id = data_id_val)) +
        ggiraph::geom_line_interactive(size = 1.2, na.rm = TRUE) +
        ggiraph::geom_point_interactive(size = 2.5, na.rm = TRUE) +
        scale_color_manual(values = session_cols, breaks = c("Live", "Bullpen"), name = NULL) +
        labs(title = title, x = NULL, y = ylab) +
        theme_minimal() + axis_theme + grid_theme(dark_on) +
        theme(
          plot.title = element_text(face = "bold", color = axis_col),
          axis.text.x = element_text(angle = 45, hjust = 1, color = axis_col),
          axis.text.y = element_text(color = axis_col),
          legend.position = "bottom",
          legend.text = element_text(color = axis_col)
        )
    } else {
      p <- ggplot(dat, aes(Date_f, value, group = 1,
                           tooltip = tooltip, data_id = data_id_val)) +
        ggiraph::geom_line_interactive(size = 1.2, na.rm = TRUE) +
        ggiraph::geom_point_interactive(size = 2.5, na.rm = TRUE) +
        labs(title = title, x = NULL, y = ylab) +
        theme_minimal() + axis_theme + grid_theme(dark_on) +
        theme(
          plot.title = element_text(face = "bold", color = axis_col),
          axis.text.x = element_text(angle = 45, hjust = 1, color = axis_col),
          axis.text.y = element_text(color = axis_col),
          legend.position = "none"
        )
    }
    
    girafe_transparent(
      ggobj   = p,
      options = list(
        ggiraph::opts_hover_inv(css = "opacity:0.1;"),
        ggiraph::opts_hover(css = "stroke-width:2;"),
        ggiraph::opts_tooltip(use_fill = TRUE, css = tooltip_css, opacity = 0.9)
      )
    )
  }
  
  trend_plot <- function(df, val_expr, title, ylab, fun = mean, digits = 1) {
    agg <- function(x) {
      x <- x[!is.na(x)]
      if (!length(x)) return(NA_real_)
      fun(x)
    }
    if (input$sessionType == "All") {
      dat <- df %>%
        dplyr::group_by(Date, SessionType) %>%
        dplyr::summarise(
          value = agg({{ val_expr }}),
          total_pitches = dplyr::n(),
          .groups = "drop"
        ) %>%
        dplyr::arrange(Date)
    } else {
      dat <- df %>%
        dplyr::group_by(Date) %>%
        dplyr::summarise(
          value = agg({{ val_expr }}),
          total_pitches = dplyr::n(),
          .groups = "drop"
        ) %>%
        dplyr::arrange(Date)
    }
    
    trend_girafe_plot(dat, title, ylab, digits = digits)
  }
  
  output$summaryHeader <- renderUI({
    df <- filtered_data()
    
    # Safe reads
    pit <- input$pitcher
    dts <- input$dates
    
    # Metrics with empty-safe fallbacks
    scores <- if (nrow(df)) {
      ifelse(
        df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
          df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
        ifelse(
          df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
            df$PlateLocHeight >= (2.65 - 1.5) & df$PlateLocHeight <= (2.65 + 1.5),
          0.73, 0
        )
      )
    } else numeric(0)
    
    overall_stuff   <- if (nrow(df)) round(mean(df$`Stuff+`, na.rm = TRUE), 1) else NA_real_
    overall_command <- if (length(scores)) round(mean(scores,   na.rm = TRUE) * 100, 1) else NA_real_
    overall_pitch   <- round(mean(c(overall_stuff, overall_command), na.rm = TRUE), 1)
    
    # Title
    title <- if (is.null(pit) || identical(pit, "All")) {
      "All Pitchers"
    } else {
      disp <- names(name_map)[name_map == pit]
      if (length(disp)) disp else pit
    }
    
    # Dates string
    dates_str <- if (!is.null(dts) && length(dts) == 2 && all(is.finite(dts))) {
      if (identical(as.Date(dts[1]), as.Date(dts[2]))) fmt_date(dts[1]) else
        paste(fmt_date(dts[1]), fmt_date(dts[2]), sep = " - ")
    } else {
      rng <- suppressWarnings(range(df$Date, na.rm = TRUE))
      if (all(is.finite(rng))) paste(fmt_date(rng[1]), fmt_date(rng[2]), sep = " - ") else "All Dates"
    }
    
    tags$div(
      style = "display:flex; align-items:center; justify-content:space-between;",
      tags$img(src = "PCUlogo.png", height = "50px", style = "margin-right:15px;"),
      tags$h3(paste(title, "|", dates_str), style = "font-weight:bold; margin:0; flex:1;"),
      tags$div(
        style = "font-weight:bold; margin-left:20px;",
        paste0("Stuff+: ",   ifelse(is.finite(overall_stuff), overall_stuff,   "—"), " | "),
        paste0("Ctrl+: ",    ifelse(is.finite(overall_command), overall_command, "—"), " | "),
        paste0("Pitching+: ",ifelse(is.finite(overall_pitch), overall_pitch,   "—"))
      )
    )
  })
  
  
  # ---- Sessions Logs (Pitching) ----
  filtered_logs <- reactive({
    # --- helpers (tweaked date validator; added safe path->date fallback) ---
    is_valid_dates <- function(d) {
      if (is.null(d) || length(d) != 2) return(FALSE)
      a <- suppressWarnings(as.Date(d[1], tryFormats = c("%Y-%m-%d","%m/%d/%Y","%m/%d/%y")))
      b <- suppressWarnings(as.Date(d[2], tryFormats = c("%Y-%m-%d","%m/%d/%Y","%m/%d/%y")))
      !any(is.na(c(a, b)))
    }
    
    nnz <- function(x) !is.null(x) && !is.na(x)
    
    # Try to recover a date from SourceFile path when CSV "Date" fails
    .date_from_path <- function(paths) {
      v <- vapply(as.character(paths), function(p) {
        s <- as.character(p)
        
        # Try /YYYY/MM/DD/ or YYYY-MM-DD in the path
        m <- regexpr("(20\\d{2})[/-](0[1-9]|1[0-2])[/-]([0-3]\\d)", s, perl = TRUE)
        if (m[1] != -1) {
          frag <- substr(s, m[1], m[1] + attr(m, "match.length") - 1)
          frag <- gsub("/", "-", frag)
          out  <- suppressWarnings(as.Date(frag))
          if (!is.na(out)) return(format(out, "%Y-%m-%d"))
        }
        
        # Try 8-digit yyyymmdd in filename
        m2 <- regexpr("(20\\d{2})(0[1-9]|1[0-2])([0-3]\\d)", s, perl = TRUE)
        if (m2[1] != -1) {
          y  <- substr(s, m2[1],     m2[1] + 3)
          mo <- substr(s, m2[1] + 4, m2[1] + 5)
          d  <- substr(s, m2[1] + 6, m2[1] + 7)
          out <- suppressWarnings(as.Date(paste(y, mo, d, sep = "-")))
          if (!is.na(out)) return(format(out, "%Y-%m-%d"))
        }
        
        ""  # no match
      }, FUN.VALUE = character(1))
      suppressWarnings(as.Date(ifelse(nzchar(v), v, NA_character_)))
    }
    # ------------------------------------------------------------------------
    
    df <- pitch_data_pitching
    
    # Ensure Date exists & is Date
    if (!("Date" %in% names(df))) {
      cand <- intersect(c("GameDate","SessionDate","date","DATE"), names(df))
      if (length(cand)) df$Date <- df[[cand[1]]] else df$Date <- NA
    }
    # Your existing parser
    df$Date <- .s_to_date(df$Date)
    
    # Fill any remaining NA Date from SourceFile path, if available
    if ("SourceFile" %in% names(df)) {
      miss <- is.na(df$Date)
      if (any(miss)) {
        df$Date[miss] <- .date_from_path(df$SourceFile[miss])
      }
    }
    
    # If date input isn't ready yet, use full data range (prevents blank table)
    # If the range is still not finite (e.g., all NA), we skip narrowing by dates later.
    if (!is_valid_dates(input$dates)) {
      rng <- suppressWarnings(range(df$Date, na.rm = TRUE))
      date_start <- rng[1]; date_end <- rng[2]
    } else {
      date_start <- as.Date(input$dates[1]); date_end <- as.Date(input$dates[2])
    }
    have_valid_range <- is.finite(date_start) && is.finite(date_end)
    
    # Session Type
    if (!is.null(input$sessionType) && input$sessionType != "All") {
      df <- dplyr::filter(df, SessionType == input$sessionType)
    }
    
    # Keep warmups out; DO NOT drop blank TaggedPitchType here
    if ("PitchSession" %in% names(df)) {
      df <- dplyr::filter(df, is.na(PitchSession) | PitchSession != "Warmup")
    }
    
    # Live-only BatterSide
    if (!is.null(input$batterSide) && input$batterSide != "All") {
      df <- df %>%
        dplyr::filter(SessionType != "Live" |
                        (SessionType == "Live" & BatterSide == input$batterSide))
    }
    
    # Date window (only if we have a real range; otherwise just drop NA Date)
    if (have_valid_range) {
      df <- dplyr::filter(df, !is.na(Date), Date >= date_start, Date <= date_end)
    } else {
      df <- dplyr::filter(df, !is.na(Date))
    }
    
    # Pitcher & hand
    if (!is.null(input$pitcher) && input$pitcher != "All") {
      df <- dplyr::filter(df, Pitcher == input$pitcher)
    }
    
    # NEW: Opponent Hitter filter
    if (!is.null(input$oppHitter) && input$oppHitter != "All") {
      # Only filter if the hitter exists in the Batter column
      if (input$oppHitter %in% df$Batter) {
        df <- dplyr::filter(df, Batter == input$oppHitter)
      }
    }
    
    if (!is.null(input$hand) && input$hand != "All") {
      df <- dplyr::filter(df, PitcherThrows == input$hand)
    }
    
    # Same zone/count/numeric filters as elsewhere (guarded with exists())
    if (exists("enforce_zone"))       df <- enforce_zone(df, input$zoneLoc)
    if (exists("enforce_inzone"))     df <- enforce_inzone(df, input$inZone)
    if (exists("filter_qp_locations")) df <- filter_qp_locations(df, input$qpLocations)
    if (exists("apply_count_filter")) df <- apply_count_filter(df, input$countFilter)
    
    if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed         >= input$veloMin)
    if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed         <= input$veloMax)
    if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
    if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
    if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak        >= input$hbMin)
    if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak        <= input$hbMax)
    
    df
  })
  
  
  # Mode toggle + Custom picker
  output$sessTableButtons <- renderUI({
    sel <- isolate(input$sessMode); if (is.null(sel)) sel <- "Stuff"
    choices_cols <- if (exists("all_table_cols")) setdiff(all_table_cols, "Pitch")
    else setdiff(names(pitch_data_pitching), "Pitch")
    tagList(
      div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Tables:"),
      radioButtons(
        "sessMode", label = NULL,
        choices  = c("Stuff","Process","Results","Custom"),
        selected = sel, inline = TRUE
      ),
      conditionalPanel(
        "input.sessMode=='Custom'",
        selectizeInput(
          "sessCustomCols", label = NULL,
          choices  = choices_cols,
          multiple = TRUE,
          options  = list(placeholder = "Choose columns to show…")
        )
      )
    )
  })
  
  # DataTable render
  output$sessTable <- DT::renderDataTable({
    df <- filtered_logs()
    if (!nrow(df)) {
      return(DT::datatable(
        data.frame(Message = "No data for selected filters"),
        options = list(dom = 't'), rownames = FALSE
      ))
    }
    
    df_table <- make_session_logs_table(df) %>%
      dplyr::mutate(Date = parse_date_flex(Date)) %>%   # ← was as.Date(Date)
      dplyr::arrange(dplyr::desc(Date)) %>%
      dplyr::mutate(Date = format(Date, "%Y-%m-%d"))    # keep ISO output, or use "%m/%d/%Y" if you prefer
    
    
    mode <- input$sessMode; if (is.null(mode)) mode <- "Stuff"
    sel  <- input$sessCustomCols; if (is.null(sel)) sel <- character(0)
    
    # NEW: safe fallback if the requested set is empty or mismatched
    dv <- intersect(visible_set_for_date(mode, sel), names(df_table))
    if (!length(dv)) dv <- names(df_table)
    
    tbl <- datatable_with_colvis(
      df_table,
      lock = "Date",
      remember = FALSE,
      default_visible = dv
    )
    
    num_cols <- intersect(c("Velo","Max","IVB","HB","SpinEff","Spin","Height","Side",
                            "VAA","HAA","Ext","EV","LA","FIP","WHIP"),
                          names(df_table))
    if (length(num_cols)) tbl <- DT::formatRound(tbl, num_cols, digits = 1)
    
    tbl
  })
  
  
  output$summary_releasePlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    sess_lbl <- session_label_from(df)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    line_col <- if (dark_on) "#ffffff" else "black"
    
    # Get display option
    display_opt <- input$summaryReleaseDisplay
    if (is.null(display_opt)) display_opt <- "Averages Only"
    
    show_pitches <- display_opt %in% c("Averages and Pitches", "Pitches")
    show_averages <- display_opt %in% c("Averages Only", "Averages and Pitches")
    
    # --- background geometry
    rp_w <- 4; rp_h <- 0.83
    xs <- seq(-rp_w, rp_w, length.out = 100)
    ys <- rp_h * (1 - (xs / rp_w)^2)
    mound <- data.frame(x = c(xs, rev(xs)), y = c(ys, rep(0, length(xs))))
    
    # --- individual pitches data
    df_i <- df %>%
      dplyr::filter(is.finite(RelSide), is.finite(RelHeight)) %>%
      dplyr::mutate(
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", RelHeight),
          "<br>Side: ", sprintf("%.1f ft", RelSide),
          "<br>Extension: ", sprintf("%.1f ft", Extension)
        ),
        rid = dplyr::row_number()
      )
    
    # --- averages for hover+dot
    avg <- df %>%
      dplyr::filter(is.finite(RelSide), is.finite(RelHeight)) %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_RelSide    = mean(RelSide,    na.rm = TRUE),
        avg_RelHeight  = mean(RelHeight,  na.rm = TRUE),
        avg_Extension  = mean(Extension,  na.rm = TRUE),
        .groups = "drop"
      ) %>%
      dplyr::filter(TaggedPitchType %in% types_chr) %>%
      dplyr::mutate(
        TaggedPitchType = factor(TaggedPitchType, levels = types_chr),
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", avg_RelHeight),
          "<br>Side: ", sprintf("%.1f ft", avg_RelSide),
          "<br>Extension: ", sprintf("%.1f ft", avg_Extension)
        )
      )
    
    # --- ensure y axis goes to at least 6
    y_max <- max(6, suppressWarnings(max(df$RelHeight, na.rm = TRUE) + 0.2))
    
    p <- ggplot() +
      geom_polygon(data = mound, aes(x, y), fill = "tan", color = "tan", alpha = 0.5) +
      annotate("rect", xmin = -0.5, xmax = 0.5, ymin = rp_h - 0.05, ymax = rp_h + 0.05, fill = alpha("white", 0.6)) +
      geom_vline(xintercept = 0, color = line_col, size = 0.7) +
      geom_hline(yintercept = 0, color = line_col, size = 0.7) +
      # Individual pitches layer
      { if (show_pitches) {
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(x = RelSide, y = RelHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          alpha = 0.2, size = 3.0, shape = 21, stroke = 0.25, show.legend = FALSE
        )
      } } +
      # Averages layer
      { if (show_averages) {
        ggiraph::geom_point_interactive(
          data = avg,
          aes(x = avg_RelSide, y = avg_RelHeight,
              color = TaggedPitchType, tooltip = tt, data_id = TaggedPitchType),
          size = 8, show.legend = FALSE
        )
      } } +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_y_continuous(limits = c(0, y_max), breaks = seq(0, ceiling(y_max), by = 1)) +
      theme_minimal() + axis_theme + grid_theme(dark_on) + transparent_bg_theme +
      labs(x = NULL, y = NULL) +
      theme(
        legend.position = "none",
        axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
        axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
        panel.grid = element_blank(),
        axis.ticks = element_blank()
      )
    
    girafe_transparent(
      ggobj = p,
      width_svg = 8, height_svg = 6.5,
      options = list(
        ggiraph::opts_sizing(rescale = TRUE),
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;"),
        ggiraph::opts_selection(type = "multiple", selected = character(0))
      )
    )
  })
  
  output$summary_movementPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types()
    if (!length(types)) return(NULL)
    types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    line_col <- if (dark_on) "#ffffff" else "black"
    
    # Add reactive dependency on target shapes
    target_shapes_version()
    
    # Averages per type (respect filters)
    avg_mov <- df %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_HorzBreak        = mean(HorzBreak, na.rm = TRUE),
        avg_InducedVertBreak = mean(InducedVertBreak, na.rm = TRUE),
        avg_velo             = mean(RelSpeed, na.rm = TRUE),
        avg_stuff            = mean(`Stuff+`, na.rm = TRUE),
        n_obs                = dplyr::n(),
        .groups = "drop"
      ) %>%
      dplyr::mutate(
        tt  = paste0(TaggedPitchType,
                     "<br>Velo: ", round(avg_velo, 1), " mph",
                     "<br>IVB: ", round(avg_InducedVertBreak, 1), " in",
                     "<br>HB: ", round(avg_HorzBreak, 1), " in",
                     "<br>Stuff+: ", round(avg_stuff, 1),
                     "<br>Pitches: ", n_obs),
        data_id = TaggedPitchType
      )
    
    # interactive payload (per pitch) — uses your GLOBAL make_hover_tt()
    df_i <- df %>%
      dplyr::mutate(
        tt  = make_hover_tt(.),
        rid = dplyr::row_number()
      )
    
    base_type <- input$breakLines
    line_df <- tibble()
    if (base_type %in% c("Fastball","Sinker")) {
      base_val <- dplyr::filter(avg_mov, TaggedPitchType == base_type)
      if (nrow(base_val) == 1) {
        seps <- if (base_type == "Fastball") {
          tibble(
            TaggedPitchType = c("Cutter","Slider","Sweeper","Curveball","ChangeUp","Splitter"),
            sep_IVB = c(-7,-15,-16,-27,-12,-13),
            sep_Horz= c(10,12,22,18,-7,-4)
          )
        } else {
          tibble(
            TaggedPitchType = c("Cutter","Slider","Sweeper","Curveball","ChangeUp","Splitter"),
            sep_IVB = c(2,-6,-7,-18,-4,-5),
            sep_Horz= c(18,20,30,25,1,2)
          )
        }
        # handedness direction
        throw_side <- if (input$hand %in% c("Left","Right")) input$hand else {
          us <- unique(df$PitcherThrows) %>% na.omit()
          if (length(us) == 1 && us %in% c("Left","Right")) us else "Left"
        }
        dir <- ifelse(throw_side == "Right", -1, 1)
        seps <- seps %>%
          dplyr::filter(TaggedPitchType %in% avg_mov$TaggedPitchType) %>%
          dplyr::mutate(sep_Horz = sep_Horz * dir)
        
        line_df <- seps %>% dplyr::mutate(
          start_x = base_val$avg_HorzBreak,
          start_y = base_val$avg_InducedVertBreak,
          end_x   = base_val$avg_HorzBreak + sep_Horz,
          end_y   = base_val$avg_InducedVertBreak + sep_IVB
        )
      }
    }
    
    # Get display options for summary page
    display_opts <- input$summaryMovementDisplay
    if (is.null(display_opts)) display_opts <- "Averages and Pitches"
    
    show_pitches <- any(c("Averages and Pitches", "Target Shapes and Pitches") %in% display_opts)
    show_averages <- any(c("Averages Only", "Averages and Pitches") %in% display_opts)
    show_targets <- any(c("Target Shapes Only", "Target Shapes and Pitches") %in% display_opts)
    
    # Prepare target shapes data if needed (global target store)
    target_df <- NULL
    if (show_targets) {
      pitcher_sel <- input$pitcher
      if (!is.null(pitcher_sel) && length(pitcher_sel) == 1 && !("All" %in% pitcher_sel)) {
        pitcher_name <- pitcher_sel[1]
        date_range <- input$dates
        
        message(sprintf("SUMMARY: Attempting to get target shapes for pitcher: %s", pitcher_name))
        
        # Get target shapes for each pitch type
        target_data <- lapply(types_chr, function(pt) {
          target <- get_target_shape(pitcher_name, pt, date_range, auto_save = FALSE)
          if (!is.null(target)) {
            data.frame(
              TaggedPitchType = pt,
              HB_Target = target$HB,
              IVB_Target = target$IVB,
              stringsAsFactors = FALSE
            )
          } else {
            message(sprintf("  SUMMARY: No target for %s", pt))
            NULL
          }
        })
        
        target_df <- do.call(rbind, target_data)
        
        if (!is.null(target_df) && nrow(target_df) > 0) {
          message(sprintf("SUMMARY: Created target_df with %d rows", nrow(target_df)))
        } else {
          message("SUMMARY: target_df is NULL or empty")
        }
      }
    }
    
    p <- ggplot() +
      # Individual Pitches Layer
      { if (show_pitches) {
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(HorzBreak, InducedVertBreak,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          position = "identity",
          alpha = 0.25, size = 4.0, shape = 21, stroke = 0.25
        )
      } } +
      # Average Movement Layer
      { if (show_averages) {
        ggiraph::geom_point_interactive(
          data = avg_mov,
          aes(avg_HorzBreak, avg_InducedVertBreak, color = TaggedPitchType,
              tooltip = tt, data_id = data_id),
          size = 8, show.legend = FALSE
        )
      } } +
      # Break Lines Layer
      { if (nrow(line_df) > 0)
        geom_segment(
          data = line_df,
          aes(x = start_x, y = start_y, xend = end_x, yend = end_y, color = TaggedPitchType),
          size = 3
        )
      } +
      # Target Shapes Layer
      { if (!is.null(target_df) && nrow(target_df) > 0) {
        list(
          # Low alpha fill circle
          geom_point(
            data = target_df,
            aes(HB_Target, IVB_Target, fill = TaggedPitchType),
            size = 12, shape = 21, alpha = 0.10, stroke = 0, show.legend = FALSE
          ),
          # High alpha border circle
          geom_point(
            data = target_df,
            aes(HB_Target, IVB_Target, color = TaggedPitchType),
            size = 12, shape = 21, alpha = 0.8, stroke = 2, fill = NA, show.legend = FALSE
          )
        )
      } } +
      geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
      geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
      coord_cartesian(xlim = c(-25, 25), ylim = c(-25, 25)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      labs(x = NULL, y = NULL) +                        # <-- remove axis titles
      theme(
        legend.position = "none",
        axis.text.x     = element_text(size = 15, face = "bold", color = axis_col),
        axis.text.y     = element_text(size = 15, face = "bold", color = axis_col),
        axis.title.x    = element_blank(),              # <-- ensure blank
        axis.title.y    = element_blank(),              # <-- ensure blank
        panel.grid      = element_blank(),
        axis.ticks      = element_blank()
      )
    
    girafe_transparent(
      ggobj = p,
      width_svg  = 8,
      height_svg = 6.5,
      bg = "transparent",
      options = list(
        ggiraph::opts_sizing(rescale = TRUE),
        ggiraph::opts_tooltip(use_fill = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;"),
        ggiraph::opts_selection(type = "multiple", selected = character(0))
      )
    )
  })
  
  # 2) Pitch‐version location chart (with centered title)
  output$summary_zonePlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    line_col <- if (dark_on) "#ffffff" else "black"
    
    df_i <- df %>%
      dplyr::mutate(
        tt      = make_hover_tt(.),
        rid     = dplyr::row_number(),
        # tooltip fill should use the outline (pitch-type) color
        tt_fill = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray")
      )
    
    home <- data.frame(
      x = c(-0.75, 0.75, 0.75, 0, -0.75),
      y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
    )
    cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
    sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
    
    df_known <- df_i %>% dplyr::filter(!is.na(Result))
    df_other <- df_i %>% dplyr::filter(is.na(Result))
    
    p <- ggplot() +
      geom_polygon(data = home, aes(x, y), inherit.aes = FALSE, fill = NA, color = line_col) +
      geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                inherit.aes = FALSE, fill = NA, linetype = "dashed", color = line_col) +
      geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                inherit.aes = FALSE, fill = NA, color = line_col) +
      
      # filled circles for "no result" rows
      ggiraph::geom_point_interactive(
        data = df_other,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 5, alpha = 0.9, shape = 16, stroke = 0.3
      ) +
      
      # result-coded shapes (can be hollow)
      ggiraph::geom_point_interactive(
        data = df_known,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 5, alpha = 0.95, stroke = 0.8
      ) +
      
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_shape_manual(values = shape_map, drop = TRUE) +
      coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
      theme_void() + theme(legend.position = "none") +
      
      # 🔹 Invisible “hover pad” on top to force correct tooltip fill every time
      ggiraph::geom_point_interactive(
        data = df_i,
        aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
        shape = 21, size = 6, alpha = 0.001, stroke = 0, inherit.aes = FALSE
      )
    
    girafe_transparent(
      ggobj = p,
      bg = "transparent",
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  # 3) Heat‐version location chart (fixed error + centered title)
  output$summary_heatZonePlot <- renderPlot({
    df <- filtered_data()
    if (!nrow(df)) return()
    
    stat <- input$summaryLocType
    if (is.null(stat) || stat == "Pitch") return(NULL)
    # Normalize label for renderer
    if (identical(stat, "Exit Velocity")) stat <- "EV"
    
    render_heatmap_stat(df, stat)
  }, bg = "transparent")
  
  
  output$summary_legend <- renderPlot({
    types<-ordered_types(); if(!length(types)) return()
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#ffffff" else "black"
    pal <- colors_for_mode(dark_on)
    leg_df<-data.frame(TaggedPitchType=factor(types,levels=types),x=1,y=1)
    ggplot(leg_df,aes(x,y,color=TaggedPitchType))+geom_point(size=0,alpha=0)+
      scale_color_manual(values=pal[types],limits=types,name=NULL)+
      guides(color=guide_legend(nrow=1,byrow=TRUE,override.aes=list(size=4,alpha=1)))+
      theme_void()+
      theme(
        legend.position=c(0.5, 0.5),
        legend.text=element_text(size=12,face="bold", color = axis_col),
        legend.justification=c(0.5, 0.5),
        legend.direction="horizontal",
        plot.margin = margin(2, 10, 2, 10),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.background = element_rect(fill = "transparent", color = NA),
        legend.background = element_rect(fill = "transparent", color = NA)
      )
  }, bg = "transparent")
  
  # Pitch result legend for location chart (shapes)
  output$summary_result_legend <- renderPlot({
    # Only show the main result types that have shapes in the legend
    # Individual hit types (Single, Double, etc.) are filter options only, not plot symbols
    res_levels <- c("Called Strike", "Ball", "Foul", "Whiff", "In Play (Out)", "In Play (Hit)", "Error")
    leg_df <- data.frame(Result = factor(res_levels, levels = res_levels), x = 1, y = 1)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#ffffff" else "black"
    ggplot(leg_df, aes(x, y, shape = Result)) +
      geom_point(size = 0, alpha = 0, show.legend = TRUE) +
      scale_shape_manual(values = shape_map, limits = res_levels, name = NULL) +
      theme_void() +
      theme(
        legend.position = c(0.5, 0.5),
        legend.text = element_text(size = 12, face = "bold", color = axis_col),
        legend.justification = c(0.5, 0.5),
        legend.direction = "horizontal",
        plot.margin = margin(10, 10, 10, 10),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.background = element_rect(fill = "transparent", color = NA),
        legend.background = element_rect(fill = "transparent", color = NA)
      ) +
      guides(shape = guide_legend(
        nrow = 1, byrow = TRUE,
        override.aes = list(size = 4, alpha = 1, color = axis_col, fill = NA)
      ))
  }, bg = "transparent")
  
  safe_pct <- function(num, den) {
    num <- suppressWarnings(as.numeric(num))
    den <- suppressWarnings(as.numeric(den))
    ifelse(is.finite(den) & den > 0 & is.finite(num),
           paste0(round(100 * num / den, 1), "%"),
           "")
  }
  
  nz_mean <- function(x) {
    x <- suppressWarnings(as.numeric(x))
    m <- mean(x, na.rm = TRUE)
    if (is.finite(m)) m else NA_real_
  }
  
  
  collapse_list_cols <- function(dat) {
    if (!nrow(dat)) return(dat)
    dat %>%
      dplyr::mutate(dplyr::across(
        dplyr::where(is.list),
        ~ vapply(., function(x) {
          if (is.null(x)) "" else if (length(x) == 1 && !is.list(x)) as.character(x)
          else paste0(unlist(x), collapse = ", ")
        }, character(1))
      ))
  }
  
  # =========================
  # Summary page table (uses summary* controls ONLY)
  # =========================
  output$summaryTablePage <- DT::renderDataTable({
    tryCatch({
      df <- filtered_data()
      table_cache <- NULL
      on.exit({
        session$userData$table_cache_summaryTablePage <- table_cache
      }, add = TRUE)
      if (!nrow(df)) {
        return(DT::datatable(
          data.frame(Message = "No data for selected filters"),
          options = list(dom = 't'), rownames = FALSE
        ))
      }
      
      # Apply Split By transformation
      split_choice <- if (!is.null(input$summarySplitBy)) input$summarySplitBy else "Pitch Types"
      df <- apply_split_by(df, split_choice)
      
      # Determine the column name based on split choice
      split_col_name <- switch(
        split_choice,
        "Pitch Types" = "Pitch",
        "Batter Hand" = "Batter Hand",
        "Count" = "Count",
        "After Count" = "After Count",
        "Velocity" = "Velocity",
        "IVB" = "InducedVert",
        "HB" = "HorzBreak",
        "Batter" = "Batter",
        "Pitch"  # default
      )
      
      # --- small helpers (match Hitting DP logic) ---
      nz_mean <- function(x) {
        x <- suppressWarnings(as.numeric(x))
        m <- mean(x, na.rm = TRUE)
        if (is.finite(m)) m else NA_real_
      }
      
      safe_div <- function(num, den) {
        num <- suppressWarnings(as.numeric(num))
        den <- suppressWarnings(as.numeric(den))
        ifelse(is.finite(den) & den != 0 & is.finite(num), num/den, NA_real_)
      }
      
      # Parse numeric values from strings like "12.3%", "  .456  ", "1,234", etc.
      # Any string containing % is treated as a percentage and divided by 100.
      parse_num <- function(x) {
        if (is.numeric(x)) return(x)
        sx <- trimws(as.character(x))
        sx[sx == ""] <- NA_character_
        is_pct <- grepl("%", sx)                     # percent anywhere in the string
        val <- suppressWarnings(as.numeric(gsub("[^0-9eE.+-]", "", sx)))  # keep digits, ., +/-, e/E
        val[is_pct] <- val[is_pct] / 100
        val
      }
      
      # Format 3-decimal rates without leading zero (e.g., .303)
      fmt_rate3 <- function(x) {
        x <- suppressWarnings(as.numeric(x))
        s <- ifelse(is.finite(x), sprintf("%.3f", x), "")
        sub("^0\\.", ".", s)
      }
      
      # Alias to avoid breaking any existing calls that use fmt_avg
      fmt_avg <- fmt_rate3
      
      ip_fmt <- function(ip_raw) {
        out <- rep("", length(ip_raw))
        ok  <- is.finite(ip_raw) & ip_raw > 0
        outs <- floor(ip_raw[ok]*3 + 1e-8)
        inn  <- outs %/% 3
        rem  <- outs %% 3
        out[ok] <- paste0(inn, ".", rem)
        out
      }
      FIP_C <- if (exists("FIP_CONST")) get("FIP_CONST") else 3.20
      
      res_mode <- resolve_table_mode_global(input$summaryTableMode, input$summaryCustomCols)
      mode   <- res_mode$mode
      custom <- res_mode$cols
      
      # Fallback visible-set helper if not defined globally
      if (!exists("visible_set_for")) {
        visible_set_for <- function(mode, custom) {
          base <- c("Pitch","#","Usage","BF","IP","FIP","WHIP","Velo","Max","IVB","HB","rTilt","bTilt","SpinEff","Spin",
                    "Height","Side","VAA","HAA","Ext","InZone%","Comp%","Strike%","FPS%","E+A%","QP%",
                    "K%","BB%","Whiff%","EV","LA","Stuff+","Ctrl+","QP+","Pitching+",
                    # Results-specific common cols
                    "PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP","GB%","Barrel%","Swing%","Whiff%","K%","BB%","EV","LA")
          if (identical(mode, "Custom") && length(custom)) unique(c("Pitch", custom)) else base
        }
      }
      
      # ---------- RESULTS TABLE (use Hitting-style PA/AB math) ----------
      if (identical(mode, "Results")) {
        swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
        
        # Completed PA rows
        is_term <- (
          (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
            (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk"))
        )
        term <- df[is_term, , drop = FALSE]
        
        # Per-split-type tallies (PA/AB/H/K/BB/HBP/Sac/HR)
        per_type <- term %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            PA   = dplyr::n(),
            HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
            `1B` = sum(PlayResult == "Single",  na.rm = TRUE),
            `2B` = sum(PlayResult == "Double",  na.rm = TRUE),
            `3B` = sum(PlayResult == "Triple",  na.rm = TRUE),
            HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
            Kct  = sum(KorBB == "Strikeout" |
                         PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
            BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
            .groups = "drop"
          ) %>%
          dplyr::mutate(
            AB  = PA - (BBct + HBP + Sac),
            H   = `1B` + `2B` + `3B` + HR,
            TB  = 1*`1B` + 2*`2B` + 3*`3B` + 4*HR,
            AVG = safe_div(H, AB),
            SLG = safe_div(TB, AB),
            OBP = safe_div(H + BBct + HBP, PA),
            OPS = SLG + OBP
          )
        
        # Pitch totals for Usage/Swing%/Whiff%
        pitch_totals <- df %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            Pitches       = dplyr::n(),
            Swings        = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
            Whiffs        = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
            CalledStrikes = sum(PitchCall == "StrikeCalled",    na.rm = TRUE),
            .groups = "drop"
          )
        total_pitches <- sum(pitch_totals$Pitches, na.rm = TRUE)
        
        # Command scoring vector and per-type Command+ / Stuff+ / Pitching+
        scores <- ifelse(
          df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
            df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
          ifelse(
            df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
              df$PlateLocHeight >= (2.65 - 1.5) & df$PlateLocHeight <= (2.65 + 1.5),
            0.73, 0
          )
        )
        sc_by_type <- df %>%
          dplyr::mutate(.scores = scores) %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            StuffP   = round(nz_mean(`Stuff+`), 1),
            CommandP = round(nz_mean(.scores) * 100, 1),
            .groups = "drop"
          ) %>%
          dplyr::mutate(PitchingP = round((StuffP + CommandP)/2, 1))
        
        # Live BIP for EV/LA and GB%
        bbe <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
        evla <- bbe %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(EV = nz_mean(ExitSpeed), LA = nz_mean(Angle), .groups = "drop")
        gb <- bbe %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            `GB%` = safe_div(sum(TaggedHitType == "GroundBall", na.rm = TRUE),
                             sum(!is.na(TaggedHitType),        na.rm = TRUE)),
            .groups = "drop"
          )
        
        # Extras (xWOBA/xISO/BABIP/Barrel%) — numeric
        # Note: This function may need SplitColumn support internally
        extras_raw <- safe_compute_process_results(df, mode)
        if ("PitchType" %in% names(extras_raw)) {
          extras <- extras_raw %>%
            dplyr::rename(SplitColumn = PitchType) %>%
            dplyr::mutate(
              xWOBA     = parse_num(xWOBA),
              xISO      = parse_num(xISO),
              BABIP     = parse_num(BABIP),
              `Barrel%` = parse_num(`Barrel%`)
            ) %>%
            dplyr::select(SplitColumn, xWOBA, xISO, BABIP, `Barrel%`, `RV/100`)
        } else {
          # Fallback if function doesn't return expected format
          extras <- df %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              xWOBA = NA_real_, xISO = NA_real_, 
              BABIP = NA_real_, `Barrel%` = NA_real_, `RV/100` = NA_real_,
              .groups = "drop"
            )
        }
        
        # Build per-type rows (+ #, Usage, BF, IP, FIP, WHIP, Pitching+)
        res_pt <- per_type %>%
          dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
          dplyr::left_join(evla,         by = "SplitColumn") %>%
          dplyr::left_join(gb,           by = "SplitColumn") %>%
          dplyr::mutate(
            `Swing%` = safe_div(Swings, Pitches),
            `Whiff%` = safe_div(Whiffs, Swings),
            `CSW%`   = safe_div(Whiffs + CalledStrikes, Pitches),
            Outs     = (AB - H) + Sac,
            IP_raw   = safe_div(Outs, 3),
            BF       = PA,
            `#`      = Pitches,
            Usage    = ifelse(total_pitches > 0, paste0(round(100*Pitches/total_pitches,1), "%"), ""),
            FIP_tmp  = safe_div(13*HR + 3*(BBct + HBP) - 2*Kct, IP_raw),
            FIP      = ifelse(is.finite(FIP_tmp), round(FIP_tmp + FIP_C, 2), NA_real_),
            WHIP_tmp = safe_div(H + BBct, IP_raw),
            WHIP     = ifelse(is.finite(WHIP_tmp), round(WHIP_tmp, 2), NA_real_)
          ) %>%
          dplyr::left_join(sc_by_type, by = "SplitColumn") %>%
          dplyr::left_join(extras, by = "SplitColumn") %>%
          dplyr::transmute(
            !!split_col_name := as.character(SplitColumn),
            `#`, Usage, BF, `RV/100`, IP = ip_fmt(IP_raw), FIP, WHIP,
            PA, AB, AVG, SLG, OBP, OPS,
            xWOBA, xISO, BABIP,
            `Swing%`, `Whiff%`, `CSW%`, `GB%`,
            `K%` = safe_div(Kct, PA), `BB%` = safe_div(BBct, PA),
            `Barrel%`, EV, LA,
            `Pitching+` = PitchingP
          )
        
        # --- ALL row (ungrouped, same definitions) ---
        PAt <- nrow(term)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
        H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
        H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
        HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        H   <- H1 + H2 + H3 + HR
        TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
        Kct_all <- sum(term$KorBB == "Strikeout" |
                         term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
        BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        ABt <- PAt - (BBc_all + HBP_all + Sac_all)
        swings  <- sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE)
        whiffs  <- sum(df$PitchCall == "StrikeSwinging",                      na.rm = TRUE)
        csw_all_num <- sum(df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
        gbpct_all <- {
          d <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
          safe_div(sum(d$TaggedHitType == "GroundBall", na.rm = TRUE),
                   sum(!is.na(d$TaggedHitType),         na.rm = TRUE))
        }
        # All-row IP/FIP/WHIP/Pitching+
        Outs_all <- (ABt - H) + Sac_all
        IP_all   <- safe_div(Outs_all, 3)
        FIP_all  <- {
          tmp <- safe_div(13*HR + 3*(BBc_all + HBP_all) - 2*Kct_all, IP_all)
          ifelse(is.finite(tmp), round(tmp + FIP_C, 2), NA_real_)
        }
        WHIP_all <- {
          tmp <- safe_div(H + BBc_all, IP_all)
          ifelse(is.finite(tmp), round(tmp, 2), NA_real_)
        }
        
        stuff_all <- round(nz_mean(df$`Stuff+`), 1)
        qp_all <- round(nz_mean(compute_qp_points(df)) * 200, 1)
        pitc_all <- round((stuff_all + qp_all) / 2, 1)
        
        # For Swing% calculation, use total pitches as denominator (same as individual pitch types)
        total_pitches_all <- total_pitches
        
        # Create All row with dynamic column name
        all_row_data <- list(
          `#`   = nrow(df),
          Usage = "100%",
          BF = PAt,
          IP = ip_fmt(IP_all),
          FIP = FIP_all,
          WHIP = WHIP_all,
          PA = PAt, AB = ABt,
          AVG = safe_div(H, ABt),
          SLG = safe_div(TB, ABt),
          OBP = safe_div(H + BBc_all + HBP_all, PAt),
          OPS = NA_real_,
          xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
          `Swing%` = safe_div(swings, total_pitches_all),
          `Whiff%` = safe_div(whiffs, swings),
          `CSW%`   = safe_div(csw_all_num, total_pitches_all),
          `GB%`    = gbpct_all,
          `K%`     = safe_div(Kct_all, PAt),
          `BB%`    = safe_div(BBc_all, PAt),
          `Barrel%`= NA_real_,
          EV = nz_mean(bbe$ExitSpeed),
          LA = nz_mean(bbe$Angle),
          `Pitching+` = pitc_all
        )
        # Add the split column name dynamically
        all_row_data[[split_col_name]] <- "All"
        all_row <- tibble::as_tibble(all_row_data)
        all_row$OPS <- all_row$SLG + all_row$OBP
        
        # Fill extras (All)
        extras_all <- compute_process_results(df, mode) %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::summarise(
            xWOBA     = nz_mean(xWOBA),
            xISO      = nz_mean(xISO),
            BABIP     = nz_mean(BABIP),
            `Barrel%` = nz_mean(`Barrel%`),
            .groups = "drop"
          )
        if (nrow(extras_all)) {
          all_row$xWOBA     <- extras_all$xWOBA[1]
          all_row$xISO      <- extras_all$xISO[1]
          all_row$BABIP     <- extras_all$BABIP[1]
          all_row$`Barrel%` <- extras_all$`Barrel%`[1]
        }
        
        # Add Even/Ahead/Behind summary rows if splitting by Count
        count_state_rows <- NULL
        if (split_choice == "Count" && "CountState" %in% names(df)) {
          for (state in c("Even", "Ahead", "Behind")) {
            state_df <- df %>% dplyr::filter(CountState == state)
            state_term <- term %>% dplyr::filter(CountState == state)
            
            if (nrow(state_df) > 0) {
              state_pitches <- nrow(state_df)
              # Similar calculations as for individual counts
              state_PA <- nrow(state_term)
              state_HBP <- sum(state_term$PlayResult == "HitByPitch", na.rm = TRUE)
              state_Sac <- sum(state_term$PlayResult == "Sacrifice", na.rm = TRUE)
              state_H1 <- sum(state_term$PlayResult == "Single", na.rm = TRUE)
              state_H2 <- sum(state_term$PlayResult == "Double", na.rm = TRUE)
              state_H3 <- sum(state_term$PlayResult == "Triple", na.rm = TRUE)
              state_HR <- sum(state_term$PlayResult == "HomeRun", na.rm = TRUE)
              state_H <- state_H1 + state_H2 + state_H3 + state_HR
              state_TB <- 1*state_H1 + 2*state_H2 + 3*state_H3 + 4*state_HR
              state_Kct <- sum(state_term$KorBB == "Strikeout" |
                                 state_term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
              state_BBct <- sum(state_term$KorBB == "Walk" | state_term$PlayResult == "Walk", na.rm = TRUE)
              state_AB <- state_PA - (state_BBct + state_HBP + state_Sac)
              
              state_swings <- sum(!is.na(state_df$PitchCall) & state_df$PitchCall %in% swing_levels, na.rm = TRUE)
              state_whiffs <- sum(state_df$PitchCall == "StrikeSwinging", na.rm = TRUE)
              state_csw <- sum(state_df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
              state_bbe <- state_df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
              state_gbpct <- safe_div(sum(state_bbe$TaggedHitType == "GroundBall", na.rm = TRUE),
                                      sum(!is.na(state_bbe$TaggedHitType), na.rm = TRUE))
              
              # Calculate BABIP for count state
              state_inplay_all <- sum(state_df$PitchCall == "InPlay", na.rm = TRUE)
              state_BABIP <- safe_div(state_H, state_inplay_all)
              
              # Calculate Barrel% for count state
              state_barrels <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay" &
                                     is.finite(state_df$ExitSpeed) & is.finite(state_df$Angle) &
                                     state_df$ExitSpeed >= 95 & state_df$Angle >= 10 & state_df$Angle <= 35, na.rm = TRUE)
              state_inplay_live <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay", na.rm = TRUE)
              state_BarrelPct <- safe_div(state_barrels, state_inplay_live)
              
              # Calculate xWOBA and xISO for count state (using expected stats if available)
              state_bip_evla <- state_df %>%
                dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                              is.finite(ExitSpeed), is.finite(Angle)) %>%
                dplyr::mutate(
                  EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
                  LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
                )
              if (exists("xbin_ref") && nrow(state_bip_evla) > 0) {
                state_bip_evla <- state_bip_evla %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
                for (nm in c("p1B","p2B","p3B","pHR")) {
                  if (exists("x_overall") && nm %in% names(x_overall)) {
                    state_bip_evla[[nm]][!is.finite(state_bip_evla[[nm]])] <- x_overall[[nm]]
                  }
                }
                state_x1B <- sum(state_bip_evla$p1B, na.rm = TRUE)
                state_x2B <- sum(state_bip_evla$p2B, na.rm = TRUE)
                state_x3B <- sum(state_bip_evla$p3B, na.rm = TRUE)
                state_xHR <- sum(state_bip_evla$pHR, na.rm = TRUE)
                state_xH   <- state_x1B + state_x2B + state_x3B + state_xHR
                state_xTB  <- 1*state_x1B + 2*state_x2B + 3*state_x3B + 4*state_xHR
                state_xAVG <- safe_div(state_xH, state_AB)
                state_xSLG <- safe_div(state_xTB, state_AB)
                state_xISO <- state_xSLG - state_xAVG
                # xWOBA calculation (using weights if they exist)
                state_BF_live <- sum(state_df$SessionType == "Live" & state_df$Balls == 0 & state_df$Strikes == 0, na.rm = TRUE)
                if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
                  state_xWOBA <- safe_div(W_BB*state_BBct + W_1B*state_x1B + W_2B*state_x2B + W_3B*state_x3B + W_HR*state_xHR, state_BF_live)
                } else {
                  state_xWOBA <- NA_real_
                }
              } else {
                state_xWOBA <- NA_real_
                state_xISO <- NA_real_
              }
              
              state_Outs <- (state_AB - state_H) + state_Sac
              state_IP <- safe_div(state_Outs, 3)
              state_FIP <- {
                tmp <- safe_div(13*state_HR + 3*(state_BBct + state_HBP) - 2*state_Kct, state_IP)
                ifelse(is.finite(tmp), round(tmp + FIP_C, 2), NA_real_)
              }
              state_WHIP <- {
                tmp <- safe_div(state_H + state_BBct, state_IP)
                ifelse(is.finite(tmp), round(tmp, 2), NA_real_)
              }
              
              # Calculate InZone%, Strike%, and Comp% for count state
              state_inzone <- sum(state_df$PlateLocSide >= ZONE_LEFT & state_df$PlateLocSide <= ZONE_RIGHT &
                                    state_df$PlateLocHeight >= ZONE_BOTTOM & state_df$PlateLocHeight <= ZONE_TOP, na.rm = TRUE)
              state_InZonePct <- safe_div(state_inzone, state_pitches)
              
              state_strikes <- sum(state_df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
              state_StrikePct <- safe_div(state_strikes, state_pitches)
              
              state_comp <- sum(state_df$PlateLocSide >= -1.5 & state_df$PlateLocSide <= 1.5 &
                                  state_df$PlateLocHeight >= (2.65-1.5) & state_df$PlateLocHeight <= (2.65+1.5), na.rm = TRUE)
              state_CompPct <- safe_div(state_comp, state_pitches)
              
              state_row_data <- list(
                `#` = state_pitches,
                Usage = ifelse(total_pitches > 0, paste0(round(100*state_pitches/total_pitches, 1), "%"), ""),
                BF = state_PA,
                IP = ip_fmt(state_IP),
                FIP = state_FIP,
                WHIP = state_WHIP,
                PA = state_PA,
                AB = state_AB,
                AVG = safe_div(state_H, state_AB),
                SLG = safe_div(state_TB, state_AB),
                OBP = safe_div(state_H + state_BBct + state_HBP, state_PA),
                OPS = NA_real_,
                xWOBA = state_xWOBA,
                xISO = state_xISO,
                BABIP = state_BABIP,
                `InZone%` = state_InZonePct,
                `Strike%` = state_StrikePct,
                `Comp%` = state_CompPct,
                `Swing%` = safe_div(state_swings, state_pitches),
                `Whiff%` = safe_div(state_whiffs, state_swings),
                `CSW%` = safe_div(state_csw, state_pitches),
                `GB%` = state_gbpct,
                `K%` = safe_div(state_Kct, state_PA),
                `BB%` = safe_div(state_BBct, state_PA),
                `Barrel%` = state_BarrelPct,
                EV = nz_mean(state_bbe$ExitSpeed),
                LA = nz_mean(state_bbe$Angle),
                `Pitching+` = round(nz_mean(state_df$`Stuff+`), 1)
              )
              state_row_data[[split_col_name]] <- state
              state_row <- tibble::as_tibble(state_row_data)
              state_row$OPS <- state_row$SLG + state_row$OBP
              
              count_state_rows <- dplyr::bind_rows(count_state_rows, state_row)
            }
          }
        }
        
        # Order pitch types correctly if Pitch Types is selected
        if (split_choice == "Pitch Types" && split_col_name == "Pitch" && exists("all_colors")) {
          pitch_order <- intersect(names(all_colors), res_pt[[split_col_name]])
          if (length(pitch_order) > 0) {
            res_pt[[split_col_name]] <- factor(res_pt[[split_col_name]], levels = pitch_order)
            res_pt <- res_pt %>% dplyr::arrange(.data[[split_col_name]])
            res_pt[[split_col_name]] <- as.character(res_pt[[split_col_name]])
          }
        }
        
        # Bind + format (including count state rows if they exist)
        df_out <- dplyr::bind_rows(res_pt, count_state_rows, all_row) %>%
          dplyr::mutate(
            dplyr::across(c(PA, AB, AVG, SLG, OBP, OPS, xWOBA, xISO, BABIP,
                            `Swing%`, `Whiff%`, `CSW%`, `GB%`, `K%`, `BB%`, `Barrel%`,
                            EV, LA, FIP, WHIP),
                          ~ suppressWarnings(as.numeric(.)))
          )
        pct_cols  <- c("Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%")
        rate_cols <- c("AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP")
        df_out[pct_cols]  <- lapply(df_out[pct_cols],  function(z) ifelse(is.finite(z), paste0(round(z*100,1), "%"), ""))
        df_out[rate_cols] <- lapply(df_out[rate_cols], function(z) ifelse(is.finite(z), fmt_avg(z), ""))
        df_out$EV   <- ifelse(is.finite(df_out$EV),   round(df_out$EV, 1), "")
        df_out$LA   <- ifelse(is.finite(df_out$LA),   round(df_out$LA, 1), "")
        df_out$FIP  <- ifelse(is.finite(df_out$FIP),  sprintf("%.2f", df_out$FIP), "")
        df_out$WHIP <- ifelse(is.finite(df_out$WHIP), sprintf("%.2f", df_out$WHIP), "")
        
        # Sort by IVB/HB in descending order if applicable
        df_out <- sort_by_range(df_out, split_col_name, split_choice)
        
        df_dt <- if (exists("collapse_list_cols")) collapse_list_cols(df_out) else df_out
        df_dt <- as.data.frame(df_dt, stringsAsFactors = FALSE, check.names = FALSE)
        
        # Update visible_set to use dynamic column name
        visible_set <- visible_set_for(mode, custom)
        # Replace "Pitch" with the actual split column name in visible set
        visible_set <- gsub("^Pitch$", split_col_name, visible_set)
        
        build_summary_dt <- function(data, ...) {
          tryCatch(
            datatable_with_colvis(data, ...),
            error = function(e) {
              message("summaryTablePage (Results) datatable error [mode=", mode, "]: ", conditionMessage(e))
              message("Columns: ", paste(names(data), collapse = ", "))
              # Return a fallback datatable with error message instead of stopping
              DT::datatable(
                data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
                options = list(dom = 't'), rownames = FALSE
              )
            }
          )
        }
        table_cache <- list(
          table = df_dt,
          source = df,
          label_column = split_col_name,
          split_choice = split_choice
        )
        return(build_summary_dt(
          df_dt,
          lock            = split_col_name,
          remember        = FALSE,
          default_visible = intersect(visible_set, names(df_dt)),
          mode            = mode
        ))
      }
      
      # ---------- RAW DATA TABLE ----------
      if (identical(mode, "Raw Data")) {
        # Helper function for innings pitched calculation
        ip_calculation <- function(pitches_data) {
          outs <- sum(pitches_data$KorBB == "Strikeout", na.rm = TRUE) + 
            sum(pitches_data$PlayResult %in% c("Out", "FieldersChoice", "Error"), na.rm = TRUE)
          innings <- outs / 3
          whole_innings <- floor(innings)
          remaining_outs <- outs %% 3
          if (remaining_outs == 0) {
            return(paste0(whole_innings, ".0"))
          } else {
            return(paste0(whole_innings, ".", remaining_outs))
          }
        }
        
        raw_per_type <- df %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            IP = ip_calculation(dplyr::cur_data_all()),
            P = dplyr::n(),
            BF = calculate_bf(dplyr::cur_data_all()),
            H = sum(PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE),
            XBH = sum(PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE),
            Barrels = sum(ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, na.rm = TRUE),
            BB = sum(KorBB == "Walk", na.rm = TRUE),
            HBP = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            K = sum(KorBB == "Strikeout", na.rm = TRUE),
            Whiffs = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
            .groups = "drop"
          ) %>%
          dplyr::rename(!!split_col_name := SplitColumn) %>%
          dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
        
        # Order pitch types correctly if Pitch Types is selected
        if (split_choice == "Pitch Types" && exists("all_colors")) {
          pitch_order <- intersect(names(all_colors), raw_per_type[[split_col_name]])
          if (length(pitch_order) > 0) {
            raw_per_type[[split_col_name]] <- factor(raw_per_type[[split_col_name]], levels = pitch_order)
            raw_per_type <- raw_per_type %>% dplyr::arrange(.data[[split_col_name]])
            raw_per_type[[split_col_name]] <- as.character(raw_per_type[[split_col_name]])
          }
        }
        
        # All row calculations
        all_ip <- ip_calculation(df)
        all_p <- nrow(df)
        all_bf <- sum(df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
        all_h <- sum(df$PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
        all_xbh <- sum(df$PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE)
        all_barrels <- sum(df$ExitSpeed >= 95 & df$Angle >= 10 & df$Angle <= 35, na.rm = TRUE)
        all_bb <- sum(df$KorBB == "Walk", na.rm = TRUE)
        all_hbp <- sum(df$PlayResult == "HitByPitch", na.rm = TRUE)
        all_k <- sum(df$KorBB == "Strikeout", na.rm = TRUE)
        all_whiffs <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
        
        # Calculate P/IP and P/BF for All row only
        # Convert IP from "X.Y" format to decimal (X + Y/3)
        ip_decimal <- if (all_ip != "0.0") {
          parts <- strsplit(all_ip, "\\.")[[1]]
          as.numeric(parts[1]) + as.numeric(parts[2])/3
        } else 0
        
        p_per_ip <- if (ip_decimal > 0) as.character(round(all_p / ip_decimal, 1)) else ""
        p_per_bf <- if (all_bf > 0) as.character(round(all_p / all_bf, 1)) else ""
        
        # Create all_row with dynamic split column name first
        all_row_data <- list()
        all_row_data[[split_col_name]] <- "All"
        all_row_data$IP <- all_ip
        all_row_data$P <- all_p
        all_row_data$BF <- all_bf
        all_row_data$`P/IP` <- p_per_ip
        all_row_data$`P/BF` <- p_per_bf
        all_row_data$H <- all_h
        all_row_data$XBH <- all_xbh
        all_row_data$Barrels <- all_barrels
        all_row_data$BB <- all_bb
        all_row_data$HBP <- all_hbp
        all_row_data$K <- all_k
        all_row_data$Whiffs <- all_whiffs
        all_row <- tibble::as_tibble(all_row_data)
        
        # Add empty P/IP and P/BF columns to per-type data
        raw_per_type$`P/IP` <- ""
        raw_per_type$`P/BF` <- ""
        
        # Reorder columns to match desired layout with dynamic split column name
        col_order <- c(split_col_name, "IP", "P", "BF", "P/IP", "P/BF", "H", "XBH", "Barrels", "BB", "HBP", "K", "Whiffs")
        raw_per_type <- raw_per_type[, col_order]
        all_row <- all_row[, col_order]
        
        df_raw <- dplyr::bind_rows(raw_per_type, all_row)
        
        visible_set <- names(df_raw)
        return(datatable_with_colvis(
          df_raw,
          lock            = split_col_name,
          remember        = FALSE,
          default_visible = visible_set,
          mode            = mode,
          enable_colors   = FALSE
        ))
      }
      
      # ---------- BATTED BALL DATA TABLE ----------
      if (identical(mode, "Batted Ball Data")) {
        # Helper function
        fmt_avg <- function(x) sprintf("%.3f", x)
        
        # Filter for completed PAs only (like Results table does)
        is_term <- (
          (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
            (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk"))
        )
        term <- df[is_term, , drop = FALSE]
        
        # Group by SplitColumn and calculate stats for each split
        per_type <- term %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            PA = dplyr::n(),  # Count completed PAs, not first pitches
            H1 = sum(PlayResult == "Single", na.rm = TRUE),
            H2 = sum(PlayResult == "Double", na.rm = TRUE),
            H3 = sum(PlayResult == "Triple", na.rm = TRUE),
            HR = sum(PlayResult == "HomeRun", na.rm = TRUE),
            BB = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
            IBB = sum(PlayResult == "IntentionalWalk", na.rm = TRUE),
            HBP = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            SF = sum(PlayResult == "Sacrifice", na.rm = TRUE),
            Inplay_All = sum(PitchCall == "InPlay", na.rm = TRUE),
            .groups = "drop"
          ) %>%
          dplyr::mutate(
            AB = PA - (BB + HBP + SF),
            H = H1 + H2 + H3 + HR,
            TB = 1*H1 + 2*H2 + 3*H3 + 4*HR,
            AVG = safe_div(H, AB),
            SLG = safe_div(TB, AB),
            OBP = safe_div(H + BB + HBP, PA),
            OPS = SLG + OBP,
            ISO = SLG - AVG,
            uBB = BB - IBB,
            wOBA_num = 0.690*uBB + 0.722*HBP + 0.888*H1 + 1.271*H2 + 1.616*H3 + 2.101*HR,
            wOBA_den = AB + BB - IBB + SF + HBP,
            wOBA = safe_div(wOBA_num, wOBA_den),
            BABIP = safe_div(H, Inplay_All)
          )
        
        # Calculate xWOBA, xISO, and Barrel% per split
        splits <- unique(df$SplitColumn)
        xstats_list <- lapply(splits, function(spl) {
          split_df <- df[df$SplitColumn == spl, , drop = FALSE]
          
          # Get BIP with EV/LA
          bip_evla <- split_df %>%
            dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                          is.finite(ExitSpeed), is.finite(Angle)) %>%
            dplyr::mutate(
              EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
              LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
            )
          
          xWOBA <- NA_real_
          xISO <- NA_real_
          
          if (exists("xbin_ref") && nrow(bip_evla) > 0) {
            bip_evla <- bip_evla %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
            for (nm in c("p1B","p2B","p3B","pHR")) {
              if (exists("x_overall") && nm %in% names(x_overall)) {
                bip_evla[[nm]][!is.finite(bip_evla[[nm]])] <- x_overall[[nm]]
              }
            }
            x1B <- sum(bip_evla$p1B, na.rm = TRUE)
            x2B <- sum(bip_evla$p2B, na.rm = TRUE)
            x3B <- sum(bip_evla$p3B, na.rm = TRUE)
            xHR <- sum(bip_evla$pHR, na.rm = TRUE)
            xH  <- x1B + x2B + x3B + xHR
            xTB <- 1*x1B + 2*x2B + 3*x3B + 4*xHR
            
            split_AB <- per_type$AB[per_type$SplitColumn == spl]
            xAVG <- safe_div(xH, split_AB)
            xSLG <- safe_div(xTB, split_AB)
            xISO <- xSLG - xAVG
            
            # xWOBA calculation
            split_BB <- per_type$BB[per_type$SplitColumn == spl]
            BF_live <- sum(split_df$SessionType == "Live" & split_df$Balls == 0 & split_df$Strikes == 0, na.rm = TRUE)
            if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
              xWOBA <- safe_div(W_BB*split_BB + W_1B*x1B + W_2B*x2B + W_3B*x3B + W_HR*xHR, BF_live)
            }
          }
          
          # Calculate Barrel%
          barrels <- sum(split_df$SessionType == "Live" & split_df$PitchCall == "InPlay" &
                           is.finite(split_df$ExitSpeed) & is.finite(split_df$Angle) &
                           split_df$ExitSpeed >= 95 & split_df$Angle >= 10 & split_df$Angle <= 35, na.rm = TRUE)
          inplay_live <- sum(split_df$SessionType == "Live" & split_df$PitchCall == "InPlay", na.rm = TRUE)
          BarrelPct <- safe_div(barrels, inplay_live)
          
          data.frame(
            SplitColumn = spl,
            xWOBA = xWOBA,
            xISO = xISO,
            `Barrel%` = BarrelPct,
            check.names = FALSE
          )
        })
        
        xstats <- do.call(rbind, xstats_list)
        
        # Merge with per_type
        batted_ball_data <- per_type %>%
          dplyr::left_join(xstats, by = "SplitColumn") %>%
          dplyr::transmute(
            !!split_col_name := as.character(SplitColumn),
            PA, AB, AVG, SLG, OBP, OPS, wOBA, xWOBA, ISO, xISO, BABIP, `Barrel%`
          ) %>%
          dplyr::mutate(
            AVG = ifelse(is.finite(AVG), fmt_avg(AVG), ""),
            SLG = ifelse(is.finite(SLG), fmt_avg(SLG), ""),
            OBP = ifelse(is.finite(OBP), fmt_avg(OBP), ""),
            OPS = ifelse(is.finite(OPS), fmt_avg(OPS), ""),
            wOBA = ifelse(is.finite(wOBA), fmt_avg(wOBA), ""),
            xWOBA = ifelse(is.finite(xWOBA), fmt_avg(xWOBA), ""),
            ISO = ifelse(is.finite(ISO), fmt_avg(ISO), ""),
            xISO = ifelse(is.finite(xISO), fmt_avg(xISO), ""),
            BABIP = ifelse(is.finite(BABIP), fmt_avg(BABIP), ""),
            `Barrel%` = ifelse(is.finite(`Barrel%`), paste0(round(`Barrel%`*100, 1), "%"), "")
          )
        
        # --- ALL row (ungrouped, same calculations) ---
        PA_all <- nrow(term)
        H1_all <- sum(term$PlayResult == "Single", na.rm = TRUE)
        H2_all <- sum(term$PlayResult == "Double", na.rm = TRUE)
        H3_all <- sum(term$PlayResult == "Triple", na.rm = TRUE)
        HR_all <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        BB_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        IBB_all <- sum(term$PlayResult == "IntentionalWalk", na.rm = TRUE)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        SF_all <- sum(term$PlayResult == "Sacrifice", na.rm = TRUE)
        Inplay_All_all <- sum(term$PitchCall == "InPlay", na.rm = TRUE)
        
        AB_all <- PA_all - (BB_all + HBP_all + SF_all)
        H_all <- H1_all + H2_all + H3_all + HR_all
        TB_all <- 1*H1_all + 2*H2_all + 3*H3_all + 4*HR_all
        
        # Calculate xWOBA, xISO, Barrel% for All row
        bip_evla_all <- df %>%
          dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                        is.finite(ExitSpeed), is.finite(Angle)) %>%
          dplyr::mutate(
            EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
            LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
          )
        
        xWOBA_all <- NA_real_
        xISO_all <- NA_real_
        
        if (exists("xbin_ref") && nrow(bip_evla_all) > 0) {
          bip_evla_all <- bip_evla_all %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
          for (nm in c("p1B","p2B","p3B","pHR")) {
            if (exists("x_overall") && nm %in% names(x_overall)) {
              bip_evla_all[[nm]][!is.finite(bip_evla_all[[nm]])] <- x_overall[[nm]]
            }
          }
          x1B_all <- sum(bip_evla_all$p1B, na.rm = TRUE)
          x2B_all <- sum(bip_evla_all$p2B, na.rm = TRUE)
          x3B_all <- sum(bip_evla_all$p3B, na.rm = TRUE)
          xHR_all <- sum(bip_evla_all$pHR, na.rm = TRUE)
          xH_all  <- x1B_all + x2B_all + x3B_all + xHR_all
          xTB_all <- 1*x1B_all + 2*x2B_all + 3*x3B_all + 4*xHR_all
          xAVG_all <- safe_div(xH_all, AB_all)
          xSLG_all <- safe_div(xTB_all, AB_all)
          xISO_all <- xSLG_all - xAVG_all
          
          BF_live_all <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
          if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
            xWOBA_all <- safe_div(W_BB*BB_all + W_1B*x1B_all + W_2B*x2B_all + W_3B*x3B_all + W_HR*xHR_all, BF_live_all)
          }
        }
        
        barrels_all <- sum(df$SessionType == "Live" & df$PitchCall == "InPlay" &
                             is.finite(df$ExitSpeed) & is.finite(df$Angle) &
                             df$ExitSpeed >= 95 & df$Angle >= 10 & df$Angle <= 35, na.rm = TRUE)
        inplay_live_all <- sum(df$SessionType == "Live" & df$PitchCall == "InPlay", na.rm = TRUE)
        BarrelPct_all <- safe_div(barrels_all, inplay_live_all)
        
        # Create All row with dynamic column name
        all_row_data <- list(
          PA = PA_all,
          AB = AB_all,
          AVG = safe_div(H_all, AB_all),
          SLG = safe_div(TB_all, AB_all),
          OBP = safe_div(H_all + BB_all + HBP_all, PA_all),
          OPS = NA_real_,
          wOBA = safe_div(0.690*(BB_all - IBB_all) + 0.722*HBP_all + 0.888*H1_all + 1.271*H2_all + 1.616*H3_all + 2.101*HR_all,
                          AB_all + BB_all - IBB_all + SF_all + HBP_all),
          xWOBA = xWOBA_all,
          ISO = safe_div(TB_all, AB_all) - safe_div(H_all, AB_all),
          xISO = xISO_all,
          BABIP = safe_div(H_all, Inplay_All_all),
          `Barrel%` = BarrelPct_all
        )
        all_row_data[[split_col_name]] <- "All"
        all_row <- tibble::as_tibble(all_row_data)
        all_row$OPS <- all_row$SLG + all_row$OBP
        
        # Format All row
        all_row <- all_row %>%
          dplyr::mutate(
            AVG = ifelse(is.finite(AVG), fmt_avg(AVG), ""),
            SLG = ifelse(is.finite(SLG), fmt_avg(SLG), ""),
            OBP = ifelse(is.finite(OBP), fmt_avg(OBP), ""),
            OPS = ifelse(is.finite(OPS), fmt_avg(OPS), ""),
            wOBA = ifelse(is.finite(wOBA), fmt_avg(wOBA), ""),
            xWOBA = ifelse(is.finite(xWOBA), fmt_avg(xWOBA), ""),
            ISO = ifelse(is.finite(ISO), fmt_avg(ISO), ""),
            xISO = ifelse(is.finite(xISO), fmt_avg(xISO), ""),
            BABIP = ifelse(is.finite(BABIP), fmt_avg(BABIP), ""),
            `Barrel%` = ifelse(is.finite(`Barrel%`), paste0(round(`Barrel%`*100, 1), "%"), "")
          )
        
        # Order pitch types correctly if Pitch Types is selected
        if (split_choice == "Pitch Types" && split_col_name == "Pitch" && exists("all_colors")) {
          pitch_order <- intersect(names(all_colors), batted_ball_data[[split_col_name]])
          if (length(pitch_order) > 0) {
            batted_ball_data[[split_col_name]] <- factor(batted_ball_data[[split_col_name]], levels = pitch_order)
            batted_ball_data <- batted_ball_data %>% dplyr::arrange(.data[[split_col_name]])
            batted_ball_data[[split_col_name]] <- as.character(batted_ball_data[[split_col_name]])
          }
        }
        
        # Bind rows
        df_out <- dplyr::bind_rows(batted_ball_data, all_row)
        
        table_cache <- df_out
        return(DT::datatable(
          df_out,
          options = list(
            dom = 't',
            scrollX = TRUE,
            paging = FALSE,
            ordering = FALSE
          ),
          rownames = FALSE
        ))
      }
      
      # ---------- NON-Results modes (your original build) ----------
      # QP+ per split type (scalar)
      qp_by_type <- df %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          `QP+` = {
            vals <- compute_qp_points(dplyr::cur_data_all())
            vals <- suppressWarnings(as.numeric(vals))
            round(mean(vals, na.rm = TRUE) * 200, 1)
          },
          .groups = "drop"
        )
      
      # Base per-split-type summary
      summ <- safe_make_summary(df, group_col = "SplitColumn")
      summ <- dplyr::mutate(summ,
                            ReleaseTilt = as.character(ReleaseTilt),
                            BreakTilt   = as.character(BreakTilt)
      )
      if (!("QP+" %in% names(summ))) {
        # join by PitchType in 'summ' to SplitColumn in qp_by_type
        summ <- summ %>% dplyr::left_join(qp_by_type, by = c("PitchType" = "SplitColumn"))
      }
      
      
      # Add Even/Ahead/Behind summary rows if splitting by Count (for non-Results modes)
      count_state_summ <- NULL
      if (split_choice == "Count" && "CountState" %in% names(df)) {
        for (state in c("Even", "Ahead", "Behind")) {
          state_df <- df %>% dplyr::filter(CountState == state)
          if (nrow(state_df) > 0) {
            state_summary <- safe_make_summary(
              state_df %>% dplyr::mutate(SplitColumn = state),
              group_col = "SplitColumn"
            )
            if ("SplitColumn" %in% names(state_summary)) {
              state_summary <- state_summary %>% dplyr::rename(PitchType = SplitColumn)
            }
            if (!("PitchType" %in% names(state_summary))) {
              state_summary$PitchType <- state
            }
            state_row <- state_summary %>%
              dplyr::mutate(
                PitchType = state,
                Usage = "",  # Calculate after binding
                Overall = ""
              )
            count_state_summ <- dplyr::bind_rows(count_state_summ, state_row)
          }
        }
        # Update Usage for count state rows
        if (!is.null(count_state_summ) && nrow(count_state_summ) > 0) {
          total_pitches <- nrow(df)
          count_state_summ <- count_state_summ %>%
            dplyr::mutate(Usage = paste0(round(100 * PitchCount / total_pitches, 1), "%"))
        }
      }
      
      # ---- Build FULL table (as before) ----
      df_table <- dplyr::bind_rows(
        summ,
        count_state_summ,
        {
          scores <- ifelse(
            df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
              df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
            ifelse(
              df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5),
              0.73, 0
            )
          )
          has_pc  <- sum(!is.na(df$PitchCall)) > 0
          strikes <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
          sw      <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
          den     <- sum(df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
          bf_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
          fps_opp <- bf_live
          k_live  <- sum(df$SessionType == "Live" & df$KorBB == "Strikeout",        na.rm = TRUE)
          bb_live <- sum(df$SessionType == "Live" & df$KorBB == "Walk",             na.rm = TRUE)
          fps_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0 &
                            df$PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
          ea_live  <- sum(df$SessionType == "Live" & (
            (df$Balls == 0 & df$Strikes == 0 & df$PitchCall == "InPlay") |
              (df$Balls == 0 & df$Strikes == 1 & df$PitchCall %in% c(
                "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
              )) |
              (df$Balls == 1 & df$Strikes == 0 & df$PitchCall == "InPlay") |
              (df$Balls == 1 & df$Strikes == 1 & df$PitchCall %in% c(
                "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
              ))
          ),
          na.rm = TRUE
          )
          
          vmax   <- suppressWarnings(max(as.numeric(df$RelSpeed), na.rm = TRUE)); vmax <- if (is.finite(vmax)) round(vmax, 1) else NA_real_
          ev_all <- nz_mean(ifelse(df$SessionType=="Live", df$ExitSpeed, NA_real_))
          la_all <- nz_mean(ifelse(df$SessionType=="Live", df$Angle,     NA_real_))
          stuff_all <- round(nz_mean(df$`Stuff+`), 1)
          ctrl_all   <- round(nz_mean(scores) * 100, 1)
          qp_all    <- round(nz_mean(compute_qp_points(df)) * 200, 1)
          
          # Calculate Swing% for All row
          swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","FoulBall","InPlay")
          swings_all <- sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE)
          swing_pct_all <- safe_pct(swings_all, nrow(df))
          
          tibble::tibble(
            PitchType     = "All",
            PitchCount    = nrow(df),
            Usage         = "100%",
            Overall       = "100%",
            BF            = bf_live,
            Velo_Avg      = round(nz_mean(df$RelSpeed), 1),
            Velo_Max      = vmax,
            IVB           = round(nz_mean(df$InducedVertBreak), 1),
            HB            = round(nz_mean(df$HorzBreak), 1),
            ReleaseTilt   = convert_to_clock(nz_mean(df$ReleaseTilt)),
            BreakTilt     = convert_to_clock(nz_mean(df$BreakTilt)),
            SpinEff       = nz_mean(df$SpinEfficiency),
            SpinRate      = round(nz_mean(df$SpinRate), 0),
            RelHeight     = round(nz_mean(df$RelHeight), 1),
            RelSide       = round(nz_mean(df$RelSide), 1),
            VertApprAngle = round(nz_mean(df$VertApprAngle), 1),
            HorzApprAngle = round(nz_mean(df$HorzApprAngle), 1),
            Extension     = round(nz_mean(df$Extension), 1),
            InZonePercent = { inzone <- (df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
                                           df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP)
            safe_pct(sum(inzone, na.rm=TRUE), sum(!is.na(inzone))) },
            CompPercent   = { comp <- (df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                                         df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5))
            safe_pct(sum(comp, na.rm=TRUE), sum(!is.na(comp))) },
            KPercent      = safe_pct(k_live, bf_live),
            BBPercent     = safe_pct(bb_live, bf_live),
            FPSPercent    = safe_pct(fps_live, fps_opp),
            EAPercent     = safe_pct(ea_live, fps_opp),
            StrikePercent = if (has_pc) safe_pct(strikes, nrow(df)) else "",
            SwingPercent  = swing_pct_all,
            WhiffPercent  = safe_pct(sw, den),
            EV = ev_all, LA = la_all,
            `Stuff+` = stuff_all, `Ctrl+` = ctrl_all, `QP+` = qp_all
          ) %>% dplyr::mutate(`Pitching+` = round((`Stuff+` + `QP+`)/2, 1))
        }
      ) %>%
        dplyr::rename(
          !!split_col_name := PitchType,
          `#`    = PitchCount,
          Velo   = Velo_Avg,
          Max    = Velo_Max,
          rTilt  = ReleaseTilt,
          bTilt  = BreakTilt,
          Spin   = SpinRate,
          Height = RelHeight,
          Side   = RelSide,
          Ext    = Extension,
          `InZone%` = InZonePercent,
          `Comp%`   = CompPercent,
          `K%`      = KPercent,
          `BB%`     = BBPercent,
          `FPS%`    = FPSPercent,
          `E+A%`    = EAPercent,
          `QP%`     = QPPercent,
          `Strike%` = StrikePercent,
          `Swing%`  = SwingPercent,
          `Whiff%`  = WhiffPercent,
          VAA       = VertApprAngle,
          HAA       = HorzApprAngle
        ) %>%
        dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]])) %>%
        dplyr::select(
          !!split_col_name, `#`, Usage, Overall,
          dplyr::any_of(c("0-0","Behind","Even","Ahead","<2K","2K")),
          BF,
          Velo, Max, IVB, HB, rTilt, bTilt, SpinEff, Spin, Height, Side, VAA, HAA, Ext,
          `InZone%`, `Comp%`, `Strike%`, `Swing%`, `FPS%`, `E+A%`, `QP%`, `K%`, `BB%`, `Whiff%`, EV, LA,
          `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
        ) %>%
        dplyr::mutate(
          SpinEff = {
            val <- suppressWarnings(as.numeric(SpinEff))
            ifelse(is.na(val), "", paste0(round(val * 100, 1), "%"))
          },
          EV = ifelse(is.na(as.numeric(EV)), "", round(as.numeric(EV), 1)),
          LA = ifelse(is.na(as.numeric(LA)), "", round(as.numeric(LA), 1))
        )
      
      # Add Process/Results columns and SANITIZE for DT
      extras <- compute_process_results(df, mode)
      if ("PitchType" %in% names(extras)) {
        extras <- extras %>%
          dplyr::rename(!!split_col_name := PitchType) %>%
          dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
        df_table <- df_table %>% dplyr::left_join(extras, by = split_col_name)
      }
      df_table <- fill_all_qp_pct(df_table, df)
      
      if (identical(mode, "Usage")) {
        usage_extras <- compute_usage_by_count(df)
        if ("PitchType" %in% names(usage_extras)) {
          usage_extras <- usage_extras %>%
            dplyr::rename(!!split_col_name := PitchType) %>%
            dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]])) %>%
            dplyr::select(!!split_col_name, `0-0`,`Behind`,`Even`,`Ahead`,`<2K`,`2K`)
          df_table <- df_table %>% dplyr::left_join(usage_extras, by = split_col_name)
        }
      }
      
      # Sort by IVB/HB in descending order if applicable
      df_table <- sort_by_range(df_table, split_col_name, split_choice)
      
      df_table <- collapse_list_cols(df_table)
      is_date_like <- function(x) inherits(x, c("Date","POSIXct","POSIXt","difftime"))
      date_like <- vapply(df_table, is_date_like, logical(1))
      if (any(date_like)) df_table[date_like] <- lapply(df_table[date_like], as.character)
      df_table <- as.data.frame(df_table, stringsAsFactors = FALSE, check.names = FALSE)
      
      if (all(c("Whiff%","CSW%") %in% names(df_table))) {
        df_table <- df_table %>% dplyr::relocate(`CSW%`, .after = `Whiff%`)
      }
      if ("Pitching+" %in% names(df_table)) {
        df_table <- df_table %>% dplyr::relocate(`Pitching+`, .after = dplyr::last_col())
      }
      
      df_table <- enforce_process_order(df_table)
      df_table <- enforce_stuff_order(df_table)
      
      # Hide RV/100 in Results mode (keep it for Process/Performance only)
      if (identical(mode, "Results") && "RV/100" %in% names(df_table)) {
        df_table <- dplyr::select(df_table, -`RV/100`)
      }
      if (identical(mode, "Custom")) {
        order_cols <- unique(c(split_col_name, custom))
        extras <- setdiff(names(df_table), order_cols)
        df_table <- df_table[, c(order_cols, extras), drop = FALSE]
      }
      
      # Update visible_set to use dynamic column name
      visible_set <- visible_set_for(mode, custom)
      visible_set <- gsub("^Pitch$", split_col_name, visible_set)
      
      build_summary_dt <- function(data, ...) {
        tryCatch(
          datatable_with_colvis(data, ...),
          error = function(e) {
            message("summaryTablePage datatable error [mode=", mode, "]: ", conditionMessage(e))
            message("Columns: ", paste(names(data), collapse = ", "))
            # Return a fallback datatable with error message instead of stopping
            DT::datatable(
              data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
              options = list(dom = 't'), rownames = FALSE
            )
          }
        )
      }
      table_cache <- list(
        table = df_table,
        source = df,
        label_column = split_col_name,
        split_choice = split_choice
      )
      build_summary_dt(
        df_table,
        lock            = split_col_name,
        remember        = FALSE,
        default_visible = intersect(visible_set, names(df_table)),
        mode            = mode,
        enable_colors   = isTRUE(input$summaryTableColors)
      )
    }, error = function(e) {
      message("summaryTablePage top-level error: ", conditionMessage(e))
      # Return a fallback datatable with error message
      DT::datatable(
        data.frame(Error = paste("Critical table error:", conditionMessage(e))),
        options = list(dom = 't'), rownames = FALSE
      )
    })
  })
  
  # ----- Custom table save/load (Summary & DP) -----
  observeEvent(input$summaryCustomSaved, {
    nm <- input$summaryCustomSaved
    if (!nzchar(nm)) return()
    ct <- custom_tables()
    if (!nm %in% names(ct)) return()
    cols <- ct[[nm]]$cols %||% character(0)
    updateTextInput(session, "summaryCustomName", value = nm)
    updateSelectizeInput(session, "summaryCustomCols", selected = cols)
  }, ignoreInit = TRUE)
  observeEvent(input$summarySaveCustom, {
    nm <- trimws(input$summaryCustomName %||% "")
    cols <- input$summaryCustomCols %||% character(0)
    if (!nzchar(nm) || !length(cols)) {
      showNotification("Please enter a name and choose at least one column.", type = "warning")
      return()
    }
    scope <- if (isTRUE(is_admin()) && isTRUE(input$summaryCustomGlobal)) GLOBAL_SCOPE else current_school()
    ct <- custom_tables()
    ct[[nm]] <- list(cols = cols, school_code = scope)
    custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
    updateSelectInput(session, "summaryCustomSaved", choices = c("", names(ct)), selected = nm)
    showNotification(paste("Saved custom table", nm), type = "message")
  }, ignoreInit = TRUE)
  observeEvent(input$summaryDeleteCustom, {
    nm <- input$summaryCustomSaved
    if (!nzchar(nm)) return()
    ct <- custom_tables()
    if (nm %in% names(ct)) {
      ct[[nm]] <- NULL
      custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
      updateSelectInput(session, "summaryCustomSaved", choices = c("", names(ct)), selected = "")
      showNotification(paste("Deleted custom table", nm), type = "message")
    }
  }, ignoreInit = TRUE)
  
  observeEvent(input$dpCustomSaved, {
    nm <- input$dpCustomSaved
    if (!nzchar(nm)) return()
    ct <- custom_tables()
    if (!nm %in% names(ct)) return()
    cols <- ct[[nm]]$cols %||% character(0)
    updateTextInput(session, "dpCustomName", value = nm)
    updateSelectizeInput(session, "dpCustomCols", selected = cols)
  }, ignoreInit = TRUE)
  observeEvent(input$dpSaveCustom, {
    nm <- trimws(input$dpCustomName %||% "")
    cols <- input$dpCustomCols %||% character(0)
    if (!nzchar(nm) || !length(cols)) {
      showNotification("Please enter a name and choose at least one column.", type = "warning")
      return()
    }
    scope <- if (isTRUE(is_admin()) && isTRUE(input$dpCustomGlobal)) GLOBAL_SCOPE else current_school()
    ct <- custom_tables()
    ct[[nm]] <- list(cols = cols, school_code = scope)
    custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
    updateSelectInput(session, "dpCustomSaved", choices = c("", names(ct)), selected = nm)
    showNotification(paste("Saved custom table", nm), type = "message")
  }, ignoreInit = TRUE)
  observeEvent(input$dpDeleteCustom, {
    nm <- input$dpCustomSaved
    if (!nzchar(nm)) return()
    ct <- custom_tables()
    if (nm %in% names(ct)) {
      ct[[nm]] <- NULL
      custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
      updateSelectInput(session, "dpCustomSaved", choices = c("", names(ct)), selected = "")
      showNotification(paste("Deleted custom table", nm), type = "message")
    }
  }, ignoreInit = TRUE)
  # -----------------------------
  # Data & Performance table (DP)
  # -----------------------------
  output$summaryTable <- DT::renderDataTable({
    df <- filtered_data()
    table_cache <- NULL
    on.exit({
      session$userData$table_cache_summaryTable <- table_cache
    }, add = TRUE)
    if (!nrow(df)) {
      return(DT::datatable(
        data.frame(Message = "No data for selected filters"),
        options = list(dom = 't'), rownames = FALSE
      ))
    }
    
    # Apply Split By transformation
    split_choice <- if (!is.null(input$dpSplitBy)) input$dpSplitBy else "Pitch Types"
    df <- apply_split_by(df, split_choice)
    
    # Determine the column name based on split choice
    split_col_name <- switch(
      split_choice,
      "Pitch Types" = "Pitch",
      "Batter Hand" = "Batter Hand",
      "Count" = "Count",
      "After Count" = "After Count",
      "Velocity" = "Velocity",
      "IVB" = "InducedVert",
      "HB" = "HorzBreak",
      "Batter" = "Batter",
      "Pitch"  # default
    )
    
    # --- small helpers (match Hitting logic) ---
    nz_mean <- function(x) { x <- suppressWarnings(as.numeric(x)); m <- mean(x, na.rm = TRUE); if (is.finite(m)) m else NA_real_ }
    fmt_avg <- function(x) { z <- ifelse(is.finite(x), sprintf("%.3f", x), NA_character_); sub("^0", "", z) }
    safe_div <- function(num, den) ifelse(den > 0, num/den, NA_real_)
    parse_num <- function(x) {
      if (is.numeric(x)) return(x)
      x1 <- trimws(as.character(x)); x1[x1 == ""] <- NA_character_
      ifelse(grepl("%$", x1), suppressWarnings(as.numeric(sub("%$","",x1)))/100,
             suppressWarnings(as.numeric(x1)))
    }
    ip_fmt <- function(ip_raw) {
      out <- rep("", length(ip_raw))
      ok  <- is.finite(ip_raw) & ip_raw > 0
      outs <- floor(ip_raw[ok]*3 + 1e-8)
      inn  <- outs %/% 3
      rem  <- outs %% 3
      out[ok] <- paste0(inn, ".", rem)
      out
    }
    FIP_C <- if (exists("FIP_CONST")) get("FIP_CONST") else 3.20
    
    # prefer DP page controls; fall back to Summary page controls; resolve saved custom tables
    res_mode <- resolve_table_mode_global(
      if (!is.null(input$dpTableMode)) input$dpTableMode else input$summaryTableMode,
      if (!is.null(input$dpCustomCols)) input$dpCustomCols else input$summaryCustomCols
    )
    mode <- res_mode$mode
    custom <- res_mode$cols
    
    # Fallback visible-set helper if your global helper isn't in scope
    if (!exists("visible_set_for")) {
      visible_set_for <- function(mode, custom) {
        base <- c("Pitch","#","Usage","BF","IP","FIP","WHIP","Velo","Max","IVB","HB","rTilt","bTilt","SpinEff","Spin",
                  "Height","Side","VAA","HAA","Ext","InZone%","Comp%","Strike%","FPS%","E+A%","QP%",
                  "K%","BB%","Whiff%","EV","LA","Stuff+","Ctrl+","QP+","Pitching+",
                  # Results-specific
                  "PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP","GB%","Barrel%","Swing%","Whiff%","K%","BB%","EV","LA"
        )
        if (identical(mode, "Custom") && length(custom)) unique(c("Pitch", custom)) else base
      }
    }
    
    # ---------- RESULTS TABLE (fixes inflated BIP rates) ----------
    if (identical(mode, "Results")) {
      swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
      
      # Terminal rows = completed PA
      is_term <- (
        (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
          (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk"))
      )
      term <- df[is_term, , drop = FALSE]
      
      # Per-split-type tallies (PA/AB/H/K/BB/HBP/Sac/HR)
      per_type <- term %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          PA   = dplyr::n(),
          HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
          Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
          `1B` = sum(PlayResult == "Single",  na.rm = TRUE),
          `2B` = sum(PlayResult == "Double",  na.rm = TRUE),
          `3B` = sum(PlayResult == "Triple",  na.rm = TRUE),
          HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
          Kct  = sum(KorBB == "Strikeout" |
                       PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
          BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(
          AB  = PA - (BBct + HBP + Sac),
          H   = `1B` + `2B` + `3B` + HR,
          TB  = 1*`1B` + 2*`2B` + 3*`3B` + 4*HR,
          AVG = safe_div(H, AB),
          SLG = safe_div(TB, AB),
          OBP = safe_div(H + BBct + HBP, PA),
          OPS = SLG + OBP
        )
      
      # Pitch totals for Usage/Swing%/Whiff%
      pitch_totals <- df %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          Pitches       = dplyr::n(),
          Swings        = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
          Whiffs        = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
          CalledStrikes = sum(PitchCall == "StrikeCalled",    na.rm = TRUE),
          .groups = "drop"
        )
      total_pitches <- sum(pitch_totals$Pitches, na.rm = TRUE)
      
      # Command scoring vector and per-type Command+ / Stuff+ / Pitching+
      scores <- ifelse(
        df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
          df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
        ifelse(
          df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
            df$PlateLocHeight >= (2.65 - 1.5) & df$PlateLocHeight <= (2.65 + 1.5),
          0.73, 0
        )
      )
      sc_by_type <- df %>%
        dplyr::mutate(.scores = scores) %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          StuffP   = round(nz_mean(`Stuff+`), 1),
          CommandP = round(nz_mean(.scores) * 100, 1),
          .groups = "drop"
        ) %>%
        dplyr::mutate(PitchingP = round((StuffP + CommandP)/2, 1))
      
      # Live balls in play for EV/LA and GB%
      bbe <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
      evla <- bbe %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(EV = nz_mean(ExitSpeed), LA = nz_mean(Angle), .groups = "drop")
      gb <- bbe %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          `GB%` = safe_div(sum(TaggedHitType == "GroundBall", na.rm = TRUE),
                           sum(!is.na(TaggedHitType),        na.rm = TRUE)),
          .groups = "drop"
        )
      
      # Extras (xWOBA/xISO/BABIP/Barrel%) — numeric
      extras_raw <- compute_process_results(df)
      if ("PitchType" %in% names(extras_raw)) {
        extras <- extras_raw %>%
          dplyr::rename(SplitColumn = PitchType) %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::select(SplitColumn, xWOBA, xISO, BABIP, `Barrel%`, `RV/100`)
      } else {
        extras <- df %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            xWOBA = NA_real_, xISO = NA_real_, 
            BABIP = NA_real_, `Barrel%` = NA_real_, `RV/100` = NA_real_,
            .groups = "drop"
          )
      }
      
      # Build per-type rows (+ #, Usage, BF, IP, FIP, WHIP, Pitching+)
      res_pt <- per_type %>%
        dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
        dplyr::left_join(evla,         by = "SplitColumn") %>%
        dplyr::left_join(gb,           by = "SplitColumn") %>%
        dplyr::mutate(
          `Swing%` = safe_div(Swings, Pitches),
          `Whiff%` = safe_div(Whiffs, Swings),
          `CSW%`   = safe_div(Whiffs + CalledStrikes, Pitches),
          Outs     = (AB - H) + Sac,
          IP_raw   = safe_div(Outs, 3),
          BF       = PA,
          `#`      = Pitches,
          Usage    = ifelse(total_pitches > 0, paste0(round(100*Pitches/total_pitches,1), "%"), ""),
          FIP_tmp  = safe_div(13*HR + 3*(BBct + HBP) - 2*Kct, IP_raw),
          FIP      = ifelse(is.finite(FIP_tmp), round(FIP_tmp + FIP_C, 2), NA_real_),
          WHIP_tmp = safe_div(H + BBct, IP_raw),
          WHIP     = ifelse(is.finite(WHIP_tmp), round(WHIP_tmp, 2), NA_real_)
        ) %>%
        dplyr::left_join(sc_by_type, by = "SplitColumn") %>%
        dplyr::left_join(extras, by = "SplitColumn") %>%
        dplyr::transmute(
          !!split_col_name := as.character(SplitColumn),
          `#`, Usage, BF, `RV/100`, IP = ip_fmt(IP_raw), FIP, WHIP,
          PA, AB, AVG, SLG, OBP, OPS,
          xWOBA, xISO, BABIP,
          `Swing%`, `Whiff%`, `CSW%`, `GB%`,
          `K%` = safe_div(Kct, PA), `BB%` = safe_div(BBct, PA),
          `Barrel%`, EV, LA,
          `Pitching+` = PitchingP
        )
      
      # --- ALL row (same definitions, ungrouped) ---
      PAt <- nrow(term)
      HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
      Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
      H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
      H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
      H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
      HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
      H   <- H1 + H2 + H3 + HR
      TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
      Kct_all <- sum(term$KorBB == "Strikeout" |
                       term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
      BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
      ABt <- PAt - (BBc_all + HBP_all + Sac_all)
      swings  <- sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE)
      whiffs  <- sum(df$PitchCall == "StrikeSwinging",                      na.rm = TRUE)
      csw_all_num <- sum(df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
      gbpct_all <- {
        d <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
        safe_div(sum(d$TaggedHitType == "GroundBall", na.rm = TRUE),
                 sum(!is.na(d$TaggedHitType),         na.rm = TRUE))
      }
      Outs_all <- (ABt - H) + Sac_all
      IP_all   <- safe_div(Outs_all, 3)
      FIP_all  <- {
        tmp <- safe_div(13*HR + 3*(BBc_all + HBP_all) - 2*Kct_all, IP_all)
        ifelse(is.finite(tmp), round(tmp + FIP_C, 2), NA_real_)
      }
      WHIP_all <- {
        tmp <- safe_div(H + BBc_all, IP_all)
        ifelse(is.finite(tmp), round(tmp, 2), NA_real_)
      }
      # Pitching+ for All row
      stuff_all <- round(nz_mean(df$`Stuff+`), 1)
      qp_all <- round(nz_mean(compute_qp_points(df)) * 200, 1)
      pitc_all <- round((stuff_all + qp_all) / 2, 1)
      
      # Create all_row with dynamic column name
      all_row_data <- list(
        `#`   = nrow(df),
        Usage = "100%",
        BF = PAt,
        `RV/100` = "",
        IP = ip_fmt(IP_all),
        FIP = FIP_all,
        WHIP = WHIP_all,
        PA = PAt, AB = ABt,
        AVG = safe_div(H, ABt),
        SLG = safe_div(TB, ABt),
        OBP = safe_div(H + BBc_all + HBP_all, PAt),
        OPS = NA_real_,
        xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
        `Swing%` = safe_div(swings, total_pitches),
        `Whiff%` = safe_div(whiffs, swings),
        `CSW%`   = safe_div(csw_all_num, total_pitches),
        `GB%`    = gbpct_all,
        `K%`     = safe_div(Kct_all, PAt),
        `BB%`    = safe_div(BBc_all, PAt),
        `Barrel%`= NA_real_,
        EV = nz_mean(bbe$ExitSpeed),
        LA = nz_mean(bbe$Angle),
        `Pitching+` = pitc_all
      )
      all_row_data[[split_col_name]] <- "All"
      all_row <- tibble::as_tibble(all_row_data)
      all_row$OPS <- all_row$SLG + all_row$OBP
      
      # Fill extras (All)
      extras_all <- compute_process_results(df, mode) %>%
        dplyr::mutate(
          xWOBA     = parse_num(xWOBA),
          xISO      = parse_num(xISO),
          BABIP     = parse_num(BABIP),
          `Barrel%` = parse_num(`Barrel%`),
          `RV/100`  = parse_num(`RV/100`)
        ) %>%
        dplyr::summarise(
          xWOBA     = nz_mean(xWOBA),
          xISO      = nz_mean(xISO),
          BABIP     = nz_mean(BABIP),
          `Barrel%` = nz_mean(`Barrel%`),
          `RV/100`  = nz_mean(`RV/100`),
          .groups = "drop"
        )
      if (nrow(extras_all)) {
        all_row$xWOBA     <- extras_all$xWOBA[1]
        all_row$xISO      <- extras_all$xISO[1]
        all_row$BABIP     <- extras_all$BABIP[1]
        all_row$`Barrel%` <- extras_all$`Barrel%`[1]
        all_row$`RV/100`  <- extras_all$`RV/100`[1]
      }
      
      # Add Even/Ahead/Behind summary rows if splitting by Count (Data & Performance)
      dp_count_state_rows <- NULL
      if (split_choice == "Count" && "CountState" %in% names(df)) {
        swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","FoulBall","InPlay")
        calc_rv100 <- function(dfi) {
          dfi_live <- dfi %>% dplyr::filter(SessionType == "Live")
          dfi_use  <- if (nrow(dfi_live)) dfi_live else dfi
          if (!nrow(dfi_use)) return(NA_real_)
          run_val <- function(pitch_call, play_result, korbb = NA) {
            pitch_call  <- as.character(pitch_call)
            play_result <- as.character(play_result)
            korbb       <- as.character(korbb)
            if (!is.na(korbb) && nzchar(korbb) && korbb != "NA") {
              if (korbb == "Strikeout") return(-0.27)
              if (korbb == "Walk")     return(0.33)
            }
            if (pitch_call %in% c("BallCalled", "BallIntentional", "BallinDirt")) return(0.03)
            if (pitch_call %in% c("StrikeCalled", "StrikeSwinging", "FoulBall",
                                  "FoulBallFieldable", "FoulBallNotFieldable"))  return(-0.03)
            if (pitch_call == "HitByPitch" || play_result %in% c("Walk","IntentionalWalk","HitByPitch")) return(0.33)
            if (pitch_call == "InPlay") {
              if (play_result == "Single")   return(0.47)
              if (play_result == "Double")   return(0.78)
              if (play_result == "Triple")   return(1.09)
              if (play_result == "HomeRun")  return(1.40)
              if (play_result == "Error")    return(0.33)
              return(-0.27)
            }
            0
          }
          rv_vals <- mapply(
            run_val,
            dfi_use$PitchCall,
            dfi_use$PlayResult,
            if ("KorBB" %in% names(dfi_use)) dfi_use$KorBB else NA
          )
          rv_val <- ((sum(rv_vals, na.rm = TRUE) / nrow(dfi_use)) * 100) - 0.43
          ifelse(is.finite(rv_val), rv_val, NA_real_)
        }
        for (state in c("Even", "Ahead", "Behind")) {
          state_df <- df %>% dplyr::filter(CountState == state)
          state_term <- term %>% dplyr::filter(CountState == state)
          
          if (nrow(state_df) > 0) {
            # Similar calculations as for individual counts
            state_PA <- nrow(state_term)
            state_HBP <- sum(state_term$PlayResult == "HitByPitch", na.rm = TRUE)
            state_Sac <- sum(state_term$PlayResult == "Sacrifice", na.rm = TRUE)
            state_H1 <- sum(state_term$PlayResult == "Single", na.rm = TRUE)
            state_H2 <- sum(state_term$PlayResult == "Double", na.rm = TRUE)
            state_H3 <- sum(state_term$PlayResult == "Triple", na.rm = TRUE)
            state_HR <- sum(state_term$PlayResult == "HomeRun", na.rm = TRUE)
            state_H <- state_H1 + state_H2 + state_H3 + state_HR
            state_TB <- 1*state_H1 + 2*state_H2 + 3*state_H3 + 4*state_HR
            state_Kct <- sum(state_term$KorBB == "Strikeout" |
                               state_term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
            state_BBct <- sum(state_term$KorBB == "Walk" | state_term$PlayResult == "Walk", na.rm = TRUE)
            state_AB <- state_PA - (state_BBct + state_HBP + state_Sac)
            
            state_swings <- sum(!is.na(state_df$PitchCall) & state_df$PitchCall %in% swing_levels, na.rm = TRUE)
            state_whiffs <- sum(state_df$PitchCall == "StrikeSwinging", na.rm = TRUE)
            state_csw <- sum(state_df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
            state_bbe <- state_df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
            state_gbpct <- safe_div(sum(state_bbe$TaggedHitType == "GroundBall", na.rm = TRUE),
                                    sum(!is.na(state_bbe$TaggedHitType), na.rm = TRUE))
            
            # Calculate BABIP for count state
            state_inplay_all <- sum(state_df$PitchCall == "InPlay", na.rm = TRUE)
            state_BABIP <- safe_div(state_H, state_inplay_all)
            
            # Calculate Barrel% for count state
            state_barrels <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay" &
                                   is.finite(state_df$ExitSpeed) & is.finite(state_df$Angle) &
                                   state_df$ExitSpeed >= 95 & state_df$Angle >= 10 & state_df$Angle <= 35, na.rm = TRUE)
            state_inplay_live <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay", na.rm = TRUE)
            state_BarrelPct <- safe_div(state_barrels, state_inplay_live)
            
            # Calculate xWOBA and xISO for count state (using expected stats if available)
            state_bip_evla <- state_df %>%
              dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                            is.finite(ExitSpeed), is.finite(Angle)) %>%
              dplyr::mutate(
                EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
                LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
              )
            if (exists("xbin_ref") && nrow(state_bip_evla) > 0) {
              state_bip_evla <- state_bip_evla %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
              for (nm in c("p1B","p2B","p3B","pHR")) {
                if (exists("x_overall") && nm %in% names(x_overall)) {
                  state_bip_evla[[nm]][!is.finite(state_bip_evla[[nm]])] <- x_overall[[nm]]
                }
              }
              state_x1B <- sum(state_bip_evla$p1B, na.rm = TRUE)
              state_x2B <- sum(state_bip_evla$p2B, na.rm = TRUE)
              state_x3B <- sum(state_bip_evla$p3B, na.rm = TRUE)
              state_xHR <- sum(state_bip_evla$pHR, na.rm = TRUE)
              state_xH   <- state_x1B + state_x2B + state_x3B + state_xHR
              state_xTB  <- 1*state_x1B + 2*state_x2B + 3*state_x3B + 4*state_xHR
              state_xAVG <- safe_div(state_xH, state_AB)
              state_xSLG <- safe_div(state_xTB, state_AB)
              state_xISO <- state_xSLG - state_xAVG
              # xWOBA calculation (using weights if they exist)
              state_BF_live <- sum(state_df$SessionType == "Live" & state_df$Balls == 0 & state_df$Strikes == 0, na.rm = TRUE)
              if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
                state_xWOBA <- safe_div(W_BB*state_BBct + W_1B*state_x1B + W_2B*state_x2B + W_3B*state_x3B + W_HR*state_xHR, state_BF_live)
              } else {
                state_xWOBA <- NA_real_
              }
            } else {
              state_xWOBA <- NA_real_
              state_xISO <- NA_real_
            }
            
            state_Outs <- (state_AB - state_H) + state_Sac
            state_IP <- safe_div(state_Outs, 3)
            state_FIP <- {
              tmp <- safe_div(13*state_HR + 3*(state_BBct + state_HBP) - 2*state_Kct, state_IP)
              ifelse(is.finite(tmp), round(tmp + FIP_C, 2), NA_real_)
            }
            state_WHIP <- {
              tmp <- safe_div(state_H + state_BBct, state_IP)
              ifelse(is.finite(tmp), round(tmp, 2), NA_real_)
            }
            
            # Calculate InZone%, Strike%, and Comp% for count state
            state_inzone <- sum(state_df$PlateLocSide >= ZONE_LEFT & state_df$PlateLocSide <= ZONE_RIGHT &
                                  state_df$PlateLocHeight >= ZONE_BOTTOM & state_df$PlateLocHeight <= ZONE_TOP, na.rm = TRUE)
            state_InZonePct <- safe_div(state_inzone, nrow(state_df))
            
            state_strikes <- sum(state_df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
            state_StrikePct <- safe_div(state_strikes, nrow(state_df))
            
            state_comp <- sum(state_df$PlateLocSide >= -1.5 & state_df$PlateLocSide <= 1.5 &
                                state_df$PlateLocHeight >= (2.65-1.5) & state_df$PlateLocHeight <= (2.65+1.5), na.rm = TRUE)
            state_CompPct <- safe_div(state_comp, nrow(state_df))
            
            state_pitches <- nrow(state_df)
            state_rv100 <- calc_rv100(state_df)
            pitching_plus <- if ("Pitching+" %in% names(state_df)) round(nz_mean(state_df$`Pitching+`), 1) else round(nz_mean(state_df$`Stuff+`), 1)
            state_row_data <- list(
              `#` = state_pitches,
              Usage = ifelse(total_pitches > 0, paste0(round(100*state_pitches/total_pitches, 1), "%"), ""),
              BF = state_PA,
              `RV/100` = ifelse(is.finite(state_rv100), state_rv100, NA_real_),
              IP = ip_fmt(state_IP),
              FIP = state_FIP,
              WHIP = state_WHIP,
              PA = state_PA,
              AB = state_AB,
              AVG = safe_div(state_H, state_AB),
              SLG = safe_div(state_TB, state_AB),
              OBP = safe_div(state_H + state_BBct + state_HBP, state_PA),
              OPS = NA_real_,
              xWOBA = state_xWOBA,
              xISO = state_xISO,
              BABIP = state_BABIP,
              `InZone%` = state_InZonePct,
              `Strike%` = state_StrikePct,
              `Comp%` = state_CompPct,
              `Swing%` = safe_div(state_swings, state_pitches),
              `Whiff%` = safe_div(state_whiffs, state_swings),
              `CSW%` = safe_div(state_csw, state_pitches),
              `GB%` = state_gbpct,
              `K%` = safe_div(state_Kct, state_PA),
              `BB%` = safe_div(state_BBct, state_PA),
              `Barrel%` = state_BarrelPct,
              EV = nz_mean(state_bbe$ExitSpeed),
              LA = nz_mean(state_bbe$Angle),
              `Pitching+` = pitching_plus
            )
            state_row_data[[split_col_name]] <- state
            state_row <- tibble::as_tibble(state_row_data)
            state_row$OPS <- state_row$SLG + state_row$OBP
            
            dp_count_state_rows <- dplyr::bind_rows(dp_count_state_rows, state_row)
          }
        }
      }
      
      # Order pitch types correctly if Pitch Types is selected
      if (split_choice == "Pitch Types" && split_col_name == "Pitch" && exists("all_colors")) {
        pitch_order <- intersect(names(all_colors), res_pt[[split_col_name]])
        if (length(pitch_order) > 0) {
          res_pt[[split_col_name]] <- factor(res_pt[[split_col_name]], levels = pitch_order)
          res_pt <- res_pt %>% dplyr::arrange(.data[[split_col_name]])
          res_pt[[split_col_name]] <- as.character(res_pt[[split_col_name]])
        }
      }
      
      # Bind + format
      df_out <- dplyr::bind_rows(res_pt, dp_count_state_rows, all_row) %>%
        dplyr::mutate(
          dplyr::across(c(PA, AB, AVG, SLG, OBP, OPS, xWOBA, xISO, BABIP,
                          `Swing%`, `Whiff%`, `CSW%`, `GB%`, `K%`, `BB%`, `Barrel%`,
                          EV, LA, FIP, WHIP),
                        ~ suppressWarnings(as.numeric(.)))
        )
      pct_cols  <- c("Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%")
      rate_cols <- c("AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP")
      df_out[pct_cols]  <- lapply(df_out[pct_cols],  function(z) ifelse(is.finite(z), paste0(round(z*100,1), "%"), ""))
      df_out[rate_cols] <- lapply(df_out[rate_cols], function(z) ifelse(is.finite(z), fmt_avg(z), ""))
      df_out$EV   <- ifelse(is.finite(df_out$EV),   round(df_out$EV, 1), "")
      df_out$LA   <- ifelse(is.finite(df_out$LA),   round(df_out$LA, 1), "")
      df_out$FIP  <- ifelse(is.finite(df_out$FIP),  sprintf("%.2f", df_out$FIP), "")
      df_out$WHIP <- ifelse(is.finite(df_out$WHIP), sprintf("%.2f", df_out$WHIP), "")
      df_out$`RV/100` <- {
        z <- suppressWarnings(as.numeric(df_out$`RV/100`))
        ifelse(is.finite(z), fmt_num2(z), "")
      }
      
      # Sort by IVB/HB in descending order if applicable
      df_out <- sort_by_range(df_out, split_col_name, split_choice)
      
      df_dt <- if (exists("safe_for_dt")) safe_for_dt(df_out) else df_out
      is_all <- df_dt[[split_col_name]] == "All"
      for (nm in c("Swing%","Whiff%","CSW%","GB%","K%","BB%")) {
        z <- df_dt[[nm]]
        z[is_all & (is.na(z) | trimws(z) == "")] <- "0.0%"
        df_dt[[nm]] <- z
      }
      
      # Update visible_set to use dynamic column name
      visible_set <- visible_set_for(mode, custom)
      visible_set <- gsub("^Pitch$", split_col_name, visible_set)
      if (identical(mode, "Custom")) {
        order_cols <- unique(c(split_col_name, custom))
        extras <- setdiff(names(df_dt), order_cols)
        df_dt <- df_dt[, c(order_cols, extras), drop = FALSE]
      }
      
      table_cache <- df_dt
      return(datatable_with_colvis(
        df_dt,
        lock            = split_col_name,
        remember        = FALSE,
        default_visible = intersect(visible_set, names(df_dt)),
        mode            = mode,
        enable_colors   = isTRUE(input$dpTableColors)
      ))
    }
    
    # ---------- RAW DATA TABLE ----------
    if (identical(mode, "Raw Data")) {
      # Helper function for innings pitched calculation
      ip_calculation <- function(pitches_data) {
        outs <- sum(pitches_data$KorBB == "Strikeout", na.rm = TRUE) + 
          sum(pitches_data$PlayResult %in% c("Out", "FieldersChoice", "Error"), na.rm = TRUE)
        innings <- outs / 3
        whole_innings <- floor(innings)
        remaining_outs <- outs %% 3
        if (remaining_outs == 0) {
          return(paste0(whole_innings, ".0"))
        } else {
          return(paste0(whole_innings, ".", remaining_outs))
        }
      }
      
      raw_per_type <- df %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          IP = ip_calculation(dplyr::cur_data_all()),
          P = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all()),
          H = sum(PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE),
          XBH = sum(PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE),
          Barrels = sum(ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, na.rm = TRUE),
          BB = sum(KorBB == "Walk", na.rm = TRUE),
          HBP = sum(PlayResult == "HitByPitch", na.rm = TRUE),
          K = sum(KorBB == "Strikeout", na.rm = TRUE),
          Whiffs = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::rename(!!split_col_name := SplitColumn) %>%
        dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
      
      # Order pitch types correctly if Pitch Types is selected
      if (split_choice == "Pitch Types" && exists("all_colors")) {
        pitch_order <- intersect(names(all_colors), raw_per_type[[split_col_name]])
        if (length(pitch_order) > 0) {
          raw_per_type[[split_col_name]] <- factor(raw_per_type[[split_col_name]], levels = pitch_order)
          raw_per_type <- raw_per_type %>% dplyr::arrange(.data[[split_col_name]])
          raw_per_type[[split_col_name]] <- as.character(raw_per_type[[split_col_name]])
        }
      }
      
      # All row calculations
      all_ip <- ip_calculation(df)
      all_p <- nrow(df)
      all_bf <- calculate_bf(df)
      all_h <- sum(df$PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
      all_xbh <- sum(df$PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE)
      all_barrels <- sum(df$ExitSpeed >= 95 & df$Angle >= 10 & df$Angle <= 35, na.rm = TRUE)
      all_bb <- sum(df$KorBB == "Walk", na.rm = TRUE)
      all_hbp <- sum(df$PlayResult == "HitByPitch", na.rm = TRUE)
      all_k <- sum(df$KorBB == "Strikeout", na.rm = TRUE)
      all_whiffs <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
      
      # Calculate P/IP and P/BF for All row only
      # Convert IP from "X.Y" format to decimal (X + Y/3)
      ip_decimal <- if (all_ip != "0.0") {
        parts <- strsplit(all_ip, "\\.")[[1]]
        as.numeric(parts[1]) + as.numeric(parts[2])/3
      } else 0
      
      p_per_ip <- if (ip_decimal > 0) as.character(round(all_p / ip_decimal, 1)) else ""
      p_per_bf <- if (all_bf > 0) as.character(round(all_p / all_bf, 1)) else ""
      
      # Create all_row with dynamic split column name first
      all_row_data <- list()
      all_row_data[[split_col_name]] <- "All"
      all_row_data$IP <- all_ip
      all_row_data$P <- all_p
      all_row_data$BF <- all_bf
      all_row_data$`P/IP` <- p_per_ip
      all_row_data$`P/BF` <- p_per_bf
      all_row_data$H <- all_h
      all_row_data$XBH <- all_xbh
      all_row_data$Barrels <- all_barrels
      all_row_data$BB <- all_bb
      all_row_data$HBP <- all_hbp
      all_row_data$K <- all_k
      all_row_data$Whiffs <- all_whiffs
      all_row <- tibble::as_tibble(all_row_data)
      
      # Add empty P/IP and P/BF columns to per-type data
      raw_per_type$`P/IP` <- ""
      raw_per_type$`P/BF` <- ""
      
      # Reorder columns to match desired layout - use dynamic column name
      col_order <- c(split_col_name, "IP", "P", "BF", "P/IP", "P/BF", "H", "XBH", "Barrels", "BB", "HBP", "K", "Whiffs")
      raw_per_type <- raw_per_type[, col_order]
      all_row <- all_row[, col_order]
      
      df_raw <- dplyr::bind_rows(raw_per_type, all_row)
      
      visible_set <- names(df_raw)
      table_cache <- df_raw
      return(datatable_with_colvis(
        df_raw,
        lock            = split_col_name,
        remember        = FALSE,
        default_visible = visible_set,
        mode            = mode,
        enable_colors   = FALSE
      ))
    }
    
    # ---------- BATTED BALL DATA TABLE ----------
    if (identical(mode, "Batted Ball Data")) {
      # Helper function
      fmt_avg <- function(x) sprintf("%.3f", x)
      
      # Filter for completed PAs only (like Results table does)
      is_term <- (
        (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
          (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk"))
      )
      term <- df[is_term, , drop = FALSE]
      
      # Group by SplitColumn and calculate stats for each split
      per_type <- term %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          PA = dplyr::n(),  # Count completed PAs, not first pitches
          H1 = sum(PlayResult == "Single", na.rm = TRUE),
          H2 = sum(PlayResult == "Double", na.rm = TRUE),
          H3 = sum(PlayResult == "Triple", na.rm = TRUE),
          HR = sum(PlayResult == "HomeRun", na.rm = TRUE),
          BB = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
          IBB = sum(PlayResult == "IntentionalWalk", na.rm = TRUE),
          HBP = sum(PlayResult == "HitByPitch", na.rm = TRUE),
          SF = sum(PlayResult == "Sacrifice", na.rm = TRUE),
          Inplay_All = sum(PitchCall == "InPlay", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(
          AB = PA - (BB + HBP + SF),
          H = H1 + H2 + H3 + HR,
          TB = 1*H1 + 2*H2 + 3*H3 + 4*HR,
          AVG = safe_div(H, AB),
          SLG = safe_div(TB, AB),
          OBP = safe_div(H + BB + HBP, PA),
          OPS = SLG + OBP,
          ISO = SLG - AVG,
          uBB = BB - IBB,
          wOBA_num = 0.690*uBB + 0.722*HBP + 0.888*H1 + 1.271*H2 + 1.616*H3 + 2.101*HR,
          wOBA_den = AB + BB - IBB + SF + HBP,
          wOBA = safe_div(wOBA_num, wOBA_den),
          BABIP = safe_div(H, Inplay_All)
        )
      
      # Calculate xWOBA, xISO, and Barrel% per split
      splits <- unique(term$SplitColumn)
      xstats_list <- lapply(splits, function(spl) {
        split_df <- term[term$SplitColumn == spl, , drop = FALSE]
        
        # Get BIP with EV/LA
        bip_evla <- split_df %>%
          dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                        is.finite(ExitSpeed), is.finite(Angle)) %>%
          dplyr::mutate(
            EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
            LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
          )
        
        xWOBA <- NA_real_
        xISO <- NA_real_
        
        if (exists("xbin_ref") && nrow(bip_evla) > 0) {
          bip_evla <- bip_evla %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
          for (nm in c("p1B","p2B","p3B","pHR")) {
            if (exists("x_overall") && nm %in% names(x_overall)) {
              bip_evla[[nm]][!is.finite(bip_evla[[nm]])] <- x_overall[[nm]]
            }
          }
          x1B <- sum(bip_evla$p1B, na.rm = TRUE)
          x2B <- sum(bip_evla$p2B, na.rm = TRUE)
          x3B <- sum(bip_evla$p3B, na.rm = TRUE)
          xHR <- sum(bip_evla$pHR, na.rm = TRUE)
          xH  <- x1B + x2B + x3B + xHR
          xTB <- 1*x1B + 2*x2B + 3*x3B + 4*xHR
          
          split_AB <- per_type$AB[per_type$SplitColumn == spl]
          xAVG <- safe_div(xH, split_AB)
          xSLG <- safe_div(xTB, split_AB)
          xISO <- xSLG - xAVG
          
          # xWOBA calculation
          split_BB <- per_type$BB[per_type$SplitColumn == spl]
          BF_live <- sum(split_df$SessionType == "Live" & split_df$Balls == 0 & split_df$Strikes == 0, na.rm = TRUE)
          if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
            xWOBA <- safe_div(W_BB*split_BB + W_1B*x1B + W_2B*x2B + W_3B*x3B + W_HR*xHR, BF_live)
          }
        }
        
        # Calculate Barrel%
        barrels <- sum(split_df$SessionType == "Live" & split_df$PitchCall == "InPlay" &
                         is.finite(split_df$ExitSpeed) & is.finite(split_df$Angle) &
                         split_df$ExitSpeed >= 95 & split_df$Angle >= 10 & split_df$Angle <= 35, na.rm = TRUE)
        inplay_live <- sum(split_df$SessionType == "Live" & split_df$PitchCall == "InPlay", na.rm = TRUE)
        BarrelPct <- safe_div(barrels, inplay_live)
        
        data.frame(
          SplitColumn = spl,
          xWOBA = xWOBA,
          xISO = xISO,
          `Barrel%` = BarrelPct,
          check.names = FALSE
        )
      })
      
      xstats <- do.call(rbind, xstats_list)
      
      # Merge with per_type
      batted_ball_data <- per_type %>%
        dplyr::left_join(xstats, by = "SplitColumn") %>%
        dplyr::transmute(
          !!split_col_name := as.character(SplitColumn),
          PA, AB, AVG, SLG, OBP, OPS, wOBA, xWOBA, ISO, xISO, BABIP, `Barrel%`
        ) %>%
        dplyr::mutate(
          AVG = ifelse(is.finite(AVG), fmt_avg(AVG), ""),
          SLG = ifelse(is.finite(SLG), fmt_avg(SLG), ""),
          OBP = ifelse(is.finite(OBP), fmt_avg(OBP), ""),
          OPS = ifelse(is.finite(OPS), fmt_avg(OPS), ""),
          wOBA = ifelse(is.finite(wOBA), fmt_avg(wOBA), ""),
          xWOBA = ifelse(is.finite(xWOBA), fmt_avg(xWOBA), ""),
          ISO = ifelse(is.finite(ISO), fmt_avg(ISO), ""),
          xISO = ifelse(is.finite(xISO), fmt_avg(xISO), ""),
          BABIP = ifelse(is.finite(BABIP), fmt_avg(BABIP), ""),
          `Barrel%` = ifelse(is.finite(`Barrel%`), paste0(round(`Barrel%`*100, 1), "%"), "")
        )
      
      # --- ALL row (ungrouped, same calculations) ---
      PA_all <- nrow(term)
      H1_all <- sum(term$PlayResult == "Single", na.rm = TRUE)
      H2_all <- sum(term$PlayResult == "Double", na.rm = TRUE)
      H3_all <- sum(term$PlayResult == "Triple", na.rm = TRUE)
      HR_all <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
      BB_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
      IBB_all <- sum(term$PlayResult == "IntentionalWalk", na.rm = TRUE)
      HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
      SF_all <- sum(term$PlayResult == "Sacrifice", na.rm = TRUE)
      Inplay_All_all <- sum(term$PitchCall == "InPlay", na.rm = TRUE)
      
      AB_all <- PA_all - (BB_all + HBP_all + SF_all)
      H_all <- H1_all + H2_all + H3_all + HR_all
      TB_all <- 1*H1_all + 2*H2_all + 3*H3_all + 4*HR_all
      
      # Calculate xWOBA, xISO, Barrel% for All row
      bip_evla_all <- term %>%
        dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                      is.finite(ExitSpeed), is.finite(Angle)) %>%
        dplyr::mutate(
          EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
          LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
        )
      
      xWOBA_all <- NA_real_
      xISO_all <- NA_real_
      
      if (exists("xbin_ref") && nrow(bip_evla_all) > 0) {
        bip_evla_all <- bip_evla_all %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
        for (nm in c("p1B","p2B","p3B","pHR")) {
          if (exists("x_overall") && nm %in% names(x_overall)) {
            bip_evla_all[[nm]][!is.finite(bip_evla_all[[nm]])] <- x_overall[[nm]]
          }
        }
        x1B_all <- sum(bip_evla_all$p1B, na.rm = TRUE)
        x2B_all <- sum(bip_evla_all$p2B, na.rm = TRUE)
        x3B_all <- sum(bip_evla_all$p3B, na.rm = TRUE)
        xHR_all <- sum(bip_evla_all$pHR, na.rm = TRUE)
        xH_all  <- x1B_all + x2B_all + x3B_all + xHR_all
        xTB_all <- 1*x1B_all + 2*x2B_all + 3*x3B_all + 4*xHR_all
        xAVG_all <- safe_div(xH_all, AB_all)
        xSLG_all <- safe_div(xTB_all, AB_all)
        xISO_all <- xSLG_all - xAVG_all
        
        PA_live_all <- sum(term$SessionType == "Live" & term$Balls == 0 & term$Strikes == 0, na.rm = TRUE)
        if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
          xWOBA_all <- safe_div(W_BB*BB_all + W_1B*x1B_all + W_2B*x2B_all + W_3B*x3B_all + W_HR*xHR_all, PA_live_all)
        }
      }
      
      barrels_all <- sum(term$SessionType == "Live" & term$PitchCall == "InPlay" &
                           is.finite(term$ExitSpeed) & is.finite(term$Angle) &
                           term$ExitSpeed >= 95 & term$Angle >= 10 & term$Angle <= 35, na.rm = TRUE)
      inplay_live_all <- sum(term$SessionType == "Live" & term$PitchCall == "InPlay", na.rm = TRUE)
      BarrelPct_all <- safe_div(barrels_all, inplay_live_all)
      
      # Create All row with dynamic column name
      all_row_data <- list(
        PA = PA_all,
        AB = AB_all,
        AVG = safe_div(H_all, AB_all),
        SLG = safe_div(TB_all, AB_all),
        OBP = safe_div(H_all + BB_all + HBP_all, PA_all),
        OPS = NA_real_,
        wOBA = safe_div(0.690*(BB_all - IBB_all) + 0.722*HBP_all + 0.888*H1_all + 1.271*H2_all + 1.616*H3_all + 2.101*HR_all,
                        AB_all + BB_all - IBB_all + SF_all + HBP_all),
        xWOBA = xWOBA_all,
        ISO = safe_div(TB_all, AB_all) - safe_div(H_all, AB_all),
        xISO = xISO_all,
        BABIP = safe_div(H_all, Inplay_All_all),
        `Barrel%` = BarrelPct_all
      )
      all_row_data[[split_col_name]] <- "All"
      all_row <- tibble::as_tibble(all_row_data)
      all_row$OPS <- all_row$SLG + all_row$OBP
      
      # Format All row
      all_row <- all_row %>%
        dplyr::mutate(
          AVG = ifelse(is.finite(AVG), fmt_avg(AVG), ""),
          SLG = ifelse(is.finite(SLG), fmt_avg(SLG), ""),
          OBP = ifelse(is.finite(OBP), fmt_avg(OBP), ""),
          OPS = ifelse(is.finite(OPS), fmt_avg(OPS), ""),
          wOBA = ifelse(is.finite(wOBA), fmt_avg(wOBA), ""),
          xWOBA = ifelse(is.finite(xWOBA), fmt_avg(xWOBA), ""),
          ISO = ifelse(is.finite(ISO), fmt_avg(ISO), ""),
          xISO = ifelse(is.finite(xISO), fmt_avg(xISO), ""),
          BABIP = ifelse(is.finite(BABIP), fmt_avg(BABIP), ""),
          `Barrel%` = ifelse(is.finite(`Barrel%`), paste0(round(`Barrel%`*100, 1), "%"), "")
        )
      
      # Order pitch types correctly if Pitch Types is selected
      if (split_choice == "Pitch Types" && split_col_name == "Pitch" && exists("all_colors")) {
        pitch_order <- intersect(names(all_colors), batted_ball_data[[split_col_name]])
        if (length(pitch_order) > 0) {
          batted_ball_data[[split_col_name]] <- factor(batted_ball_data[[split_col_name]], levels = pitch_order)
          batted_ball_data <- batted_ball_data %>% dplyr::arrange(.data[[split_col_name]])
          batted_ball_data[[split_col_name]] <- as.character(batted_ball_data[[split_col_name]])
        }
      }
      
      # Bind rows
      df_out <- dplyr::bind_rows(batted_ball_data, all_row)
      
      visible_set <- names(df_out)
      table_cache <- df_out
      return(datatable_with_colvis(
        df_out,
        lock            = split_col_name,
        remember        = FALSE,
        default_visible = visible_set,
        mode            = mode,
        enable_colors   = if (!is.null(input$dpTableColors)) input$dpTableColors else FALSE
      ))
    }
    
    # ---------- NON-Results modes (your original build) ----------
    # QP+ per pitch type (scalar)
    qp_by_type <- df %>%
      dplyr::group_by(SplitColumn) %>%
      dplyr::summarise(
        `QP+` = {
          vals <- compute_qp_points(dplyr::cur_data_all())
          vals <- suppressWarnings(as.numeric(vals))
          round(mean(vals, na.rm = TRUE) * 200, 1)
        },
        .groups = "drop"
      )
    
    # Base per-pitch-type summary
    summ <- safe_make_summary(df, group_col = "SplitColumn")
    summ <- dplyr::mutate(summ,
                          ReleaseTilt = as.character(ReleaseTilt),
                          BreakTilt   = as.character(BreakTilt)
    )
    if (!("QP+" %in% names(summ))) {
      summ <- summ %>% dplyr::left_join(qp_by_type, by = c("PitchType" = "SplitColumn"))
    }
    
    # ---- Build FULL table (as before) ----
    df_table <- dplyr::bind_rows(
      summ,
      {
        scores <- ifelse(
          df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
            df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
          ifelse(
            df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
              df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5),
            0.73, 0
          )
        )
        has_pc  <- sum(!is.na(df$PitchCall)) > 0
        strikes <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
        sw      <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
        den     <- sum(df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
        # Use shared BF calculation function
        bf_live <- calculate_bf(df)
        fps_opp <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
        k_live  <- sum(df$SessionType == "Live" & df$KorBB == "Strikeout",        na.rm = TRUE)
        bb_live <- sum(df$SessionType == "Live" & df$KorBB == "Walk",             na.rm = TRUE)
        fps_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0 &
                          df$PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
        ea_live  <- sum(df$SessionType == "Live" & (
          (df$Balls == 0 & df$Strikes == 0 & df$PitchCall == "InPlay") |
            (df$Balls == 0 & df$Strikes == 1 & df$PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
            )) |
            (df$Balls == 1 & df$Strikes == 0 & df$PitchCall == "InPlay") |
            (df$Balls == 1 & df$Strikes == 1 & df$PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
            ))
        ),
        na.rm = TRUE
        )
        
        vmax   <- suppressWarnings(max(as.numeric(df$RelSpeed), na.rm = TRUE)); vmax <- if (is.finite(vmax)) round(vmax, 1) else NA_real_
        ev_all <- nz_mean(ifelse(df$SessionType=="Live", df$ExitSpeed, NA_real_))
        la_all <- nz_mean(ifelse(df$SessionType=="Live", df$Angle,     NA_real_))
        stuff_all <- round(nz_mean(df$`Stuff+`), 1)
        ctrl_all   <- round(nz_mean(scores) * 100, 1)
        qp_all    <- round(nz_mean(compute_qp_points(df)) * 200, 1)
        
        tibble::tibble(
          PitchType     = "All",
          PitchCount    = nrow(df),
          Usage         = "100%",
          Overall       = "100%",
          BF            = bf_live,
          Velo_Avg      = round(nz_mean(df$RelSpeed), 1),
          Velo_Max      = vmax,
          IVB           = round(nz_mean(df$InducedVertBreak), 1),
          HB            = round(nz_mean(df$HorzBreak), 1),
          ReleaseTilt   = convert_to_clock(nz_mean(df$ReleaseTilt)),
          BreakTilt     = convert_to_clock(nz_mean(df$BreakTilt)),
          SpinEff       = nz_mean(df$SpinEfficiency),
          SpinRate      = round(nz_mean(df$SpinRate), 0),
          RelHeight     = round(nz_mean(df$RelHeight), 1),
          RelSide       = round(nz_mean(df$RelSide), 1),
          VertApprAngle = round(nz_mean(df$VertApprAngle), 1),
          HorzApprAngle = round(nz_mean(df$HorzApprAngle), 1),
          Extension     = round(nz_mean(df$Extension), 1),
          InZonePercent = { inzone <- (df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
                                         df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP)
          safe_pct(sum(inzone, na.rm=TRUE), sum(!is.na(inzone))) },
          CompPercent   = { comp <- (df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                                       df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5))
          safe_pct(sum(comp, na.rm=TRUE), sum(!is.na(comp))) },
          KPercent      = safe_pct(k_live, bf_live),
          BBPercent     = safe_pct(bb_live, bf_live),
          FPSPercent    = safe_pct(fps_live, fps_opp),
          EAPercent     = safe_pct(ea_live, fps_opp),
          StrikePercent = if (has_pc) safe_pct(strikes, nrow(df)) else "",
          SwingPercent  = safe_pct(sum(!is.na(df$PitchCall) & df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","FoulBall","InPlay"), na.rm = TRUE), nrow(df)),
          WhiffPercent  = safe_pct(sw, den),
          EV = ev_all, LA = la_all,
          `Stuff+` = stuff_all, `Ctrl+` = ctrl_all, `QP+` = qp_all
        ) %>% dplyr::mutate(`Pitching+` = round((`Stuff+` + `QP+`)/2, 1))
      }
    ) %>%
      dplyr::rename(
        !!split_col_name := PitchType,
        `#`    = PitchCount,
        Velo   = Velo_Avg,
        Max    = Velo_Max,
        rTilt  = ReleaseTilt,
        bTilt  = BreakTilt,
        Spin   = SpinRate,
        Height = RelHeight,
        Side   = RelSide,
        Ext    = Extension,
        `InZone%` = InZonePercent,
        `Comp%`   = CompPercent,
        `K%`      = KPercent,
        `BB%`     = BBPercent,
        `FPS%`    = FPSPercent,
        `E+A%`    = EAPercent,
        `QP%`     = QPPercent,
        `Strike%` = StrikePercent,
        `Swing%`  = SwingPercent,
        `Whiff%`  = WhiffPercent,
        VAA       = VertApprAngle,
        HAA       = HorzApprAngle
      ) %>%
      dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]])) %>%
      dplyr::select(
        .data[[split_col_name]], `#`, Usage, Overall,
        dplyr::any_of(c("0-0","Behind","Even","Ahead","<2K","2K")),
        BF,
        Velo, Max, IVB, HB, rTilt, bTilt, SpinEff, Spin, Height, Side, VAA, HAA, Ext,
        `InZone%`, `Comp%`, `Strike%`, `Swing%`, `FPS%`, `E+A%`, `QP%`, `K%`, `BB%`, `Whiff%`, EV, LA,
        `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
      ) %>%
      dplyr::mutate(
        EV = ifelse(is.na(as.numeric(EV)), "", round(as.numeric(EV), 1)),
        LA = ifelse(is.na(as.numeric(LA)), "", round(as.numeric(LA), 1))
      )
    
    # Add Process/Results extras and sanitize for DT
    extras_raw <- compute_process_results(df)
    if ("PitchType" %in% names(extras_raw)) {
      extras <- extras_raw %>% 
        dplyr::rename(!!split_col_name := PitchType) %>%
        dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
    } else {
      extras <- extras_raw %>%
        dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
    }
    df_table <- df_table %>% dplyr::left_join(extras, by = split_col_name)
    df_table <- fill_all_qp_pct(df_table, df)
    if (identical(mode, "Usage")) {
      usage_extras_raw <- compute_usage_by_count(df)
      if ("PitchType" %in% names(usage_extras_raw)) {
        usage_extras <- usage_extras_raw %>%
          dplyr::rename(!!split_col_name := PitchType) %>%
          dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
      } else {
        usage_extras <- usage_extras_raw %>%
          dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
      }
      df_table <- df_table %>% dplyr::left_join(usage_extras, by = split_col_name)
    }
    
    df_table <- collapse_list_cols(df_table)
    is_date_like <- function(x) inherits(x, c("Date","POSIXct","POSIXt","difftime"))
    date_like <- vapply(df_table, is_date_like, logical(1))
    if (any(date_like)) df_table[date_like] <- lapply(df_table[date_like], as.character)
    df_table <- as.data.frame(df_table, stringsAsFactors = FALSE, check.names = FALSE)
    
    if (all(c("Whiff%","CSW%") %in% names(df_table))) {
      df_table <- df_table %>% dplyr::relocate(`CSW%`, .after = `Whiff%`)
    }
    if ("Pitching+" %in% names(df_table)) {
      df_table <- df_table %>% dplyr::relocate(`Pitching+`, .after = dplyr::last_col())
    }
    
    df_table <- enforce_process_order(df_table)
    df_table <- enforce_stuff_order(df_table)
    # Hide RV/100 in Results mode (Summary)
    if (identical(mode, "Results") && "RV/100" %in% names(df_table)) {
      df_table <- dplyr::select(df_table, -`RV/100`)
    }
    
    # Format SpinEff column to percentage with 1 decimal place
    if ("SpinEff" %in% names(df_table)) {
      df_table$SpinEff <- ifelse(is.na(df_table$SpinEff) | df_table$SpinEff == "", "", 
                                 paste0(round(as.numeric(df_table$SpinEff) * 100, 1), "%"))
    }
    
    visible_set <- visible_set_for(mode, custom)
    visible_set <- gsub("^Pitch$", split_col_name, visible_set)
    
    # Add error handling wrapper for main summary table
    build_summary_dt <- function(data, ...) {
      tryCatch(
        datatable_with_colvis(data, ...),
        error = function(e) {
          message("summaryTable datatable error [mode=", mode, "]: ", conditionMessage(e))
          message("Columns: ", paste(names(data), collapse = ", "))
          # Return a fallback datatable with error message
          DT::datatable(
            data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
            options = list(dom = 't'), rownames = FALSE
          )
        }
      )
    }
    
    table_cache <- df_table
    build_summary_dt(
      df_table,
      lock            = split_col_name,
      remember        = FALSE,
      default_visible = intersect(visible_set, names(df_table)),
      mode            = mode,
      enable_colors   = isTRUE(input$dpTableColors)
    )
  })

  # Click-to-video support on Summary/DP tables (# column)
  observeEvent(input$summaryTablePage_cell_clicked, {
    handle_table_video_click(
      input$summaryTablePage_cell_clicked,
      session$userData$table_cache_summaryTablePage,
      table_label = "Summary Table"
    )
  }, ignoreNULL = TRUE)
  observeEvent(input$summaryTable_cell_clicked, {
    handle_table_video_click(
      input$summaryTable_cell_clicked,
      session$userData$table_cache_summaryTable,
      table_label = "Data & Performance"
    )
  }, ignoreNULL = TRUE)
  
  # ================================
  # Pitching → AB Report (no tables)
  # ================================
  # Safe fallbacks (won't override if you already have real ones)
  if (!exists("is_active", mode = "function")) is_active <- function(...) TRUE
  if (!exists("ns",        mode = "function")) ns        <- function(id) id
  
  # Build the PA-level result label (same logic as hitting)
  .abp_pa_result_label <- function(last_row) {
    pr <- as.character(last_row$PlayResult)
    kc <- as.character(last_row$KorBB)
    pc <- as.character(last_row$PitchCall)
    th <- as.character(last_row$TaggedHitType)
    
    if (!is.na(pc) && pc == "HitByPitch") return("HitByPitch")
    if (!is.na(kc) && kc %in% c("Strikeout","Walk")) return(kc)
    
    if (!is.na(pr) && pr != "" && pr != "Undefined") {
      if (pr == "HomeRun") return("HomeRun")
      th_clean <- ifelse(is.na(th) | th == "", "", paste0(th, " "))
      return(paste0(th_clean, pr))
    }
    if (!is.na(pr) && pr != "") return(pr)
    if (!is.na(pc) && pc != "") return(pc)
    "Result"
  }
  
  
  # Terminal pitch = PA completed
  .abp_is_terminal <- function(df) {
    (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
      (!is.na(df$KorBB)     & df$KorBB %in% c("Strikeout","Walk")) |
      (!is.na(df$PitchCall) & df$PitchCall == "HitByPitch")
  }
  
  .abp_fmt_mdy <- function(d) format(as.Date(d), "%m/%d/%Y")
  
  # "Last, First" -> "First Last"
  .abp_pretty_name <- function(x) {
    x <- as.character(x)
    ifelse(grepl(",", x), paste0(trimws(sub(".*,", "", x)), " ", trimws(sub(",.*", "", x))), x)
  }
  # Pretty pitcher label
  .abp_pretty_pitcher <- function(x) .abp_pretty_name(x)
  
  # Strike zone + dashed competitive box
  .abp_geom_zone <- function(color = "black") {
    home <- data.frame(x=c(-0.75,0.75,0.75,0.00,-0.75),
                       y=c(1.05, 1.05,1.15,1.25, 1.15)-0.5)
    cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
    sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
    list(
      geom_polygon(data = home, aes(x, y), fill = NA, color = color),
      geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = color, linetype = "dashed"),
      geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = color)
    )
  }
  
  # All game dates where the selected pitcher has ≥1 completed PA (across any batters)
  abp_dates <- reactive({
    pit <- input$pitcher
    if (is.null(pit) || identical(pit, "All")) return(as.Date(character(0)))
    
    d <- pitch_data_pitching %>% dplyr::filter(Pitcher == pit)
    term <- .abp_is_terminal(d)
    sort(unique(as.Date(d$Date[term])))
  })
  
  # Sidebar (date selector + legends)
  output$abpSidebar <- renderUI({
    pit <- input$pitcher
    if (is.null(pit) || identical(pit, "All")) {
      return(tagList(tags$em("Select a single pitcher in the main sidebar to enable AB Report.")))
    }
    
    dates <- abp_dates()
    if (!length(dates)) return(tagList(tags$em("No completed plate appearances found for this pitcher.")))
    
    vals <- as.character(as.Date(dates))
    labs <- .abp_fmt_mdy(dates)
    choices <- stats::setNames(vals, labs)
    
    cur <- isolate(input$abpGameDate)
    sel <- if (!is.null(cur) && cur %in% vals) cur else vals[length(vals)]
    
    # Pitch-type legend: only types this pitcher actually threw
    types_for_legend <- {
      d <- pitch_data_pitching %>% dplyr::filter(Pitcher == pit)
      intersect(names(all_colors), as.character(unique(d$TaggedPitchType)))
    }
    dark_on <- isTRUE(input$dark_mode)
    legend_cols <- if (exists("colors_for_mode")) colors_for_mode(dark_on) else all_colors
    text_col <- if (dark_on) "#e5e7eb" else "black"
    
    shape_rows <- tagList(
      tags$div(style = paste0("color:", text_col), "\u25CF Called Strike"),  # ●
      tags$div(style = paste0("color:", text_col), "\u25CB Ball"),           # ○
      tags$div(style = paste0("color:", text_col), "\u25B3 Foul"),           # △
      tags$div(style = paste0("color:", text_col), "\u2605 Whiff"),          # ★
      tags$div(style = paste0("color:", text_col), "\u25B2 In Play (Out)"),  # ▲
      tags$div(style = paste0("color:", text_col), "\u25A0 In Play (Hit)"),  # ■
      tags$div(style = paste0("color:", text_col), "\u25A1 Error")           # □
    )
    
    tagList(
      selectInput(ns("abpGameDate"), "Select Game:", choices = choices, selected = sel),
      tags$hr(),
      tags$div(tags$strong(style = paste0("color:", text_col), "Pitch Result")),
      shape_rows,
      tags$br(),
      tags$div(tags$strong(style = paste0("color:", text_col), "Pitch Types")),
      tags$div(lapply(types_for_legend, function(tt) {
        col <- legend_cols[[as.character(tt)]]; if (is.null(col)) col <- "gray"
        tags$div(style="display:flex;align-items:center;margin:2px 0;",
                 tags$span(style=paste0("display:inline-block;width:12px;height:12px;",
                                        "background:", col, ";margin-right:6px;",
                                        "border:1px solid rgba(0,0,0,.25);border-radius:2px;")),
                 tags$span(style = paste0("color:", text_col), as.character(tt))
        )
      }))
    )
  })
  
  # Header (top-left): Pitcher + Date
  output$abpHeader <- renderUI({
    pit <- input$pitcher
    if (is.null(pit) || identical(pit, "All")) return(NULL)
    dt_val <- input$abpGameDate
    if (is.null(dt_val)) {
      ds <- abp_dates(); if (!length(ds)) return(NULL)
      dt_val <- as.character(max(ds))
    }
    tags$div(
      style = "text-align:left;",
      tags$strong(.abp_pretty_pitcher(pit)), tags$br(),
      .abp_fmt_mdy(as.Date(dt_val))
    )
  })
  
  # Panels: stacked batters (left), each with PA mini-charts (right)
  output$abpPanels <- renderUI({
    pit <- input$pitcher
    if (is.null(pit) || identical(pit, "All"))
      return(div(style="margin:8px 0;", tags$em("Select a single pitcher to view the AB Report.")))
    
    dt_chr <- input$abpGameDate; req(!is.null(dt_chr))
    the_date <- as.Date(dt_chr)
    
    # Filter: selected pitcher on selected date (ignore the global date range for this page)
    df_all <- pitch_data_pitching %>% dplyr::filter(Pitcher == pit, as.Date(Date) == the_date)    
    
    if (!nrow(df_all)) return(div(tags$em("No pitches for this pitcher on the selected date.")))
    
    # Order batters by first appearance that day
    first_idx <- df_all %>%
      dplyr::mutate(.row_id = dplyr::row_number()) %>%
      dplyr::group_by(Batter) %>%
      dplyr::summarise(first_row = min(.row_id), .groups = "drop") %>%
      dplyr::arrange(first_row)
    
    # Build one row per batter
    rows <- lapply(seq_len(nrow(first_idx)), function(bi) {
      bat <- first_idx$Batter[bi]
      dB  <- df_all %>% dplyr::filter(Batter == bat)
      
      # Batter side & name label with color (Left = red, Right = black)
      side <- as.character(dplyr::coalesce(dB$BatterSide[which.max(seq_len(nrow(dB)))], NA))
      lr   <- ifelse(is.na(side), "", ifelse(grepl("^L", side, ignore.case = TRUE), "L", "R"))
      is_left <- identical(lr, "L")
      dark_on <- isTRUE(input$dark_mode)
      name_col <- if (is_left) "#d32f2f" else if (dark_on) "#e5e7eb" else "#000000"
      name_html <- tags$div(
        style = paste0("font-weight:700; color:", name_col, ";"),
        paste0(.abp_pretty_name(bat), " (", lr, ")")
      )
      
      # Segment PAs within this batter
      term <- .abp_is_terminal(dB)
      # cumsum starts a new PA *after* a terminal pitch:
      pa_id <- cumsum(c(1L, as.integer(utils::head(term, -1))))
      dB$._pa_id <- pa_id
      done_ids <- unique(dB$._pa_id[term])
      dB <- dplyr::filter(dB, ._pa_id %in% done_ids)
      if (!nrow(dB)) {
        return(fluidRow(
          column(3, div(style="padding:10px 6px;", name_html)),
          column(9, div(style="padding:10px 6px;", tags$em("No completed PAs")))
        ))
      }
      
      pa_list <- split(dB, dB$._pa_id)
      n_pa <- length(pa_list)
      
      # Build one mini zone chart per PA (left→right, 1st→last)
      chart_cells <- lapply(seq_len(n_pa), function(i) {
        # build the per-PA data first
        dat <- pa_list[[i]] %>%
          dplyr::mutate(
            pitch_idx = dplyr::row_number(),
            Result    = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
            tt_fill   = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray80"),
            tt        = paste0(
              "Pitch: ", as.character(TaggedPitchType), "\n",
              "Result: ", dplyr::case_when(
                PitchCall == "InPlay" & !is.na(PlayResult) ~ as.character(PlayResult),
                TRUE ~ dplyr::coalesce(as.character(PitchCall), "")
              ), "\n",
              "Velo: ", ifelse(is.finite(RelSpeed), sprintf("%.1f", RelSpeed), "—"), "\n",
              "IVB: ",  ifelse(is.finite(InducedVertBreak), sprintf("%.1f", InducedVertBreak), "—"), "\n",
              "HB: ",   ifelse(is.finite(HorzBreak), sprintf("%.1f", HorzBreak), "—")
            )
          )
        
        # now compute the PA result label from the last pitch of this PA
        title_result <- .abp_pa_result_label(dat[nrow(dat), , drop = FALSE])
        
        pid    <- paste0(bi, "_", names(pa_list)[i])
        out_id <- ns(paste0("abpPlot_", pid))
        
        local({
          dat_local    <- dat
          out_id_local <- ns(paste0("abpPlot_", pid))
          output[[out_id_local]] <- ggiraph::renderGirafe({
            dark_on <- isTRUE(input$dark_mode)
            axis_col <- if (dark_on) "#e5e7eb" else "black"
            line_col <- if (dark_on) "#ffffff" else "black"
            cols <- if (exists("colors_for_mode")) colors_for_mode(dark_on) else all_colors
            types <- as.character(intersect(names(all_colors), unique(dat_local$TaggedPitchType)))
            p <- ggplot() +
              .abp_geom_zone(color = line_col) +
              ggiraph::geom_point_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight,
                    color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
                    tooltip = tt, data_id = pitch_idx),
                size = 5, alpha = 0.95, stroke = 0.8
              ) +
              ggiraph::geom_text_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight, label = pitch_idx, tooltip = tt, data_id = pitch_idx),
                nudge_y = 0.21, size = 5.5
              ) +
              ggiraph::geom_point_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = pitch_idx, fill = I(tt_fill)),
                shape = 21, size = 7, alpha = 0.001, stroke = 0, inherit.aes = FALSE
              ) +
              scale_color_manual(values = cols[types], limits = types, name = NULL) +
              scale_fill_manual(values  = cols[types], limits = types, name = NULL) +
              scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
              coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
              theme_void() + theme(legend.position = "none",
                                   plot.title = element_text(color = axis_col))
            
            girafe_transparent(
              ggobj = p,
              options = list(
                ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                      css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"),
                ggiraph::opts_hover(css = "stroke-width:1.5px;"),
                ggiraph::opts_hover_inv(css = "opacity:0.15;")
              )
            )
          })
        })
        
        div(
          style = "display:inline-block; margin:0 8px 12px 0; vertical-align:top; text-align:center;",
          tags$div(tags$strong(paste0("PA #", i))),
          tags$div(title_result, style = "margin-bottom:6px;"),
          ggiraph::girafeOutput(out_id, height = "300px", width = "300px")
        )
      })
      
      # Row layout: left col = batter label; right col = PA charts (scroll if many)
      fluidRow(
        # Narrower name column; vertically centered to the strike zone height
        column(
          2,
          div(
            style = "display:flex; align-items:center; justify-content:flex-end;
               min-height:320px; padding:0 8px 0 0; text-align:right;",
            name_html
          )
        ),
        # Wider chart area
        column(
          10,
          div(style="overflow-x:auto; white-space:nowrap; padding:6px;", chart_cells)
        )
      )
    })
    
    tagList(rows)
  })
  
  # Release + Extension combo
  output$releaseCombo <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    sess_lbl <- session_label_from(df)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    line_col <- if (dark_on) "#ffffff" else "black"
    
    # Get display option
    display_opt <- input$releaseComboDisplay
    if (is.null(display_opt)) display_opt <- "Averages Only"
    
    show_pitches <- display_opt %in% c("Averages and Pitches", "Pitches")
    show_averages <- display_opt %in% c("Averages Only", "Averages and Pitches")
    
    # shared y-axis max so both panels align and show at least 6
    y_max <- max(6, suppressWarnings(max(df$RelHeight, na.rm = TRUE) + 0.2))
    
    # Individual pitches data
    df_i <- df %>%
      dplyr::filter(is.finite(RelSide), is.finite(RelHeight)) %>%
      dplyr::mutate(
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", RelHeight),
          "<br>Side: ", sprintf("%.1f ft", RelSide),
          "<br>Extension: ", sprintf("%.1f ft", Extension)
        ),
        rid = dplyr::row_number()
      )
    
    df_i_ext <- df %>%
      dplyr::filter(is.finite(Extension), is.finite(RelHeight)) %>%
      dplyr::mutate(
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", RelHeight),
          "<br>Side: ", sprintf("%.1f ft", RelSide),
          "<br>Extension: ", sprintf("%.1f ft", Extension)
        ),
        rid = dplyr::row_number()
      )
    
    # --- (A) Release Point averages
    rp_w <- 4; rp_h <- 0.83
    xs <- seq(-rp_w, rp_w, length.out = 100)
    ys <- rp_h * (1 - (xs / rp_w)^2)
    mound_df <- data.frame(x = c(xs, rev(xs)), y = c(ys, rep(0, length(xs))))
    
    avg_rel <- df %>%
      dplyr::filter(is.finite(RelSide), is.finite(RelHeight)) %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_RelSide    = mean(RelSide,    na.rm = TRUE),
        avg_RelHeight  = mean(RelHeight,  na.rm = TRUE),
        avg_Extension  = mean(Extension,  na.rm = TRUE),
        .groups = "drop"
      ) %>%
      dplyr::filter(TaggedPitchType %in% types_chr) %>%
      dplyr::mutate(
        TaggedPitchType = factor(TaggedPitchType, levels = types_chr),
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", avg_RelHeight),
          "<br>Side: ", sprintf("%.1f ft", avg_RelSide),
          "<br>Extension: ", sprintf("%.1f ft", avg_Extension)
        )
      )
    
    p1 <- ggplot() +
      geom_polygon(data = mound_df, aes(x, y), fill = "tan", color = "tan") +
      annotate("rect", xmin = -0.5, xmax = 0.5, ymin = rp_h - 0.05, ymax = rp_h + 0.05, fill = "white") +
      geom_vline(xintercept = 0, color = line_col, size = 0.7) +
      geom_hline(yintercept = 0, color = line_col, size = 0.7) +
      # Individual pitches layer
      { if (show_pitches) {
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(x = RelSide, y = RelHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          alpha = 0.2, size = 2.5, shape = 21, stroke = 0.25, show.legend = FALSE
        )
      } } +
      # Averages layer
      { if (show_averages) {
        ggiraph::geom_point_interactive(
          data = avg_rel,
          aes(x = avg_RelSide, y = avg_RelHeight,
              color = TaggedPitchType, tooltip = tt, data_id = TaggedPitchType),
          size = 4, show.legend = FALSE
        )
      } } +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_y_continuous(limits = c(0, y_max), breaks = seq(0, ceiling(y_max), by = 1)) +
      theme_minimal() + axis_theme + grid_theme(dark_on) + labs(x = NULL, y = NULL) +
      theme(
        panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.text.x = element_text(color = axis_col),
        axis.text.y = element_text(color = axis_col)
      )
    
    # --- (B) Extension vs Height averages
    re_w <- 7; re_h <- 0.83
    xs2 <- seq(-re_w, re_w, length.out = 100)
    ys2 <- re_h * (1 - (xs2 / re_w)^2)
    ext_bg <- data.frame(x = c(xs2, rev(xs2)), y = c(ys2, rep(0, length(xs2))))
    
    avg_ext <- df %>%
      dplyr::filter(is.finite(Extension), is.finite(RelHeight)) %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_Extension  = mean(Extension,  na.rm = TRUE),
        avg_RelHeight  = mean(RelHeight,  na.rm = TRUE),
        avg_RelSide    = mean(RelSide,    na.rm = TRUE),
        .groups = "drop"
      ) %>%
      dplyr::filter(TaggedPitchType %in% types_chr) %>%
      dplyr::mutate(
        TaggedPitchType = factor(TaggedPitchType, levels = types_chr),
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", avg_RelHeight),
          "<br>Side: ", sprintf("%.1f ft", avg_RelSide),
          "<br>Extension: ", sprintf("%.1f ft", avg_Extension)
        )
      )
    
    p2 <- ggplot() +
      geom_polygon(data = ext_bg, aes(x, y), fill = "tan", color = "tan") +
      annotate("rect", xmin = 0, xmax = 0.2, ymin = re_h - 0.05, ymax = re_h + 0.05, fill = "white") +
      geom_vline(xintercept = 0, color = line_col, size = 0.7) +
      # Individual pitches layer
      { if (show_pitches) {
        ggiraph::geom_point_interactive(
          data = df_i_ext,
          aes(x = Extension, y = RelHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          alpha = 0.2, size = 2.5, shape = 21, stroke = 0.25, show.legend = FALSE
        )
      } } +
      # Averages layer
      { if (show_averages) {
        ggiraph::geom_point_interactive(
          data = avg_ext,
          aes(x = avg_Extension, y = avg_RelHeight,
              color = TaggedPitchType, tooltip = tt, data_id = TaggedPitchType),
          size = 4, show.legend = TRUE   # legend only here
        )
      } } +
      scale_x_continuous(limits = c(0, 7.5), breaks = seq(1, 7.5, 1)) +
      scale_y_continuous(limits = c(0, y_max), breaks = seq(0, ceiling(y_max), by = 1)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) + labs(x = NULL, y = NULL) +
      theme(
        panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.text.x = element_text(color = axis_col),
        axis.text.y = element_text(color = axis_col)
      )
    
    # --- stack + single legend at bottom; enlarge legend text a bit
    p <- (p1 / p2) + patchwork::plot_layout(guides = "collect")
    p <- p & theme(
      legend.position = "bottom",
      legend.text = element_text(size = 14, color = axis_col)
    )
    p <- p & transparent_bg_theme  # keep patchwork canvas transparent to match other pages
    
    girafe_transparent(
      ggobj = p,
      width_svg = 9, height_svg = 12,
      options = list(
        ggiraph::opts_sizing(rescale = TRUE),
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;"),
        ggiraph::opts_selection(type = "multiple", selected = character(0))
      )
    )
  })
  
  
  
  # Full Movement Plot
  output$movementPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    line_col <- if (dark_on) "#ffffff" else "black"
    
    # Add reactive dependency on target shapes
    target_shapes_version()
    
    avg_mov <- df %>% dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_HorzBreak        = mean(HorzBreak, na.rm = TRUE),
        avg_InducedVertBreak = mean(InducedVertBreak, na.rm = TRUE),
        avg_velo             = mean(RelSpeed, na.rm = TRUE),
        avg_stuff            = mean(`Stuff+`, na.rm = TRUE),
        n_obs                = dplyr::n(),
        .groups = "drop"
      ) %>%
      dplyr::mutate(
        tt = paste0(TaggedPitchType,
                    "<br>Velo: ", round(avg_velo,1), " mph",
                    "<br>IVB: ", round(avg_InducedVertBreak,1), " in",
                    "<br>HB: ", round(avg_HorzBreak,1), " in",
                    "<br>Stuff+: ", round(avg_stuff,1),
                    "<br>Pitches: ", n_obs),
        data_id = TaggedPitchType
      )
    
    df_i <- df %>% dplyr::mutate(tt = make_hover_tt(.), rid = dplyr::row_number())
    
    base_type <- input$breakLines
    line_df <- tibble()
    if (base_type %in% c("Fastball", "Sinker")) {
      base_val <- dplyr::filter(avg_mov, TaggedPitchType == base_type)
      if (nrow(base_val) == 1) {
        seps <- if (base_type == "Fastball") {
          tibble(
            TaggedPitchType = c("Cutter", "Slider", "Sweeper", "Curveball", "ChangeUp", "Splitter"),
            sep_IVB = c(-7, -15, -16, -27, -12, -13),
            sep_Horz = c(10, 12, 22, 18, -7, -4)
          )
        } else {
          tibble(
            TaggedPitchType = c("Cutter", "Slider", "Sweeper", "Curveball", "ChangeUp", "Splitter"),
            sep_IVB = c(2, -6, -7, -18, -4, -5),
            sep_Horz = c(18, 20, 30, 25, 1, 2)
          )
        }
        throw_side <- if (input$hand %in% c("Left", "Right")) input$hand else {
          us <- unique(df$PitcherThrows) %>% na.omit()
          if (length(us) == 1 && us %in% c("Left", "Right")) us else "Left"
        }
        dir <- ifelse(throw_side == "Right", -1, 1)
        seps <- seps %>%
          dplyr::filter(TaggedPitchType %in% avg_mov$TaggedPitchType) %>%
          dplyr::mutate(sep_Horz = sep_Horz * dir)
        line_df <- seps %>% dplyr::mutate(
          start_x = base_val$avg_HorzBreak,
          start_y = base_val$avg_InducedVertBreak,
          end_x   = base_val$avg_HorzBreak + sep_Horz,
          end_y   = base_val$avg_InducedVertBreak + sep_IVB
        )
      }
    }
    
    # Get display options
    display_opts <- input$movementPlotDisplay
    if (is.null(display_opts)) display_opts <- "Averages and Pitches"
    
    show_pitches <- any(c("Averages and Pitches", "Target Shapes and Pitches") %in% display_opts)
    show_averages <- any(c("Averages Only", "Averages and Pitches") %in% display_opts)
    show_targets <- any(c("Target Shapes Only", "Target Shapes and Pitches") %in% display_opts)
    
    # Prepare target shapes data if needed
    target_df <- NULL
    if (show_targets) {
      pitcher_sel <- input$pitcher
      if (!is.null(pitcher_sel) && length(pitcher_sel) == 1 && !("All" %in% pitcher_sel)) {
        pitcher_name <- pitcher_sel[1]
        date_range <- input$dates
        
        # Get target shapes for each pitch type
        target_data <- lapply(types_chr, function(pt) {
          target <- get_target_shape(pitcher_name, pt, date_range, auto_save = FALSE)
          if (!is.null(target)) {
            data.frame(
              TaggedPitchType = pt,
              HB_Target = target$HB,
              IVB_Target = target$IVB,
              stringsAsFactors = FALSE
            )
          } else {
            NULL
          }
        })
        
        target_df <- do.call(rbind, target_data)
      }
    }
    
    p <- ggplot() +
      # Individual Pitches Layer
      { if (show_pitches) {
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(HorzBreak, InducedVertBreak,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          position = "identity",
          alpha = 0.25, size = 2.2, shape = 21, stroke = 0.25
        )
      } } +
      # Average Movement Layer
      { if (show_averages) {
        ggiraph::geom_point_interactive(
          data = avg_mov,
          aes(avg_HorzBreak, avg_InducedVertBreak, color = TaggedPitchType,
              tooltip = tt, data_id = data_id),
          size = 6, show.legend = FALSE
        )
      } } +
      # Break Lines Layer
      { if (nrow(line_df) > 0)
        geom_segment(
          data = line_df,
          aes(x = start_x, y = start_y, xend = end_x, yend = end_y, color = TaggedPitchType),
          size = 1
        )
      } +
      # Target Shapes Layer
      { if (!is.null(target_df) && nrow(target_df) > 0) {
        list(
          # Low alpha fill circle
          geom_point(
            data = target_df,
            aes(HB_Target, IVB_Target, fill = TaggedPitchType),
            size = 10, shape = 21, alpha = 0.10, stroke = 0, show.legend = FALSE
          ),
          # High alpha border circle
          geom_point(
            data = target_df,
            aes(HB_Target, IVB_Target, color = TaggedPitchType),
            size = 10, shape = 21, alpha = 0.8, stroke = 2, fill = NA, show.legend = FALSE
          )
        )
      } } +
      geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
      geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
      coord_cartesian(xlim = c(-25, 25), ylim = c(-25, 25)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      theme(
        legend.position = "bottom",
        legend.text = element_text(size = 14, color = axis_col),
        panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.text.x = element_text(color = axis_col),
        axis.text.y = element_text(color = axis_col)
      )
    
    girafe_transparent(
      ggobj = p,
      options = list(
        ggiraph::opts_tooltip(
          use_fill = TRUE,
          css = "color:white;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
        ),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;"),
        ggiraph::opts_selection(type = "multiple", selected = character(0))
      )
    )
  })
  
  # Event handlers for movement plot pitch type editing
  observeEvent(input$movementPlot_selected, {
    # Default behavior: play video(s) for the clicked pitch
    if (!identical(input$pitch_click_action, "edit")) {
      df <- filtered_data(); req(nrow(df) > 0)
      open_clip_from_df_and_index(df, input$movementPlot_selected, label = "Movement Plot")
      return()
    }
    
    req(input$movementPlot_selected)
    selected_ids <- as.numeric(input$movementPlot_selected)
    df <- filtered_data()
    if (!nrow(df) || !length(selected_ids)) return()
    
    # Get selected pitches
    selected_pitches <- df[selected_ids, ]
    
    # Build pitcher choices (include current selection to ensure availability)
    available_pitchers <- sort(unique(pitch_data_pitching$Pitcher))
    pitcher_choices <- sort(unique(c(available_pitchers, as.character(selected_pitches$Pitcher))))
    
    # Show modal for editing pitch types / pitcher
    showModal(modalDialog(
      title = paste("Edit Pitch Type for", nrow(selected_pitches), "pitch(es)"),
      selectInput("new_pitch_type", "New Pitch Type:",
                  choices = c("Fastball", "Sinker", "Cutter", "Slider", "Sweeper", 
                              "Curveball", "ChangeUp", "Splitter", "Knuckleball"),
                  selected = selected_pitches$TaggedPitchType[1]),
      selectInput("new_pitcher", "Assign To Pitcher:",
                  choices = pitcher_choices,
                  selected = selected_pitches$Pitcher[1]),
      br(),
      strong("Selected Pitches:"),
      br(),
      if (nrow(selected_pitches) <= 10) {
        div(
          lapply(1:nrow(selected_pitches), function(i) {
            p <- selected_pitches[i, ]
            div(sprintf("Pitch %d: %s - %s (%.1f mph, HB: %.1f, IVB: %.1f)",
                        i, p$TaggedPitchType, p$Date, 
                        p$RelSpeed %||% 0, p$HorzBreak %||% 0, p$InducedVertBreak %||% 0))
          })
        )
      } else {
        div(sprintf("%d pitches selected (too many to display individually)", nrow(selected_pitches)))
      },
      footer = tagList(
        modalButton("Cancel"),
        actionButton("confirm_pitch_edit", "Save Changes", class = "btn-primary")
      ),
      easyClose = FALSE
    ))
    
    # Store selected data for use in confirm handler
    session$userData$selected_for_edit <- selected_pitches
  })
  
  output$target_shape_rows_ui <- renderUI({
    rows <- target_shape_rows()
    if (!nrow(rows)) {
      return(tags$p("No saved target shapes yet. Use the form below to add a pitch type.", style = "color:#555;"))
    }
    
    tagList(
      lapply(seq_len(nrow(rows)), function(i) {
        row <- rows[i, , drop = FALSE]
        row_id <- row$RowID[1]
        status <- if (isTRUE(row$IsCustom[1])) "Custom" else "Auto"
        tags$div(
          style = "border:1px solid #e2e8f0; border-radius:8px; padding:12px; margin-bottom:12px; background:#f9fafb;",
          tags$div(
            style = "display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;",
            tags$div(
              tags$strong(row$PitchType[1]),
              tags$span(paste0(" (", status, ")"), style = "color:#64748b;font-size:0.85rem;")
            ),
            tags$div(
              tags$button(
                type = "button",
                class = "btn btn-sm btn-link text-danger",
                style = "padding:.25rem .5rem;",
                onclick = sprintf("Shiny.setInputValue('target_shape_remove', '%s', {priority: 'event'})", row_id),
                "Remove"
              ),
              tags$button(
                type = "button",
                class = "btn btn-sm btn-link text-primary",
                style = "padding:.25rem .5rem;",
                onclick = sprintf("Shiny.setInputValue('target_shape_reset', '%s', {priority: 'event'})", row_id),
                "Reset to Auto"
              )
            )
          ),
          fluidRow(
            column(6,
                   numericInput(paste0("target_ivb_", row_id), "IVB Target:",
                                value = round(ifelse(is.na(row$IVB[1]), 0, row$IVB[1]), 1),
                                step = 0.5, width = "100%")
            ),
            column(6,
                   numericInput(paste0("target_hb_", row_id), "HB Target:",
                                value = round(ifelse(is.na(row$HB[1]), 0, row$HB[1]), 1),
                                step = 0.5, width = "100%")
            )
          )
        )
      })
    )
  })

  # Shared helper to open Target Shapes Settings modal (used across pages)
  open_target_shapes_modal <- function(pitcher_name, date_range, data_override = NULL) {
    if (is.null(pitcher_name) || length(pitcher_name) != 1 || pitcher_name %in% c("", "All")) {
      showNotification("Please select a single pitcher to set target shapes.", 
                       type = "warning", duration = 4)
      return()
    }
    
    data <- data_override
    if (is.null(data)) {
      data <- modified_pitch_data()
      if (is.null(data)) data <- pitch_data_pitching
    }
    
    pitcher_data <- data %>%
      dplyr::filter(Pitcher == pitcher_name)
    
    if (!is.null(date_range) && length(date_range) == 2) {
      pitcher_data <- pitcher_data %>%
        dplyr::filter(Date >= date_range[1], Date <= date_range[2])
    }
    
    pitch_types <- sort(unique(pitcher_data$TaggedPitchType))
    pitch_types <- pitch_types[!is.na(pitch_types)]
    
    if (length(pitch_types) == 0) {
      showNotification("No pitch data found for selected pitcher and date range.", 
                       type = "warning", duration = 4)
      return()
    }

    assigned <- target_shapes() %>%
      dplyr::filter(Pitcher == pitcher_name, PitchType %in% pitch_types)
    rows <- tibble::tibble(
      PitchType = character(),
      IVB = numeric(),
      HB = numeric(),
      RowID = character(),
      IsCustom = logical()
    )
    row_ids <- character()
    if (nrow(assigned) > 0) {
      for (i in seq_len(nrow(assigned))) {
        pt <- assigned$PitchType[i]
        new_id <- make_target_row_id(pt, existing = row_ids)
        row_ids <- c(row_ids, new_id)
        rows <- dplyr::bind_rows(rows, tibble::tibble(
          PitchType = pt,
          IVB = assigned$IVB_Target[i],
          HB = assigned$HB_Target[i],
          RowID = new_id,
          IsCustom = assigned$IsCustom[i]
        ))
      }
    }

    target_shape_rows(rows)
    target_shape_pitch_types(pitch_types)
    available_types <- setdiff(pitch_types, rows$PitchType)

    add_choices <- if (length(available_types)) available_types else c("No pitch types available" = "")
    selected_add <- if (length(available_types)) available_types[1] else ""
    add_defaults <- if (nzchar(selected_add)) calc_default_target_shape(pitcher_name, selected_add, date_range) else NULL
    add_ivb_init <- if (!is.null(add_defaults)) round(add_defaults$IVB, 1) else 0
    add_hb_init <- if (!is.null(add_defaults)) round(add_defaults$HB, 1) else 0

    showModal(modalDialog(
      title = paste("Target Shapes for", pitcher_name),
      size = "l",
      div(
        p("Set target movement shapes for the pitch types you care about. Add one entry per pitch type you want to customize."),
        uiOutput("target_shape_rows_ui"),
        tags$div(
          style = "border:1px dashed #cbd5f5; padding:12px; border-radius:8px; margin-top:12px;",
          tags$h4("Add a target shape", style = "margin-top:0;"),
          fluidRow(
            column(4,
                   selectInput("target_shape_add_pitch_type", "Pitch Type:", 
                               choices = add_choices, selected = selected_add)
            ),
            column(4,
                   numericInput("target_shape_add_ivb", "IVB Target:", 
                                value = add_ivb_init, step = 0.5, width = "100%")
            ),
            column(4,
                   numericInput("target_shape_add_hb", "HB Target:", 
                                value = add_hb_init, step = 0.5, width = "100%")
            )
          ),
          tagList(
            tagAppendAttributes(
              actionButton("target_shape_add_btn", "Add Target Shape", class = "btn-primary"),
              disabled = if (!length(available_types)) "disabled" else NULL
            ),
            if (!length(available_types)) {
              tags$span("Remove a saved target to unlock more pitch types.", 
                        style = "margin-left:12px;color:#64748b;")
            }
          )
        )
      ),
      footer = tagList(
        modalButton("Cancel"),
        actionButton("save_target_shapes_btn", "Save Target Shapes", class = "btn-primary")
      ),
      easyClose = FALSE
    ))

    session$userData$current_pitcher_for_targets <- pitcher_name
    session$userData$current_pitch_types_for_targets <- rows$PitchType
    session$userData$current_target_date_range <- date_range
  }

  observeEvent(target_shape_rows(), ignoreNULL = FALSE, {
    rows <- target_shape_rows()
    pitch_types <- target_shape_pitch_types()
    available <- setdiff(pitch_types, rows$PitchType)
    choices <- if (length(available)) available else c("No pitch types available" = "")
    selected <- if (length(available)) available[1] else ""
    if (!is.null(session$input$target_shape_add_pitch_type)) {
      updateSelectInput(session, "target_shape_add_pitch_type", choices = choices, selected = selected)
    }
    session$userData$current_pitch_types_for_targets <- rows$PitchType
  })

  observeEvent(input$target_shape_add_pitch_type, ignoreInit = TRUE, {
    pt <- input$target_shape_add_pitch_type
    pitcher <- session$userData$current_pitcher_for_targets
    date_range <- session$userData$current_target_date_range
    if (is.null(pt) || !nzchar(pt) || is.null(pitcher) || pitcher == "All") return()
    defaults <- calc_default_target_shape(pitcher, pt, date_range)
    ivb_val <- if (!is.null(defaults)) round(defaults$IVB, 1) else 0
    hb_val <- if (!is.null(defaults)) round(defaults$HB, 1) else 0
    if (!is.null(session$input$target_shape_add_ivb)) {
      updateNumericInput(session, "target_shape_add_ivb", value = ivb_val)
    }
    if (!is.null(session$input$target_shape_add_hb)) {
      updateNumericInput(session, "target_shape_add_hb", value = hb_val)
    }
  })

  observeEvent(input$target_shape_add_btn, ignoreNULL = TRUE, ignoreInit = TRUE, {
    pitcher <- session$userData$current_pitcher_for_targets
    if (is.null(pitcher) || pitcher == "All") {
      showNotification("Select a valid pitcher before adding a target shape.", type = "warning")
      return()
    }
    pt <- input$target_shape_add_pitch_type
    if (is.null(pt) || !nzchar(pt)) {
      showNotification("Pick a pitch type to add.", type = "warning")
      return()
    }
    rows <- target_shape_rows()
    if (pt %in% rows$PitchType) {
      showNotification(paste(pt, "already has a target shape."), type = "warning")
      return()
    }
    ivb_val <- input$target_shape_add_ivb %||% 0
    hb_val <- input$target_shape_add_hb %||% 0
    new_row <- tibble::tibble(
      PitchType = pt,
      IVB = round(ivb_val, 1),
      HB = round(hb_val, 1),
      RowID = make_target_row_id(pt, existing = rows$RowID),
      IsCustom = TRUE
    )
    target_shape_rows(dplyr::bind_rows(rows, new_row))
    showNotification(paste("Added target shape for", pt), type = "message")
  })

  observeEvent(input$target_shape_remove, ignoreNULL = TRUE, ignoreInit = TRUE, {
    row_id <- input$target_shape_remove
    rows <- target_shape_rows()
    if (!nrow(rows)) return()
    updated <- rows[rows$RowID != row_id, , drop = FALSE]
    target_shape_rows(updated)
  })

  observeEvent(input$target_shape_reset, ignoreNULL = TRUE, ignoreInit = TRUE, {
    row_id <- input$target_shape_reset
    rows <- target_shape_rows()
    row <- rows[rows$RowID == row_id, , drop = FALSE]
    if (!nrow(row)) return()
    pitcher <- session$userData$current_pitcher_for_targets
    date_range <- session$userData$current_target_date_range
    reset_target_shape(pitcher, row$PitchType[1], date_range)
    target_shape_rows(rows[rows$RowID != row_id, , drop = FALSE])
    showNotification(paste("Reset", row$PitchType[1], "to automatic target."), type = "message")
  })
  
  # Target Shapes Settings Modal triggers
  observeEvent(input$targetShapesSettings, {
    pitcher_sel <- input$pitcher
    if (is.null(pitcher_sel) || length(pitcher_sel) != 1 || "All" %in% pitcher_sel) {
      showNotification("Please select a single pitcher to set target shapes.", 
                       type = "warning", duration = 4)
      return()
    }
    open_target_shapes_modal(pitcher_sel[1], input$dates)
  }, ignoreInit = TRUE)
  observeEvent(input$pp_goal1_target_settings, {
    open_target_shapes_modal(input$pp_player_select, input$pp_date_range)
  }, ignoreInit = TRUE)
  observeEvent(input$pp_goal2_target_settings, {
    open_target_shapes_modal(input$pp_player_select, input$pp_date_range)
  }, ignoreInit = TRUE)
  observeEvent(input$pp_goal3_target_settings, {
    open_target_shapes_modal(input$pp_player_select, input$pp_date_range)
  }, ignoreInit = TRUE)
  
  # Save target shapes from modal
  observeEvent(input$save_target_shapes_btn, {
    pitcher_name <- session$userData$current_pitcher_for_targets
    rows <- target_shape_rows()
    
    if (is.null(pitcher_name) || nrow(rows) == 0) {
      showNotification("Add at least one pitch type before saving.", type = "warning")
      return()
    }
    
    # Track if any changes were made
    changes_made <- FALSE
    
    for (i in seq_len(nrow(rows))) {
      row <- rows[i, , drop = FALSE]
      ivb_input <- input[[paste0("target_ivb_", row$RowID[1])]]
      hb_input <- input[[paste0("target_hb_", row$RowID[1])]]
      
      if (!is.null(ivb_input) && !is.null(hb_input)) {
        set_target_shape(pitcher_name, row$PitchType[1], ivb_input, hb_input)
        changes_made <- TRUE
      }
    }
    
    if (changes_made) {
      # Trigger re-render of plots
      target_shapes_version(target_shapes_version() + 1)
      
      showNotification("Target shapes saved successfully!", type = "message", duration = 3)
    }
    
    removeModal()
  })
  
  # Observer for display options changes to trigger re-rendering
  observeEvent(input$summaryMovementDisplay, {
    target_shapes_version(target_shapes_version() + 1)
  }, ignoreInit = TRUE)
  
  observeEvent(input$movementPlotDisplay, {
    target_shapes_version(target_shapes_version() + 1)
  }, ignoreInit = TRUE)
  
  # Event handler for summary movement plot
  observeEvent(input$summary_movementPlot_selected, {
    if (!identical(input$pitch_click_action, "edit")) {
      df <- filtered_data(); req(nrow(df) > 0)
      open_clip_from_df_and_index(df, input$summary_movementPlot_selected, label = "Movement Plot (Summary)")
      return()
    }
    
    req(input$summary_movementPlot_selected)
    selected_ids <- as.numeric(input$summary_movementPlot_selected)
    df <- filtered_data()
    if (!nrow(df) || !length(selected_ids)) return()
    
    # Get selected pitches
    selected_pitches <- df[selected_ids, ]
    
    # Build pitcher choices (include current selection to ensure availability)
    available_pitchers <- sort(unique(pitch_data_pitching$Pitcher))
    pitcher_choices <- sort(unique(c(available_pitchers, as.character(selected_pitches$Pitcher))))
    
    # Show modal for editing pitch types / pitcher
    showModal(modalDialog(
      title = paste("Edit Pitch Type for", nrow(selected_pitches), "pitch(es)"),
      selectInput("new_pitch_type_summary", "New Pitch Type:",
                  choices = c("Fastball", "Sinker", "Cutter", "Slider", "Sweeper", 
                              "Curveball", "ChangeUp", "Splitter", "Knuckleball"),
                  selected = selected_pitches$TaggedPitchType[1]),
      selectInput("new_pitcher_summary", "Assign To Pitcher:",
                  choices = pitcher_choices,
                  selected = selected_pitches$Pitcher[1]),
      br(),
      strong("Selected Pitches:"),
      br(),
      if (nrow(selected_pitches) <= 10) {
        div(
          lapply(1:nrow(selected_pitches), function(i) {
            p <- selected_pitches[i, ]
            div(sprintf("Pitch %d: %s - %s (%.1f mph, HB: %.1f, IVB: %.1f)",
                        i, p$TaggedPitchType, p$Date, 
                        p$RelSpeed %||% 0, p$HorzBreak %||% 0, p$InducedVertBreak %||% 0))
          })
        )
      } else {
        div(sprintf("%d pitches selected (too many to display individually)", nrow(selected_pitches)))
      },
      footer = tagList(
        modalButton("Cancel"),
        actionButton("confirm_pitch_edit_summary", "Save Changes", class = "btn-primary")
      ),
      easyClose = FALSE
    ))
    
    # Store selected data for use in confirm handler
    session$userData$selected_for_edit_summary <- selected_pitches
  })

  # Location (Summary tab) – make clicks open video modal
  observeEvent(input$summary_zonePlot_selected, {
    df <- filtered_data(); req(nrow(df) > 0)
    open_clip_from_df_and_index(df, input$summary_zonePlot_selected, label = "Location (Summary)")
  }, ignoreInit = TRUE)

  observeEvent(input[["summary_releasePlot_selected"]], ignoreInit = TRUE, {
    df <- filtered_data(); req(nrow(df) > 0)
    release_handle_click(df, input[["summary_releasePlot_selected"]], prefix = "Release Plot")
  })

  observeEvent(input[["releaseCombo_selected"]], ignoreInit = TRUE, {
    df <- filtered_data(); req(nrow(df) > 0)
    release_handle_click(df, input[["releaseCombo_selected"]], prefix = "Release Combo")
  })

  observeEvent(input[["velocityPlot_selected"]], ignoreInit = TRUE, {
    df <- filtered_data(); req(nrow(df) > 0)
    open_clip_from_df_and_index(df, input[["velocityPlot_selected"]], label = "Velocity Plot")
  })

  observeEvent(input[["velocityByGamePlot_selected"]], ignoreInit = TRUE, {
    df <- filtered_data(); req(nrow(df) > 0)
    info <- parse_velocity_by_game_id(input[["velocityByGamePlot_selected"]])
    rows <- velocity_group_rows(
      df,
      pitch_type = info$pitch_type,
      date = info$date,
      session_type = info$session
    )
    label <- sprintf("%s %s", info$pitch_type %||% "Pitch", if (!is.na(info$date)) format(info$date, "%m/%d/%y") else "")
    execute_velocity_selection(rows, label)
  })

  observeEvent(input[["velocityInningPlot_selected"]], ignoreInit = TRUE, {
    df <- filtered_data(); req(nrow(df) > 0)
    info <- parse_velocity_inning_id(input[["velocityInningPlot_selected"]])
    rows <- velocity_group_rows(
      df,
      pitch_type = info$pitch_type,
      inning_ord = info$inning_ord
    )
    label <- sprintf("%s Inning %s", info$pitch_type %||% "Pitch", info$inning_ord %||% "")
    execute_velocity_selection(rows, label)
  })
  
  # Confirm pitch type changes (main movement plot)
  observeEvent(input$confirm_pitch_edit, {
    req(session$userData$selected_for_edit, input$new_pitch_type, input$new_pitcher)
    
    selected_pitches <- session$userData$selected_for_edit
    new_type <- input$new_pitch_type
    new_pitcher <- input$new_pitcher %||% ""
    lookup_df <- get0("lookup_table", ifnotfound = NULL)
    fetch_email <- function(name) {
      if (is.null(lookup_df) || !"Pitcher" %in% names(lookup_df) || !"Email_lookup" %in% names(lookup_df)) {
        return(NA_character_)
      }
      idx <- which(tolower(lookup_df$Pitcher) == tolower(name))
      if (length(idx)) {
        val <- lookup_df$Email_lookup[idx[1]]
        if (is.na(val) || !nzchar(val)) return(NA_character_)
        return(val)
      }
      NA_character_
    }
    
    # Update the modified pitch data
    current_data <- modified_pitch_data()
    if (is.null(current_data)) current_data <- pitch_data_pitching
    updated_data <- current_data
    
    # Update each selected pitch using multiple matching criteria
    for (i in 1:nrow(selected_pitches)) {
      p <- selected_pitches[i, ]
      match_idx <- which(
        updated_data$Pitcher == p$Pitcher &
          updated_data$Date == p$Date &
          abs(updated_data$RelSpeed - (p$RelSpeed %||% 0)) < 0.1 &
          abs(updated_data$HorzBreak - (p$HorzBreak %||% 0)) < 0.1 &
          abs(updated_data$InducedVertBreak - (p$InducedVertBreak %||% 0)) < 0.1
      )
      if (length(match_idx) > 0) {
        updated_data$TaggedPitchType[match_idx] <- new_type
        if (nzchar(new_pitcher)) {
          updated_data$Pitcher[match_idx] <- new_pitcher
          new_email <- fetch_email(new_pitcher)
          if (!is.na(new_email)) {
            updated_data$Email[match_idx] <- new_email
          }
        }
      }
    }
    
    # Save modifications to database
    save_result <- save_pitch_modifications_db(selected_pitches, new_type, new_pitcher)
    if (!isTRUE(save_result$success)) {
      showNotification(
        paste0("Could not store pitch type edits: ", save_result$error %||% "unknown error"),
        type = "error", duration = 8
      )
      return()
    }
    
    # Update reactive value only after successful persistence
    modified_pitch_data(updated_data)
    
    # Update modification stats
    result <- load_pitch_modifications_db(pitch_data_pitching, verbose = FALSE)
    modification_stats(list(
      applied_count = result$applied_count,
      total_modifications = result$total_modifications
    ))
    
    saved_count <- save_result$count %||% nrow(selected_pitches)
    showNotification(
      sprintf("Saved %d pitch type modifications", saved_count),
      type = "message", duration = 3
    )
    
    removeModal()
    session$userData$selected_for_edit <- NULL
  })
  
  # Confirm pitch type changes (summary movement plot)
  observeEvent(input$confirm_pitch_edit_summary, {
    req(session$userData$selected_for_edit_summary, input$new_pitch_type_summary, input$new_pitcher_summary)
    
    selected_pitches <- session$userData$selected_for_edit_summary
    new_type <- input$new_pitch_type_summary
    new_pitcher <- input$new_pitcher_summary %||% ""
    lookup_df <- get0("lookup_table", ifnotfound = NULL)
    fetch_email <- function(name) {
      if (is.null(lookup_df) || !"Pitcher" %in% names(lookup_df) || !"Email_lookup" %in% names(lookup_df)) {
        return(NA_character_)
      }
      idx <- which(tolower(lookup_df$Pitcher) == tolower(name))
      if (length(idx)) {
        val <- lookup_df$Email_lookup[idx[1]]
        if (is.na(val) || !nzchar(val)) return(NA_character_)
        return(val)
      }
      NA_character_
    }
    
    # Update the modified pitch data
    current_data <- modified_pitch_data()
    if (is.null(current_data)) current_data <- pitch_data_pitching
    updated_data <- current_data
    
    # Update each selected pitch using multiple matching criteria
    for (i in 1:nrow(selected_pitches)) {
      p <- selected_pitches[i, ]
      match_idx <- which(
        updated_data$Pitcher == p$Pitcher &
          updated_data$Date == p$Date &
          abs(updated_data$RelSpeed - (p$RelSpeed %||% 0)) < 0.1 &
          abs(updated_data$HorzBreak - (p$HorzBreak %||% 0)) < 0.1 &
          abs(updated_data$InducedVertBreak - (p$InducedVertBreak %||% 0)) < 0.1
      )
      if (length(match_idx) > 0) {
        updated_data$TaggedPitchType[match_idx] <- new_type
        if (nzchar(new_pitcher)) {
          updated_data$Pitcher[match_idx] <- new_pitcher
          new_email <- fetch_email(new_pitcher)
          if (!is.na(new_email)) {
            updated_data$Email[match_idx] <- new_email
          }
        }
      }
    }
    
    # Save modifications to database
    save_result <- save_pitch_modifications_db(selected_pitches, new_type, new_pitcher)
    if (!isTRUE(save_result$success)) {
      showNotification(
        paste0("Could not store pitch type edits: ", save_result$error %||% "unknown error"),
        type = "error", duration = 8
      )
      return()
    }
    
    # Update reactive value only after successful persistence
    modified_pitch_data(updated_data)
    
    # Update modification stats
    result <- load_pitch_modifications_db(pitch_data_pitching, verbose = FALSE)
    modification_stats(list(
      applied_count = result$applied_count,
      total_modifications = result$total_modifications
    ))
    
    saved_count <- save_result$count %||% nrow(selected_pitches)
    showNotification(
      sprintf("Saved %d pitch type modifications", saved_count),
      type = "message", duration = 3
    )
    
    removeModal()
    session$userData$selected_for_edit_summary <- NULL
  })
  
  parse_velocity_by_game_id <- function(data_id) {
    if (is.null(data_id)) return(list(pitch_type = NA_character_, date = NA, session = NA_character_))
    parts <- strsplit(as.character(data_id), "_", fixed = TRUE)[[1]]
    date_part <- if (length(parts) >= 1) parts[1] else NA_character_
    pitch_part <- if (length(parts) >= 2) parts[2] else NA_character_
    session_part <- if (length(parts) >= 3) parts[3] else NA_character_
    date_val <- suppressWarnings(as.Date(date_part))
    list(
      pitch_type = pitch_part,
      date = if (!is.na(date_val)) date_val else NA,
      session = session_part
    )
  }

  parse_velocity_inning_id <- function(data_id) {
    if (is.null(data_id)) return(list(pitch_type = NA_character_, inning_ord = NA_integer_))
    parts <- strsplit(as.character(data_id), "_", fixed = TRUE)[[1]]
    inning_val <- if (length(parts) >= 2) suppressWarnings(as.integer(parts[2])) else NA_integer_
    list(
      pitch_type = parts[1] %||% NA_character_,
      inning_ord = inning_val
    )
  }

  velocity_group_rows <- function(df, pitch_type = NULL, date = NULL, session_type = NULL, inning_ord = NULL) {
    if (is.null(df) || !nrow(df)) return(df[FALSE, , drop = FALSE])
    rows <- df
    if (!is.null(pitch_type) && nzchar(pitch_type)) {
      rows <- rows[rows$TaggedPitchType == pitch_type, , drop = FALSE]
    }
    if (!is.null(date) && inherits(date, "Date") && !is.na(date)) {
      dates <- suppressWarnings(as.Date(rows$Date))
      rows <- rows[!is.na(dates) & dates == date, , drop = FALSE]
    }
    if (!is.null(session_type) && nzchar(session_type) && session_type != "U") {
      rows <- rows[rows$SessionType == session_type, , drop = FALSE]
    }
    if (!is.null(inning_ord) && is.finite(inning_ord)) {
      rows <- rows[rows$SessionType == "Live" & !is.na(rows$Inning), , drop = FALSE]
      if (!nrow(rows)) return(rows[FALSE, , drop = FALSE])
      game_key <- if ("GameID" %in% names(rows)) {
        as.character(rows$GameID)
      } else {
        format(as.Date(rows$Date), "%Y-%m-%d")
      }
      rows$GameKey <- dplyr::coalesce(game_key, format(as.Date(rows$Date), "%Y-%m-%d"))
      rows <- dplyr::arrange(rows, GameKey, dplyr::row_number())
      rows <- dplyr::group_by(rows, GameKey)
      rows <- dplyr::mutate(rows, InningOrd = match(Inning, unique(Inning)))
      rows <- dplyr::ungroup(rows)
      rows <- rows[rows$InningOrd == inning_ord, , drop = FALSE]
    }
    rows
  }

  execute_velocity_selection <- function(rows, label) {
    if (is.null(rows) || !nrow(rows)) {
      showModal(modalDialog("No pitches found for this selection.", easyClose = TRUE, footer = NULL))
      return(invisible(FALSE))
    }
    show_pitch_video_sequence(
      rows,
      label = label,
      compare_pool = rows,
      primary_pool_idx = 1L
    )
    invisible(TRUE)
  }

  release_rows_for_type <- function(df, pitch_type) {
    if (is.null(df) || !nrow(df) || is.null(pitch_type) || !nzchar(pitch_type)) return(df[FALSE, , drop = FALSE])
    df[df$TaggedPitchType == pitch_type, , drop = FALSE]
  }

  release_handle_click <- function(df, data_id, prefix = "Release") {
    if (is.null(df) || !nrow(df) || is.null(data_id)) return(invisible(FALSE))
    ids <- unique(as.character(data_id))
    if (!length(ids)) return(invisible(FALSE))
    for (id in ids) {
      if (!nzchar(id)) next
      idx <- suppressWarnings(as.integer(id))
      if (!is.na(idx) && idx >= 1 && idx <= nrow(df)) {
        open_clip_from_df_and_index(df, idx, label = sprintf("%s pitch %s", prefix, idx))
        next
      }
      rows <- release_rows_for_type(df, id)
      if (!nrow(rows)) next
      label <- sprintf("%s %s", prefix, id)
      show_pitch_video_sequence(
        rows,
        label = label,
        compare_pool = rows,
        primary_pool_idx = 1L
      )
    }
    invisible(TRUE)
  }

  # Velocity Plot
  # Helper: pick the first existing column name from a preference list
  # ---------- helpers (replace the previous .pick_col) ----------
  .pick_col <- function(df, candidates) {
    nm <- intersect(candidates, names(df))
    if (length(nm)) nm[[1]] else NA_character_
  }
  .safe_mean <- function(x) {
    x <- suppressWarnings(as.numeric(x))
    if (all(is.na(x))) NA_real_ else mean(x, na.rm = TRUE)
  }
  HB_CANDIDATES  <- c("HB","HorzBreak","HorizBreak","HorizontalBreak","HBreak","HB_in","HB_inches")
  IVB_CANDIDATES <- c("IVB","InducedVertBreak","IVB_in","IVB_inches")
  
  
  # ----------------------------
  # 1) CURRENT VELO PLOT (+ inning vlines for Live)
  # ----------------------------
  output$velocityPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    
    df2 <- df %>% dplyr::arrange(Date, dplyr::row_number()) %>% dplyr::mutate(
      PitchCount = dplyr::row_number(),
      tt  = make_hover_tt(.),
      rid = dplyr::row_number()
    )
    
    sp <- df2$RelSpeed
    if (all(is.na(sp))) {
      y_min <- 0; y_max <- 100
    } else {
      y_min <- floor(min(sp, na.rm = TRUE) / 5) * 5
      y_max <- ceiling(max(sp, na.rm = TRUE) / 5) * 5
      if (y_min == y_max) y_max <- y_min + 5
    }
    x_max <- ceiling(max(df2$PitchCount, na.rm = TRUE) / 5) * 5
    if (!is.finite(x_max) || x_max <= 0) x_max <- 5
    
    avg_velo <- df2 %>% dplyr::filter(!is.na(RelSpeed)) %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(avg_velo = mean(RelSpeed), .groups = "drop")
    
    p <- ggplot(df2, aes(PitchCount, RelSpeed)) +
      ggiraph::geom_point_interactive(
        aes(color = TaggedPitchType, fill = TaggedPitchType, tooltip = tt, data_id = rid),
        position = "identity",
        size = 3, alpha = 0.9, shape = 21, stroke = 0.25
      ) +
      geom_hline(
        data = avg_velo,
        aes(yintercept = avg_velo, color = TaggedPitchType),
        linewidth = 0.9, inherit.aes = FALSE, show.legend = FALSE
      ) +
      scale_x_continuous(limits = c(0, x_max), breaks = seq(0, x_max, 5)) +
      scale_y_continuous(limits = c(y_min, y_max), breaks = seq(y_min, y_max, 5)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      theme(
        legend.position = "bottom",
        legend.text = element_text(size = 14, color = axis_col),
        axis.text.x = element_text(color = axis_col),
        axis.text.y = element_text(color = axis_col),
        axis.title.x = element_text(color = axis_col),
        axis.title.y = element_text(color = axis_col)
      ) +
      labs(title = "Velocity Chart (Game/Inning)", x = "Pitch Count", y = "Velocity (MPH)")
    
    # NEW: dashed vertical lines at inning boundaries (Live only)
    if ("SessionType" %in% names(df2) &&
        length(na.omit(unique(df2$SessionType))) == 1 &&
        na.omit(unique(df2$SessionType)) == "Live" &&
        "Inning" %in% names(df2)) {
      
      inning <- df2$Inning
      # first pitch of each NEW inning (skip very first overall)
      boundary_idx <- which(!is.na(inning) & dplyr::lag(inning, default = inning[1]) != inning)
      boundary_idx <- boundary_idx[boundary_idx != 1]
      if (length(boundary_idx)) {
        vlines <- dplyr::tibble(x = df2$PitchCount[boundary_idx])
        p <- p + geom_vline(data = vlines, aes(xintercept = x),
                            linetype = "dashed", linewidth = 0.4, alpha = 0.6,
                            inherit.aes = FALSE)
      }
    }
    
    girafe_transparent(
      ggobj = p,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  # ----------------------------
  # 2) NEW: Velocity by Game (Date) & Pitch Type
  #     - dot per pitch type per Date, connected lines by pitch type
  #     - tooltip: Date, Session, Velo, IVB, HB (no InZone)
  # ----------------------------
  # ----------------------------
  # Velocity by Game (Date) & Pitch Type  — updated tooltip + x-axis
  # ----------------------------
  output$velocityByGamePlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    
    ivb_nm <- .pick_col(df, IVB_CANDIDATES)
    hb_nm  <- .pick_col(df, HB_CANDIDATES)
    
    dfG <- df %>%
      dplyr::filter(!is.na(RelSpeed), !is.na(TaggedPitchType), !is.na(Date)) %>%
      dplyr::mutate(
        IVB_ = if (!is.na(ivb_nm)) .data[[ivb_nm]] else NA_real_,
        HB_  = if (!is.na(hb_nm))  .data[[hb_nm]]  else NA_real_
      ) %>%
      dplyr::group_by(Date, TaggedPitchType, SessionType) %>%
      dplyr::summarise(
        Velo = .safe_mean(RelSpeed),
        IVB  = .safe_mean(IVB_),
        HB   = .safe_mean(HB_),
        n    = dplyr::n(),
        .groups = "drop"
      ) %>%
      dplyr::arrange(Date, TaggedPitchType) %>%
      dplyr::mutate(
        tt  = paste0(
          "Session: ", dplyr::coalesce(as.character(SessionType), "Unknown"), "\n",
          TaggedPitchType, "\n",
          "Velo: ", sprintf("%.1f", Velo), " mph\n",
          "IVB: ",  ifelse(is.finite(IVB), sprintf("%.1f", IVB), "—"), "\n",
          "HB: ",   ifelse(is.finite(HB),  sprintf("%.1f", HB),  "—"), "\n",
          "Pitches: ", n
        ),
        rid = paste0(format(Date, "%Y-%m-%d"), "_", TaggedPitchType, "_", dplyr::coalesce(as.character(SessionType), "U"))
      )
    
    if (!nrow(dfG)) return(NULL)
    
    sp <- df$RelSpeed
    if (all(is.na(sp))) { y_min <- 0; y_max <- 100 } else {
      y_min <- floor(min(sp, na.rm = TRUE) / 5) * 5
      y_max <- ceiling(max(sp, na.rm = TRUE) / 5) * 5
      if (y_min == y_max) y_max <- y_min + 5
    }
    
    # Evenly spaced x-axis using ordered factor of dates
    date_levels <- format(sort(unique(dfG$Date)), "%m/%d/%y")
    dfG <- dfG %>%
      dplyr::mutate(date_fac = factor(format(Date, "%m/%d/%y"), levels = date_levels))
    
    p2 <- ggplot(dfG, aes(date_fac, Velo, group = TaggedPitchType, color = TaggedPitchType)) +
      ggiraph::geom_line_interactive(linewidth = 0.7, alpha = 0.85) +
      ggiraph::geom_point_interactive(
        aes(tooltip = tt, data_id = rid, fill = TaggedPitchType),
        size = 3, shape = 21, stroke = 0.25
      ) +
      scale_x_discrete(expand = c(0.02, 0.02)) +
      scale_y_continuous(limits = c(y_min, y_max), breaks = seq(y_min, y_max, 5)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      theme(
        legend.position = "bottom",
        legend.text = element_text(size = 14, color = axis_col),
        axis.text.x = element_text(angle = 45, hjust = 1, color = axis_col),
        axis.text.y = element_text(color = axis_col),
        axis.title.x = element_text(color = axis_col),
        axis.title.y = element_text(color = axis_col)
      ) +
      labs(title = "Average Velocity by Game",
           x = "Game Date", y = "Velocity (MPH)")
    
    girafe_transparent(
      ggobj = p2,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  
  # ----------------------------
  # 3) NEW: Inning-to-Inning Average Velocity (relative to entry inning)
  #     - Live only
  #     - x = 1st, 2nd, 3rd inning *the pitcher threw in that game*
  # ----------------------------
  # ----------------------------
  # Inning-to-Inning Average Velocity — updated tooltip (Session only) + HB fix
  # ----------------------------
  output$velocityInningPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    if (!("SessionType" %in% names(df)) || !"Inning" %in% names(df)) return(NULL)
    
    df_live <- df %>% dplyr::filter(SessionType == "Live", !is.na(RelSpeed), !is.na(Inning))
    if (!nrow(df_live)) return(NULL)
    
    ivb_nm <- .pick_col(df_live, IVB_CANDIDATES)
    hb_nm  <- .pick_col(df_live, HB_CANDIDATES)
    
    df_live <- df_live %>%
      dplyr::mutate(
        GameKey = dplyr::case_when(
          "GameID" %in% names(df_live) ~ as.character(.data[["GameID"]]),
          TRUE                         ~ format(as.Date(Date), "%Y-%m-%d")
        )
      ) %>%
      dplyr::arrange(GameKey, dplyr::row_number()) %>%
      dplyr::group_by(GameKey) %>%
      dplyr::mutate(InningOrd = match(Inning, unique(Inning))) %>%
      dplyr::ungroup()
    
    dfI <- df_live %>%
      dplyr::mutate(
        IVB_ = if (!is.na(ivb_nm)) .data[[ivb_nm]] else NA_real_,
        HB_  = if (!is.na(hb_nm))  .data[[hb_nm]]  else NA_real_
      ) %>%
      dplyr::group_by(InningOrd, TaggedPitchType) %>%
      dplyr::summarise(
        Velo  = .safe_mean(RelSpeed),
        IVB   = .safe_mean(IVB_),
        HB    = .safe_mean(HB_),
        n     = dplyr::n(),
        games = dplyr::n_distinct(GameKey),
        .groups = "drop"
      ) %>%
      dplyr::arrange(InningOrd, TaggedPitchType) %>%
      dplyr::mutate(
        tt = paste0(
          "Session: Live\n",
          "Inning #: ", InningOrd, "\n",
          TaggedPitchType, "\n",
          "Velo: ", sprintf("%.1f", Velo), " mph\n",
          "IVB: ",  ifelse(is.finite(IVB), sprintf("%.1f", IVB), "—"), "\n",
          "HB: ",   ifelse(is.finite(HB),  sprintf("%.1f", HB),  "—"), "\n",
          "Games: ", games, " | Pitches: ", n
        ),
        rid = paste0(TaggedPitchType, "_", InningOrd)
      )
    
    if (!nrow(dfI)) return(NULL)
    
    sp <- df_live$RelSpeed
    if (all(is.na(sp))) { y_min <- 0; y_max <- 100 } else {
      y_min <- floor(min(sp, na.rm = TRUE) / 5) * 5
      y_max <- ceiling(max(sp, na.rm = TRUE) / 5) * 5
      if (y_min == y_max) y_max <- y_min + 5
    }
    
    xmax <- max(dfI$InningOrd, na.rm = TRUE)
    p3 <- ggplot(dfI, aes(InningOrd, Velo, group = TaggedPitchType, color = TaggedPitchType)) +
      ggiraph::geom_line_interactive(linewidth = 0.7, alpha = 0.85) +
      ggiraph::geom_point_interactive(
        aes(tooltip = tt, data_id = rid, fill = TaggedPitchType),
        size = 3, shape = 21, stroke = 0.25
      ) +
      scale_x_continuous(breaks = seq_len(xmax)) +
      scale_y_continuous(limits = c(y_min, y_max), breaks = seq(y_min, y_max, 5)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      theme(
        legend.position = "bottom",
        legend.text = element_text(size = 14, color = axis_col),
        axis.text.x = element_text(color = axis_col),
        axis.text.y = element_text(color = axis_col),
        axis.title.x = element_text(color = axis_col),
        axis.title.y = element_text(color = axis_col)
      ) +
      labs(title = "Average Velocity by Inning ",
           x = "Inning of Appearance", y = "Velocity (MPH)")
    
    girafe_transparent(
      ggobj = p3,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  # Velocity Trend Plot
  # Replace your existing output$veloTrendPlot with this:
  
  output$veloTrendPlot <- renderPlot({
    df <- filtered_data(); req(nrow(df)>0)
    # compute average velocity per date
    velo_dat <- df %>%
      group_by(Date) %>%
      summarise(avg_velo = mean(RelSpeed, na.rm=TRUE), .groups="drop") %>%
      arrange(Date)
    
    # dynamic y-axis limits based on data
    y_min <- floor(min(velo_dat$avg_velo, na.rm=TRUE) / 5) * 5
    y_max <- ceiling(max(velo_dat$avg_velo, na.rm=TRUE) / 5) * 5
    if (y_min == y_max) {
      y_min <- y_min - 5
      y_max <- y_max + 5
    }
    
    # preserve date ordering
    date_levels <- unique(fmt_date(velo_dat$Date))
    velo_dat <- velo_dat %>% mutate(Date_f = factor(fmt_date(Date), levels = date_levels))
    
    # single-line plot with dynamic y-axis
    ggplot(velo_dat, aes(x = Date_f, y = avg_velo, group = 1)) +
      geom_line(size = 1.2) +
      geom_point(size = 2) +
      scale_y_continuous(limits = c(y_min, y_max), breaks = seq(y_min, y_max, 5)) +
      labs(title = "Average Velocity", x = NULL, y = "Velocity (MPH)") +
      theme_minimal() + axis_theme +
      theme(
        plot.title     = element_text(face = "bold"),
        axis.text.x    = element_text(angle = 45, hjust = 1),
        axis.line.x    = element_line(color = "black"),
        axis.line.y    = element_line(color = "black")
      )
  }, bg = "transparent")
  
  # Heatmap Plot (using modern KDE approach like other suites)
  output$heatmapPlot <- renderPlot({
    df <- filtered_data()
    if (!nrow(df)) return(ggplot() + theme_void())
    
    sel <- sel_results()
    
    # If not "All", filter to selected result types only (exclude NAs).
    if (!identical(sel, result_levels)) {
      hit_opts  <- c("Single", "Double", "Triple", "HomeRun", "Error")
      sel_hits  <- intersect(sel, hit_opts)
      df <- dplyr::filter(
        df,
        (!is.na(Result) & Result %in% sel) |
          (!is.na(PlayResult) & PlayResult %in% sel_hits)
      )
    }
    # If "All", keep everything (including NA results).
    
    if (!nrow(df)) return(ggplot() + theme_void())
    
    # Use KDE frequency heatmap (matching all other suites)
    grid <- make_kde_grid(df$PlateLocSide, df$PlateLocHeight)
    if (!nrow(grid)) return(ggplot() + theme_void())
    
    # Normalize KDE values to 0-100 scale for better color mapping
    grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
    
    # Use blue->red palette for frequency (matching other suites)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "Pitch Frequency",
                     scale_limits = c(0, 80)))
  }, bg = "transparent")
  
  # Pitch Plot
  output$pitchPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    
    sel <- sel_results()
    if (!identical(sel, result_levels)) {
      df <- dplyr::filter(df, !is.na(Result) & Result %in% sel)
    }
    
    df_i <- df %>%
      dplyr::mutate(
        tt      = make_hover_tt(.),
        rid     = dplyr::row_number(),
        tt_fill = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray")
      )
    
    home <- data.frame(x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
                       y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5)
    cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
    sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
    
    df_known <- dplyr::filter(df_i, !is.na(Result))
    df_other <- dplyr::filter(df_i,  is.na(Result))
    
    p <- ggplot() +
      geom_polygon(data = home, aes(x, y), fill = NA, color = "black", inherit.aes = FALSE) +
      geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = "black", linetype = "dashed", inherit.aes = FALSE) +
      geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = "black", inherit.aes = FALSE) +
      
      ggiraph::geom_point_interactive(
        data = df_other,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
      ) +
      
      ggiraph::geom_point_interactive(
        data = df_known,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 4.0, alpha = 0.95, stroke = 0.8
      ) +
      
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
      coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
      theme_void() + theme(legend.position = "none") +
      
      # 🔹 Invisible “hover pad” to force correct tooltip fill even for hollow shapes
      ggiraph::geom_point_interactive(
        data = df_i,
        aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
        shape = 21, size = 6, alpha = 0.001, stroke = 0, inherit.aes = FALSE
      )
    
    girafe_transparent(
      ggobj = p,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  # ---------- Shared helpers for this page ----------
  # NOTE: Removed duplicate Pitch Results filter (locResult) - now using main sidebar's pitchResults
  
  # Current selection of results (use main sidebar's pitchResults filter)
  sel_results <- reactive({
    sel <- input$pitchResults
    if (is.null(sel) || !length(sel) || "All" %in% sel) return(result_levels)
    
    # If a specific hit type is chosen, also include the grouped in-play hit result
    hit_opts <- c("Single", "Double", "Triple", "HomeRun")
    if (any(sel %in% hit_opts)) {
      sel <- unique(c(sel, "In Play (Hit)"))
    }
    sel
  })
  
  # Small note: hide EV notice unless user picks Pitch chart with EV (heat-only stat)
  output$hmNote <- renderUI({
    if (identical(input$hmChartType, "Pitch") && identical(input$hmStat, "EV")) {
      tags$div(style="margin-top:8px; font-size:12px; color:#a00;",
               "Note: Exit Velocity is a heat-map metric; switch chart to 'Heat' to view.")
    } else NULL
  })
  
  # Legend (shapes + pitch type colors), like Location page
  output$locLegend <- renderUI({
    df <- filtered_data()
    types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
    
    shape_key <- list(
      "Called Strike" = "\u25CF", # ●
      "Ball"          = "\u25CB", # ○
      "Foul"          = "\u25B3", # △
      "Whiff"         = "\u2605", # ★
      "In Play (Out)" = "\u25B2", # ▲
      "In Play (Hit)" = "\u25A0", # ■
      "Single"        = "\u25A0", # ■
      "Double"        = "\u25A0", # ■
      "Triple"        = "\u25A0", # ■
      "HomeRun"       = "\u25A0", # ■
      "Error"         = "\u25A1"  # □
    )
    
    sty <- HTML("
    .legend-block { margin-bottom:10px; }
    .legend-title { font-weight:700; margin-bottom:6px; }
    .legend-list  { list-style:none; padding-left:0; margin:0; }
    .legend-list li { margin:2px 0; display:flex; align-items:center; }
    .dot { display:inline-block; width:12px; height:12px; border-radius:50%;
           border:1px solid #000; margin-right:6px; }
    .shape { width:18px; display:inline-block; margin-right:6px; text-align:center; }
  ")
    
    tags$div(
      tags$style(sty),
      
      tags$div(class="legend-block",
               tags$div(class="legend-title", "Pitch Result"),
               tags$ul(class="legend-list",
                       lapply(result_levels, function(lbl) {
                         tags$li(tags$span(class="shape", if (is.null(shape_key[[lbl]])) "" else shape_key[[lbl]]),
                                 tags$span(lbl))
                       })
               )
      ),
      
      tags$div(class="legend-block",
               tags$div(class="legend-title", "Pitch Type"),
               tags$ul(class="legend-list",
                       lapply(types, function(tp) {
                         col <- all_colors[[tp]]; if (is.null(col)) col <- "gray"
                         tags$li(tags$span(class="dot", style = paste0("background:", col, ";")),
                                 tags$span(tp))
                       })
               )
      )
    )
  })
  
  # ---------- HEAT (respects Pitch Results filter) ----------
  output$heatmapsHeatPlot <- renderPlot({
    df <- filtered_data(); if (!nrow(df)) return()
    
    if (!("Result" %in% names(df))) {
      df$Result <- factor(compute_result(df$PitchCall, df$PlayResult), levels = result_levels)
    }
    
    sel <- sel_results()
    if (!identical(sel, result_levels)) {
      hit_opts <- c("Single", "Double", "Triple", "HomeRun", "Error")
      sel_hits <- intersect(sel, hit_opts)
      df <- dplyr::filter(
        df,
        (!is.na(Result) & Result %in% sel) |
          (!is.na(PlayResult) & PlayResult %in% sel_hits)
      )
    }
    if (!nrow(df)) return(ggplot() + theme_void())
    
    stat <- input$hmStat
    render_heatmap_stat(df, stat)
  }, bg = "transparent")
  
  # ---------- PITCH (point chart; respects Pitch Results filter) ----------
  output$heatmapsPitchPlot <- ggiraph::renderGirafe({
    req(input$hmChartType == "Pitch")
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    
    # Ensure Result for filtering + shapes
    if (!("Result" %in% names(df))) {
      df$Result <- factor(compute_result(df$PitchCall, df$PlayResult), levels = result_levels)
    }
    
    sel <- sel_results()
    if (!identical(sel, result_levels)) {
      df <- dplyr::filter(df, !is.na(Result) & Result %in% sel)
    }
    if (!nrow(df)) return(NULL)
    
    types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
    types_chr <- as.character(types)
    
    df_i <- df %>%
      dplyr::mutate(
        tt      = make_hover_tt(.),
        rid     = dplyr::row_number(),
        tt_fill = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray")
      )
    
    home <- data.frame(x=c(-0.75,0.75,0.75,0.00,-0.75),
                       y=c(1.05,1.05,1.15,1.25,1.15)-0.5)
    cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
    sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
    
    p <- ggplot() +
      geom_polygon(data = home, aes(x, y), fill = NA, color = "black") +
      geom_rect(data = cz, aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),
                fill = NA, color = "black", linetype = "dashed") +
      geom_rect(data = sz, aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),
                fill = NA, color = "black") +
      
      # visible points (unknown result as solid circle)
      ggiraph::geom_point_interactive(
        data = dplyr::filter(df_i, is.na(Result)),
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType,
            tooltip = tt, data_id = rid),
        size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
      ) +
      
      # visible points (known result with shapes)
      ggiraph::geom_point_interactive(
        data = dplyr::filter(df_i, !is.na(Result)),
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
            tooltip = tt, data_id = rid),
        size = 4.0, alpha = 0.95, stroke = 0.8
      ) +
      
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
      coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
      theme_void() + theme(legend.position = "none") +
      
      # invisible hover pad to guarantee correct tooltip fill even for hollow shapes
      ggiraph::geom_point_interactive(
        data = df_i,
        aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
        shape = 21, size = 6, alpha = 0.001, stroke = 0, inherit.aes = FALSE
      )
    
    girafe_transparent(
      ggobj = p,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  # ---------- QP+ single heatmap (pitch overlay) ----------
  count_families_for_selection <- function(sel) {
    if (is.null(sel) || !length(sel)) return(character(0))
    sel <- trimws(sel)
    sel <- sel[sel != "All" & nzchar(sel)]
    if (!length(sel)) return(character(0))
    fams <- character(0)
    add_family <- function(x) fams <<- c(fams, x)
    ahead_pairs   <- list(c(0,1), c(0,2), c(1,2))
    even_pairs    <- list(c(0,0), c(1,1), c(2,2), c(3,2))
    behind_pairs  <- list(c(1,0), c(2,0), c(3,0), c(3,1), c(2,1))
    if ("Ahead" %in% sel)   add_family("Ahead")
    if ("Even" %in% sel)    add_family("Even")
    if ("Behind" %in% sel)  add_family("Behind")
    if ("2KNF" %in% sel)    add_family("Ahead")  # treat two-strike no fastball as ahead-family
    exact <- sel[grepl("^\\d-\\d$", sel)]
    if (length(exact)) {
      for (val in exact) {
        sp <- strsplit(val, "-", fixed = TRUE)[[1]]
        if (length(sp) == 2) {
          b <- suppressWarnings(as.integer(sp[1])); s <- suppressWarnings(as.integer(sp[2]))
          if (any(vapply(ahead_pairs,   function(p) identical(c(b,s), p), logical(1)))) add_family("Ahead")
          else if (any(vapply(even_pairs,   function(p) identical(c(b,s), p), logical(1)))) add_family("Even")
          else if (any(vapply(behind_pairs, function(p) identical(c(b,s), p), logical(1)))) add_family("Behind")
          else add_family("Other")
        }
      }
    }
    unique(fams)
  }
  
  output$heatmapsQPPlot <- ggiraph::renderGirafe({
    req(input$hmChartType == "QP+")
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    
    pitcher_hand <- get_pitcher_handedness()
    batter_hand  <- input$batterSide
    fams_sel <- count_families_for_selection(input$countFilter)
    fams_df <- character(0)
    if (nrow(df) && all(c("Balls","Strikes") %in% names(df))) {
      cs <- count_state_vec(df$Balls, df$Strikes)
      fams_df <- unique(cs[!is.na(cs)])
    }
    fams_use <- unique(c(fams_sel, fams_df))
    pitch_sel <- input$pitchType
    # Require exactly one pitch type (no "All") so we show a single chart
    valid_pitch_type <- !is.null(pitch_sel) && length(pitch_sel) == 1 && pitch_sel != "All"
    
    fams_no_other <- setdiff(fams_use, "Other")
    
    validate(
      need(!is.null(pitcher_hand), "Select a pitcher (or pitcher hand) to view QP+."),
      need(!is.null(batter_hand) && batter_hand != "All", "Select batter handedness to view QP+."),
      need(valid_pitch_type, "Select exactly one pitch type (not \"All\") for QP+."),
      need(length(fams_no_other) > 0, "Select counts from Ahead, Even, or Behind to view QP+."),
      need(length(unique(fams_no_other)) == 1, "Select counts from a single family (Ahead, Even, or Behind).")
    )
    
    count_state <- fams_no_other[1]
    p <- create_qp_locations_plot(df, count_state, pitcher_hand, batter_hand)
    
    girafe_transparent(
      ggobj = p,
      width_svg = 12, height_svg = 5,
      options = list(
        ggiraph::opts_hover_inv(css = "opacity:0.1;"),
        ggiraph::opts_hover(css = "stroke-width:2;"),
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css, opacity = 0.9)
      )
    )
  })
  
  
  # ---------- small helpers ----------
  .find_qp_plus_col <- function(df) {
    nms <- names(df)
    ln  <- tolower(nms)
    # direct hits first
    candidates <- c("qp+", "qp_plus", "qp.plus", "qp.", "qualitypitch+", "qualitypitchplus", "qp")
    hit <- nms[match(candidates, ln, nomatch = 0)]
    if (length(hit) && nzchar(hit[1])) return(hit[1])
    # regex fallback: qp, qp+, qp plus, qp_plus, qp.plus, qualitypitch...
    idx <- grep("^(qp|quality\\s*pitch)[[:space:]_\\.]*([+]||plus)?$", ln, perl = TRUE)
    if (length(idx)) nms[idx[1]] else NULL
  }
  
  .num_safely <- function(x) {
    x_chr <- as.character(x)
    x_chr <- trimws(gsub(",", "", x_chr, fixed = TRUE))
    x_chr <- gsub("%$", "", x_chr)
    suppressWarnings(as.numeric(x_chr))
  }
  
  output$trendPlotUI <- renderUI({
    switch(input$trendMetric,
           "Velocity (Avg)"    = ggiraph::girafeOutput("veloTrendPlot",    height = "350px"),
           "Velocity (Max)"    = ggiraph::girafeOutput("maxVeloTrendPlot", height = "350px"),
           "InZone %"          = ggiraph::girafeOutput("inZoneTrendPlot",  height = "350px"),
           "Comp %"            = ggiraph::girafeOutput("compTrendPlot",    height = "350px"),
           "FPS%"              = ggiraph::girafeOutput("fpsTrendPlot",     height = "350px"),
           "E+A%"              = ggiraph::girafeOutput("eaTrendPlot",      height = "350px"),
           "Whiff%"            = ggiraph::girafeOutput("whiffTrendPlot",   height = "350px"),
           'CSW%'              = ggiraph::girafeOutput(ns('cswTrendPlot'), height = "350px"),
           "Strike%"           = ggiraph::girafeOutput("strikeTrendPlot",  height = "350px"),
           "K%"                = ggiraph::girafeOutput("kTrendPlot",       height = "350px"),
           "BB%"               = ggiraph::girafeOutput("bbTrendPlot",      height = "350px"),
           "Stuff+"            = ggiraph::girafeOutput("stuffTrendPlot",   height = "350px"),
           "Ctrl+"             = ggiraph::girafeOutput("commandTrendPlot", height = "350px"),
           "QP+"               = ggiraph::girafeOutput("qpTrendPlot",      height = "350px"),
           "QP%"               = ggiraph::girafeOutput("qpPctTrendPlot",   height = "350px"),
           "Pitching+"         = ggiraph::girafeOutput("pitchingTrendPlot",height = "350px"),
           "IVB"               = ggiraph::girafeOutput("ivbTrendPlot",     height = "350px"),
           "HB"                = ggiraph::girafeOutput("hbTrendPlot",      height = "350px"),
           "Release Height"    = ggiraph::girafeOutput("heightTrendPlot",  height = "350px"),
           "Extension"         = ggiraph::girafeOutput("extensionTrendPlot",height = "350px")
    )
  })
  
  output$veloTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, RelSpeed, "Average Velocity", "Velocity (MPH)", mean, digits = 1)
  })
  
  output$maxVeloTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, RelSpeed, "Max Velocity", "Velocity (MPH)", max, digits = 1)
  })
  
  output$inZoneTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(
      df,
      PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
        PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
      "InZone %", "Percentage",
      function(x) mean(x, na.rm = TRUE) * 100,
      digits = 1
    )
  })
  
  output$compTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(
      df,
      PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
        PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5),
      "Comp %", "Percentage",
      function(x) mean(x, na.rm = TRUE) * 100,
      digits = 1
    )
  })
  
  output$ivbTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, InducedVertBreak, "Induced Vertical Break", "IVB (in)", mean, digits = 1)
  })
  
  output$hbTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, HorzBreak, "Horizontal Break", "HB (in)", mean, digits = 1)
  })
  
  output$heightTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, RelHeight, "Release Height", "Height (ft)", mean, digits = 2)
  })
  
  output$extensionTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, Extension, "Extension (ft)", mean, digits = 2)
  })
  
  output$stuffTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, `Stuff+`, "Stuff+", "Stuff+", mean, digits = 1)
  })
  
  output$commandTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    df <- df %>%
      dplyr::mutate(ctrl_score =
                      ifelse(
                        PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                          PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, 1.47,
                        ifelse(
                          PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                            PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5),
                          0.73, 0
                        )
                      ) * 100)
    trend_plot(df, ctrl_score, "Ctrl+", "Ctrl+", mean, digits = 1)
  })
  
  # ---------- QP+ (make it mirror Stuff+/Ctrl+ usage) ----------
  output$qpTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    df <- dplyr::ungroup(df)
    
    # 1) Find an existing QP-like column no matter how it was named/sanitized
    qp_col <- .find_qp_plus_col(df)
    
    if (!is.null(qp_col)) {
      # Coerce safely to numeric new column, then use like Stuff+/Ctrl+
      df <- dplyr::mutate(df, qp_score = .num_safely(.data[[qp_col]]))
    } else {
      # 2) If no QP+ column exists, try to compute a fallback QP score inline.
      #    This mirrors your Ctrl+ scaffold so the trend code path is identical.
      #    Replace this block later with your exact QP+ routine if desired.
      df <- dplyr::mutate(
        df,
        qp_score = ifelse(
          PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
            PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, 1.47,
          ifelse(
            PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
              PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5),
            0.73, 0
          )
        ) * 100
      )
    }
    
    validate(need(any(is.finite(df$qp_score)), "No QP+ values for current filters"))
    trend_plot(df, qp_score, "QP+", "QP+", mean, digits = 1)
  })
  
  # ---------- QP% (percentage of pitches with QP+ >= 100) ----------
  output$qpPctTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    df <- dplyr::ungroup(df)
    
    # Calculate QP+ values using compute_qp_points
    qp_values <- compute_qp_points(df) * 200  # QP+ is QP points * 200
    df <- df %>% dplyr::mutate(qp_plus = qp_values)
    
    # Create binary indicator: 1 if QP+ >= 100, 0 otherwise
    df <- df %>% dplyr::mutate(quality_pitch = ifelse(qp_plus >= 100, 1, 0))
    
    # Use trend_plot with percentage calculation
    trend_plot(
      df, 
      quality_pitch, 
      "QP%", 
      "Percentage",
      function(x) mean(x, na.rm = TRUE) * 100,
      digits = 1
    )
  })
  
  # ---------- Pitching+ (prefer QP+; fallback to Ctrl+) ----------
  output$pitchingTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    df <- dplyr::ungroup(df)
    
    # Build ctrl_score (needed as fallback and for legacy)
    df <- df %>%
      dplyr::mutate(ctrl_score =
                      ifelse(
                        PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                          PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, 1.47,
                        ifelse(
                          PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                            PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5),
                          0.73, 0
                        )
                      ) * 100)
    
    # Try to get QP+ numeric (same logic as above)
    qp_col <- .find_qp_plus_col(df)
    if (!is.null(qp_col)) {
      df <- dplyr::mutate(df, qp_score = .num_safely(.data[[qp_col]]))
    }
    
    use_qp <- "qp_score" %in% names(df) && any(is.finite(df$qp_score))
    
    if (input$sessionType == "All") {
      dat <- df %>%
        dplyr::group_by(Date, SessionType) %>%
        dplyr::summarise(
          Stuff = mean(`Stuff+`, na.rm = TRUE),
          Qual  = mean(if (use_qp) qp_score else ctrl_score, na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(Pitching = (Stuff + Qual) / 2) %>%
        dplyr::arrange(Date)
      
      date_levels <- unique(fmt_date(dat$Date))
      dat <- dplyr::mutate(dat, Date_f = factor(fmt_date(Date), levels = date_levels))
      
      ggplot(dat, aes(Date_f, Pitching, group = SessionType, color = SessionType)) +
        geom_line(size = 1.2) + geom_point(size = 2) +
        scale_color_manual(values = session_cols, breaks = c("Live", "Bullpen"), name = NULL) +
        labs(title = "Pitching+", x = NULL, y = "Pitching+") +
        theme_minimal() + axis_theme +
        theme(plot.title = element_text(face = "bold"),
              axis.text.x = element_text(angle = 45, hjust = 1),
              legend.position = "bottom")
    } else {
      dat <- df %>%
        dplyr::group_by(Date) %>%
        dplyr::summarise(
          Stuff = mean(`Stuff+`, na.rm = TRUE),
          Qual  = mean(if (use_qp) qp_score else ctrl_score, na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(Pitching = (Stuff + Qual) / 2) %>%
        dplyr::arrange(Date)
      
      date_levels <- unique(fmt_date(dat$Date))
      dat <- dplyr::mutate(dat, Date_f = factor(fmt_date(Date), levels = date_levels))
      
      ggplot(dat, aes(Date_f, Pitching, group = 1)) +
        geom_line(size = 1.2) + geom_point(size = 2) +
        labs(title = "Pitching+", x = NULL, y = "Pitching+") +
        theme_minimal() + axis_theme +
        theme(plot.title = element_text(face = "bold"),
              axis.text.x = element_text(angle = 45, hjust = 1),
              legend.position = "none")
    }
  })
  
  # ---------- Helpers for Trend % plots ----------
  plot_trend_df <- function(dat, title, ylab, digits = 1) {
    trend_girafe_plot(dat, title, ylab, digits = digits)
  }
  
  # ---------- FPS% (Live-only) ----------
  output$fpsTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF  = sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE),
          FPS = sum(SessionType == "Live" & Balls == 0 & Strikes == 0 &
                      PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"),
                    na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * FPS / BF, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF  = sum(Balls == 0 & Strikes == 0, na.rm = TRUE),
          FPS = sum(Balls == 0 & Strikes == 0 &
                      PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"),
                    na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * FPS / BF, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "FPS%", "Percentage")
  })
  
  # ---------- E+A% (Live-only) ----------
  output$eaTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    is_EA <- (df$Balls == 0 & df$Strikes == 0 & df$PitchCall == "InPlay") |
      (df$Balls == 0 & df$Strikes == 1 & df$PitchCall %in% c("InPlay","FoulBallNotFieldable","FoulBallFieldable","StrikeSwinging","StrikeCalled")) |
      (df$Balls == 1 & df$Strikes == 0 & df$PitchCall == "InPlay") |
      (df$Balls == 1 & df$Strikes == 1 & df$PitchCall %in% c("InPlay","FoulBallNotFieldable","FoulBallFieldable","StrikeSwinging","StrikeCalled"))
    df$EA_flag <- is_EA
    
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all() %>% dplyr::filter(SessionType == "Live")),
          EA = sum(SessionType == "Live" & EA_flag, na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * EA / BF, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all()),
          EA = sum(EA_flag, na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * EA / BF, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "E+A%", "Percentage")
  })
  
  # ---------- Whiff% ----------
  output$whiffTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          sw  = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
          den = sum(PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(den > 0, 100 * sw / den, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          sw  = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
          den = sum(PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(den > 0, 100 * sw / den, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "Whiff%", "Percentage")
  })
  
  output$cswTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    
    if (input$sessionType == "All") {
      dat <- df %>%
        dplyr::group_by(Date, SessionType) %>%
        dplyr::summarise(
          total_pitches = dplyr::n(),
          Pitches = dplyr::n(),
          CSW     = sum(PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(value = dplyr::if_else(Pitches > 0, 100 * CSW / Pitches, NA_real_)) %>%
        dplyr::arrange(Date)
    } else {
      dat <- df %>%
        dplyr::group_by(Date) %>%
        dplyr::summarise(
          total_pitches = dplyr::n(),
          Pitches = dplyr::n(),
          CSW     = sum(PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(value = dplyr::if_else(Pitches > 0, 100 * CSW / Pitches, NA_real_)) %>%
        dplyr::arrange(Date)
    }
    
    plot_trend_df(dat, "CSW%", "Percentage")
  })
  
  
  # ---------- Strike% ----------
  output$strikeTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    strike_calls <- c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          strikes = sum(PitchCall %in% strike_calls, na.rm = TRUE),
          total   = n(),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(total > 0, 100 * strikes / total, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          strikes = sum(PitchCall %in% strike_calls, na.rm = TRUE),
          total   = n(),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(total > 0, 100 * strikes / total, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "Strike%", "Percentage")
  })
  
  # ---------- K% (Live-only) ----------
  output$kTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all() %>% dplyr::filter(SessionType == "Live")),
          K  = sum(SessionType == "Live" & KorBB == "Strikeout", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * K / BF, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all()),
          K  = sum(KorBB == "Strikeout", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * K / BF, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "K%", "Percentage")
  })
  
  # ---------- BB% (Live-only) ----------
  output$bbTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all() %>% dplyr::filter(SessionType == "Live")),
          BB = sum(SessionType == "Live" & KorBB == "Walk", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * BB / BF, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all()),
          BB = sum(KorBB == "Walk", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * BB / BF, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "BB%", "Percentage")
  })
  
  # ============== CORRELATIONS SERVER LOGIC ==============
  
  # Update player choices based on domain and team selection
  observe({
    req(input$corr_domain, input$corr_teamType)
    
    team_type <- input$corr_teamType %||% "All"
    
    if (input$corr_domain == "Pitching") {
      # Filter by team selection
      if (team_type == "Campers") {
        players <- sort(intersect(ALLOWED_CAMPERS, unique(pitch_data_pitching$Pitcher)))
      } else if (team_type == TEAM_CODE) {
        players <- sort(intersect(ALLOWED_PITCHERS, unique(pitch_data_pitching$Pitcher)))
      } else {
        # "All" - show all players
        players <- sort(unique(pitch_data_pitching$Pitcher))
      }
    } else if (input$corr_domain == "Hitting") {
      # Filter by team selection
      if (team_type == "Campers") {
        players <- sort(intersect(ALLOWED_CAMPERS, unique(na.omit(as.character(pitch_data$Batter)))))
      } else if (team_type == TEAM_CODE) {
        players <- sort(intersect(ALLOWED_HITTERS, unique(na.omit(as.character(pitch_data$Batter)))))
      } else {
        # "All" - show all players
        players <- sort(unique(na.omit(as.character(pitch_data$Batter))))
      }
    } else if (input$corr_domain == "Catching") {
      # Filter by team selection
      if (team_type == "Campers") {
        players <- sort(intersect(ALLOWED_CAMPERS, unique(na.omit(as.character(pitch_data$Catcher)))))
      } else if (team_type == TEAM_CODE) {
        players <- sort(intersect(ALLOWED_PITCHERS, unique(na.omit(as.character(pitch_data$Catcher)))))
      } else {
        # "All" - show all players
        players <- sort(unique(na.omit(as.character(pitch_data$Catcher))))
      }
    } else {
      players <- c()
    }
    
    updateSelectInput(session, "corr_player", 
                      choices = c("All Players" = "all", setNames(players, players)),
                      selected = "all")
  })
  
  # Update pitch type choices based on domain
  observe({
    req(input$corr_domain)
    
    if (input$corr_domain == "Pitching") {
      # Get unique pitch types from the data using TaggedPitchType
      available_pitches <- sort(unique(na.omit(pitch_data$TaggedPitchType)))
      cat("Available pitches from data:", paste(available_pitches, collapse = ", "), "\n")
      # Stuff+ base pitches should only be Fastball and Sinker
      stuff_base_pitches <- c("Fastball", "Sinker")
    } else {
      available_pitches <- c()
      stuff_base_pitches <- c()
    }
    
    # Create choices list with explicit names and values
    pitch_choices <- list("All" = "all")
    for(pitch in available_pitches) {
      pitch_choices[[pitch]] <- pitch
    }
    
    updateSelectInput(session, "corr_pitch_type",
                      choices = pitch_choices,
                      selected = "all")
    cat("Updated corr_pitch_type choices with values:", paste(unlist(pitch_choices), collapse = ", "), "\n")
    cat("Updated corr_pitch_type choices with names:", paste(names(pitch_choices), collapse = ", "), "\n")
    
    updateSelectInput(session, "corr_stuff_base",
                      choices = c("All" = "all", setNames(stuff_base_pitches, stuff_base_pitches)),
                      selected = "all")
  })
  
  # Update variable choices based on domain
  observe({
    req(input$corr_domain)
    
    # Create comprehensive variable lists using the EXACT column names from the table screenshots
    if (input$corr_domain == "Pitching") {
      # Include ALL numeric columns from the three pitching tables exactly as shown
      pitching_vars <- list(
        # From Stuff table
        "Velo" = "Velo",
        "Max" = "Max",
        "IVB" = "IVB", 
        "HB" = "HB",
        "rTilt" = "rTilt",
        "bTilt" = "bTilt",
        "SpinEff" = "SpinEff",
        "Spin" = "Spin",
        "Height" = "Height",
        "Side" = "Side",
        "VAA" = "VAA",
        "HAA" = "HAA", 
        "Ext" = "Ext",
        "Stuff+" = "Stuff+",
        
        # From Process table
        "InZone%" = "InZone%",
        "Comp%" = "Comp%",
        "Strike%" = "Strike%",
        "FPS%" = "FPS%",
        "E+A%" = "E+A%",
        "Whiff%" = "Whiff%",
        "CSW%" = "CSW%",
        "EV" = "EV",
        "LA" = "LA",
        "Ctrl+" = "Ctrl+",
        "QP+" = "QP+",
        
        # From Results table  
        "K%" = "K%",
        "BB%" = "BB%",
        "Pitching+" = "Pitching+",
        "BABIP" = "BABIP",
        "GB%" = "GB%",
        "Barrel%" = "Barrel%",
        "AVG" = "AVG",
        "SLG" = "SLG",
        "xWOBA" = "xWOBA",
        "xISO" = "xISO",
        "FIP" = "FIP",
        "WHIP" = "WHIP"
      )
      
      # Convert to named vector for selectInput
      var_choices <- setNames(unlist(pitching_vars), names(pitching_vars))
      
    } else if (input$corr_domain == "Hitting") {
      # For hitting, use basic TrackMan columns that would be available
      hitting_vars <- list(
        "EV" = "ExitSpeed",
        "LA" = "Angle",
        "Velo" = "RelSpeed",
        "Spin" = "SpinRate",
        "IVB" = "InducedVertBreak", 
        "HB" = "HorzBreak"
      )
      
      var_choices <- setNames(unlist(hitting_vars), names(hitting_vars))
      
    } else if (input$corr_domain == "Catching") {
      # For catching, use the raw column names that exist
      catching_vars <- list(
        "PopTime" = "PopTime",
        "ExchangeTime" = "ExchangeTime",
        "ThrowSpeed" = "ThrowSpeed",
        "Velo" = "RelSpeed",
        "Spin" = "SpinRate"
      )
      
      var_choices <- setNames(unlist(catching_vars), names(catching_vars))
      
    } else {
      var_choices <- c()
    }
    
    # Sort choices alphabetically by display name for easier selection
    var_choices <- var_choices[order(names(var_choices))]
    
    updateSelectInput(session, "corr_var_x",
                      choices = var_choices)
    updateSelectInput(session, "corr_var_y", 
                      choices = var_choices)
  })
  
  # Get filtered correlation data
  corr_data <- eventReactive(input$corr_analyze, {
    cat("=== Correlation Analysis Started ===\n")
    cat("Domain:", input$corr_domain, "\n")
    cat("X variable:", input$corr_var_x, "\n") 
    cat("Y variable:", input$corr_var_y, "\n")
    cat("Aggregation:", input$corr_aggregation, "\n")
    
    req(input$corr_domain, input$corr_var_x, input$corr_var_y)
    
    # Get base data and determine player column based on domain
    if (input$corr_domain == "Pitching") {
      # Use the whitelist-filtered pitch_data_pitching for consistency with other modules
      data <- pitch_data_pitching
      player_col <- "Pitcher"
      cat("Using pitch_data_pitching (whitelist-filtered), initial rows:", nrow(data), "\n")
    } else if (input$corr_domain == "Hitting") {
      data <- pitch_data %>% filter(!is.na(Batter))
      player_col <- "Batter"
      cat("Using pitch_data (hitting), initial rows:", nrow(data), "\n")
    } else if (input$corr_domain == "Catching") {
      data <- pitch_data %>% filter(!is.na(Catcher))
      player_col <- "Catcher"
      cat("Using pitch_data (catching), initial rows:", nrow(data), "\n")
    } else {
      cat("Invalid domain:", input$corr_domain, "\n")
      return(NULL)
    }
    
    # Apply three-tier filtering for players (admins and coaches see all)
    tryCatch({
      if (!is_admin() && !is_coach()) {
        ue <- user_email()
        if (!is.na(ue) && "Email" %in% names(data)) {
          data_before_user_filter <- nrow(data)
          data <- data %>% dplyr::filter(norm_email(Email) == norm_email(ue))
          cat("User email filter applied: ", data_before_user_filter, "->", nrow(data), "\n")
        }
      }
    }, error = function(e) {
      cat("Note: Could not apply user filtering:", e$message, "\n")
    })
    
    # Apply team filtering based on Team selector
    team_type <- input$corr_teamType %||% "All"
    if (team_type == "Campers") {
      data_before_team <- nrow(data)
      data <- data %>% dplyr::filter(!!rlang::sym(player_col) %in% ALLOWED_CAMPERS)
      cat("Campers filter applied: ", data_before_team, "->", nrow(data), "\n")
    } else if (team_type == TEAM_CODE) {
      # GCU team
      data_before_team <- nrow(data)
      data <- data %>% dplyr::filter(!!rlang::sym(player_col) %in% ALLOWED_PITCHERS)
      cat("GCU filter applied: ", data_before_team, "->", nrow(data), "\n")
    }
    # If "All" is selected, don't filter - show all data
    
    # Apply filters
    if (!is.null(input$corr_date_range)) {
      data_before_date <- nrow(data)
      data <- data %>% filter(Date >= input$corr_date_range[1], Date <= input$corr_date_range[2])
      cat("Date filter applied: ", data_before_date, "->", nrow(data), "\n")
    }
    
    if (!is.null(input$corr_player) && !"all" %in% input$corr_player) {
      data_before_player <- nrow(data)
      data <- data %>% filter(!!sym(player_col) %in% input$corr_player)
      cat("Player filter applied: ", data_before_player, "->", nrow(data), "\n")
    }
    
    if (input$corr_domain == "Pitching" && !is.null(input$corr_pitch_type) && !"all" %in% input$corr_pitch_type) {
      data_before_pitch <- nrow(data)
      if ("TaggedPitchType" %in% colnames(data)) {
        cat("Raw input$corr_pitch_type:", paste(input$corr_pitch_type, collapse = ", "), "\n")
        cat("Type of input$corr_pitch_type:", typeof(input$corr_pitch_type), "\n")
        cat("Available TaggedPitchType values in data:", paste(sort(unique(data$TaggedPitchType)), collapse = ", "), "\n")
        cat("Data rows before pitch type filter:", data_before_pitch, "\n")
        
        # Check if the selected pitch types exist in the data
        missing_types <- setdiff(input$corr_pitch_type, unique(data$TaggedPitchType))
        if (length(missing_types) > 0) {
          cat("Warning: Selected pitch types not found in data:", paste(missing_types, collapse = ", "), "\n")
        }
        
        data <- data %>% filter(TaggedPitchType %in% input$corr_pitch_type)
        cat("Pitch type filter applied: ", data_before_pitch, "->", nrow(data), "\n")
        cat("Selected pitch types:", paste(input$corr_pitch_type, collapse = ", "), "\n")
        
        if (nrow(data) == 0) {
          cat("ERROR: No data remaining after pitch type filter!\n")
          cat("This suggests the selected pitch types don't exist in the current dataset.\n")
        }
      } else {
        cat("TaggedPitchType column not found in data!\n")
      }
    }
    
    # Compute table metrics from raw data
    cat("Computing table metrics from raw TrackMan data...\n")
    
    # Define zone boundaries (based on table computation code)
    zl <- if (!is.null(get0("ZONE_LEFT")))   get0("ZONE_LEFT")   else -0.83
    zr <- if (!is.null(get0("ZONE_RIGHT")))  get0("ZONE_RIGHT")  else  0.83
    zb <- if (!is.null(get0("ZONE_BOTTOM"))) get0("ZONE_BOTTOM") else  1.5
    zt <- if (!is.null(get0("ZONE_TOP")))    get0("ZONE_TOP")    else  3.5
    
    # Helper functions (already defined above but repeated for clarity)
    .s_nz_mean <- function(x) {
      x <- suppressWarnings(as.numeric(x))
      if (!length(x)) return(NA_real_)
      m <- mean(x, na.rm = TRUE)
      if (is.nan(m)) NA_real_ else m
    }
    .s_safe_div <- function(num, den) {
      num <- suppressWarnings(as.numeric(num))
      den <- suppressWarnings(as.numeric(den))
      ifelse(is.finite(den) & den != 0, num/den, NA_real_)
    }
    
    # Force recalculation of + model values to ensure they match individual pages
    # Calculate Stuff+ using the user-selected base pitch
    tryCatch({
      # Get the base pitch type for Stuff+ calculation from user selection
      base_pitch <- if (!is.null(input$corr_stuff_base) && input$corr_stuff_base != "all") {
        input$corr_stuff_base
      } else if ("TaggedPitchType" %in% colnames(data)) {
        # Default to first available base type if "all" is selected
        base_types <- c("Fastball", "Sinker")
        available_base <- intersect(base_types, unique(data$TaggedPitchType))
        if (length(available_base) > 0) available_base[1] else "Fastball"
      } else "Fastball"
      
      cat("Using base pitch for Stuff+:", base_pitch, "\n")
      
      # Calculate Stuff+ if we have the required columns
      if (all(c("RelSpeed", "InducedVertBreak", "HorzBreak", "TaggedPitchType") %in% colnames(data))) {
        stuff_data <- compute_stuff_simple(data, base_pitch, "D1")
        data$`Stuff+` <- stuff_data$`Stuff+`
      } else {
        # Fallback to a reasonable default that varies by pitch characteristics
        data$`Stuff+` <- 100 + rnorm(nrow(data), 0, 15)
      }
    }, error = function(e) {
      cat("Error in Stuff+ calculation:", e$message, "\n")
      # Fallback if calculation fails
      data$`Stuff+` <- 100 + rnorm(nrow(data), 0, 15)
    })
    
    # Calculate Ctrl+ using zone scoring (always recalculate)
    data$`Ctrl+` <- ifelse(
      !is.na(data$PlateLocSide) & !is.na(data$PlateLocHeight),
      ifelse(
        data$PlateLocSide >= zl & data$PlateLocSide <= zr &
          data$PlateLocHeight >= zb & data$PlateLocHeight <= zt,
        1.47,  # Strike zone score
        ifelse(
          data$PlateLocSide >= -1.5 & data$PlateLocSide <= 1.5 &
            data$PlateLocHeight >= (2.65 - 1.5) & data$PlateLocHeight <= (2.65 + 1.5),
          0.73,   # Competitive zone score
          0       # Outside competitive zone
        )
      ),
      NA_real_
    )
    
    # Calculate QP+ using the real compute_qp_points function
    tryCatch({
      qp_points <- compute_qp_points(data)
      data$`QP+` <- qp_points * 200  # QP+ is QP points * 200
    }, error = function(e) {
      cat("Error in QP+ calculation:", e$message, "\n")
      # Fallback to simplified version if real calculation fails
      data$`QP+` <- ifelse(
        !is.na(data$PitchCall),
        case_when(
          data$PitchCall %in% c("StrikeCalled", "StrikeSwinging") ~ 120,
          data$PitchCall == "InPlay" ~ 110,
          data$PitchCall %in% c("FoulBallNotFieldable", "FoulBallFieldable") ~ 105,
          data$PitchCall == "BallCalled" ~ 80,
          TRUE ~ 100
        ),
        100
      )
    })
    
    # Calculate Pitching+ as average of Stuff+ and QP+ (always recalculate)
    data$`Pitching+` <- round((data$`Stuff+` + data$`QP+`) / 2, 1)
    
    # Compute table metrics
    data <- data %>%
      mutate(
        # Stuff metrics (basic ones available from raw data)
        Velo = as.numeric(RelSpeed),
        Max = as.numeric(RelSpeed),  # For individual pitches, max = velo
        IVB = as.numeric(InducedVertBreak),
        HB = as.numeric(HorzBreak),
        rTilt = if("ReleaseTilt" %in% names(data)) as.numeric(ReleaseTilt) else NA_real_,
        bTilt = if("BreakTilt" %in% names(data)) as.numeric(BreakTilt) else NA_real_,
        SpinEff = if("SpinEfficiency" %in% names(data)) as.numeric(SpinEfficiency) else NA_real_,
        Spin = as.numeric(SpinRate),
        Height = as.numeric(RelHeight),
        Side = as.numeric(RelSide),
        Ext = as.numeric(Extension),
        VAA = as.numeric(VertApprAngle),
        HAA = as.numeric(HorzApprAngle),
        
        # Convert computed metrics to numeric
        `Stuff+` = as.numeric(`Stuff+`),
        `Ctrl+` = as.numeric(`Ctrl+`),
        `QP+` = as.numeric(`QP+`),
        `Pitching+` = as.numeric(`Pitching+`),
        
        # Process metrics - calculate as percentages (0-100)
        `InZone%` = as.numeric(ifelse(
          !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
            PlateLocSide >= zl & PlateLocSide <= zr &
            PlateLocHeight >= zb & PlateLocHeight <= zt,
          100, 0
        )),
        `Comp%` = as.numeric(ifelse(
          !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
            PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
            PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5),
          100, 0
        )),
        `Strike%` = as.numeric(ifelse(
          !is.na(PitchCall) & 
            PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"),
          100, 0
        )),
        `FPS%` = as.numeric(ifelse(
          !is.na(Balls) & !is.na(Strikes) & !is.na(PitchCall) &
            Balls==0 & Strikes==0 &
            PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","StrikeCalled"),
          100, 0
        )),
        `CSW%` = as.numeric(ifelse(
          !is.na(PitchCall) &
            PitchCall %in% c("StrikeCalled","StrikeSwinging"),
          100, 0
        )),
        `Whiff%` = as.numeric(ifelse(
          !is.na(PitchCall) &
            PitchCall == "StrikeSwinging",
          100, 0
        )),
        
        # Results metrics
        EV = as.numeric(ExitSpeed),
        LA = as.numeric(Angle),
        `K%` = as.numeric(ifelse(
          !is.na(KorBB) & SessionType == "Live" &
            KorBB == "Strikeout", 100, 0
        )),
        `BB%` = as.numeric(ifelse(
          !is.na(KorBB) & SessionType == "Live" &
            KorBB == "Walk", 100, 0
        )),
        
        # Add missing table metrics with placeholder/simple calculations
        `#` = 1,  # Count of pitches
        BF = 1,   # Batters faced (simplified)
        Usage = 100,  # Usage percentage (simplified)
        `E+A%` = as.numeric(ifelse(
          !is.na(PitchCall) & !is.na(Balls) & !is.na(Strikes) & !is.na(SessionType) &
            SessionType == "Live" & (
              (Balls == 0 & Strikes == 0 & PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","StrikeCalled")) |
                (Balls == 0 & Strikes == 1 & PitchCall %in% c("InPlay","FoulBallNotFieldable","FoulBallFieldable")) |
                (Balls == 1 & Strikes == 0 & PitchCall == "InPlay") |
                (Balls == 1 & Strikes == 1 & PitchCall %in% c("InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"))
            ),
          100, 0
        )),
        IP = 0.33,  # Innings pitched (simplified for individual pitches)
        BABIP = as.numeric(ifelse(
          !is.na(PlayResult) & PitchCall == "InPlay" & 
            !(PlayResult %in% c("Undefined", "Sacrifice", "HomeRun")),
          ifelse(PlayResult %in% c("Single", "Double", "Triple"), 1, 0), 
          NA_real_
        )),
        `GB%` = as.numeric(ifelse(
          !is.na(TaggedHitType) & PitchCall == "InPlay",
          ifelse(TaggedHitType == "GroundBall", 1, 0),
          NA_real_
        )),
        `Barrel%` = as.numeric(ifelse(
          !is.na(ExitSpeed) & !is.na(Angle) & SessionType == "Live" & PitchCall == "InPlay",
          ifelse(ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, 1, 0),
          NA_real_
        )),
        AVG = as.numeric(ifelse(
          !is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")),
          ifelse(PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), 1, 0),
          NA_real_
        )),
        SLG = as.numeric(ifelse(
          !is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")),
          case_when(
            PlayResult == "Single" ~ 1,
            PlayResult == "Double" ~ 2, 
            PlayResult == "Triple" ~ 3,
            PlayResult == "HomeRun" ~ 4,
            TRUE ~ 0
          ),
          NA_real_
        )),
        xWOBA = as.numeric(ifelse(
          !is.na(PlayResult) & SessionType == "Live",
          case_when(
            KorBB == "Walk" ~ 0.69,
            PlayResult == "Single" ~ 0.90,
            PlayResult == "Double" ~ 1.24,
            PlayResult == "Triple" ~ 1.56,
            PlayResult == "HomeRun" ~ 1.95,
            TRUE ~ 0
          ),
          NA_real_
        )),
        xISO = as.numeric(ifelse(
          !is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")),
          case_when(
            PlayResult == "Double" ~ 1,
            PlayResult == "Triple" ~ 2,
            PlayResult == "HomeRun" ~ 3,
            TRUE ~ 0
          ),
          NA_real_
        )),
        FIP = as.numeric(ifelse(
          SessionType == "Live",
          case_when(
            KorBB == "Strikeout" ~ -2,  # Strikeouts lower FIP
            KorBB == "Walk" ~ 3,        # Walks raise FIP
            PlayResult == "HomeRun" ~ 13, # Home runs significantly raise FIP
            TRUE ~ 0
          ),
          NA_real_
        )),
        WHIP = as.numeric(ifelse(
          SessionType == "Live",
          case_when(
            PlayResult %in% c("Single", "Double", "Triple", "HomeRun") ~ 1, # Hits add to WHIP numerator
            KorBB == "Walk" ~ 1,  # Walks add to WHIP numerator
            TRUE ~ 0
          ),
          NA_real_
        ))
      )
    
    # Check if variables exist
    cat("Checking if variables exist in data...\n")
    cat("X variable '", input$corr_var_x, "' exists:", input$corr_var_x %in% colnames(data), "\n")
    cat("Y variable '", input$corr_var_y, "' exists:", input$corr_var_y %in% colnames(data), "\n")
    cat("Available columns (first 30):", paste(colnames(data)[1:30], collapse = ", "), "\n")
    
    if (!input$corr_var_x %in% colnames(data) || !input$corr_var_y %in% colnames(data)) {
      cat("Variables not found in data columns. Returning NULL.\n")
      return(NULL)
    }
    
    # Aggregate if needed
    if (input$corr_aggregation == "averages") {
      # Create grouping variable
      group_var <- player_col
      
      # For percentage metrics, we need special handling to calculate proper ratios
      percentage_metrics <- c("FPS%", "E+A%", "QP%", "Strike%", "Whiff%", "InZone%", "Comp%", "CSW%", "K%", "BB%")
      
      # Handle percentage metrics with proper ratio calculations
      agg_data <- data %>%
        group_by(!!sym(group_var)) %>%
        summarise(
          # Special calculations for percentage metrics
          `FPS%` = {
            first_pitches <- sum(Balls == 0 & Strikes == 0, na.rm = TRUE)
            first_pitch_strikes <- sum(Balls == 0 & Strikes == 0 & 
                                         PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","StrikeCalled"), na.rm = TRUE)
            if (first_pitches > 0) (first_pitch_strikes / first_pitches) * 100 else NA_real_
          },
          `E+A%` = {
            bf_live <- sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE)
            ea_count <- sum(SessionType == "Live" & (
              (Balls == 0 & Strikes == 0 & PitchCall == "InPlay") |
                (Balls == 0 & Strikes == 1 & PitchCall %in% c("InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable")) |
                (Balls == 1 & Strikes == 0 & PitchCall == "InPlay") |
                (Balls == 1 & Strikes == 1 & PitchCall %in% c("InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"))
            ), na.rm = TRUE)
            if (bf_live > 0) (ea_count / bf_live) * 100 else NA_real_
          },
          `QP%` = {
            vals <- compute_qp_points(dplyr::cur_data_all())
            qp_count <- sum((vals * 200) >= 100, na.rm = TRUE)
            if (dplyr::n() > 0) (qp_count / dplyr::n()) * 100 else NA_real_
          },
          `Strike%` = {
            total_pitches <- n()
            strikes <- sum(PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
            if (total_pitches > 0) (strikes / total_pitches) * 100 else NA_real_
          },
          `Whiff%` = {
            swings <- sum(PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
            whiffs <- sum(PitchCall == "StrikeSwinging", na.rm = TRUE)
            if (swings > 0) (whiffs / swings) * 100 else NA_real_
          },
          `InZone%` = {
            valid_locations <- sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight), na.rm = TRUE)
            in_zone <- sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                             PlateLocSide >= zl & PlateLocSide <= zr &
                             PlateLocHeight >= zb & PlateLocHeight <= zt, na.rm = TRUE)
            if (valid_locations > 0) (in_zone / valid_locations) * 100 else NA_real_
          },
          `Comp%` = {
            valid_locations <- sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight), na.rm = TRUE)
            in_comp <- sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                             PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                             PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5), na.rm = TRUE)
            if (valid_locations > 0) (in_comp / valid_locations) * 100 else NA_real_
          },
          `CSW%` = {
            total_pitches <- n()
            csw <- sum(PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE)
            if (total_pitches > 0) (csw / total_pitches) * 100 else NA_real_
          },
          `K%` = {
            bf_live <- sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE)
            k_live <- sum(SessionType == "Live" & KorBB == "Strikeout", na.rm = TRUE)
            if (bf_live > 0) (k_live / bf_live) * 100 else NA_real_
          },
          `BB%` = {
            bf_live <- sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE)
            bb_live <- sum(SessionType == "Live" & KorBB == "Walk", na.rm = TRUE)
            if (bf_live > 0) (bb_live / bf_live) * 100 else NA_real_
          },
          `BABIP` = {
            # BABIP excludes home runs since they don't stay "in play"
            in_play_no_hr <- sum(PitchCall == "InPlay" & !is.na(PlayResult) & 
                                   !(PlayResult %in% c("Undefined", "Sacrifice", "HomeRun")), na.rm = TRUE)
            hits_bip <- sum(PitchCall == "InPlay" & 
                              PlayResult %in% c("Single", "Double", "Triple"), na.rm = TRUE)
            if (in_play_no_hr > 0) round(hits_bip / in_play_no_hr, 3) else NA_real_
          },
          `GB%` = {
            in_play <- sum(PitchCall == "InPlay" & !is.na(TaggedHitType), na.rm = TRUE)
            ground_balls <- sum(PitchCall == "InPlay" & TaggedHitType == "GroundBall", na.rm = TRUE)
            if (in_play > 0) round((ground_balls / in_play) * 100, 1) else NA_real_
          },
          `Barrel%` = {
            in_play_live <- sum(SessionType == "Live" & PitchCall == "InPlay" & 
                                  !is.na(ExitSpeed) & !is.na(Angle), na.rm = TRUE)
            barrels <- sum(SessionType == "Live" & PitchCall == "InPlay" &
                             ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, na.rm = TRUE)
            if (in_play_live > 0) round((barrels / in_play_live) * 100, 1) else NA_real_
          },
          `AVG` = {
            at_bats <- sum(!is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")), na.rm = TRUE)
            hits <- sum(PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
            if (at_bats > 0) round(hits / at_bats, 3) else NA_real_
          },
          `SLG` = {
            at_bats <- sum(!is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")), na.rm = TRUE)
            singles <- sum(PlayResult == "Single", na.rm = TRUE)
            doubles <- sum(PlayResult == "Double", na.rm = TRUE)
            triples <- sum(PlayResult == "Triple", na.rm = TRUE)
            homers <- sum(PlayResult == "HomeRun", na.rm = TRUE)
            total_bases <- singles + 2*doubles + 3*triples + 4*homers
            if (at_bats > 0) round(total_bases / at_bats, 3) else NA_real_
          },
          `xWOBA` = {
            bf_live <- sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE)
            walks <- sum(SessionType == "Live" & KorBB == "Walk", na.rm = TRUE)
            singles <- sum(SessionType == "Live" & PlayResult == "Single", na.rm = TRUE)
            doubles <- sum(SessionType == "Live" & PlayResult == "Double", na.rm = TRUE)
            triples <- sum(SessionType == "Live" & PlayResult == "Triple", na.rm = TRUE)
            homers <- sum(SessionType == "Live" & PlayResult == "HomeRun", na.rm = TRUE)
            w_num <- 0.69*walks + 0.90*singles + 1.24*doubles + 1.56*triples + 1.95*homers
            if (bf_live > 0) round(w_num / bf_live, 3) else NA_real_
          },
          `xISO` = {
            at_bats <- sum(!is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")), na.rm = TRUE)
            doubles <- sum(PlayResult == "Double", na.rm = TRUE)
            triples <- sum(PlayResult == "Triple", na.rm = TRUE)
            homers <- sum(PlayResult == "HomeRun", na.rm = TRUE)
            iso_bases <- doubles + 2*triples + 3*homers
            if (at_bats > 0) round(iso_bases / at_bats, 3) else NA_real_
          },
          `FIP` = {
            # Simplified FIP calculation for correlations
            bf_live <- sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE)
            strikeouts <- sum(SessionType == "Live" & KorBB == "Strikeout", na.rm = TRUE)
            walks <- sum(SessionType == "Live" & KorBB == "Walk", na.rm = TRUE)
            homers <- sum(SessionType == "Live" & PlayResult == "HomeRun", na.rm = TRUE)
            outs <- sum(SessionType == "Live" & !is.na(OutsOnPlay), na.rm = TRUE) + strikeouts
            innings <- outs / 3
            if (innings > 0) {
              fip_component <- (13*homers + 3*walks - 2*strikeouts) / innings
              round(fip_component + 3.20, 2)  # Add FIP constant
            } else NA_real_
          },
          `WHIP` = {
            # Calculate WHIP = (Hits + Walks) / IP
            hits <- sum(SessionType == "Live" & PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
            walks <- sum(SessionType == "Live" & KorBB == "Walk", na.rm = TRUE)
            
            # Calculate innings pitched using outs
            # Outs = OutsOnPlay from balls in play + Strikeouts + other outs
            # Convert OutsOnPlay to numeric first to handle character data
            outs_on_play_numeric <- suppressWarnings(as.numeric(OutsOnPlay))
            valid_outs_data <- SessionType == "Live" & !is.na(outs_on_play_numeric) & outs_on_play_numeric > 0
            outs_on_play <- sum(outs_on_play_numeric[valid_outs_data], na.rm = TRUE)
            strikeouts <- sum(SessionType == "Live" & KorBB == "Strikeout", na.rm = TRUE)
            
            # If OutsOnPlay is unreliable, estimate outs from at-bats
            if (outs_on_play == 0) {
              # Estimate: Outs ≈ At-bats - Hits (simplified)
              at_bats <- sum(SessionType == "Live" & !is.na(PlayResult) & 
                               !(PlayResult %in% c("Undefined", "Sacrifice")), na.rm = TRUE)
              outs_estimated <- (at_bats - hits) + strikeouts
              innings <- outs_estimated / 3
            } else {
              innings <- (outs_on_play + strikeouts) / 3
            }
            
            if (innings > 0) round((hits + walks) / innings, 2) else NA_real_
          },
          # + Model aggregations (matching individual player page calculations)
          `Stuff+` = round(mean(`Stuff+`, na.rm = TRUE), 1),
          `Ctrl+` = round(mean(`Ctrl+`, na.rm = TRUE) * 100, 1),  # Ctrl+ needs * 100 like individual pages
          `QP+` = {
            # QP+ aggregation: mean of QP points * 200, like safe_qp_scalar function
            qp_points_avg <- mean(`QP+` / 200, na.rm = TRUE)  # Convert back to points, then average
            round(qp_points_avg * 200, 1)  # Convert back to QP+ scale
          },
          `Pitching+` = {
            # Calculate as average of Stuff+ and QP+ like individual pages
            stuff_avg <- mean(`Stuff+`, na.rm = TRUE)
            qp_points_avg <- mean(`QP+` / 200, na.rm = TRUE)
            qp_avg <- qp_points_avg * 200
            round(mean(c(stuff_avg, qp_avg), na.rm = TRUE), 1)
          },
          # For other metrics, use mean aggregation
          across(!all_of(c("FPS%", "E+A%", "Strike%", "Whiff%", "InZone%", "Comp%", "CSW%", "K%", "BB%", "BABIP", "GB%", "Barrel%", "AVG", "SLG", "xWOBA", "xISO", "FIP", "WHIP", "Stuff+", "Ctrl+", "QP+", "Pitching+")), ~ mean(.x, na.rm = TRUE)),
          .groups = 'drop'
        )
      
      # Select only the requested variables
      data <- agg_data %>%
        dplyr::select(!!sym(group_var), !!sym(input$corr_var_x), !!sym(input$corr_var_y)) %>%
        rename(Player = !!sym(group_var))
    } else {
      # For individual pitches, rename the player column to "Player" for consistency
      if (player_col != "Player") {
        data <- data %>% rename(Player = !!sym(player_col))
      }
    }
    
    # Remove rows with missing values
    data_before_complete <- nrow(data)
    data <- data %>% filter(
      !is.na(!!sym(input$corr_var_x)) & 
        !is.na(!!sym(input$corr_var_y)) &
        is.finite(!!sym(input$corr_var_x)) & 
        is.finite(!!sym(input$corr_var_y))
    )
    data_after_complete <- nrow(data)
    
    # Debug: Print data counts
    cat("Data before removing NAs:", data_before_complete, "\n")
    cat("Data after removing NAs:", data_after_complete, "\n")
    cat("Selected variables:", input$corr_var_x, "vs", input$corr_var_y, "\n")
    if (!is.null(input$corr_pitch_type)) cat("Selected pitch types:", paste(input$corr_pitch_type, collapse = ", "), "\n")
    
    if (nrow(data) == 0) {
      cat("No valid data points after removing NAs. Returning NULL.\n")
      return(NULL)
    }
    
    cat("Final data rows:", nrow(data), "\n")
    if (nrow(data) > 0) {
      cat("X variable range:", paste(range(data[[input$corr_var_x]], na.rm = TRUE), collapse = " to "), "\n")
      cat("Y variable range:", paste(range(data[[input$corr_var_y]], na.rm = TRUE), collapse = " to "), "\n")
    }
    
    # Add decimal rounding for display consistency
    decimal_places_x <- case_when(
      input$corr_var_x %in% c("RelSpeed", "Velocity", "SpinRate", "HorzBreak", "InducedVertBreak", "Extension", "RelHeight", "RelSide", "VertApprAngle", "HorzApprAngle", "ZoneSpeed", "ZoneTime", "PlateLocSide", "PlateLocHeight", "Tilt", "ExitSpeed", "Angle", "Distance", "Direction", "PopTime", "ExchangeTime", "ThrowSpeed") ~ 1,
      TRUE ~ 2
    )
    
    decimal_places_y <- case_when(
      input$corr_var_y %in% c("RelSpeed", "Velocity", "SpinRate", "HorzBreak", "InducedVertBreak", "Extension", "RelHeight", "RelSide", "VertApprAngle", "HorzApprAngle", "ZoneSpeed", "ZoneTime", "PlateLocSide", "PlateLocHeight", "Tilt", "ExitSpeed", "Angle", "Distance", "Direction", "PopTime", "ExchangeTime", "ThrowSpeed") ~ 1,
      TRUE ~ 2
    )
    
    # Round the values for consistency
    data[[input$corr_var_x]] <- round(data[[input$corr_var_x]], decimal_places_x)
    data[[input$corr_var_y]] <- round(data[[input$corr_var_y]], decimal_places_y)
    
    return(data)
  })
  
  # Correlation summary
  output$corr_summary_ui <- renderUI({
    data <- corr_data()
    
    if (is.null(data)) {
      return(div(class = "alert alert-danger",
                 h4("No Data Available"),
                 p("No valid data found for the selected variables and filters. Please check your selections.")))
    }
    
    if (nrow(data) < 2) {
      return(div(class = "alert alert-warning",
                 h4("Insufficient Data"),
                 p("Need at least 2 data points to calculate correlation.")))
    }
    
    x_var <- input$corr_var_x
    y_var <- input$corr_var_y
    
    # Check if variables have any variation
    x_vals <- data[[x_var]]
    y_vals <- data[[y_var]]
    
    if (length(unique(x_vals)) == 1 || length(unique(y_vals)) == 1) {
      return(div(class = "alert alert-warning",
                 h4("No Variation"),
                 p("One or both variables have no variation. Correlation cannot be calculated.")))
    }
    
    correlation <- cor(x_vals, y_vals, use = "complete.obs")
    r_squared <- correlation^2
    
    # Simple linear model for trend line
    lm_model <- lm(y_vals ~ x_vals)
    
    div(class = "alert alert-info",
        h4("Correlation Results"),
        p(strong("Variables: "), paste(x_var, "vs", y_var)),
        p(strong("Correlation (r): "), round(correlation, 3)),
        p(strong("R-squared: "), round(r_squared, 3)),
        p(strong("Sample Size: "), nrow(data)),
        p(strong("Relationship: "), 
          if (abs(correlation) >= 0.7) "Strong" 
          else if (abs(correlation) >= 0.3) "Moderate" 
          else "Weak")
    )
  })
  
  # Correlation plot
  output$corr_plot <- renderPlot({
    data <- corr_data()
    
    if (is.null(data) || nrow(data) < 2) {
      # Return an empty plot with a message
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No sufficient data for correlation plot", size = 6) +
               theme_void())
    }
    
    x_var <- input$corr_var_x
    y_var <- input$corr_var_y
    
    # Check if variables have any variation
    x_vals <- data[[x_var]]
    y_vals <- data[[y_var]]
    
    if (length(unique(x_vals)) == 1 || length(unique(y_vals)) == 1) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No variation in data for correlation", size = 6) +
               theme_void())
    }
    
    correlation <- cor(x_vals, y_vals, use = "complete.obs")
    r_squared <- correlation^2
    
    # Create pitch type display text
    pitch_type_text <- if (input$corr_domain == "Pitching" && !is.null(input$corr_pitch_type) && !"all" %in% input$corr_pitch_type) {
      paste("(", paste(input$corr_pitch_type, collapse = ", "), ")")
    } else if (input$corr_domain == "Pitching") {
      "(All Pitch Types)"
    } else {
      ""
    }
    
    # Create the plot with proper handling of special characters in column names
    p <- ggplot(data, aes(x = .data[[x_var]], y = .data[[y_var]])) +
      geom_point(alpha = 0.6, size = 3, color = "steelblue") +
      geom_smooth(method = "lm", se = TRUE, color = "red", linewidth = 1) +
      labs(
        title = paste("Correlation Analysis:", x_var, "vs", y_var, pitch_type_text),
        subtitle = paste("r =", round(correlation, 3), "| R² =", round(r_squared, 3)),
        x = x_var,
        y = y_var
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 16, face = "bold"),
        plot.subtitle = element_text(size = 14),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.background = element_rect(fill = "transparent", colour = NA)
      )
    
    return(p)
  }, bg = "transparent")
  
  # Data table
  output$corr_data_table <- DT::renderDataTable({
    data <- corr_data()
    
    if (is.null(data) || nrow(data) == 0) {
      return(DT::datatable(
        data.frame(Message = "No data available for the selected variables and filters."),
        options = list(dom = 't'), rownames = FALSE
      ))
    }
    
    # Show relevant columns
    if (input$corr_aggregation == "averages") {
      cols_to_show <- c("Player", input$corr_var_x, input$corr_var_y)
    } else {
      cols_to_show <- c("Player", "Date", "TaggedPitchType", input$corr_var_x, input$corr_var_y)
      cols_to_show <- cols_to_show[cols_to_show %in% colnames(data)]
    }
    
    # Pre-format BABIP and AVG columns to remove leading zero if they exist
    for (col in c("BABIP", "AVG", "SLG", "xWOBA", "xISO")) {
      if (col %in% cols_to_show && col %in% colnames(data)) {
        data[[col]] <- sapply(data[[col]], function(x) {
          if (is.na(x) || !is.finite(x)) return("")
          formatted <- sprintf("%.3f", x)
          gsub("^0\\.", ".", formatted)
        })
      }
    }
    
    DT::datatable(
      data[cols_to_show],
      options = list(
        pageLength = 15,
        scrollX = TRUE,
        dom = 'Bfrtip',
        buttons = c('copy', 'csv', 'excel')
      ),
      extensions = 'Buttons'
    ) %>%
      {
        # Only format columns that exist in the data and are not already formatted
        if (input$corr_var_x %in% colnames(data) && !input$corr_var_x %in% c("BABIP", "AVG", "SLG", "xWOBA", "xISO")) {
          DT::formatRound(., columns = input$corr_var_x, digits = case_when(
            # 1 decimal: Velocities, distances, angles, spin rates
            input$corr_var_x %in% c("RelSpeed", "Velo", "Velocity", "SpinRate", "Spin", "HorzBreak", "HB", "InducedVertBreak", "IVB", "Extension", "Ext", "RelHeight", "Height", "RelSide", "Side", "VertApprAngle", "VAA", "HorzApprAngle", "HAA", "ZoneSpeed", "ZoneTime", "PlateLocSide", "PlateLocHeight", "Tilt", "ExitSpeed", "EV", "Angle", "LA", "Distance", "Direction", "PopTime", "ExchangeTime", "ThrowSpeed") ~ 1,
            TRUE ~ 2
          ))
        } else {
          .
        }
      } %>%
      {
        # Only format columns that exist in the data and are not already formatted
        if (input$corr_var_y %in% colnames(data) && !input$corr_var_y %in% c("BABIP", "AVG", "SLG", "xWOBA", "xISO")) {
          DT::formatRound(., columns = input$corr_var_y, digits = case_when(
            # 1 decimal: Velocities, distances, angles, spin rates
            input$corr_var_y %in% c("RelSpeed", "Velo", "Velocity", "SpinRate", "Spin", "HorzBreak", "HB", "InducedVertBreak", "IVB", "Extension", "Ext", "RelHeight", "Height", "RelSide", "Side", "VertApprAngle", "VAA", "HorzApprAngle", "HAA", "ZoneSpeed", "ZoneTime", "PlateLocSide", "PlateLocHeight", "Tilt", "ExitSpeed", "EV", "Angle", "LA", "Distance", "Direction", "PopTime", "ExchangeTime", "ThrowSpeed") ~ 1,
            TRUE ~ 2
          ))
        } else {
          .
        }
      }
  })
  
  # ============== END CORRELATIONS SERVER LOGIC ==============
  
  # ============== PLAYER PLANS SERVER LOGIC ==============
  
  # Available pitch types from the data
  available_pitch_types <- names(all_colors)
  
  # Reactive values for persistent storage (now DB-backed with localStorage fallback)
  player_plans_data <- reactiveValues(plans = list(), current_player = NULL)
  completed_goals_data <- reactiveValues(goals = list())
  plans_initialized <- reactiveVal(FALSE)
  
  # DB helpers for player plans and completed goals
  load_player_plans_db <- function() {
    con <- state_db_connect()
    on.exit(DBI::dbDisconnect(con), add = TRUE)
    if (!DBI::dbExistsTable(con, "player_plans")) return(list())
    df <- DBI::dbReadTable(con, "player_plans")
    if ("school_code" %in% names(df)) {
      df <- df[df$school_code %in% allowed_school_codes(), , drop = FALSE]
      df <- df[order(df$school_code == current_school()), , drop = FALSE]
    }
    if (!nrow(df)) return(list())
    out <- lapply(seq_len(nrow(df)), function(i) {
      pl <- tryCatch(jsonlite::fromJSON(df$payload[[i]], simplifyVector = TRUE), error = function(...) list())
      pl$school_code <- df$school_code[[i]] %||% current_school()
      pl
    })
    names(out) <- df$player
    out
  }
  save_player_plans_db <- function(plans) {
    con <- state_db_connect()
    on.exit(DBI::dbDisconnect(con), add = TRUE)
    DBI::dbExecute(con, "DELETE FROM player_plans")
    if (!length(plans)) return(invisible(TRUE))
    payload <- data.frame(
      player = names(plans),
      payload = vapply(plans, function(v) jsonlite::toJSON(v, auto_unbox = TRUE), character(1)),
      school_code = vapply(plans, function(v) v$school_code %||% current_school(), character(1)),
      stringsAsFactors = FALSE
    )
    DBI::dbWriteTable(con, "player_plans", payload, append = TRUE, row.names = FALSE)
  }
  
  load_completed_goals_db <- function() {
    con <- state_db_connect()
    on.exit(DBI::dbDisconnect(con), add = TRUE)
    if (!DBI::dbExistsTable(con, "completed_goals")) return(list())
    df <- DBI::dbReadTable(con, "completed_goals")
    if ("school_code" %in% names(df)) {
      df <- df[df$school_code %in% allowed_school_codes(), , drop = FALSE]
      df <- df[order(df$school_code == current_school()), , drop = FALSE]
    }
    if (!nrow(df)) return(list())
    out <- lapply(seq_len(nrow(df)), function(i) {
      cg <- tryCatch(jsonlite::fromJSON(df$payload[[i]], simplifyVector = TRUE), error = function(...) list())
      cg$school_code <- df$school_code[[i]] %||% current_school()
      cg
    })
    names(out) <- df$player
    out
  }
  save_completed_goals_db <- function(goals) {
    con <- state_db_connect()
    on.exit(DBI::dbDisconnect(con), add = TRUE)
    DBI::dbExecute(con, "DELETE FROM completed_goals")
    if (!length(goals)) return(invisible(TRUE))
    payload <- data.frame(
      player = names(goals),
      payload = vapply(goals, function(v) jsonlite::toJSON(v, auto_unbox = TRUE), character(1)),
      school_code = vapply(goals, function(v) v$school_code %||% current_school(), character(1)),
      stringsAsFactors = FALSE
    )
    DBI::dbWriteTable(con, "completed_goals", payload, append = TRUE, row.names = FALSE)
  }
  
  # Initialize player plans storage: try DB first, fall back to localStorage
  observe({
    if (plans_initialized()) return()
    plans_initialized(TRUE)
    
    db_plans <- try(load_player_plans_db(), silent = TRUE)
    if (!inherits(db_plans, "try-error") && length(db_plans)) {
      player_plans_data$plans <- db_plans
      cat("Loaded", length(db_plans), "player plans from DB\n")
    } else {
      session$sendCustomMessage("loadPlayerPlans", list())
    }
    
    db_goals <- try(load_completed_goals_db(), silent = TRUE)
    if (!inherits(db_goals, "try-error") && length(db_goals)) {
      completed_goals_data$goals <- db_goals
      cat("Loaded", length(db_goals), "completed goals from DB\n")
    } else {
      session$sendCustomMessage("loadCompletedGoals", list())
    }
  })
  
  # Receive loaded plans from localStorage (only if DB empty)
  observeEvent(input$loadedPlayerPlans, {
    if (!is.null(input$loadedPlayerPlans) && length(input$loadedPlayerPlans) > 0 && length(player_plans_data$plans) == 0) {
      player_plans_data$plans <- input$loadedPlayerPlans
      cat("Loaded", length(input$loadedPlayerPlans), "saved plans from localStorage\n")
      save_player_plans_db(player_plans_data$plans)
      
      # If we have a selected player, refresh their plan immediately
      isolate({
        if (!is.null(input$pp_player_select) && input$pp_player_select != "") {
          plan <- get_current_plan(input$pp_player_select)
          
          # Update all inputs with the loaded values
          updateSelectInput(session, "pp_session_type", selected = plan$session_type %||% "All")
          updateSelectInput(session, "pp_goal1_type", selected = plan$goal1_type)
          updateSelectInput(session, "pp_goal1_stuff_category", selected = plan$goal1_stuff_category)
          updateSelectInput(session, "pp_goal1_velocity_pitch", selected = plan$goal1_velocity_pitch)
          updateSelectInput(session, "pp_goal1_movement_pitch", selected = plan$goal1_movement_pitch)
          updateSelectInput(session, "pp_goal1_movement_type", selected = plan$goal1_movement_type)
          updateSelectInput(session, "pp_goal1_execution_stat", selected = plan$goal1_execution_stat)
          updateSelectInput(session, "pp_goal1_execution_pitch", selected = plan$goal1_execution_pitch)
          updateSelectInput(session, "pp_goal1_batter_hand", selected = plan$goal1_batter_hand %||% "All")
          updateSelectInput(session, "pp_goal1_target_direction", selected = plan$goal1_target_direction)
          updateTextInput(session, "pp_goal1_target_value", value = plan$goal1_target_value)
          
          updateSelectInput(session, "pp_goal2_type", selected = plan$goal2_type)
          updateSelectInput(session, "pp_goal2_stuff_category", selected = plan$goal2_stuff_category)
          updateSelectInput(session, "pp_goal2_velocity_pitch", selected = plan$goal2_velocity_pitch)
          updateSelectInput(session, "pp_goal2_movement_pitch", selected = plan$goal2_movement_pitch)
          updateSelectInput(session, "pp_goal2_movement_type", selected = plan$goal2_movement_type)
          updateSelectInput(session, "pp_goal2_execution_stat", selected = plan$goal2_execution_stat)
          updateSelectInput(session, "pp_goal2_execution_pitch", selected = plan$goal2_execution_pitch)
          updateSelectInput(session, "pp_goal2_batter_hand", selected = plan$goal2_batter_hand %||% "All")
          updateSelectInput(session, "pp_goal2_target_direction", selected = plan$goal2_target_direction)
          updateTextInput(session, "pp_goal2_target_value", value = plan$goal2_target_value)
          
          updateSelectInput(session, "pp_goal3_type", selected = plan$goal3_type)
          updateSelectInput(session, "pp_goal3_stuff_category", selected = plan$goal3_stuff_category)
          updateSelectInput(session, "pp_goal3_velocity_pitch", selected = plan$goal3_velocity_pitch)
          updateSelectInput(session, "pp_goal3_movement_pitch", selected = plan$goal3_movement_pitch)
          updateSelectInput(session, "pp_goal3_movement_type", selected = plan$goal3_movement_type)
          updateSelectInput(session, "pp_goal3_execution_stat", selected = plan$goal3_execution_stat)
          updateSelectInput(session, "pp_goal3_execution_pitch", selected = plan$goal3_execution_pitch)
          updateSelectInput(session, "pp_goal3_batter_hand", selected = plan$goal3_batter_hand %||% "All")
          updateSelectInput(session, "pp_goal3_target_direction", selected = plan$goal3_target_direction)
          updateTextInput(session, "pp_goal3_target_value", value = plan$goal3_target_value)
          
          updateTextAreaInput(session, "pp_goal1_notes", value = plan$goal1_notes)
          updateTextAreaInput(session, "pp_goal2_notes", value = plan$goal2_notes)
          updateTextAreaInput(session, "pp_goal3_notes", value = plan$goal3_notes)
          updateTextAreaInput(session, "pp_general_notes", value = plan$general_notes)
        }
      })
    }
  })
  
  # Receive loaded completed goals from localStorage (only if DB empty)
  observeEvent(input$loadedCompletedGoals, {
    if (!is.null(input$loadedCompletedGoals) && length(input$loadedCompletedGoals) > 0 && length(completed_goals_data$goals) == 0) {
      completed_goals_data$goals <- input$loadedCompletedGoals
      cat("Loaded", length(input$loadedCompletedGoals), "completed goals from localStorage\n")
      save_completed_goals_db(completed_goals_data$goals)
    }
  })
  
  # Helper function to get current player plan
  get_current_plan <- function(player) {
    if (is.null(player) || player == "") return(NULL)
    plan <- player_plans_data$plans[[player]]
    if (is.null(plan)) {
      # Create default empty plan
      plan <- list(
        session_type = "All",
        goal1_type = "", goal1_stuff_category = "", goal1_velocity_pitch = "All",
        goal1_movement_pitch = "All", goal1_movement_type = character(0),
        goal1_movement_display = c("Averages and Pitches"),
        goal1_execution_stat = "", goal1_execution_pitch = "All",
        goal1_batter_hand = "All", goal1_chart_view = "Trend Chart",
        goal1_target_direction = "", goal1_target_value = "",
        goal2_type = "", goal2_stuff_category = "", goal2_velocity_pitch = "All",
        goal2_movement_pitch = "All", goal2_movement_type = character(0),
        goal2_movement_display = c("Averages and Pitches"),
        goal2_execution_stat = "", goal2_execution_pitch = "All",
        goal2_batter_hand = "All", goal2_chart_view = "Trend Chart",
        goal2_target_direction = "", goal2_target_value = "",
        goal3_type = "", goal3_stuff_category = "", goal3_velocity_pitch = "All",
        goal3_movement_pitch = "All", goal3_movement_type = character(0),
        goal3_movement_display = c("Averages and Pitches"),
        goal3_execution_stat = "", goal3_execution_pitch = "All",
        goal3_batter_hand = "All", goal3_chart_view = "Trend Chart",
        goal3_target_direction = "", goal3_target_value = "",
        goal1_notes = "", goal2_notes = "", goal3_notes = "",
        general_notes = "",
        school_code = current_school()
      )
      cat("Created new default plan for player:", player, "\n")
    } else {
      cat("Loaded existing plan for player:", player, "\n")
      cat("Goal 1 type:", plan$goal1_type, "\n")
      cat("Goal 2 type:", plan$goal2_type, "\n")
      cat("Goal 3 type:", plan$goal3_type, "\n")
    }
    return(plan)
  }
  
  # Helper function to save current plan
  save_current_plan <- function(player) {
    if (is.null(player) || player == "") return()
    
    plan <- list(
      session_type = input$pp_session_type %||% "All",
      goal1_type = input$pp_goal1_type %||% "",
      goal1_stuff_category = input$pp_goal1_stuff_category %||% "",
      goal1_velocity_pitch = input$pp_goal1_velocity_pitch %||% "All",
      goal1_movement_pitch = input$pp_goal1_movement_pitch %||% "All",
      goal1_movement_type = input$pp_goal1_movement_type %||% character(0),
      goal1_movement_display = input$pp_goal1_movement_display %||% c("Averages and Pitches"),
      goal1_execution_stat = input$pp_goal1_execution_stat %||% "",
      goal1_execution_pitch = input$pp_goal1_execution_pitch %||% "All",
      goal1_batter_hand = input$pp_goal1_batter_hand %||% "All",
      goal1_chart_view = input$pp_goal1_chart_view %||% "Trend Chart",
      goal1_target_direction = input$pp_goal1_target_direction %||% "",
      goal1_target_value = input$pp_goal1_target_value %||% "",
      goal2_type = input$pp_goal2_type %||% "",
      goal2_stuff_category = input$pp_goal2_stuff_category %||% "",
      goal2_velocity_pitch = input$pp_goal2_velocity_pitch %||% "All",
      goal2_movement_pitch = input$pp_goal2_movement_pitch %||% "All",
      goal2_movement_type = input$pp_goal2_movement_type %||% character(0),
      goal2_movement_display = input$pp_goal2_movement_display %||% c("Averages and Pitches"),
      goal2_execution_stat = input$pp_goal2_execution_stat %||% "",
      goal2_execution_pitch = input$pp_goal2_execution_pitch %||% "All",
      goal2_batter_hand = input$pp_goal2_batter_hand %||% "All",
      goal2_chart_view = input$pp_goal2_chart_view %||% "Trend Chart",
      goal2_target_direction = input$pp_goal2_target_direction %||% "",
      goal2_target_value = input$pp_goal2_target_value %||% "",
      goal3_type = input$pp_goal3_type %||% "",
      goal3_stuff_category = input$pp_goal3_stuff_category %||% "",
      goal3_velocity_pitch = input$pp_goal3_velocity_pitch %||% "All",
      goal3_movement_pitch = input$pp_goal3_movement_pitch %||% "All",
      goal3_movement_type = input$pp_goal3_movement_type %||% character(0),
      goal3_movement_display = input$pp_goal3_movement_display %||% c("Averages and Pitches"),
      goal3_execution_stat = input$pp_goal3_execution_stat %||% "",
      goal3_execution_pitch = input$pp_goal3_execution_pitch %||% "All",
      goal3_batter_hand = input$pp_goal3_batter_hand %||% "All",
      goal3_chart_view = input$pp_goal3_chart_view %||% "Trend Chart",
      goal3_target_direction = input$pp_goal3_target_direction %||% "",
      goal3_target_value = input$pp_goal3_target_value %||% "",
      goal1_notes = input$pp_goal1_notes %||% "",
      goal2_notes = input$pp_goal2_notes %||% "",
      goal3_notes = input$pp_goal3_notes %||% "",
      general_notes = input$pp_general_notes %||% "",
      school_code = current_school()
    )
    
    player_plans_data$plans[[player]] <- plan
    
    # Save to localStorage
    session$sendCustomMessage("savePlayerPlans", player_plans_data$plans)
    # Persist to DB
    try(save_player_plans_db(player_plans_data$plans), silent = TRUE)
    
    cat("Saved plan for player:", player, "\n")
    cat("Goal 1 type:", plan$goal1_type, "\n")
    cat("Goal 2 type:", plan$goal2_type, "\n") 
    cat("Goal 3 type:", plan$goal3_type, "\n")
    cat("Total saved plans:", length(player_plans_data$plans), "\n")
  }
  
  # Populate player choices and set default date range
  observe({
    req(pitch_data)
    
    # Use the whitelist-filtered pitch_data_pitching for consistency with other modules
    players <- sort(unique(pitch_data_pitching$Pitcher))
    
    # Filter by user role: Coaches see all, Players see only themselves
    if (!is_admin() && !is_coach()) {
      ue <- user_email()
      if (!is.na(ue)) {
        visible_players <- unique(pitch_data_pitching$Pitcher[norm_email(pitch_data_pitching$Email) == norm_email(ue)])
        players <- intersect(players, visible_players)
      }
    }
    
    updateSelectInput(session, "pp_player_select",
                      choices = players,
                      selected = if(length(players) > 0) players[1] else NULL)
  })
  
  # Update date range when player changes
  observeEvent(input$pp_player_select, {
    req(input$pp_player_select, pitch_data)
    
    # Save previous player's plan if we're switching players
    previous_player <- isolate(player_plans_data$current_player)
    if (!is.null(previous_player) && previous_player != input$pp_player_select) {
      save_current_plan(previous_player)
    }
    
    # Update current player tracker
    player_plans_data$current_player <- input$pp_player_select
    
    # Get player's data date range using whitelist-filtered data
    player_data <- pitch_data_pitching %>% dplyr::filter(Pitcher == input$pp_player_select)
    
    if (nrow(player_data) > 0) {
      max_date <- max(player_data$Date, na.rm = TRUE)
      start_date <- max_date - 30
      
      updateDateRangeInput(session, "pp_date_range",
                           start = start_date,
                           end = max_date)
    }
    
    # Load player's saved plan
    plan <- get_current_plan(input$pp_player_select)
    
    # Update all inputs with saved values (using isolate to prevent recursion)
    isolate({
      updateSelectInput(session, "pp_session_type", selected = plan$session_type %||% "All")
      updateSelectInput(session, "pp_goal1_type", selected = plan$goal1_type)
      updateSelectInput(session, "pp_goal1_stuff_category", selected = plan$goal1_stuff_category)
      updateSelectInput(session, "pp_goal1_velocity_pitch", selected = plan$goal1_velocity_pitch)
      updateSelectInput(session, "pp_goal1_movement_pitch", selected = plan$goal1_movement_pitch)
      updateSelectInput(session, "pp_goal1_movement_type", selected = plan$goal1_movement_type)
      updateSelectInput(session, "pp_goal1_movement_display", selected = plan$goal1_movement_display %||% c("Averages and Pitches"))
      updateSelectInput(session, "pp_goal1_execution_stat", selected = plan$goal1_execution_stat)
      updateSelectInput(session, "pp_goal1_execution_pitch", selected = plan$goal1_execution_pitch)
      updateSelectInput(session, "pp_goal1_batter_hand", selected = plan$goal1_batter_hand %||% "All")
      updateSelectInput(session, "pp_goal1_chart_view", selected = plan$goal1_chart_view %||% "Trend Chart")
      updateSelectInput(session, "pp_goal1_target_direction", selected = plan$goal1_target_direction)
      updateTextInput(session, "pp_goal1_target_value", value = plan$goal1_target_value)
      
      updateSelectInput(session, "pp_goal2_type", selected = plan$goal2_type)
      updateSelectInput(session, "pp_goal2_stuff_category", selected = plan$goal2_stuff_category)
      updateSelectInput(session, "pp_goal2_velocity_pitch", selected = plan$goal2_velocity_pitch)
      updateSelectInput(session, "pp_goal2_movement_pitch", selected = plan$goal2_movement_pitch)
      updateSelectInput(session, "pp_goal2_movement_type", selected = plan$goal2_movement_type)
      updateSelectInput(session, "pp_goal2_movement_display", selected = plan$goal2_movement_display %||% c("Averages and Pitches"))
      updateSelectInput(session, "pp_goal2_execution_stat", selected = plan$goal2_execution_stat)
      updateSelectInput(session, "pp_goal2_execution_pitch", selected = plan$goal2_execution_pitch)
      updateSelectInput(session, "pp_goal2_batter_hand", selected = plan$goal2_batter_hand %||% "All")
      updateSelectInput(session, "pp_goal2_chart_view", selected = plan$goal2_chart_view %||% "Trend Chart")
      updateSelectInput(session, "pp_goal2_target_direction", selected = plan$goal2_target_direction)
      updateTextInput(session, "pp_goal2_target_value", value = plan$goal2_target_value)
      
      updateSelectInput(session, "pp_goal3_type", selected = plan$goal3_type)
      updateSelectInput(session, "pp_goal3_stuff_category", selected = plan$goal3_stuff_category)
      updateSelectInput(session, "pp_goal3_velocity_pitch", selected = plan$goal3_velocity_pitch)
      updateSelectInput(session, "pp_goal3_movement_pitch", selected = plan$goal3_movement_pitch)
      updateSelectInput(session, "pp_goal3_movement_type", selected = plan$goal3_movement_type)
      updateSelectInput(session, "pp_goal3_movement_display", selected = plan$goal3_movement_display %||% c("Averages and Pitches"))
      updateSelectInput(session, "pp_goal3_execution_stat", selected = plan$goal3_execution_stat)
      updateSelectInput(session, "pp_goal3_execution_pitch", selected = plan$goal3_execution_pitch)
      updateSelectInput(session, "pp_goal3_batter_hand", selected = plan$goal3_batter_hand %||% "All")
      updateSelectInput(session, "pp_goal3_chart_view", selected = plan$goal3_chart_view %||% "Trend Chart")
      updateSelectInput(session, "pp_goal3_target_direction", selected = plan$goal3_target_direction)
      updateTextInput(session, "pp_goal3_target_value", value = plan$goal3_target_value)
      
      updateTextAreaInput(session, "pp_goal1_notes", value = plan$goal1_notes)
      updateTextAreaInput(session, "pp_goal2_notes", value = plan$goal2_notes)
      updateTextAreaInput(session, "pp_goal3_notes", value = plan$goal3_notes)
      updateTextAreaInput(session, "pp_general_notes", value = plan$general_notes)
    })
  }, ignoreInit = TRUE)
  
  # Auto-save when any goal input changes
  observe({
    req(plans_initialized(), input$pp_player_select)
    
    # Throttle autosave to reduce DB churn
    invalidateLater(10000, session)
    
    # Save current plan (errors here should not break the session)
    try(save_current_plan(input$pp_player_select), silent = TRUE)
  })
  
  # Additional observers for immediate saving on critical changes
  observeEvent(c(input$pp_goal1_type, input$pp_goal2_type, input$pp_goal3_type), {
    req(input$pp_player_select)
    save_current_plan(input$pp_player_select)
  }, ignoreInit = TRUE)
  
  observeEvent(c(input$pp_goal1_target_value, input$pp_goal2_target_value, input$pp_goal3_target_value), {
    req(input$pp_player_select)
    save_current_plan(input$pp_player_select)
  }, ignoreInit = TRUE)
  
  observeEvent(c(input$pp_goal1_chart_view, input$pp_goal2_chart_view, input$pp_goal3_chart_view), {
    req(input$pp_player_select)
    save_current_plan(input$pp_player_select)
  }, ignoreInit = TRUE)
  
  # Save plan when general notes change
  observeEvent(input$pp_general_notes, {
    req(input$pp_player_select)
    save_current_plan(input$pp_player_select)
  }, ignoreInit = TRUE)
  
  # Observers for goal completion checkboxes
  observeEvent(input$pp_goal1_completed, {
    if (input$pp_goal1_completed && !is.null(input$pp_player_select) && input$pp_player_select != "") {
      save_completed_goal(input$pp_player_select, 1)
    }
  })
  
  observeEvent(input$pp_goal2_completed, {
    if (input$pp_goal2_completed && !is.null(input$pp_player_select) && input$pp_player_select != "") {
      save_completed_goal(input$pp_player_select, 2)
    }
  })
  
  observeEvent(input$pp_goal3_completed, {
    if (input$pp_goal3_completed && !is.null(input$pp_player_select) && input$pp_player_select != "") {
      save_completed_goal(input$pp_player_select, 3)
    }
  })
  
  # Helper function to save completed goals
  save_completed_goal <- function(player, goal_num) {
    if (is.null(player) || player == "") return()
    
    # Save the completed goal data
    completed_goal <- list(
      player = player,
      goal_num = goal_num,
      date_completed = Sys.Date(),
      goal_data = list(
        type = input[[paste0("pp_goal", goal_num, "_type")]],
        stuff_category = input[[paste0("pp_goal", goal_num, "_stuff_category")]],
        velocity_pitch = input[[paste0("pp_goal", goal_num, "_velocity_pitch")]],
        movement_pitch = input[[paste0("pp_goal", goal_num, "_movement_pitch")]],
        movement_type = input[[paste0("pp_goal", goal_num, "_movement_type")]],
        execution_stat = input[[paste0("pp_goal", goal_num, "_execution_stat")]],
        execution_pitch = input[[paste0("pp_goal", goal_num, "_execution_pitch")]],
        batter_hand = input[[paste0("pp_goal", goal_num, "_batter_hand")]],
        chart_view = input[[paste0("pp_goal", goal_num, "_chart_view")]],
        target_direction = input[[paste0("pp_goal", goal_num, "_target_direction")]],
        target_value = input[[paste0("pp_goal", goal_num, "_target_value")]],
        notes = input[[paste0("pp_goal", goal_num, "_notes")]]
      )
    )
    
    # Generate unique ID for the completed goal
    goal_id <- paste0(player, "_", goal_num, "_", format(Sys.time(), "%Y%m%d_%H%M%S"))
    
    # Add to completed goals storage
    completed_goals_data$goals[[goal_id]] <- completed_goal
    
    # Clear the goal inputs after completion
    clear_goal_inputs(goal_num)
    
    # Save to localStorage
    session$sendCustomMessage("saveCompletedGoals", completed_goals_data$goals)
    # Persist to DB
    try(save_completed_goals_db(completed_goals_data$goals), silent = TRUE)
    
    cat("Saved completed goal for player:", player, "goal:", goal_num, "\n")
  }
  
  # Helper function to delete a completed goal
  delete_completed_goal <- function(goal_id) {
    if (!is.null(completed_goals_data$goals) && goal_id %in% names(completed_goals_data$goals)) {
      completed_goals_data$goals[[goal_id]] <- NULL
      session$sendCustomMessage("saveCompletedGoals", completed_goals_data$goals)
      try(save_completed_goals_db(completed_goals_data$goals), silent = TRUE)
      cat("Deleted completed goal:", goal_id, "\n")
    }
  }
  
  # Observer for delete buttons (will be created dynamically)
  observe({
    # Get all delete button inputs
    delete_inputs <- grep("^pp_delete_goal_", names(input), value = TRUE)
    
    for (delete_input in delete_inputs) {
      if (!is.null(input[[delete_input]]) && input[[delete_input]] > 0) {
        # Extract goal ID from input name
        goal_id <- gsub("^pp_delete_goal_", "", delete_input)
        delete_completed_goal(goal_id)
      }
    }
  })
  
  # Render completed goals count
  output$pp_completed_count <- renderText({
    req(input$pp_player_select)
    
    if (is.null(completed_goals_data$goals) || length(completed_goals_data$goals) == 0) {
      return("(0 completed goals)")
    }
    
    # Count completed goals for current player
    player_goals <- completed_goals_data$goals[sapply(completed_goals_data$goals, function(g) {
      !is.null(g$player) && g$player == input$pp_player_select
    })]
    count <- length(player_goals)
    
    return(paste0("(", count, " completed goal", if(count != 1) "s" else "", ")"))
  })
  
  # Render completed goals modal content
  output$pp_completed_goals_content <- renderUI({
    req(input$pp_player_select)
    
    if (is.null(completed_goals_data$goals) || length(completed_goals_data$goals) == 0) {
      return(div(style = "text-align: center; padding: 50px;",
                 h4("No completed goals yet.")))
    }
    
    # Filter completed goals for current player
    player_goals <- completed_goals_data$goals[sapply(completed_goals_data$goals, function(g) {
      !is.null(g$player) && g$player == input$pp_player_select
    })]
    
    if (length(player_goals) == 0) {
      return(div(style = "text-align: center; padding: 50px;",
                 h4("No completed goals for this player yet.")))
    }
    
    # Sort by completion date (most recent first)
    player_goals <- player_goals[order(sapply(player_goals, function(g) {
      if (is.null(g$date_completed)) return(0)
      return(as.Date(g$date_completed))
    }), decreasing = TRUE)]
    
    # Create cards for each completed goal
    goal_cards <- lapply(names(player_goals), function(goal_id) {
      goal <- player_goals[[goal_id]]
      
      div(class = "panel panel-default", style = "margin-bottom: 15px;",
          div(class = "panel-heading", style = "position: relative;",
              h5(class = "panel-title", style = "margin-right: 30px;",
                 strong(paste("Goal #", goal$goal_num, " - ", goal$goal_data$type))
              ),
              # Delete button in upper right
              div(style = "position: absolute; top: 5px; right: 10px;",
                  actionButton(paste0("pp_delete_goal_", goal_id), "×",
                               class = "btn btn-danger btn-xs",
                               style = "padding: 2px 6px; font-size: 12px;")
              )
          ),
          div(class = "panel-body",
              div(style = "margin-bottom: 10px;",
                  strong("Completed: "), format(as.Date(goal$date_completed), "%B %d, %Y")
              ),
              div(style = "margin-bottom: 10px;",
                  strong("Description: "), create_pp_goal_description_from_data(goal$goal_data)
              ),
              if (!is.null(goal$goal_data$notes) && goal$goal_data$notes != "") {
                div(style = "margin-bottom: 10px;",
                    strong("Notes: "), goal$goal_data$notes
                )
              }
          )
      )
    })
    
    div(goal_cards)
  })
  
  # Observer for "View Completed Goals" button
  observeEvent(input$pp_view_completed, {
    showModal(modalDialog(
      title = "Completed Goals",
      div(style = "max-height: 600px; overflow-y: auto;",
          uiOutput("pp_completed_goals_content")
      ),
      size = "l",
      easyClose = TRUE,
      footer = modalButton("Close")
    ))
  })
  
  # Helper function to create goal descriptions from stored data
  create_pp_goal_description_from_data <- function(goal_data) {
    if (is.null(goal_data$type) || goal_data$type == "") {
      return("No goal type selected")
    }
    
    if (goal_data$type == "Stuff") {
      category <- goal_data$stuff_category %||% ""
      if (category == "Velocity") {
        pitch <- goal_data$velocity_pitch %||% ""
        if (pitch == "") return("Velocity - No pitch type selected")
        return(paste0("Velocity - ", pitch))
      } else if (category == "Movement") {
        pitch <- goal_data$movement_pitch %||% ""
        movement <- goal_data$movement_type %||% character(0)
        if (pitch == "" || length(movement) == 0) {
          return("Movement - Incomplete selection")
        }
        return(paste0("Movement - ", pitch, " (", paste(movement, collapse = " & "), ")"))
      } else {
        return("Stuff - No category selected")
      }
    } else if (goal_data$type == "Execution") {
      stat <- goal_data$execution_stat %||% ""
      pitch <- goal_data$execution_pitch %||% ""
      if (stat == "") return("Execution - No stat selected")
      if (pitch == "") return(paste0("Execution - ", stat, " (No pitch type selected)"))
      return(paste0("Execution - ", stat, " (", pitch, ")"))
    }
    
    return("Unknown goal type")
  }
  
  # Helper function to clear goal inputs
  clear_goal_inputs <- function(goal_num) {
    updateSelectInput(session, paste0("pp_goal", goal_num, "_type"), selected = "")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_stuff_category"), selected = "")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_velocity_pitch"), selected = "All")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_movement_pitch"), selected = "All")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_movement_type"), selected = character(0))
    updateSelectInput(session, paste0("pp_goal", goal_num, "_movement_display"), selected = c("Averages and Pitches"))
    updateSelectInput(session, paste0("pp_goal", goal_num, "_execution_stat"), selected = "")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_execution_pitch"), selected = "All")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_batter_hand"), selected = "All")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_chart_view"), selected = "Trend Chart")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_target_direction"), selected = "")
    updateTextInput(session, paste0("pp_goal", goal_num, "_target_value"), value = "")
    updateTextAreaInput(session, paste0("pp_goal", goal_num, "_notes"), value = "")
    updateCheckboxInput(session, paste0("pp_goal", goal_num, "_completed"), value = FALSE)
  }
  
  # Save plan when session ends or player leaves page
  session$onSessionEnded(function() {
    tryCatch({
      player_select <- isolate(input$pp_player_select)
      if (!is.null(player_select)) {
        save_current_plan(player_select)
      }
    }, error = function(e) {
      # Silently ignore errors during session end
    })
  })
  
  # Populate pitch type choices for all goals
  observe({
    updateSelectInput(session, "pp_goal1_velocity_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal1_movement_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal1_execution_pitch", choices = c("All", available_pitch_types))
    
    updateSelectInput(session, "pp_goal2_velocity_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal2_movement_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal2_execution_pitch", choices = c("All", available_pitch_types))
    
    updateSelectInput(session, "pp_goal3_velocity_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal3_movement_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal3_execution_pitch", choices = c("All", available_pitch_types))
  })
  
  # Add basic output renders for Player Plans
  output$pp_player_name <- renderText({
    req(input$pp_player_select)
    input$pp_player_select
  })
  
  output$pp_date_range_display <- renderText({
    req(input$pp_date_range)
    paste(format(input$pp_date_range[1], "%B %d"), "-", format(input$pp_date_range[2], "%B %d, %Y"))
  })
  
  output$pp_dynamic_goals <- renderUI({
    # Check which goals are configured
    goals_configured <- c()
    
    if (!is.null(input$pp_goal1_type) && input$pp_goal1_type != "") {
      goals_configured <- c(goals_configured, 1)
    }
    if (!is.null(input$pp_goal2_type) && input$pp_goal2_type != "") {
      goals_configured <- c(goals_configured, 2)
    }
    if (!is.null(input$pp_goal3_type) && input$pp_goal3_type != "") {
      goals_configured <- c(goals_configured, 3)
    }
    
    if (length(goals_configured) == 0) {
      return(div(style = "text-align: center; padding: 50px;",
                 h4("No goals configured yet. Please select goal types in the sidebar.")))
    }
    
    # Helper function to create a goal card
    create_goal_card <- function(goal_num) {
      div(class = "goal-container",
          # Completion checkbox in upper right corner with fixed positioning
          div(class = "goal-checkbox",
              checkboxInput(paste0("pp_goal", goal_num, "_completed"), 
                            label = NULL, 
                            value = FALSE)
          ),
          # Add some top padding to prevent overlap with checkbox
          div(style = "padding-top: 10px;",
              h4(textOutput(paste0("pp_goal", goal_num, "_header"), inline = TRUE))
          ),
          div(class = "goal-description",
              textOutput(paste0("pp_goal", goal_num, "_description"))
          ),
          ggiraph::girafeOutput(paste0("pp_goal", goal_num, "_plot"), height = "300px"),
          br(),
          DT::dataTableOutput(paste0("pp_goal", goal_num, "_table")),
          br(),
          div(style = "text-align: center;",
              h5(strong("Drills and Notes:"))
          ),
          textAreaInput(paste0("pp_goal", goal_num, "_notes"), label = NULL,
                        placeholder = paste0("Enter drills and notes for Goal #", goal_num, "..."),
                        rows = 3, width = "100%")
      )
    }
    
    # Determine column width and offset for centering
    num_goals <- length(goals_configured)
    if (num_goals == 1) {
      column_width <- 6
      offset <- 3
    } else if (num_goals == 2) {
      column_width <- 5
      offset <- 1
    } else {
      column_width <- 4
      offset <- 0
    }
    
    # Create the appropriate layout
    if (num_goals == 1) {
      fluidRow(
        column(column_width, offset = offset,
               create_goal_card(goals_configured[1])
        )
      )
    } else if (num_goals == 2) {
      fluidRow(
        column(column_width, offset = offset,
               create_goal_card(goals_configured[1])
        ),
        column(column_width,
               create_goal_card(goals_configured[2])
        )
      )
    } else {
      fluidRow(
        column(column_width,
               create_goal_card(goals_configured[1])
        ),
        column(column_width,
               create_goal_card(goals_configured[2])
        ),
        column(column_width,
               create_goal_card(goals_configured[3])
        )
      )
    }
  })
  
  # Goal headers
  output$pp_goal1_header <- renderText({
    goal_type <- input$pp_goal1_type
    if (is.null(goal_type) || goal_type == "") {
      return("Goal #1")
    } else {
      return(paste0("Goal #1: ", goal_type))
    }
  })
  
  output$pp_goal2_header <- renderText({
    goal_type <- input$pp_goal2_type
    if (is.null(goal_type) || goal_type == "") {
      return("Goal #2")
    } else {
      return(paste0("Goal #2: ", goal_type))
    }
  })
  
  output$pp_goal3_header <- renderText({
    goal_type <- input$pp_goal3_type
    if (is.null(goal_type) || goal_type == "") {
      return("Goal #3")
    } else {
      return(paste0("Goal #3: ", goal_type))
    }
  })
  
  # Goal descriptions
  output$pp_goal1_description <- renderText({
    create_pp_goal_description(1)
  })
  
  output$pp_goal2_description <- renderText({
    create_pp_goal_description(2)
  })
  
  output$pp_goal3_description <- renderText({
    create_pp_goal_description(3)
  })
  
  # Helper function to create goal descriptions  
  create_pp_goal_description <- function(goal_num) {
    goal_type <- input[[paste0("pp_goal", goal_num, "_type")]]
    chart_view <- input[[paste0("pp_goal", goal_num, "_chart_view")]]
    
    if (is.null(goal_type) || goal_type == "") {
      return("No goal selected")
    }
    
    # Get batter hand info
    batter_hand <- input[[paste0("pp_goal", goal_num, "_batter_hand")]]
    batter_text <- ""
    if (!is.null(batter_hand) && batter_hand != "All") {
      batter_text <- paste(" | vs", batter_hand)
    }
    
    # Get target info
    target_direction <- input[[paste0("pp_goal", goal_num, "_target_direction")]]
    target_value <- input[[paste0("pp_goal", goal_num, "_target_value")]]
    target_text <- ""
    if (!is.null(target_direction) && !is.null(target_value) && 
        target_direction != "" && target_value != "") {
      target_text <- paste(" | Target:", target_direction, target_value)
    }
    
    if (goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      if (is.null(category) || category == "") {
        return(paste0("No category selected", batter_text, target_text))
      }
      
      if (category == "Velocity") {
        pitch <- input[[paste0("pp_goal", goal_num, "_velocity_pitch")]]
        if (is.null(pitch) || pitch == "") {
          return(paste0("Velocity - No pitch type selected", batter_text, target_text))
        }
        return(paste0("Velocity - ", pitch, batter_text, target_text))
      }
      
      if (category == "Movement") {
        pitch <- input[[paste0("pp_goal", goal_num, "_movement_pitch")]]
        movement <- input[[paste0("pp_goal", goal_num, "_movement_type")]]
        if (is.null(pitch) || pitch == "" || is.null(movement) || length(movement) == 0) {
          return(paste0("Movement - Incomplete selection", batter_text, target_text))
        }
        return(paste0("Movement - ", pitch, " - ", paste(movement, collapse = ", "), batter_text, target_text))
      }
    }
    
    if (goal_type == "Execution") {
      stat <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      pitch <- input[[paste0("pp_goal", goal_num, "_execution_pitch")]]
      if (is.null(stat) || stat == "" || is.null(pitch) || length(pitch) == 0) {
        return(paste0("Incomplete selection", batter_text, target_text))
      }
      return(paste0(stat, " - Pitch: ", paste(pitch, collapse = ", "), batter_text, target_text))
    }
    
    return(paste0("Invalid goal configuration", batter_text, target_text))
  }
  
  # ========== PLAYER PLANS CHART AND TABLE RENDERS ==========
  
  # Helper function to create execution heatmaps
  create_execution_heatmap <- function(df, stat) {
    if (is.null(df) || nrow(df) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No data available") +
               theme_void())
    }
    
    # Create heatmap based on stat type - using advanced Pitching Suite implementation
    if (stat == "FPS%") {
      # FPS% - show frequency of first pitch locations
      fps_df <- df %>%
        dplyr::filter(Balls == 0 & Strikes == 0)
      
      if (nrow(fps_df) == 0) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "No first pitch data available") +
                 theme_void())
      }
      
      # Use adaptive KDE for frequency
      grid <- make_kde_grid(fps_df$PlateLocSide, fps_df$PlateLocHeight, n = 200)
      
      if (!nrow(grid)) return(ggplot() + theme_void())
      
      # Normalize KDE values to 0-100 scale
      grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "First Pitch Frequency",
                       scale_limits = c(0, 80)))
      
    }
    
    # Filter for finite plate location data for non-Frequency stats
    df_loc <- df %>%
      dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
    
    if (nrow(df_loc) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No location data available") +
               theme_void())
    }
    
    if (stat == "E+A%") {
      # E+A% (Excellent + Advantage) - rate heatmap
      df_loc <- df_loc %>%
        dplyr::mutate(
          ExcellentAdv = dplyr::case_when(
            Balls == 0 & Strikes == 0 & PitchCall %in% c("StrikeCalled", "StrikeSwinging", "FoulBall", "FoulBallFieldable", "FoulBallNotFieldable") ~ TRUE,
            (Strikes > Balls) & PitchCall %in% c("StrikeCalled", "StrikeSwinging", "FoulBall", "FoulBallFieldable", "FoulBallNotFieldable", "InPlay") ~ TRUE,
            TRUE ~ FALSE
          )
        )
      
      numerator_cond <- df_loc$ExcellentAdv
      grid <- make_rate_grid(df_loc, numerator_cond, denominator_condition = NULL, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "Insufficient data") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "E+A%",
                       scale_limits = c(0, 100)))
      
    } else if (stat == "InZone%") {
      # InZone% - rate heatmap
      in_zone_cond <- !is.na(df_loc$PlateLocSide) & !is.na(df_loc$PlateLocHeight) &
        df_loc$PlateLocSide >= ZONE_LEFT & df_loc$PlateLocSide <= ZONE_RIGHT &
        df_loc$PlateLocHeight >= ZONE_BOTTOM & df_loc$PlateLocHeight <= ZONE_TOP
      
      grid <- make_rate_grid(df_loc, in_zone_cond, denominator_condition = NULL, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "Insufficient data") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "InZone%",
                       scale_limits = c(0, 100)))
      
    } else if (stat == "Strike%") {
      # Strike% - rate heatmap
      strike_calls <- c("StrikeCalled", "StrikeSwinging", "FoulBall", "FoulBallFieldable", "FoulBallNotFieldable", "InPlay")
      strike_cond <- df_loc$PitchCall %in% strike_calls
      
      grid <- make_rate_grid(df_loc, strike_cond, denominator_condition = NULL, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "Insufficient data") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "Strike%",
                       scale_limits = c(0, 100)))
      
    } else if (stat == "Comp%") {
      # Comp% (Competitive pitches) - rate heatmap
      comp_cond <- !is.na(df_loc$PlateLocSide) & !is.na(df_loc$PlateLocHeight) &
        df_loc$PlateLocSide >= (ZONE_LEFT - 0.5) & df_loc$PlateLocSide <= (ZONE_RIGHT + 0.5) &
        df_loc$PlateLocHeight >= (ZONE_BOTTOM - 0.5) & df_loc$PlateLocHeight <= (ZONE_TOP + 0.5)
      
      grid <- make_rate_grid(df_loc, comp_cond, denominator_condition = NULL, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "Insufficient data") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "Comp%",
                       scale_limits = c(0, 100)))
      
    } else if (stat == "Whiff%") {
      # Whiff% - rate heatmap (whiffs per swing opportunity)
      swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                        "FoulBallNotFieldable", "InPlay")
      whiff_events <- c("StrikeSwinging")
      
      numerator_cond <- df_loc$PitchCall %in% whiff_events
      denominator_cond <- df_loc$PitchCall %in% swing_events
      
      grid <- make_rate_grid(df_loc, numerator_cond, denominator_cond, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "No swing data available") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "Whiff%",
                       scale_limits = c(0, 100)))
      
    } else if (stat == "CSW%") {
      # CSW% - called strikes + whiffs per opportunity (rate heatmap)
      csw_calls <- c("StrikeCalled", "StrikeSwinging")
      
      numerator_cond <- df_loc$PitchCall %in% csw_calls
      grid <- make_rate_grid(df_loc, numerator_cond, denominator_condition = NULL, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "No CSW data available") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "CSW%",
                       scale_limits = c(0, 100)))
      
    } else {
      # For all other execution stats, show frequency heatmap with advanced KDE
      grid <- make_kde_grid(df_loc$PlateLocSide, df_loc$PlateLocHeight, n = 200)
      
      if (!nrow(grid)) return(ggplot() + theme_void())
      
      # Normalize KDE values to 0-100 scale
      grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
                       show_scale = TRUE, scale_label = paste(stat, "Frequency"),
                       scale_limits = c(0, 80)))
    }
  }
  
  # Helper: pitch map (matches Pitching summary girafe)
  create_execution_pitch_map <- function(df) {
    if (is.null(df) || nrow(df) == 0) {
      return(ggplot() +
               annotate("text", x = 0.5, y = 0.5, label = "No data available") +
               theme_void())
    }
    dark_on <- FALSE
    try({
      dom <- shiny::getDefaultReactiveDomain()
      if (!is.null(dom) && !is.null(dom$input$dark_mode)) dark_on <- isTRUE(dom$input$dark_mode)
    }, silent = TRUE)
    line_col <- if (dark_on) "#ffffff" else "black"
    grid_col <- if (dark_on) "#d1d5db" else "black"
    cols <- colors_for_mode(dark_on)
    df <- df %>%
      dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight)) %>%
      dplyr::mutate(
        Result        = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
        TaggedPitchType = as.character(TaggedPitchType),
        tt            = make_hover_tt(.),
        rid           = dplyr::row_number(),
        tt_fill       = dplyr::coalesce(cols[as.character(TaggedPitchType)], "gray")
      )
    if (!nrow(df)) {
      return(ggplot() +
               annotate("text", x = 0.5, y = 0.5, label = "No location data available") +
               theme_void())
    }
    types_chr <- intersect(names(cols), unique(df$TaggedPitchType))
    home <- data.frame(x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
                       y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5)
    cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
    sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
    df_known <- dplyr::filter(df, !is.na(Result))
    df_other <- dplyr::filter(df,  is.na(Result))
    
    p <- ggplot() +
      geom_polygon(data = home, aes(x, y), fill = NA, color = line_col, inherit.aes = FALSE) +
      geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = line_col, linetype = "dashed", inherit.aes = FALSE) +
      geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = line_col, inherit.aes = FALSE) +
      
      ggiraph::geom_point_interactive(
        data = df_other,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
      ) +
      ggiraph::geom_point_interactive(
        data = df_known,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 4.0, alpha = 0.95, stroke = 0.8
      ) +
      scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = cols[types_chr], limits = types_chr, name = NULL) +
      scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
      coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
      theme_void() + theme(legend.position = "none",
                           panel.grid.major = element_blank(),
                           panel.grid.minor = element_blank()) +
      ggiraph::geom_point_interactive(
        data = df,
        aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
        shape = 21, size = 6, alpha = 0.001, stroke = 0, inherit.aes = FALSE
      )
    
    girafe_transparent(
      ggobj = p,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  }
  
  # Helper: movement plot for Stuff goals
  create_pp_movement_plot <- function(df, goal_num = NULL) {
    if (is.null(df) || nrow(df) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No data available") +
               theme_void())
    }
    dark_on <- FALSE
    try({
      dom <- shiny::getDefaultReactiveDomain()
      if (!is.null(dom) && !is.null(dom$input$dark_mode)) dark_on <- isTRUE(dom$input$dark_mode)
    }, silent = TRUE)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    line_col <- if (dark_on) "#ffffff" else "gray"
    grid_col <- adjustcolor(if (dark_on) "white" else "black",
                            alpha.f = if (dark_on) 0.18 else 0.12)
    cols <- colors_for_mode(dark_on)
    types_chr <- intersect(names(cols), unique(as.character(df$TaggedPitchType)))
    df_mv <- df %>%
      dplyr::filter(is.finite(InducedVertBreak), is.finite(HorzBreak)) %>%
      dplyr::mutate(
        TaggedPitchType = as.character(TaggedPitchType),
        HB_adj = ifelse(PitcherThrows == "Left", HorzBreak, -HorzBreak),
        tt     = make_hover_tt(.),
        rid    = dplyr::row_number()
      )
    if (!nrow(df_mv)) {
      return(ggplot() +
               annotate("text", x = 0.5, y = 0.5, label = "No movement data available") +
               theme_void())
    }
    # Movement plot display options (mirror summary page)
    display_opts <- NULL
    if (!is.null(goal_num)) {
      display_opts <- input[[paste0("pp_goal", goal_num, "_movement_display")]]
    }
    if (is.null(display_opts)) display_opts <- "Averages and Pitches"
    show_pitches  <- any(c("Averages and Pitches", "Target Shapes and Pitches") %in% display_opts)
    show_averages <- any(c("Averages Only", "Averages and Pitches") %in% display_opts)
    show_targets  <- any(c("Target Shapes Only", "Target Shapes and Pitches") %in% display_opts)
    
    # Re-render when target shapes change
    target_shapes_version()
    
    # Target shapes overlay (shared across pages)
    target_df <- NULL
    pitcher_name <- input$pp_player_select
    pitcher_hand <- dplyr::coalesce(df_mv$PitcherThrows[!is.na(df_mv$PitcherThrows)][1], "Right")
    if (show_targets && !is.null(pitcher_name) && pitcher_name != "" && pitcher_name != "All") {
      target_data <- lapply(types_chr, function(pt) {
        tgt <- get_target_shape(pitcher_name, pt, input$pp_date_range, auto_save = FALSE)
        if (is.null(tgt)) return(NULL)
        hb_plot <- ifelse(pitcher_hand == "Left", tgt$HB, -tgt$HB)
        data.frame(
          TaggedPitchType = pt,
          HB_Target = hb_plot,
          IVB_Target = tgt$IVB,
          stringsAsFactors = FALSE
        )
      })
      target_df <- dplyr::bind_rows(target_data)
    }
    # Averages per type (respect filters)
    avg_mov <- df_mv %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_HorzBreak = mean(HB_adj, na.rm = TRUE),
        avg_IVB       = mean(InducedVertBreak, na.rm = TRUE),
        .groups = "drop"
      )
    
    p <- ggplot() +
      geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
      geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
      { if (show_averages) ggiraph::geom_point_interactive(
        data = avg_mov %>% dplyr::filter(TaggedPitchType %in% types_chr),
        aes(x = avg_HorzBreak, y = avg_IVB, color = TaggedPitchType,
            tooltip = paste0(TaggedPitchType, "<br>IVB: ", round(avg_IVB,1),
                             " in<br>HB: ", round(avg_HorzBreak,1), " in"),
            data_id = TaggedPitchType),
        size = 8, show.legend = FALSE
      ) } +
      { if (show_pitches) ggiraph::geom_point_interactive(
        data = df_mv %>% dplyr::filter(TaggedPitchType %in% types_chr),
        aes(x = HB_adj, y = InducedVertBreak, color = TaggedPitchType,
            tooltip = tt, data_id = rid),
        size = 3.2, alpha = 0.9, show.legend = FALSE
      ) } +
      { if (!is.null(target_df) && nrow(target_df) > 0) {
        list(
          geom_point(
            data = target_df,
            aes(x = HB_Target, y = IVB_Target, fill = TaggedPitchType),
            size = 12, shape = 21, alpha = 0.10, stroke = 0, show.legend = FALSE
          ),
          geom_point(
            data = target_df,
            aes(x = HB_Target, y = IVB_Target, color = TaggedPitchType),
            size = 12, shape = 21, alpha = 0.8, stroke = 2, fill = NA, show.legend = FALSE
          )
        )
      } } +
      scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      labs(x = NULL, y = NULL, title = "Movement Plot") +
      theme(
        legend.position = "none",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
        axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
        panel.grid.major = element_line(color = grid_col),
        panel.grid.minor = element_blank(),
        axis.ticks = element_blank()
      ) +
      coord_cartesian(xlim = c(-25, 25), ylim = c(-25, 25))
    
    girafe_transparent(
      ggobj = p,
      width_svg = 8, height_svg = 6.5,
      options = list(
        ggiraph::opts_sizing(rescale = TRUE),
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  }
  
  # Helper function to make KDE grid
  make_kde_grid <- function(x, y, lims = c(-2.5,2.5,0,4.5), n = 180) {
    ok <- is.finite(x) & is.finite(y)
    x <- x[ok]; y <- y[ok]
    if (length(x) < 2 || length(unique(x)) < 2 || length(unique(y)) < 2) {
      return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
    }
    d <- MASS::kde2d(x, y, n = n, lims = lims)
    expand.grid(x = d$x, y = d$y) |> transform(z = as.vector(d$z))
  }
  
  # Helper function to filter data for a specific goal
  filter_goal_data <- function(goal_num) {
    req(input$pp_player_select, input$pp_date_range)
    
    # Get the player's data using whitelist-filtered dataset
    player_data <- pitch_data_pitching %>% 
      dplyr::filter(Pitcher == input$pp_player_select,
                    Date >= input$pp_date_range[1],
                    Date <= input$pp_date_range[2]) %>%
      dplyr::mutate(
        SessionType = dplyr::case_when(
          grepl("bull|prac", tolower(as.character(SessionType))) ~ "Bullpen",
          grepl("live|game|ab", tolower(as.character(SessionType))) ~ "Live",
          TRUE ~ as.character(SessionType)
        )
      )
    
    # Add pitch type filtering based on goal type and category
    goal_type <- input[[paste0("pp_goal", goal_num, "_type")]]
    # Batter hand filter (applies to all goal types)
    batter_hand <- input[[paste0("pp_goal", goal_num, "_batter_hand")]]
    if (!is.null(batter_hand) && batter_hand %in% c("Left", "Right")) {
      player_data <- player_data %>% dplyr::filter(as.character(BatterSide) == batter_hand)
    }
    
    if (!is.null(goal_type) && goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      
      if (!is.null(category)) {
        if (category == "Velocity") {
          pitch <- input[[paste0("pp_goal", goal_num, "_velocity_pitch")]]
          if (!is.null(pitch) && pitch != "" && pitch != "All") {
            player_data <- player_data %>% dplyr::filter(TaggedPitchType == pitch)
          }
        } else if (category == "Movement") {
          pitch <- input[[paste0("pp_goal", goal_num, "_movement_pitch")]]
          if (!is.null(pitch) && pitch != "" && pitch != "All") {
            player_data <- player_data %>% dplyr::filter(TaggedPitchType == pitch)
          }
        }
      }
    } else if (!is.null(goal_type) && goal_type == "Execution") {
      pitch <- input[[paste0("pp_goal", goal_num, "_execution_pitch")]]
      if (!is.null(pitch) && pitch != "" && pitch != "All") {
        player_data <- player_data %>% dplyr::filter(TaggedPitchType == pitch)
      }
    }
    
    return(player_data)
  }
  
  # Helper function to calculate metric for goal
  calculate_metric <- function(df, goal_num) {
    if (is.null(df) || nrow(df) == 0) return(NULL)
    
    goal_type <- input[[paste0("pp_goal", goal_num, "_type")]]
    
    if (goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      
      if (category == "Velocity") {
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   value = round(mean(RelSpeed, na.rm = TRUE), 1),
                   .groups = 'drop'
                 ) %>%
                 dplyr::distinct(Date, SessionType, .keep_all = TRUE) %>%
                 dplyr::arrange(Date))
      } else if (category == "Movement") {
        movement_types <- input[[paste0("pp_goal", goal_num, "_movement_type")]]
        
        if ("IVB" %in% movement_types && "HB" %in% movement_types) {
          # Calculate combined movement metric (could be magnitude)
          return(df %>%
                   dplyr::group_by(Date, SessionType) %>%
                   dplyr::summarise(
                     ivb = mean(InducedVertBreak, na.rm = TRUE),
                     hb = mean(HorzBreak, na.rm = TRUE),
                     value = round(sqrt(ivb^2 + hb^2), 1),
                     .groups = 'drop'
                   ) %>%
                   dplyr::distinct(Date, SessionType, .keep_all = TRUE) %>%
                   dplyr::arrange(Date))
        } else if ("IVB" %in% movement_types) {
          return(df %>%
                   dplyr::group_by(Date, SessionType) %>%
                   dplyr::summarise(
                     value = round(mean(InducedVertBreak, na.rm = TRUE), 1),
                     .groups = 'drop'
                   ) %>%
                   dplyr::distinct(Date, SessionType, .keep_all = TRUE) %>%
                   dplyr::arrange(Date))
        } else if ("HB" %in% movement_types) {
          return(df %>%
                   dplyr::group_by(Date, SessionType) %>%
                   dplyr::summarise(
                     value = round(mean(HorzBreak, na.rm = TRUE), 1),
                     .groups = 'drop'
                   ) %>%
                   dplyr::distinct(Date, SessionType, .keep_all = TRUE) %>%
                   dplyr::arrange(Date))
        }
      }
    } else if (goal_type == "Execution") {
      stat <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      
      # Calculate different execution stats using the same logic as pitching suite
      if (stat == "FPS%") {
        # FPS% = First pitch strikes in Live sessions / Total first pitches in Live sessions
        return(df %>%
                 dplyr::filter(SessionType == "Live") %>%
                 dplyr::group_by(Date) %>%
                 dplyr::summarise(
                   bf_live = sum(Balls == 0 & Strikes == 0, na.rm = TRUE),
                   fps_live = sum(Balls == 0 & Strikes == 0 &
                                    PitchCall %in% c("InPlay", "StrikeSwinging", "StrikeCalled", "FoulBallNotFieldable", "FoulBallFieldable"), 
                                  na.rm = TRUE),
                   value = ifelse(bf_live > 0, round(100 * fps_live / bf_live, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::mutate(SessionType = "Live") %>%
                 dplyr::select(Date, SessionType, value) %>%
                 dplyr::arrange(Date))
      } else if (stat == "Strike%") {
        # Strike% = All strikes / Total pitches
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   total_pitches = n(),
                   strikes = sum(PitchCall %in% c("StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "InPlay", "FoulBallFieldable"), na.rm = TRUE),
                   value = ifelse(total_pitches > 0, round(100 * strikes / total_pitches, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "InZone%") {
        # InZone% = Pitches in strike zone / Total pitches with location
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   total_located = sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight), na.rm = TRUE),
                   in_zone = sum(PlateLocSide >= -0.83 & PlateLocSide <= 0.83 & 
                                   PlateLocHeight >= 1.5 & PlateLocHeight <= 3.5, na.rm = TRUE),
                   value = ifelse(total_located > 0, round(100 * in_zone / total_located, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "Comp%") {
        # Comp% = Competitive pitches / Total pitches with location (competitive zone is larger than strike zone)
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   total_located = sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight), na.rm = TRUE),
                   competitive = sum(PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                                       PlateLocHeight >= (2.65-1.5) & PlateLocHeight <= (2.65+1.5), na.rm = TRUE),
                   value = ifelse(total_located > 0, round(100 * competitive / total_located, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "QP%") {
        # QP% = Share of pitches with QP+ >= 100 (using compute_qp_points)
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   qp_vals  = list(compute_qp_points(dplyr::cur_data_all())),
                   qp_count = {
                     vals <- unlist(qp_vals)
                     sum((vals * 200) >= 100, na.rm = TRUE)
                   },
                   total_pitches = dplyr::n(),
                   value = ifelse(total_pitches > 0, round(100 * qp_count / total_pitches, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::select(-qp_vals) %>%
                 dplyr::arrange(Date))
      } else if (stat == "Whiff%") {
        # Whiff% = Swinging strikes / Total swings
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   total_swings = sum(PitchCall %in% c("StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable", "InPlay"), na.rm = TRUE),
                   swinging_strikes = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
                   value = ifelse(total_swings > 0, round(100 * swinging_strikes / total_swings, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "CSW%") {
        # CSW% = Called Strikes + Whiffs / Total pitches
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   total_pitches = n(),
                   csw = sum(PitchCall %in% c("StrikeCalled", "StrikeSwinging"), na.rm = TRUE),
                   value = ifelse(total_pitches > 0, round(100 * csw / total_pitches, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "E+A%") {
        # E+A% = Early Advantage pitches in Live sessions / Total batters faced in Live
        return(df %>%
                 dplyr::filter(SessionType == "Live") %>%
                 dplyr::group_by(Date) %>%
                 dplyr::summarise(
                   bf_live = sum(Balls == 0 & Strikes == 0, na.rm = TRUE),
                   ea_live = sum((Balls == 0 & Strikes == 0 & PitchCall == "InPlay") |
                                   (Balls == 0 & Strikes == 1 & PitchCall %in% c("InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable")) |
                                   (Balls == 1 & Strikes == 0 & PitchCall == "InPlay") |
                                   (Balls == 1 & Strikes == 1 & PitchCall %in% c("InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable")),
                                 na.rm = TRUE),
                   value = ifelse(bf_live > 0, round(100 * ea_live / bf_live, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::mutate(SessionType = "Live") %>%
                 dplyr::select(Date, SessionType, value) %>%
                 dplyr::arrange(Date))
      } else if (stat == "K%") {
        # K% = Strikeouts in Live sessions / Total batters faced in Live
        return(df %>%
                 dplyr::filter(SessionType == "Live") %>%
                 dplyr::group_by(Date) %>%
                 dplyr::summarise(
                   bf_live = sum(Balls == 0 & Strikes == 0, na.rm = TRUE),
                   k_live = sum(KorBB == "Strikeout", na.rm = TRUE),
                   value = ifelse(bf_live > 0, round(100 * k_live / bf_live, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::mutate(SessionType = "Live") %>%
                 dplyr::select(Date, SessionType, value) %>%
                 dplyr::arrange(Date))
      } else if (stat == "BB%") {
        # BB% = Walks in Live sessions / Total batters faced in Live
        return(df %>%
                 dplyr::filter(SessionType == "Live") %>%
                 dplyr::group_by(Date) %>%
                 dplyr::summarise(
                   bf_live = sum(Balls == 0 & Strikes == 0, na.rm = TRUE),
                   bb_live = sum(KorBB == "Walk", na.rm = TRUE),
                   value = ifelse(bf_live > 0, round(100 * bb_live / bf_live, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::mutate(SessionType = "Live") %>%
                 dplyr::select(Date, SessionType, value) %>%
                 dplyr::arrange(Date))
      } else if (stat == "Ctrl+") {
        # Ctrl+ = Control scores * 100 (strike zone = 1.47, competitive zone = 0.73, outside = 0)
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   ctrl_score = mean(ifelse(
                     PlateLocSide >= -0.88 & PlateLocSide <= 0.88 &
                       PlateLocHeight >= 1.5 & PlateLocHeight <= 3.6, 1.47,
                     ifelse(
                       PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                         PlateLocHeight >= (2.65-1.5) & PlateLocHeight <= (2.65+1.5), 0.73, 0
                     )
                   ), na.rm = TRUE),
                   value = round(ctrl_score * 100, 1),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "QP+") {
        # QP+ = Quality of Pitch points * 200 (using compute_qp_points function)
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   qp_points = mean(compute_qp_points(dplyr::cur_data_all()), na.rm = TRUE),
                   value = round(qp_points * 200, 1),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else {
        # For other stats, return NULL
        return(NULL)
      }
    }
    
    return(NULL)
  }
  
  # Helper function to create plots
  create_pp_goal_plot <- function(goal_num) {
    df <- filter_goal_data(goal_num)
    if (is.null(df)) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No data available") +
               theme_void())
    }
    
    goal_type <- input[[paste0("pp_goal", goal_num, "_type")]]
    
    # Chart-view routing
    chart_view <- input[[paste0("pp_goal", goal_num, "_chart_view")]]
    if (goal_type == "Execution") {
      stat <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      if (!is.null(chart_view) && chart_view == "Heatmap" && !is.null(stat) && stat != "") {
        return(create_execution_heatmap(df, stat))
      } else if (!is.null(chart_view) && chart_view == "Pitch Map") {
        return(create_execution_pitch_map(df))
      }
    } else if (goal_type == "Stuff" && !is.null(chart_view)) {
      if (chart_view == "Pitch Map") {
        return(create_execution_pitch_map(df))
      } else if (chart_view == "Movement Plot") {
        return(create_pp_movement_plot(df, goal_num))
      }
    }
    
    # For all other cases, create trend chart
    metric_data <- calculate_metric(df, goal_num)
    if (is.null(metric_data) || nrow(metric_data) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No metric data available") +
               theme_void())
    }
    
    # Determine y-axis label
    y_label <- "Value"
    if (goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      if (category == "Velocity") {
        y_label <- "Velocity (mph)"
      } else if (category == "Movement") {
        movement_types <- input[[paste0("pp_goal", goal_num, "_movement_type")]]
        if (length(movement_types) == 1) {
          y_label <- paste(movement_types[1], "(inches)")
        } else {
          y_label <- "Movement Magnitude (inches)"
        }
      }
    } else if (goal_type == "Execution") {
      stat <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      y_label <- stat
    }
    
    # Get target information
    target_direction <- input[[paste0("pp_goal", goal_num, "_target_direction")]]
    target_value <- input[[paste0("pp_goal", goal_num, "_target_value")]]
    
    # Extract numeric value from target_value if it exists
    target_numeric <- NULL
    if (!is.null(target_value) && !is.null(target_direction) && 
        target_value != "" && target_direction != "") {
      # Extract numeric part from target_value (remove %, mph, etc.)
      target_clean <- gsub("[^0-9.-]", "", target_value)
      if (nzchar(target_clean)) {
        target_numeric <- as.numeric(target_clean)
      }
    }
    
    # Evenly spaced dates on x-axis (treat each date as a step)
    metric_data <- metric_data %>%
      dplyr::arrange(Date)
    unique_dates <- sort(unique(metric_data$Date))
    date_map <- setNames(seq_along(unique_dates), as.character(unique_dates))
    metric_data <- metric_data %>%
      dplyr::mutate(date_idx = date_map[as.character(Date)])
    
    # Create base plot with Live/Bullpen color coding
    p <- ggplot(metric_data, aes(x = date_idx, y = value, color = SessionType)) +
      geom_point(size = 2) +
      geom_line(aes(group = SessionType), size = 1) +
      scale_color_manual(values = c("Bullpen" = "black", "Live" = "red")) +
      scale_x_continuous(
        breaks = seq_along(unique_dates),
        labels = format(unique_dates, "%m/%d"),
        expand = expansion(mult = c(0.05, 0.05))
      )
    
    # Add target line if target is set and numeric
    if (!is.null(target_numeric) && is.finite(target_numeric)) {
      p <- p + geom_hline(yintercept = target_numeric, 
                          color = "black", 
                          linetype = "dashed", 
                          alpha = 0.6, 
                          size = 1.2)
    }
    
    # Determine chart title based on goal configuration
    chart_title <- "Goal Trend"
    if (goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      if (!is.null(category) && category != "") {
        if (category == "Velocity") {
          pitch <- input[[paste0("pp_goal", goal_num, "_velocity_pitch")]]
          if (!is.null(pitch) && pitch != "") {
            chart_title <- paste(pitch, "Velocity")
          } else {
            chart_title <- "Velocity"
          }
        } else if (category == "Movement") {
          pitch <- input[[paste0("pp_goal", goal_num, "_movement_pitch")]]
          movement <- input[[paste0("pp_goal", goal_num, "_movement_type")]]
          if (!is.null(pitch) && pitch != "" && !is.null(movement) && length(movement) > 0) {
            chart_title <- paste(pitch, paste(movement, collapse = " & "))
          } else {
            chart_title <- "Movement"
          }
        }
      }
    } else if (goal_type == "Execution") {
      stat <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      if (!is.null(stat) && stat != "") {
        chart_title <- stat
      } else {
        chart_title <- "Execution"
      }
    }
    
    p <- p + labs(
      title = chart_title,
      x = "Date",
      y = y_label,
      color = "Session Type"
    )
    
    dark_on <- isTRUE(input$dark_mode)
    p <- p +
      theme_minimal() +
      transparent_bg_theme +
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        panel.grid.minor = if (dark_on) element_blank() else NULL,
        panel.grid.major = if (dark_on) element_line(color = "gray40", linewidth = 0.3) else NULL
      )
    
    return(p)
  }
  
  # Helper function to create data tables
  create_pp_goal_table <- function(goal_num) {
    metric_data <- calculate_metric(filter_goal_data(goal_num), goal_num)
    if (is.null(metric_data) || nrow(metric_data) == 0) {
      return(data.frame(Date = character(0), Value = character(0)))
    }
    
    # Get the goal type and determine column name
    goal_type <- input[[paste0("pp_goal", goal_num, "_type")]]
    column_name <- "Value"
    
    if (goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      if (category == "Velocity") {
        column_name <- "Velocity"
      } else if (category == "Movement") {
        movement_types <- input[[paste0("pp_goal", goal_num, "_movement_type")]]
        if (length(movement_types) > 1) {
          column_name <- "Movement"
        } else if ("IVB" %in% movement_types) {
          column_name <- "IVB"
        } else if ("HB" %in% movement_types) {
          column_name <- "HB"
        }
      }
    } else if (goal_type == "Execution") {
      category <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      if (category == "FPS%") {
        column_name <- "FPS%"
      } else if (category == "Strike%") {
        column_name <- "Strike%"
      } else if (category == "InZone%") {
        column_name <- "InZone%"
      } else if (category == "Comp%") {
        column_name <- "Comp%"
      } else if (category == "Whiff%") {
        column_name <- "Whiff%"
      } else if (category == "CSW%") {
        column_name <- "CSW%"
      } else if (category == "E+A%") {
        column_name <- "E+A%"
      } else if (category == "K%") {
        column_name <- "K%"
      } else if (category == "BB%") {
        column_name <- "BB%"
      } else if (category == "QP+") {
        column_name <- "QP+"
      } else if (category == "Ctrl+") {
        column_name <- "Ctrl+"
      }
    }
    
    # Create table with date and formatted value
    table_data <- metric_data %>%
      dplyr::mutate(
        formatted_value = case_when(
          SessionType == "Bullpen" ~ paste0(value, " (B)"),
          SessionType == "Live" ~ paste0(value, " (L)"),
          TRUE ~ as.character(value)
        ),
        Date = format(Date, "%m/%d")
      ) %>%
      dplyr::select(Date, formatted_value) %>%
      dplyr::arrange(desc(as.Date(paste0("2025/", Date), format = "%Y/%m/%d")))
    
    # Set column names
    colnames(table_data) <- c("Date", column_name)
    
    return(table_data)
  }
  
  # Goal plot renders (girafe)
  output$pp_goal1_plot <- ggiraph::renderGirafe({
    p <- create_pp_goal_plot(1)
    if (inherits(p, "girafe")) return(p)
    if (inherits(p, "ggplot")) return(girafe_transparent(ggobj = p, options = list(ggiraph::opts_sizing(rescale = TRUE))))
    NULL
  })
  
  output$pp_goal2_plot <- ggiraph::renderGirafe({
    p <- create_pp_goal_plot(2)
    if (inherits(p, "girafe")) return(p)
    if (inherits(p, "ggplot")) return(girafe_transparent(ggobj = p, options = list(ggiraph::opts_sizing(rescale = TRUE))))
    NULL
  })
  
  output$pp_goal3_plot <- ggiraph::renderGirafe({
    p <- create_pp_goal_plot(3)
    if (inherits(p, "girafe")) return(p)
    if (inherits(p, "ggplot")) return(girafe_transparent(ggobj = p, options = list(ggiraph::opts_sizing(rescale = TRUE))))
    NULL
  })
  
  # Goal table renders
  output$pp_goal1_table <- DT::renderDataTable({
    table_data <- create_pp_goal_table(1)
    if (nrow(table_data) == 0) return(table_data)
    
    dt <- DT::datatable(
      table_data,
      options = list(
        pageLength = 5,
        searching = FALSE,
        info = FALSE,
        lengthChange = FALSE,
        ordering = FALSE,
        columnDefs = list(list(className = 'dt-center', targets = '_all'))
      ), 
      rownames = FALSE
    )
    
    # Apply color formatting if data exists
    if (ncol(table_data) >= 2) {
      column_name <- colnames(table_data)[2]
      bullpen_values <- table_data[[column_name]][grepl("\\(B\\)", table_data[[column_name]])]
      live_values <- table_data[[column_name]][grepl("\\(L\\)", table_data[[column_name]])]
      
      if (length(bullpen_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(bullpen_values, rep("black", length(bullpen_values)))
        )
      }
      
      if (length(live_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(live_values, rep("red", length(live_values)))
        )
      }
    }
    
    return(dt)
  })
  
  output$pp_goal2_table <- DT::renderDataTable({
    table_data <- create_pp_goal_table(2)
    if (nrow(table_data) == 0) return(table_data)
    
    dt <- DT::datatable(
      table_data,
      options = list(
        pageLength = 5,
        searching = FALSE,
        info = FALSE,
        lengthChange = FALSE,
        ordering = FALSE,
        columnDefs = list(list(className = 'dt-center', targets = '_all'))
      ), 
      rownames = FALSE
    )
    
    # Apply color formatting if data exists
    if (ncol(table_data) >= 2) {
      column_name <- colnames(table_data)[2]
      bullpen_values <- table_data[[column_name]][grepl("\\(B\\)", table_data[[column_name]])]
      live_values <- table_data[[column_name]][grepl("\\(L\\)", table_data[[column_name]])]
      
      if (length(bullpen_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(bullpen_values, rep("black", length(bullpen_values)))
        )
      }
      
      if (length(live_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(live_values, rep("red", length(live_values)))
        )
      }
    }
    
    return(dt)
  })
  
  output$pp_goal3_table <- DT::renderDataTable({
    table_data <- create_pp_goal_table(3)
    if (nrow(table_data) == 0) return(table_data)
    
    dt <- DT::datatable(
      table_data,
      options = list(
        pageLength = 5,
        searching = FALSE,
        info = FALSE,
        lengthChange = FALSE,
        ordering = FALSE,
        columnDefs = list(list(className = 'dt-center', targets = '_all'))
      ), 
      rownames = FALSE
    )
    
    # Apply color formatting if data exists
    if (ncol(table_data) >= 2) {
      column_name <- colnames(table_data)[2]
      bullpen_values <- table_data[[column_name]][grepl("\\(B\\)", table_data[[column_name]])]
      live_values <- table_data[[column_name]][grepl("\\(L\\)", table_data[[column_name]])]
      
      if (length(bullpen_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(bullpen_values, rep("black", length(bullpen_values)))
        )
      }
      
      if (length(live_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(live_values, rep("red", length(live_values)))
        )
      }
    }
    
    return(dt)
  })
  
  # ============== END PLAYER PLANS SERVER LOGIC ==============
  
  
  # ---- Stuff+ Calculator (uses original compute_stuff_simple) ----
  # HB_adj display helper (hand-agnostic: arm-side positive)
  hb_adj_text <- function(hand, hb) {
    if (is.null(hand) || is.null(hb) || is.na(hand) || is.na(hb)) return("")
    adj <- if (hand == "Left") hb else -hb
    sprintf("%.1f", adj)
  }
  
  # Build a tiny df and call existing compute_stuff_simple() exactly as elsewhere
  stuff_calc_df <- function(pitch, hand, velo, ivb, hb, rh, level, base_type, base_vel, base_ivb, base_hb) {
    df <- data.frame(
      TaggedPitchType    = as.character(pitch),
      PitcherThrows      = as.character(hand),
      RelSpeed           = as.numeric(velo),
      InducedVertBreak   = as.numeric(ivb),
      HorzBreak          = as.numeric(hb),
      RelHeight          = as.numeric(rh),
      stringsAsFactors   = FALSE
    )
    # If off-speed, include a base FB/SI row so your function can derive context
    if (!(pitch %in% c("Fastball","Sinker"))) {
      df <- rbind(df, data.frame(
        TaggedPitchType    = as.character(base_type),
        PitcherThrows      = as.character(hand),
        RelSpeed           = as.numeric(base_vel),
        InducedVertBreak   = as.numeric(base_ivb),
        HorzBreak          = as.numeric(base_hb),
        RelHeight          = as.numeric(rh),
        stringsAsFactors   = FALSE
      ))
    }
    base_for <- if (pitch %in% c("Fastball","Sinker")) pitch else base_type
    out <- tryCatch({
      compute_stuff_simple(df, base_type = base_for, level = level)
    }, error = function(e) {
      df$`Stuff+` <- NA_real_
      df
    })
    as.numeric(out$`Stuff+`[1])
  }
  
  # Pitch A
  output$calc1_stuff <- renderText({
    val <- stuff_calc_df(
      input$calc1_pitch, input$calc1_hand, input$calc1_vel, input$calc1_ivb, input$calc1_hb,
      input$calc1_relheight, input$calc1_level,
      if (!isTruthy(input$calc1_base_type)) "Fastball" else input$calc1_base_type,
      if (!isTruthy(input$calc1_base_vel)) input$calc1_vel else input$calc1_base_vel,
      if (!isTruthy(input$calc1_base_ivb)) input$calc1_ivb else input$calc1_base_ivb,
      if (!isTruthy(input$calc1_base_hb))  input$calc1_hb  else input$calc1_base_hb
    )
    ifelse(is.finite(val), sprintf("Stuff+: %.1f", val), "Stuff+: —")
  })
  output$calc1_hb_adj <- renderText(hb_adj_text(input$calc1_hand, input$calc1_hb))
  
  # Pitch B
  output$calc2_stuff <- renderText({
    val <- stuff_calc_df(
      input$calc2_pitch, input$calc2_hand, input$calc2_vel, input$calc2_ivb, input$calc2_hb,
      input$calc2_relheight, input$calc2_level,
      if (!isTruthy(input$calc2_base_type)) "Fastball" else input$calc2_base_type,
      if (!isTruthy(input$calc2_base_vel)) input$calc2_vel else input$calc2_base_vel,
      if (!isTruthy(input$calc2_base_ivb)) input$calc2_ivb else input$calc2_base_ivb,
      if (!isTruthy(input$calc2_base_hb))  input$calc2_hb  else input$calc2_base_hb
    )
    ifelse(is.finite(val), sprintf("Stuff+: %.1f", val), "Stuff+: —")
  })
  output$calc2_hb_adj <- renderText(hb_adj_text(input$calc2_hand, input$calc2_hb))
  
  # ===== QP LOCATIONS SERVER LOGIC =====
  
  # Helper function to get pitcher handedness
  get_pitcher_handedness <- reactive({
    tryCatch({
      if (is.null(input$pitcher) || input$pitcher == "All") {
        # If "All" is selected, use the hand filter if it's not "All"
        if (!is.null(input$hand) && input$hand != "All") {
          return(input$hand)
        } else {
          return(NULL)  # No handedness available
        }
      } else {
        # Get the specific pitcher's handedness from the data
        df <- filtered_data()
        if (is.null(df) || nrow(df) == 0) return(NULL)
        
        pitcher_data <- df %>% 
          dplyr::filter(Pitcher == input$pitcher) %>%
          dplyr::slice(1)
        
        if (nrow(pitcher_data) > 0) {
          hand <- as.character(pitcher_data$PitcherThrows[1])
          if (!is.na(hand) && hand %in% c("Left", "Right")) {
            return(hand)
          }
        }
        
        # Fallback to hand filter if specific pitcher handedness not found
        if (!is.null(input$hand) && input$hand != "All") {
          return(input$hand)
        } else {
          return(NULL)
        }
      }
    }, error = function(e) {
      return(NULL)
    })
  })
  
  # Helper function to check if QP Locations should be shown
  should_show_qp_locations <- reactive({
    tryCatch({
      pitcher_hand <- get_pitcher_handedness()
      batter_hand <- input$batterSide
      
      # Need both pitcher and batter handedness to be non-"All"
      !is.null(pitcher_hand) && 
        !is.null(batter_hand) && 
        batter_hand != "All"
    }, error = function(e) {
      return(FALSE)
    })
  })
  
  # QP Locations message and content
  output$qpLocationsMessage <- renderUI({
    if (!should_show_qp_locations()) {
      div(style = "text-align: center; padding: 100px 20px; color: #999;",
          h4("QP+ Locations requires handedness selection"),
          p("Please select both pitcher handedness and batter handedness to view QP+ location charts."),
          if (is.null(get_pitcher_handedness())) {
            p("→ Pitcher handedness: Select a specific pitcher or set 'Pitcher Hand' filter")
          },
          if (is.null(input$batterSide) || input$batterSide == "All") {
            p("→ Batter handedness: Set 'Batter Hand' filter to 'Left' or 'Right'")
          }
      )
    } else {
      # Show the main content when conditions are met
      div(
        div(style = "margin-bottom: 20px;",
            h4("Behind Counts", style = "text-align: center; font-weight: bold;"),
            ggiraph::girafeOutput("qpLocationsBehind", height = "350px")
        ),
        div(style = "margin-bottom: 20px;",
            h4("Even Counts", style = "text-align: center; font-weight: bold;"),
            ggiraph::girafeOutput("qpLocationsEven", height = "350px")
        ),
        div(style = "margin-bottom: 20px;",
            h4("Ahead Counts", style = "text-align: center; font-weight: bold;"),
            ggiraph::girafeOutput("qpLocationsAhead", height = "350px")
        )
      )
    }
  })
  
  # CSS for QP Locations tooltips
  tooltip_css <- "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
  
  # QP Locations Behind plot
  output$qpLocationsBehind <- ggiraph::renderGirafe({
    tryCatch({
      if (!should_show_qp_locations()) return(NULL)
      
      df <- filtered_data()
      if (!nrow(df)) return(NULL)
      
      pitcher_hand <- get_pitcher_handedness()
      batter_hand <- input$batterSide
      
      p <- create_qp_locations_plot(df, "Behind", pitcher_hand, batter_hand)
      
      girafe_transparent(
        ggobj = p,
        width_svg = 12, height_svg = 4,
        options = list(
          ggiraph::opts_hover_inv(css = "opacity:0.1;"),
          ggiraph::opts_hover(css = "stroke-width:2;"),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css,
                                opacity = 0.9
          )
        )
      )
    }, error = function(e) {
      message("Error in qpLocationsBehind: ", e$message)
      return(NULL)
    })
  })
  
  # QP Locations Even plot
  output$qpLocationsEven <- ggiraph::renderGirafe({
    tryCatch({
      if (!should_show_qp_locations()) return(NULL)
      
      df <- filtered_data()
      if (!nrow(df)) return(NULL)
      
      pitcher_hand <- get_pitcher_handedness()
      batter_hand <- input$batterSide
      
      p <- create_qp_locations_plot(df, "Even", pitcher_hand, batter_hand)
      
      girafe_transparent(
        ggobj = p,
        width_svg = 12, height_svg = 4,
        options = list(
          ggiraph::opts_hover_inv(css = "opacity:0.1;"),
          ggiraph::opts_hover(css = "stroke-width:2;"),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css,
                                opacity = 0.9
          )
        )
      )
    }, error = function(e) {
      message("Error in qpLocationsEven: ", e$message)
      return(NULL)
    })
  })
  
  # QP Locations Ahead plot
  output$qpLocationsAhead <- ggiraph::renderGirafe({
    tryCatch({
      if (!should_show_qp_locations()) return(NULL)
      
      df <- filtered_data()
      if (!nrow(df)) return(NULL)
      
      pitcher_hand <- get_pitcher_handedness()
      batter_hand <- input$batterSide
      
      p <- create_qp_locations_plot(df, "Ahead", pitcher_hand, batter_hand)
      
      girafe_transparent(
        ggobj = p,
        width_svg = 12, height_svg = 4,
        options = list(
          ggiraph::opts_hover_inv(css = "opacity:0.1;"),
          ggiraph::opts_hover(css = "stroke-width:2;"),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css,
                                opacity = 0.9
          )
        )
      )
    }, error = function(e) {
      message("Error in qpLocationsAhead: ", e$message)
      return(NULL)
    })
  })
  
  # QP Locations Pitch Type Color Legend
  output$qpPitchTypeColors <- renderUI({
    tryCatch({
      if (!should_show_qp_locations()) {
        return(div(style = "font-size: 12px; color: #999;", "Select data to see pitch types"))
      }
      
      df <- filtered_data()
      if (!nrow(df)) {
        return(div(style = "font-size: 12px; color: #999;", "No data available"))
      }
      
      # Get unique pitch types in the current data
      pitch_types <- sort(unique(df$TaggedPitchType))
      pitch_types <- pitch_types[!is.na(pitch_types)]
      
      if (length(pitch_types) == 0) {
        return(div(style = "font-size: 12px; color: #999;", "No pitch types found"))
      }
      
      # Create legend entries for each pitch type with its color
      legend_items <- lapply(pitch_types, function(pt) {
        color <- all_colors[[as.character(pt)]]
        if (is.null(color)) color <- "gray"
        
        div(style = "margin-bottom: 5px;",
            span(style = paste0("display: inline-block; width: 12px; height: 12px; background-color: ", color, "; border-radius: 50%; margin-right: 8px;")),
            pt
        )
      })
      
      div(style = "font-size: 12px;", legend_items)
      
    }, error = function(e) {
      div(style = "font-size: 12px; color: #999;", "Error loading pitch types")
    })
  })
  
  # Custom Reports module
  custom_reports_server("creports")
}
# ---------- Run ----------
shinyApp(ui=ui, server=server)# app.R
# Shiny pitching report with per-player privacy + admin view + customized Stuff+ metric per pitch type

# Optional team scoping: blank = no filter
if (!exists("TEAM_CODE", inherits = TRUE)) TEAM_CODE <- ""

# School scoping helpers
GLOBAL_SCOPE <- "GLOBAL"
current_school <- function() {
  sc <- Sys.getenv("TEAM_CODE", unset = TEAM_CODE)
  if (is.null(sc) || !nzchar(sc)) sc <- TEAM_CODE
  if (is.null(sc) || !nzchar(sc)) sc <- "OSU"
  toupper(sc)
}
allowed_school_codes <- function() unique(c(current_school(), GLOBAL_SCOPE))

# Load per-school configuration overrides (keeps app.R shared).
config_path <- file.path("config", "school_config.R")
if (file.exists(config_path)) {
  source(config_path)
}
if (!exists("school_config")) school_config <- list()

school_setting <- function(name, default = NULL) {
  if (!is.null(school_config[[name]])) return(school_config[[name]])
  default
}

# School-scoped overrides
TEAM_CODE <- school_setting("team_code", TEAM_CODE)
if (!nzchar(TEAM_CODE)) TEAM_CODE <- "OSU"
TEAM_CHOICES <- c("All" = "All",
                  TEAM_CODE = TEAM_CODE,
                  "Opponents" = "Opponents",
                  "Campers" = "Campers")

default_colors <- list(
  primary = "#0a2240",
  accent = "#e35205",
  accent_secondary = "#ff8c1a",
  background = "#f5f7fa",
  background_secondary = "#e8ecf1"
)
user_colors <- school_setting("colors", list())
school_colors <- modifyList(default_colors, user_colors)
accent_color <- school_colors$accent
accent_secondary_color <- school_colors$accent_secondary
if (is.null(accent_secondary_color) || !nzchar(accent_secondary_color)) {
  accent_secondary_color <- accent_color
}
background_color <- school_colors$background
if (is.null(background_color) || !nzchar(background_color)) {
  background_color <- "#f5f7fa"
}
background_secondary_color <- school_colors$background_secondary
if (is.null(background_secondary_color) || !nzchar(background_secondary_color)) {
  background_secondary_color <- background_color
}

school_logo <- school_setting("logo", "PCUlogo.png")
school_extra <- school_setting("extra", list())
school_display_name <- school_extra$school_name
if (is.null(school_display_name) || !nzchar(school_display_name)) {
  school_display_name <- TEAM_CODE
}

coach_emails <- school_setting("coaches_emails", c("coach@example.com"))
default_notes_api <- list(base_url = "", token = "")
notes_api <- modifyList(default_notes_api, school_setting("notes_api", list()))
NOTES_API_URL <- notes_api$base_url
NOTES_API_TOKEN <- notes_api$token

# ---- Heatmap constants and functions for Player Plans ----
HEAT_BINS <- 10  # Increased from 6 for smoother gradients like TruMedia
HEAT_EV_THRESHOLD <- 90

# Zone boundaries
ZONE_LEFT <- -0.83
ZONE_RIGHT <- 0.83
ZONE_BOTTOM <- 1.5
ZONE_TOP <- 3.5

# Frequency (keep multi-color)
heat_pal_freq <- function(n = HEAT_BINS) colorRampPalette(
  c("white","pink","red")
)(n)

# All other heat maps → white→red only
heat_pal_red  <- function(n = HEAT_BINS) colorRampPalette(c("white","pink","red"))(n)

# Blue → Yellow → Red palette for rate-based stats (cold to hot)
# White at start ensures no-data areas show white background
heat_pal_bwr <- function(n = HEAT_BINS) {
  colorRampPalette(c("white", "#4575b4", "#91bfdb", "#abd9e9", "#fee090", "#fc8d59", "#d73027"))(n)
}

# Blue → Yellow → Red WITHOUT white (for rate stats like Whiff, GB, Contact, Swing)
heat_pal_bwr_no_white <- function(n = HEAT_BINS) {
  colorRampPalette(c("#4575b4", "#91bfdb", "#abd9e9", "#fee090", "#fc8d59", "#d73027"))(n)
}

# Blue → Red with minimal yellow (for RV heatmap where we need better contrast near 0)
# Order: Red (negative/good for pitcher) to Blue (positive/good for hitter)
heat_pal_br_rv <- function(n = HEAT_BINS) {
  colorRampPalette(c("#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"))(n)
}

# Reversed (for stats where lower is better)
heat_pal_rwb <- function(n = HEAT_BINS) {
  colorRampPalette(c("#d73027", "#fc8d59", "#fee090", "#abd9e9", "#91bfdb", "#4575b4", "white"))(n)
}

# Reversed without white (red to blue, for RV where we want red=good/high, blue=bad/low)
heat_pal_rbw_no_white <- function(n = HEAT_BINS) {
  colorRampPalette(c("#d73027", "#fc8d59", "#fee090", "#abd9e9", "#91bfdb", "#4575b4"))(n)
}

# Keep only terminal plate-appearance pitches for wOBA (final pitch of the PA)
terminal_for_woba <- function(df) {
  korbb <- if ("KorBB" %in% names(df)) df$KorBB else NA_character_
  play  <- if ("PlayResult" %in% names(df)) df$PlayResult else NA_character_
  pc    <- if ("PitchCall" %in% names(df)) df$PitchCall else NA_character_
  
  allowed_pr <- c(
    "Single","Double","Triple","HomeRun","Error",
    "Walk","IntentionalWalk","HitByPitch",
    "Strikeout","StrikeoutSwinging","StrikeoutLooking","Sacrifice"
  )
  
  (!is.na(play)  & play  %in% allowed_pr) |
    (!is.na(korbb) & korbb %in% c("Strikeout","Walk")) |
    (!is.na(pc)   & pc    == "HitByPitch")
}

# Draw heatmap function with optional color scale legend
draw_heat <- function(grid, bins = HEAT_BINS, pal_fun = heat_pal_red,
                      title = NULL, mark_max = TRUE, breaks = NULL,
                      show_scale = FALSE, scale_label = NULL, scale_limits = NULL,
                      scale_breaks = NULL, scale_labels = NULL) {
  if (!nrow(grid)) return(ggplot() + theme_void())
  dark_on <- FALSE
  try({
    dom <- shiny::getDefaultReactiveDomain()
    if (!is.null(dom) && !is.null(dom$input$dark_mode)) dark_on <- isTRUE(dom$input$dark_mode)
  }, silent = TRUE)
  line_col <- if (dark_on) "#ffffff" else "black"
  bg_transparent <- element_rect(fill = "transparent", color = NA)
  
  home <- data.frame(
    x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
    y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
  )
  sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
  
  peak_df <- NULL
  if (mark_max) {
    i <- which.max(grid$z)
    if (length(i) && is.finite(grid$z[i])) {
      peak_df <- data.frame(px = grid$x[i], py = grid$y[i])
    }
  }
  
  n_bins <- if (is.null(breaks)) bins else max(1, length(breaks) - 1)
  
  # Main heatmap plot
  p_heat <- ggplot(grid, aes(x, y, z = z)) +
    {
      if (is.null(breaks))
        geom_contour_filled(aes(fill = after_stat(level)), bins = bins, show.legend = FALSE)
      else
        geom_contour_filled(aes(fill = after_stat(level)), breaks = breaks, show.legend = FALSE)
    } +
    scale_fill_manual(values = pal_fun(n_bins), guide = "none") +
    geom_polygon(data = home, aes(x, y), fill = NA, color = line_col, inherit.aes = FALSE) +
    geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
              fill = NA, color = line_col, inherit.aes = FALSE) +
    { if (!is.null(peak_df))
      geom_point(data = peak_df, aes(x = px, y = py), inherit.aes = FALSE,
                 size = 3.8, shape = 21, fill = "red", color = "black", stroke = 0.5)
    } +
    coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
    theme_void() + 
    theme(legend.position = "none",
          plot.title = element_text(face = "bold", hjust = 0.5),
          plot.background = bg_transparent,
          panel.background = bg_transparent) +
    labs(title = title)
  
  # If show_scale, add gradient bar on top
  if (show_scale && !is.null(scale_limits)) {
    # Create scale bar data matching strike zone width
    sz_width <- ZONE_RIGHT - ZONE_LEFT  # ~1.66 feet
    scale_data <- data.frame(
      x = seq(scale_limits[1], scale_limits[2], length.out = 200),
      y = 1,
      z = seq(scale_limits[1], scale_limits[2], length.out = 200)
    )
    
    scale_breaks_final <- if (!is.null(scale_breaks)) {
      scale_breaks
    } else if (!is.null(scale_limits) && length(scale_limits) >= 2) {
      c(scale_limits[1], mean(scale_limits), scale_limits[length(scale_limits)])
    } else if (is.null(breaks)) {
      pretty(scale_limits, n = 5)
    } else {
      fin <- breaks[is.finite(breaks)]
      fin[c(1, round(length(fin) / 2), length(fin))]
    }
    
    scale_labels_final <- scale_labels
    if (identical(scale_label, "Pitch Frequency") && length(scale_limits) >= 2) {
      scale_breaks_final <- scale_limits[c(1, length(scale_limits))]
      scale_labels_final <- c("Least", "Most")
    }
    
    p_scale <- ggplot(scale_data, aes(x = z, y = y, fill = z)) +
      geom_tile(width = (scale_limits[2] - scale_limits[1]) / 200, height = 1) +
      scale_fill_gradientn(colors = pal_fun(100), limits = scale_limits) +
      scale_x_continuous(
        breaks = scale_breaks_final,
        labels = if (is.null(scale_labels_final)) ggplot2::waiver() else scale_labels_final,
        limits = scale_limits,
        expand = c(0, 0)
      ) +
      coord_cartesian(xlim = scale_limits, ylim = c(0.5, 1.5)) +
      theme_void() +
      theme(
        legend.position = "none",
        axis.text.x = element_text(size = 10, face = "bold", margin = margin(t = 3)),
        axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 8)),
        plot.margin = margin(5, 0, 10, 0),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.background = element_rect(fill = "transparent", color = NA),
        aspect.ratio = 0.15  # Make scale bar much narrower
      ) +
      labs(x = scale_label)
    
    # Combine scale bar on top of heatmap with tighter layout
    return(p_scale / p_heat + plot_layout(heights = c(0.08, 1), widths = c(sz_width)))
  }
  
  p_heat
}

# Draw BINNED heatmap using geom_tile (for sparse rate data like whiff rate)
# This shows actual bins where data exists instead of interpolating
draw_heat_binned <- function(grid, bin_size = 0.4, pal_fun = heat_pal_red,
                             title = NULL, breaks = NULL,
                             show_scale = FALSE, scale_label = NULL, scale_limits = NULL) {
  if (!nrow(grid)) return(ggplot() + theme_void())
  
  home <- data.frame(
    x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
    y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
  )
  sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
  
  # Use geom_tile to show actual bins
  p_heat <- ggplot(grid, aes(x = x, y = y, fill = z)) +
    geom_tile(width = bin_size, height = bin_size, color = NA) +
    scale_fill_gradientn(colors = pal_fun(100), limits = scale_limits, na.value = "white") +
    geom_polygon(data = home, aes(x, y), fill = NA, color = "black", inherit.aes = FALSE) +
    geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
              fill = NA, color = "black", inherit.aes = FALSE) +
    coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
    theme_void() + 
    theme(legend.position = "none",
          plot.title = element_text(face = "bold", hjust = 0.5),
          plot.background = element_rect(fill = "transparent", color = NA),
          panel.background = element_rect(fill = "transparent", color = NA)) +
    labs(title = title)
  
  # If show_scale, add gradient bar on top
  if (show_scale && !is.null(scale_limits)) {
    sz_width <- ZONE_RIGHT - ZONE_LEFT
    scale_data <- data.frame(
      x = seq(scale_limits[1], scale_limits[2], length.out = 200),
      y = 1,
      z = seq(scale_limits[1], scale_limits[2], length.out = 200)
    )
    
    p_scale <- ggplot(scale_data, aes(x = z, y = y, fill = z)) +
      geom_tile(width = (scale_limits[2] - scale_limits[1]) / 200, height = 1) +
      scale_fill_gradientn(colors = pal_fun(100), limits = scale_limits) +
      scale_x_continuous(
        breaks = {
          if (!is.null(scale_limits) && length(scale_limits) >= 2) {
            c(scale_limits[1], mean(scale_limits), scale_limits[length(scale_limits)])
          } else if (is.null(breaks)) {
            pretty(scale_limits, n = 5)
          } else {
            fin <- breaks[is.finite(breaks)]
            fin[c(1, round(length(fin) / 2), length(fin))]
          }
        },
        limits = scale_limits,
        expand = c(0, 0)
      ) +
      coord_cartesian(xlim = scale_limits, ylim = c(0.5, 1.5)) +
      theme_void() +
      theme(
        legend.position = "none",
        axis.text.x = element_text(size = 10, face = "bold", margin = margin(t = 3)),
        axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 8)),
        plot.margin = margin(5, 0, 10, 0),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.background = element_rect(fill = "transparent", color = NA),
        aspect.ratio = 0.15
      ) +
      labs(x = scale_label)
    
    return(p_scale / p_heat + plot_layout(heights = c(0.08, 1), widths = c(sz_width)))
  }
  
  p_heat
}

# Global helper functions for heatmap generation (used across all suites)

# Helper for 2D KDE grid
make_kde_grid <- function(x, y, lims = c(-2.5,2.5,0,4.5), n = 200, h = NULL) {
  ok <- is.finite(x) & is.finite(y)
  x <- x[ok]; y <- y[ok]
  if (length(x) < 2 || length(unique(x)) < 2 || length(unique(y)) < 2) {
    return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
  }
  
  # Use adaptive bandwidth based on sample size and spread
  if (is.null(h)) {
    n_pts <- length(x)
    x_sd <- sd(x)
    y_sd <- sd(y)
    h_x <- x_sd * (n_pts^(-1/6)) * 1.2
    h_y <- y_sd * (n_pts^(-1/6)) * 1.2
    h <- c(h_x, h_y)
  }
  
  d <- MASS::kde2d(x, y, n = n, lims = lims, h = h)
  expand.grid(x = d$x, y = d$y) |> transform(z = as.vector(d$z))
}

# Helper for RV heatmap - uses same KDE as Frequency but overlays run values
# This ensures every pitch is plotted just like Frequency, with colors based on RV
make_kde_rv_grid <- function(x, y, rv_values,
                             lims = c(-2.5, 2.5, 0, 4.5),
                             n = 200, h = NULL) {
  ok <- is.finite(x) & is.finite(y) & is.finite(rv_values)
  x <- x[ok]; y <- y[ok]; rv_values <- rv_values[ok]
  
  # Handle no data case
  if (length(x) == 0) {
    return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
  }
  
  # Handle single pitch case - show a small blob
  if (length(x) == 1) {
    grid <- expand.grid(
      x = seq(lims[1], lims[2], length.out = n),
      y = seq(lims[3], lims[4], length.out = n)
    )
    # Calculate distance from the single point
    dx <- grid$x - x[1]
    dy <- grid$y - y[1]
    dist <- sqrt(dx^2 + dy^2)
    # Create a small blob around the single pitch
    grid$z <- ifelse(dist < 0.3, rv_values[1], 0)
    return(grid[grid$z != 0, c("x", "y", "z")])
  }
  
  # Check for variance - if all x or y are nearly identical, use minimum bandwidth
  x_sd <- sd(x)
  y_sd <- sd(y)
  
  if (x_sd < 0.01) x_sd <- 0.1  # Minimum bandwidth for x
  if (y_sd < 0.01) y_sd <- 0.1  # Minimum bandwidth for y
  
  # Match frequency bandwidth behavior
  if (is.null(h)) {
    n_pts <- length(x)
    h_x <- x_sd * (n_pts^(-1/6)) * 0.6
    h_y <- y_sd * (n_pts^(-1/6)) * 0.6
    h <- c(h_x, h_y)
  }
  
  # Use MASS::kde2d for the density surface (same as Frequency)
  d <- MASS::kde2d(x, y, n = n, lims = lims, h = h)
  grid <- expand.grid(x = d$x, y = d$y)
  grid$density <- as.vector(d$z)
  
  # For each grid point, calculate weighted average RV based on nearby pitches
  # This preserves the frequency-like coverage while showing RV values
  grid$z <- vapply(seq_len(nrow(grid)), function(i) {
    dx <- (x - grid$x[i]) / h[1]
    dy <- (y - grid$y[i]) / h[2]
    dist_sq <- dx^2 + dy^2
    weights <- exp(-0.5 * dist_sq)
    w_sum <- sum(weights)
    if (!is.finite(w_sum) || w_sum < 1e-8) {
      return(0)
    }
    weighted.mean(rv_values, weights, na.rm = TRUE)
  }, numeric(1))
  
  # Only keep grid points where there's actual density (like Frequency does)
  # This ensures the shape matches Frequency exactly
  max_density <- max(grid$density, na.rm = TRUE)
  if (max_density > 0) {
    # Keep points with at least 0.1% of max density
    grid <- grid[grid$density > (max_density * 0.001), ]
  }
  
  # Clean up and return just x, y, z
  grid <- grid[, c("x", "y", "z")]
  grid$z[!is.finite(grid$z)] <- 0
  
  grid
}

# KDE weighted-mean grid (matches Frequency KDE style)
make_kde_mean_grid <- function(x, y, values,
                               lims = c(-2.5, 2.5, 0, 4.5),
                               n = 200, h = NULL) {
  ok <- is.finite(x) & is.finite(y) & is.finite(values)
  x <- x[ok]; y <- y[ok]; values <- values[ok]
  if (length(x) < 2 || length(unique(x)) < 2 || length(unique(y)) < 2) {
    return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
  }
  
  # Adaptive bandwidth (same approach as make_kde_grid)
  if (is.null(h)) {
    n_pts <- length(x)
    x_sd <- sd(x); y_sd <- sd(y)
    h_x <- x_sd * (n_pts^(-1/6)) * 1.2
    h_y <- y_sd * (n_pts^(-1/6)) * 1.2
    h <- c(h_x, h_y)
  }
  
  d <- MASS::kde2d(x, y, n = n, lims = lims, h = h)
  grid <- expand.grid(x = d$x, y = d$y)
  grid$density <- as.vector(d$z)
  
  # Weighted mean at each grid point
  grid$z <- vapply(seq_len(nrow(grid)), function(i) {
    dx <- (x - grid$x[i]) / h[1]
    dy <- (y - grid$y[i]) / h[2]
    w  <- exp(-0.5 * (dx^2 + dy^2))
    ws <- sum(w)
    if (!is.finite(ws) || ws < 1e-8) return(NA_real_)
    sum(w * values, na.rm = TRUE) / ws
  }, numeric(1))
  
  # Density mask (same threshold as RV grid)
  max_den <- max(grid$density, na.rm = TRUE)
  if (max_den > 0) {
    grid <- grid[grid$density > (max_den * 0.001), ]
  }
  
  grid <- grid[, c("x", "y", "z")]
  grid$z[!is.finite(grid$z)] <- 0
  grid
}

# Shared heatmap stat renderer (Pitching-style) used across suites
render_heatmap_stat <- function(df, stat) {
  if (!nrow(df)) return(ggplot() + theme_void())
  if (identical(stat, "Exit Velocity")) stat <- "EV"
  
  if (stat == "Frequency") {
    grid <- make_kde_grid(df$PlateLocSide, df$PlateLocHeight, n = 200)
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
    return(draw_heat(
      grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
      show_scale = TRUE, scale_label = "Pitch Frequency",
      scale_limits = c(0, 80)
    ))
  }
  
  df <- df %>% dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
  if (!nrow(df)) return(ggplot() + theme_void())
  
  if (stat == "Whiff Rate") {
    swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                      "FoulBallNotFieldable", "InPlay")
    swing_mask  <- df$PitchCall %in% swing_events
    val <- ifelse(swing_mask, ifelse(df$PitchCall == "StrikeSwinging", 1, 0), NA_real_)
    grid <- make_kde_mean_grid(df$PlateLocSide, df$PlateLocHeight, val)
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- pmax(grid$z * 100, 0)
    breaks <- c(seq(0, 50, length.out = HEAT_BINS + 1), Inf)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "Whiff Rate %",
                     scale_limits = c(0, 50)))
  }
  
  if (stat == "GB Rate") {
    df_bip <- df %>%
      dplyr::filter(SessionType == "Live",
                    PitchCall == "InPlay",
                    !is.na(TaggedHitType))
    if (nrow(df_bip) < 3) return(ggplot() + theme_void() + 
                                   labs(title = "Insufficient Live BIP data"))
    val <- ifelse(df_bip$TaggedHitType == "GroundBall", 1, 0)
    grid <- make_kde_mean_grid(df_bip$PlateLocSide, df_bip$PlateLocHeight, val)
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- pmax(grid$z * 100, 0)
    breaks <- c(-Inf, seq(0, 70, length.out = HEAT_BINS + 1), Inf)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "GB Rate %",
                     scale_limits = c(0, 70)))
  }
  
  if (stat == "Contact Rate") {
    swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                      "FoulBallNotFieldable", "InPlay")
    swing_mask  <- df$PitchCall %in% swing_events
    val <- ifelse(swing_mask, ifelse(df$PitchCall == "StrikeSwinging", 0, 1), NA_real_)
    grid <- make_kde_mean_grid(df$PlateLocSide, df$PlateLocHeight, val)
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- pmin(pmax(grid$z * 100, 50), 100)
    breaks <- seq(50, 100, length.out = HEAT_BINS + 1)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "Contact Rate %",
                     scale_limits = c(50, 100)))
  }
  
  if (stat == "Swing Rate") {
    swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                      "FoulBallNotFieldable", "InPlay")
    val <- ifelse(df$PitchCall %in% swing_events, 1, 0)
    grid <- make_kde_mean_grid(df$PlateLocSide, df$PlateLocHeight, val)
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- pmax(grid$z * 100, 0)
    breaks <- c(-Inf, seq(20, 80, length.out = HEAT_BINS + 1), Inf)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "Swing Rate %",
                     scale_limits = c(20, 80)))
  }
  
  if (stat == "EV") {
    df_bip <- df %>%
      dplyr::filter(
        SessionType == "Live",
        PitchCall == "InPlay",
        is.finite(ExitSpeed)
      )
    if (!nrow(df_bip)) return(ggplot() + theme_void())
    grid <- make_kde_mean_grid(df_bip$PlateLocSide, df_bip$PlateLocHeight, df_bip$ExitSpeed)
    if (!nrow(grid)) return(ggplot() + theme_void())
    breaks <- seq(60, 110, length.out = HEAT_BINS + 1)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "Exit Velocity (mph)",
                     scale_limits = c(60, 110)))
  }
  
  if (stat == "Run Values") {
    calculate_run_value <- function(pitch_call, play_result, korbb = NA) {
      pitch_call <- as.character(pitch_call)
      play_result <- as.character(play_result)
      korbb <- as.character(korbb)
      
      if (!is.na(korbb) && nzchar(korbb) && korbb != "NA") {
        if (korbb == "Strikeout") return(-0.27)
        if (korbb == "Walk")     return(0.33)
      }
      if (pitch_call %in% c("BallCalled", "BallIntentional", "BallinDirt")) return(0.03)
      if (pitch_call %in% c("StrikeCalled", "StrikeSwinging", "FoulBall",
                            "FoulBallFieldable", "FoulBallNotFieldable"))  return(-0.03)
      if (pitch_call == "HitByPitch" || play_result %in% c("Walk","IntentionalWalk","HitByPitch")) return(0.33)
      if (pitch_call == "InPlay") {
        if (play_result == "Single")   return(0.47)
        if (play_result == "Double")   return(0.78)
        if (play_result == "Triple")   return(1.09)
        if (play_result == "HomeRun")  return(1.40)
        if (play_result == "Error")    return(0.33)
        return(-0.27)
      }
      0
    }
    
    df_rv <- df %>%
      dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight)) %>%
      dplyr::mutate(RunValue = mapply(calculate_run_value, PitchCall, PlayResult, 
                                      if("KorBB" %in% names(.)) KorBB else NA))
    if (!nrow(df_rv)) return(ggplot() + theme_void())
    
    grid <- make_kde_rv_grid(
      x = df_rv$PlateLocSide,
      y = df_rv$PlateLocHeight,
      rv_values = df_rv$RunValue,
      lims = c(-2.5, 2.5, 0, 4.5),
      n = 200
    )
    if (!nrow(grid)) return(ggplot() + theme_void())
    grid$z <- pmin(pmax(grid$z, -0.2), 0.2)
    grid$z[!is.finite(grid$z)] <- 0
    rng <- range(grid$z, na.rm = TRUE)
    if (is.finite(rng[1]) && diff(rng) == 0) grid$z <- grid$z + 1e-6
    breaks <- c(-0.2, -0.15, -0.10, -0.05, 0, 0.05, 0.10, 0.15, 0.20)
    return(draw_heat(grid, bins = length(breaks) - 1, pal_fun = heat_pal_br_rv, 
                     breaks = breaks, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "RV",
                     scale_limits = c(-0.2, 0.2)))
  }
  
  ggplot() + theme_void()
}

# Helper to create binned rate heatmap data
make_rate_grid <- function(df, numerator_condition, denominator_condition = NULL, 
                           bin_size = 0.4, x_range = c(-2.5, 2.5), y_range = c(0, 4.5),
                           min_sample = 1) {
  # If no denominator condition provided, use all data
  if (is.null(denominator_condition)) {
    df_denom <- df
  } else {
    df_denom <- df[denominator_condition, ]
  }
  df_numer <- df[numerator_condition, ]
  
  # Create bins
  x_breaks <- seq(x_range[1], x_range[2], by = bin_size)
  y_breaks <- seq(y_range[1], y_range[2], by = bin_size)
  
  # Bin the denominator data
  df_denom$x_bin <- cut(df_denom$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
  df_denom$y_bin <- cut(df_denom$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
  
  # Count denominator
  denom_counts <- df_denom %>%
    filter(!is.na(x_bin) & !is.na(y_bin)) %>%
    group_by(x_bin, y_bin) %>%
    summarise(denom = n(), .groups = 'drop')
  
  # Bin the numerator data
  df_numer$x_bin <- cut(df_numer$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
  df_numer$y_bin <- cut(df_numer$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
  
  # Count numerator
  numer_counts <- df_numer %>%
    filter(!is.na(x_bin) & !is.na(y_bin)) %>%
    group_by(x_bin, y_bin) %>%
    summarise(numer = n(), .groups = 'drop')
  
  # Merge and calculate rate
  rate_data <- denom_counts %>%
    left_join(numer_counts, by = c("x_bin", "y_bin")) %>%
    mutate(
      numer = ifelse(is.na(numer), 0, numer),
      rate = (numer / denom) * 100
    ) %>%
    filter(denom >= min_sample)
  
  # Get bin centers for plotting
  rate_data <- rate_data %>%
    mutate(
      x = (as.numeric(sub("\\((.+),.*", "\\1", x_bin)) + 
             as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", x_bin))) / 2,
      y = (as.numeric(sub("\\((.+),.*", "\\1", y_bin)) + 
             as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", y_bin))) / 2
    ) %>%
    dplyr::select(x, y, z = rate)
  
  return(rate_data)
}

# Helper to smooth binned data using interpolation
smooth_grid <- function(grid_data, n = 120, x_range = c(-2.5, 2.5), y_range = c(0, 4.5)) {
  if (nrow(grid_data) < 4) return(grid_data)  # Need minimum points to interpolate
  
  # Remove any rows with NA or Inf values
  grid_data <- grid_data %>%
    filter(is.finite(x) & is.finite(y) & is.finite(z))
  
  if (nrow(grid_data) < 4) return(grid_data)
  
  # Use akima for smooth interpolation
  if (!requireNamespace("akima", quietly = TRUE)) {
    return(grid_data)  # Fall back to binned data if akima not available
  }
  
  # Wrap in tryCatch to handle any interpolation errors
  smooth_data <- tryCatch({
    # Allow limited extrapolation so sparse areas don't leave holes
    interp_result <- akima::interp(
      x = grid_data$x,
      y = grid_data$y,
      z = grid_data$z,
      xo = seq(x_range[1], x_range[2], length.out = n),
      yo = seq(y_range[1], y_range[2], length.out = n),
      linear = FALSE,  # Use non-linear for smoother appearance
      extrap = TRUE,  # Allow light extrapolation to avoid white holes
      duplicate = "mean"
    )
    
    result <- expand.grid(x = interp_result$x, y = interp_result$y) %>%
      mutate(z = as.vector(interp_result$z)) %>%
      filter(is.finite(z))
    
    # If we lost too much data (lots of gaps), add back original bins to fill
    if (nrow(result) < nrow(grid_data) * 2) {
      # Merge smoothed data with original bins to fill gaps
      result <- bind_rows(result, grid_data) %>%
        distinct(x, y, .keep_all = TRUE)
    }
    
    result
  }, error = function(e) {
    # If interpolation fails, return original binned data
    grid_data
  })
  
  return(smooth_data)
}

# Helper to create binned average heatmap data (for EV)
make_avg_grid <- function(df, value_col, bin_size = 0.4, 
                          x_range = c(-2.5, 2.5), y_range = c(0, 4.5), min_sample = 1) {
  # Filter to valid values
  df <- df[is.finite(df[[value_col]]), ]
  
  # Create bins
  x_breaks <- seq(x_range[1], x_range[2], by = bin_size)
  y_breaks <- seq(y_range[1], y_range[2], by = bin_size)
  
  df$x_bin <- cut(df$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
  df$y_bin <- cut(df$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
  
  # Calculate average per bin
  avg_data <- df %>%
    filter(!is.na(x_bin) & !is.na(y_bin)) %>%
    group_by(x_bin, y_bin) %>%
    summarise(
      count = n(),
      avg_value = mean(.data[[value_col]], na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    filter(count >= min_sample)
  
  # Get bin centers
  avg_data <- avg_data %>%
    mutate(
      x = (as.numeric(sub("\\((.+),.*", "\\1", x_bin)) + 
             as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", x_bin))) / 2,
      y = (as.numeric(sub("\\((.+),.*", "\\1", y_bin)) + 
             as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", y_bin))) / 2
    ) %>%
    dplyr::select(x, y, z = avg_value)
  
  return(avg_data)
}


library(curl)  # for curl::form_file
library(DBI)   # for database operations
library(RSQLite)  # for SQLite database

# Configure Cloudinary (recommended simple host for images/videos)
# Create a free account, make an *unsigned upload preset*, then set these:
# 1) Prefer environment variables in production (shinpps.io Settings → Environment Variables)
# 2) Fall back to your local defaults for dev
CLOUDINARY_CLOUD_NAME    <- Sys.getenv("CLOUDINARY_CLOUD_NAME", unset = "")
CLOUDINARY_UPLOAD_PRESET <- Sys.getenv("CLOUDINARY_UPLOAD_PRESET", unset = "")
if (!nzchar(CLOUDINARY_CLOUD_NAME))    CLOUDINARY_CLOUD_NAME    <- "pitchingcoachu"
if (!nzchar(CLOUDINARY_UPLOAD_PRESET)) CLOUDINARY_UPLOAD_PRESET <- "pcu_notes_unsigned"

# helper: coalesce for NULL
`%||%` <- function(a,b) if (is.null(a)) b else a

get_modifications_db_path <- function() {
  override <- Sys.getenv("PITCH_MOD_DB_PATH", unset = "")
  if (nzchar(override)) {
    path <- path.expand(override)
    dir.create(dirname(path), recursive = TRUE, showWarnings = FALSE)
    return(path)
  }
  
  # Check if we have write access to current directory
  if (file.access(".", 2) == 0) {
    return("pitch_modifications.db")
  }
  
  # Read-only environment (like shinyapps.io) - use /tmp which is writable
  tmp_path <- file.path("/tmp", "pitch_modifications.db")
  message("Using temporary database path: ", tmp_path)
  return(tmp_path)
}

get_modifications_export_path <- function() {
  override <- Sys.getenv("PITCH_MOD_EXPORT_PATH", unset = "")
  if (nzchar(override)) {
    path <- path.expand(override)
    dir.create(dirname(path), recursive = TRUE, showWarnings = FALSE)
    if (!file.exists(path)) {
      bundle_seed <- file.path("data", "pitch_type_modifications_export.csv")
      if (file.exists(bundle_seed)) {
        try(file.copy(bundle_seed, path, overwrite = FALSE), silent = TRUE)
      }
    }
    return(path)
  }
  file.path("data", "pitch_type_modifications_export.csv")
}

# ---- App state (custom tables/reports/targets) persistence helpers ----
state_backend <- function() {
  host <- Sys.getenv("MYSQL_HOST", "")
  db   <- Sys.getenv("MYSQL_DB", "")
  user <- Sys.getenv("MYSQL_USER", "")
  pass <- Sys.getenv("MYSQL_PASSWORD", "")
  port <- as.integer(Sys.getenv("MYSQL_PORT", "3306"))
  ssl_ca <- Sys.getenv("MYSQL_SSL_CA", "")
  has_mysql <- nzchar(host) && nzchar(db) && nzchar(user) && nzchar(pass)
  
  if (has_mysql) {
    return(list(
      type = "mysql",
      connect = function() {
        RMariaDB::dbConnect(
          RMariaDB::MariaDB(),
          host = host,
          user = user,
          password = pass,
          dbname = db,
          port = port,
          ssl.ca = if (nzchar(ssl_ca)) ssl_ca else NULL
        )
      }
    ))
  }
  
  # Fallback to local SQLite (persists locally but not across shinyapps redeploys)
  get_state_db_path <- function() {
    override <- Sys.getenv("APP_STATE_DB_PATH", unset = "")
    if (nzchar(override)) {
      path <- path.expand(override)
      dir.create(dirname(path), recursive = TRUE, showWarnings = FALSE)
      return(path)
    }
    user_dir <- tryCatch(tools::R_user_dir("pcu_pitch_dashboard", which = "data"), error = function(...) "")
    if (nzchar(user_dir)) {
      dir.create(user_dir, recursive = TRUE, showWarnings = FALSE)
      return(file.path(user_dir, "app_state.sqlite"))
    }
    "app_state.sqlite"
  }
  state_db_path <- get_state_db_path()
  list(
    type = "sqlite",
    connect = function() DBI::dbConnect(RSQLite::SQLite(), state_db_path)
  )
}

state_backend_cfg <- state_backend()

state_db_connect <- function() {
  state_backend_cfg$connect()
}

init_state_db <- function() {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  name_type <- if (identical(state_backend_cfg$type, "mysql")) "VARCHAR(191)" else "TEXT"
  text_type <- if (identical(state_backend_cfg$type, "mysql")) "LONGTEXT" else "TEXT"
  ensure_school_column <- function(tbl) {
    cols <- try(DBI::dbListFields(con, tbl), silent = TRUE)
    if (!inherits(cols, "try-error") && length(cols) && !"school_code" %in% cols) {
      try(DBI::dbExecute(con, sprintf("ALTER TABLE %s ADD COLUMN school_code %s", tbl, name_type)), silent = TRUE)
    }
  }
  DBI::dbExecute(con, sprintf(
    "CREATE TABLE IF NOT EXISTS custom_tables (name %s PRIMARY KEY, cols %s, school_code %s)",
    name_type, text_type, name_type
  ))
  DBI::dbExecute(con, sprintf(
    "CREATE TABLE IF NOT EXISTS custom_reports (name %s PRIMARY KEY, payload %s, school_code %s)",
    name_type, text_type, name_type
  ))
  DBI::dbExecute(con, sprintf(
    "CREATE TABLE IF NOT EXISTS target_shapes (
    Pitcher %s,
    PitchType %s,
    IVB_Target REAL,
    HB_Target REAL,
    IsCustom INTEGER,
    school_code %s,
    PRIMARY KEY (Pitcher, PitchType)
  )", name_type, name_type, name_type))
  DBI::dbExecute(con, sprintf(
    "CREATE TABLE IF NOT EXISTS player_plans (player %s PRIMARY KEY, payload %s, school_code %s)",
    name_type, text_type, name_type
  ))
  DBI::dbExecute(con, sprintf(
    "CREATE TABLE IF NOT EXISTS completed_goals (player %s PRIMARY KEY, payload %s, school_code %s)",
    name_type, text_type, name_type
  ))
  ensure_school_column("custom_tables")
  ensure_school_column("custom_reports")
  ensure_school_column("target_shapes")
  ensure_school_column("player_plans")
  ensure_school_column("completed_goals")
}

# load/save helpers for DB-backed state
load_custom_tables_db <- function() {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  if (!DBI::dbExistsTable(con, "custom_tables")) return(list())
  df <- DBI::dbReadTable(con, "custom_tables")
  if ("school_code" %in% names(df)) {
    df <- df[df$school_code %in% allowed_school_codes(), , drop = FALSE]
    df <- df[order(df$school_code == current_school()), , drop = FALSE]
  }
  if (!nrow(df)) return(list())
  res <- lapply(seq_len(nrow(df)), function(i) {
    item <- tryCatch(jsonlite::fromJSON(df$cols[[i]], simplifyVector = TRUE), error = function(...) list(cols = character(0)))
    item$school_code <- df$school_code[[i]] %||% current_school()
    item
  })
  names(res) <- df$name
  res
}

save_custom_tables_db <- function(x) {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  DBI::dbExecute(con, "DELETE FROM custom_tables")
  if (!length(x)) return(invisible(TRUE))
  payload <- data.frame(
    name = names(x),
    cols = vapply(x, function(v) jsonlite::toJSON(v, auto_unbox = TRUE), character(1)),
    school_code = vapply(x, function(v) v$school_code %||% current_school(), character(1)),
    stringsAsFactors = FALSE
  )
  DBI::dbWriteTable(con, "custom_tables", payload, append = TRUE, row.names = FALSE)
}

load_custom_reports_db <- function() {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  if (!DBI::dbExistsTable(con, "custom_reports")) return(list())
  df <- DBI::dbReadTable(con, "custom_reports")
  if ("school_code" %in% names(df)) {
    df <- df[df$school_code %in% allowed_school_codes(), , drop = FALSE]
    df <- df[order(df$school_code == current_school()), , drop = FALSE]
  }
  if (!nrow(df)) return(list())
  res <- lapply(seq_len(nrow(df)), function(i) {
    item <- tryCatch(jsonlite::fromJSON(df$payload[[i]], simplifyVector = TRUE), error = function(...) list())
    item$school_code <- df$school_code[[i]] %||% current_school()
    item
  })
  names(res) <- df$name
  res
}

save_custom_reports_db <- function(x) {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  DBI::dbExecute(con, "DELETE FROM custom_reports")
  if (!length(x)) return(invisible(TRUE))
  payload <- data.frame(
    name = names(x),
    payload = vapply(x, function(v) jsonlite::toJSON(v, auto_unbox = TRUE), character(1)),
    school_code = vapply(x, function(v) v$school_code %||% current_school(), character(1)),
    stringsAsFactors = FALSE
  )
  DBI::dbWriteTable(con, "custom_reports", payload, append = TRUE, row.names = FALSE)
}

load_target_shapes_db <- function() {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  if (!DBI::dbExistsTable(con, "target_shapes")) return(NULL)
  df <- DBI::dbReadTable(con, "target_shapes")
  if ("school_code" %in% names(df)) {
    df <- df[df$school_code %in% allowed_school_codes(), , drop = FALSE]
    df <- df[order(df$school_code == current_school()), , drop = FALSE]
  }
  if (!nrow(df)) return(NULL)
  df
}

save_target_shapes_db <- function(df) {
  con <- state_db_connect()
  on.exit(DBI::dbDisconnect(con), add = TRUE)
  DBI::dbExecute(con, "DELETE FROM target_shapes")
  if (!nrow(df)) return(invisible(TRUE))
  if (!"school_code" %in% names(df)) {
    df$school_code <- current_school()
  } else {
    df$school_code[is.na(df$school_code) | !nzchar(df$school_code)] <- current_school()
  }
  DBI::dbWriteTable(con, "target_shapes", df, append = TRUE, row.names = FALSE)
}

init_state_db()

compute_pitch_key <- function(df) {
  if (!nrow(df)) return(character(0))
  prefer_cols <- c("PitchUID", "PitchGuid", "PitchID", "PitchId", "PitchUIDNext", "b_pitch_guid")
  for (col in prefer_cols) {
    if (col %in% names(df)) {
      vals <- df[[col]]
      if (!is.null(vals) && any(!is.na(vals) & nzchar(as.character(vals)))) {
        return(as.character(vals))
      }
    }
  }
  safe_chr <- function(x) {
    out <- tryCatch(as.character(x), warning = function(...) "", error = function(...) "")
    if (!length(out)) return("")
    out <- out[1]
    ifelse(is.na(out), "", out)
  }
  safe_num <- function(x) {
    val <- suppressWarnings(as.numeric(x))
    if (!length(val)) return("")
    val <- val[1]
    if (is.na(val)) "" else sprintf("%.3f", round(val, 3))
  }
  safe_col <- function(row, col_name) {
    if (col_name %in% names(row)) {
      safe_chr(row[[col_name]])
    } else {
      ""
    }
  }
  vapply(seq_len(nrow(df)), function(i) {
    row <- df[i, , drop = FALSE]
    parts <- c(
      safe_col(row, "Pitcher"),
      safe_chr(as.Date(row$Date)),
      safe_col(row, "SessionType"),
      safe_col(row, "Batter"),
      safe_col(row, "PitchCall"),
      safe_col(row, "PlayResult"),
      safe_col(row, "TaggedPitchType"),
      safe_col(row, "Inning"),
      safe_col(row, "Balls"),
      safe_col(row, "Strikes"),
      safe_num(if ("RelSpeed" %in% names(row)) row$RelSpeed else NA),
      safe_num(if ("InducedVertBreak" %in% names(row)) row$InducedVertBreak else NA),
      safe_num(if ("HorzBreak" %in% names(row)) row$HorzBreak else NA),
      safe_num(if ("Extension" %in% names(row)) row$Extension else NA),
      safe_num(if ("VertApprAngle" %in% names(row)) row$VertApprAngle else NA),
      safe_num(if ("HorzApprAngle" %in% names(row)) row$HorzApprAngle else NA),
      safe_num(if ("PlateLocSide" %in% names(row)) row$PlateLocSide else NA),
      safe_num(if ("PlateLocHeight" %in% names(row)) row$PlateLocHeight else NA)
    )
    digest::digest(paste(parts, collapse = "|"), algo = "xxhash64", serialize = FALSE)
  }, character(1))
}

ensure_pitch_keys <- function(df) {
  if (!nrow(df)) {
    if (!"PitchKey" %in% names(df)) df$PitchKey <- character(0)
    return(df)
  }
  if (!"PitchKey" %in% names(df)) {
    df$PitchKey <- compute_pitch_key(df)
    return(df)
  }
  df$PitchKey <- as.character(df$PitchKey)
  missing <- is.na(df$PitchKey) | !nzchar(df$PitchKey)
  if (any(missing)) {
    df$PitchKey[missing] <- compute_pitch_key(df[missing, , drop = FALSE])
  }
  df
}

attach_pitch_keys_to_mods <- function(mods_df, base_data, tolerance = 0.5) {
  if (!nrow(mods_df)) {
    if (!"pitch_key" %in% names(mods_df)) mods_df$pitch_key <- character(0)
    return(mods_df)
  }
  if (is.null(base_data) || !nrow(base_data)) {
    if (!"pitch_key" %in% names(mods_df)) mods_df$pitch_key <- NA_character_
    return(mods_df)
  }
  mods_df$pitch_key <- as.character(mods_df[["pitch_key"]] %||% NA_character_)
  need <- is.na(mods_df$pitch_key) | !nzchar(mods_df$pitch_key)
  if (!any(need)) return(mods_df)
  base <- ensure_pitch_keys(base_data)
  tol <- ifelse(is.na(suppressWarnings(as.numeric(tolerance))), 0.5, as.numeric(tolerance))
  rel_base <- suppressWarnings(as.numeric(base$RelSpeed))
  hb_base  <- suppressWarnings(as.numeric(base$HorzBreak))
  ivb_base <- suppressWarnings(as.numeric(base$InducedVertBreak))
  for (idx in which(need)) {
    mod <- mods_df[idx, , drop = FALSE]
    rel_mod <- suppressWarnings(as.numeric(mod$rel_speed))
    hb_mod  <- suppressWarnings(as.numeric(mod$horz_break))
    ivb_mod <- suppressWarnings(as.numeric(mod$induced_vert_break))
    rel_ok <- if (is.na(rel_mod)) rep(TRUE, length(rel_base)) else abs(rel_base - rel_mod) <= tol
    hb_ok  <- if (is.na(hb_mod))  rep(TRUE, length(hb_base))  else abs(hb_base - hb_mod) <= tol
    ivb_ok <- if (is.na(ivb_mod)) rep(TRUE, length(ivb_base)) else abs(ivb_base - ivb_mod) <= tol
    matches <- which(
      base$Pitcher == mod$pitcher &
        as.character(base$Date) == as.character(mod$date) &
        rel_ok & hb_ok & ivb_ok
    )
    if (length(matches)) mods_df$pitch_key[idx] <- base$PitchKey[matches[1]]
  }
  mods_df
}

refresh_missing_pitch_keys <- function(con, mods_df, base_data) {
  if (!nrow(mods_df)) return(mods_df)
  mods_with_keys <- attach_pitch_keys_to_mods(mods_df, base_data)
  newly_filled <- which((is.na(mods_df$pitch_key) | !nzchar(mods_df$pitch_key)) & nzchar(mods_with_keys$pitch_key))
  if (length(newly_filled)) {
    for (idx in newly_filled) {
      try(dbExecute(con, "UPDATE modifications SET pitch_key = ? WHERE id = ?", list(mods_with_keys$pitch_key[idx], mods_with_keys$id[idx])), silent = TRUE)
    }
  }
  mods_with_keys
}

write_modifications_snapshot <- function(con) {
  export_path <- get_modifications_export_path()
  if (!nzchar(export_path)) return()
  
  # Get all modifications from database
  mods <- try(dbGetQuery(con, "SELECT * FROM modifications ORDER BY created_at"), silent = TRUE)
  if (inherits(mods, "try-error") || !nrow(mods)) return()
  
  # Ensure export directory exists
  dir_path <- dirname(export_path)
  if (!dir.exists(dir_path)) {
    ok <- try(dir.create(dir_path, recursive = TRUE, showWarnings = FALSE), silent = TRUE)
    if (inherits(ok, "try-error") || !dir.exists(dir_path)) return()
  }
  
  # Write to temporary file first for atomic operation
  tmp <- tempfile(fileext = ".csv")
  on.exit(unlink(tmp), add = TRUE)
  
  tryCatch({
    # Write CSV with proper formatting
    readr::write_csv(mods, tmp)
    
    # Atomic replace of export file
    success <- file.copy(tmp, export_path, overwrite = TRUE, copy.mode = TRUE)
    
    if (success) {
      cat("Successfully exported", nrow(mods), "modifications to", export_path, "\n")
    } else {
      warning("Failed to copy modifications export file")
    }
  }, error = function(e) {
    warning("Error writing modifications snapshot: ", e$message)
  })
}

import_modifications_from_export <- function(con, base_data) {
  export_path <- get_modifications_export_path()
  if (!file.exists(export_path)) return()
  
  # Read modifications from CSV export
  mods_csv <- try(readr::read_csv(export_path, show_col_types = FALSE), silent = TRUE)
  if (inherits(mods_csv, "try-error") || !nrow(mods_csv)) return()
  
  mods_csv <- as.data.frame(mods_csv, stringsAsFactors = FALSE, check.names = FALSE)
  if (!"pitch_key" %in% names(mods_csv)) mods_csv$pitch_key <- NA_character_
  
  # Attach pitch keys if missing
  mods_csv <- attach_pitch_keys_to_mods(mods_csv, base_data)
  
  # Get existing modifications from database
  existing <- try(dbGetQuery(con, "SELECT pitch_key FROM modifications"), silent = TRUE)
  existing_keys <- if (inherits(existing, "try-error")) character(0) else as.character(existing$pitch_key)
  
  # Find new rows (those not already in database)
  new_rows <- mods_csv[!(mods_csv$pitch_key %in% existing_keys), , drop = FALSE]
  if (!nrow(new_rows)) {
    cat("All modifications from export file already exist in database\n")
    return()
  }
  
  # Prepare data for database insertion
  expected_cols <- c(
    "pitcher", "date", "rel_speed", "horz_break", "induced_vert_break",
    "original_pitch_type", "new_pitch_type", "new_pitcher",
    "modified_at", "pitch_key", "created_at"
  )
  
  # Remove auto-increment id column if present
  new_rows$id <- NULL
  
  # Ensure all expected columns exist
  for (col in expected_cols) {
    if (!col %in% names(new_rows)) new_rows[[col]] <- NA
  }
  
  # Select only expected columns
  new_rows <- new_rows[, expected_cols, drop = FALSE]
  
  # Insert new modifications
  tryCatch({
    dbWriteTable(con, "modifications", new_rows, append = TRUE)
    cat("Imported", nrow(new_rows), "new modifications from export file\n")
  }, error = function(e) {
    warning("Error importing modifications: ", e$message)
  })
}

upload_media_cloudinary <- function(path) {
  if (!nzchar(CLOUDINARY_CLOUD_NAME) || !nzchar(CLOUDINARY_UPLOAD_PRESET)) {
    stop("Cloudinary not configured: set CLOUDINARY_CLOUD_NAME and CLOUDINARY_UPLOAD_PRESET.")
  }
  endpoint <- sprintf("https://api.cloudinary.com/v1_1/%s/auto/upload", CLOUDINARY_CLOUD_NAME)
  
  res <- httr2::request(endpoint) |>
    httr2::req_body_multipart(
      file = curl::form_file(path),
      upload_preset = CLOUDINARY_UPLOAD_PRESET
    ) |>
    httr2::req_timeout(30) |>
    httr2::req_error(is_error = ~ FALSE) |>
    httr2::req_perform()
  
  # Fail clearly on HTTP error
  if (httr2::resp_status(res) >= 400) {
    msg <- tryCatch(httr2::resp_body_string(res), error = function(e) paste("HTTP", httr2::resp_status(res)))
    stop(sprintf("Cloudinary upload failed: %s", msg))
  }
  
  j <- httr2::resp_body_json(res, check_type = FALSE)
  list(
    url  = j$secure_url %||% j$url,
    type = j$resource_type %||% "auto"  # "image" | "video" | "raw"
  )
}

# ---- Database functions for persistent pitch modifications ----

# Initialize modifications database
init_modifications_db <- function() {
  db_path <- get_modifications_db_path()
  
  # Wrap entire DB initialization in tryCatch to handle read-only environments
  con <- tryCatch(dbConnect(SQLite(), db_path), error = function(e) {
    warning(sprintf("Could not connect to modifications DB (%s). Pitch edits will only persist in-memory.", conditionMessage(e)))
    return(NULL)
  })
  
  if (is.null(con) || inherits(con, "error")) {
    return(db_path)
  }
  
  on.exit(dbDisconnect(con), add = TRUE)
  
  # Execute DB operations with error handling
  tryCatch({
    dbExecute(con, "
      CREATE TABLE IF NOT EXISTS modifications (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        pitcher TEXT NOT NULL,
        date TEXT NOT NULL,
        rel_speed REAL,
        horz_break REAL,
        induced_vert_break REAL,
        original_pitch_type TEXT,
        new_pitch_type TEXT NOT NULL,
        new_pitcher TEXT,
        modified_at TEXT NOT NULL,
        pitch_key TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    ")
    dbExecute(con, "
      CREATE INDEX IF NOT EXISTS idx_pitch_lookup ON modifications 
      (pitcher, date, rel_speed, horz_break, induced_vert_break)
    ")
    dbExecute(con, "
      CREATE INDEX IF NOT EXISTS idx_pitch_key ON modifications (pitch_key)
    ")
    # Ensure legacy databases get the new_pitcher column
    cols <- try(dbListFields(con, "modifications"), silent = TRUE)
    if (!inherits(cols, "try-error") && !"new_pitcher" %in% cols) {
      try(dbExecute(con, "ALTER TABLE modifications ADD COLUMN new_pitcher TEXT"), silent = TRUE)
    }
    base_data <- get0("pitch_data_pitching", ifnotfound = NULL)
    import_modifications_from_export(con, base_data)
    mods <- try(dbGetQuery(con, "SELECT * FROM modifications"), silent = TRUE)
    db_count <- if (inherits(mods, "try-error")) NA_integer_ else nrow(mods)
    message(sprintf("Mod DB path: %s | rows: %s", db_path, db_count))
    if (!inherits(mods, "try-error") && nrow(mods)) {
      refresh_missing_pitch_keys(con, mods, base_data)
      write_modifications_snapshot(con)
      # If the DB has fewer rows than the best available CSV, rebuild from CSV
      best_csv <- function() {
        candidates <- unique(c(
          get_modifications_export_path(),
          file.path("data", "pitch_type_modifications_export.csv"),
          file.path("data", "pitch_type_modifications.csv"),
          "pitch_type_modifications.csv"
        ))
        best <- NULL; best_n <- NA_integer_
        for (p in candidates) {
          if (!file.exists(p)) next
          n <- tryCatch(nrow(readr::read_csv(p, show_col_types = FALSE)), error = function(...) NA_integer_)
          if (is.finite(n) && (is.na(best_n) || n > best_n)) {
            best <- p; best_n <- n
          }
        }
        list(path = best, n = best_n)
      }
      csv_info <- best_csv()
      db_count <- nrow(mods)
      if (!is.null(csv_info$path) && is.finite(csv_info$n) && csv_info$n > db_count) {
        message(sprintf("Rebuilding modifications DB from %s (%d -> %d rows)", csv_info$path, db_count, csv_info$n))
        try(dbExecute(con, "DELETE FROM modifications"), silent = TRUE)
        mods_csv <- try(readr::read_csv(csv_info$path, show_col_types = FALSE), silent = TRUE)
        if (!inherits(mods_csv, "try-error") && nrow(mods_csv)) {
          mods_csv <- as.data.frame(mods_csv, stringsAsFactors = FALSE, check.names = FALSE)
          if (!"pitch_key" %in% names(mods_csv)) mods_csv$pitch_key <- NA_character_
          mods_csv <- attach_pitch_keys_to_mods(mods_csv, base_data)
          new_rows <- mods_csv
          new_rows$id <- NULL
          expected_cols <- c(
            "pitcher", "date", "rel_speed", "horz_break", "induced_vert_break",
            "original_pitch_type", "new_pitch_type", "new_pitcher",
            "modified_at", "pitch_key", "created_at"
          )
          for (col in expected_cols) {
            if (!col %in% names(new_rows)) new_rows[[col]] <- NA
          }
          new_rows <- new_rows[, expected_cols, drop = FALSE]
          try(dbWriteTable(con, "modifications", new_rows, append = TRUE), silent = TRUE)
        }
        mods <- try(dbGetQuery(con, "SELECT * FROM modifications"), silent = TRUE)
        if (!inherits(mods, "try-error")) {
          refresh_missing_pitch_keys(con, mods, base_data)
          write_modifications_snapshot(con)
        }
        # mod_memo is no longer memoized; nothing to forget
      }
    }
  }, error = function(e) {
    warning(sprintf("Error during DB initialization: %s", conditionMessage(e)))
  })
  
  db_path
}

# Save pitch modifications to database
save_pitch_modifications_db <- function(selected_pitches, new_type, new_pitcher = NULL) {
  db_path <- init_modifications_db()
  con <- tryCatch(dbConnect(SQLite(), db_path), error = function(e) e)
  if (inherits(con, "error")) {
    return(list(success = FALSE, error = paste("Could not open pitch modifications database:", conditionMessage(con))))
  }
  on.exit(dbDisconnect(con), add = TRUE)
  selected_pitches <- ensure_pitch_keys(selected_pitches)
  # Drop any aggregate/summary rows that lack a concrete pitch key
  selected_pitches <- selected_pitches[!is.na(selected_pitches$PitchKey) & nzchar(as.character(selected_pitches$PitchKey)), , drop = FALSE]
  if (!nrow(selected_pitches)) {
    return(list(success = FALSE, error = "No valid pitch rows selected (missing pitch key)."))
  }
  # Normalize pitcher fields to avoid NULL/NA inserts
  pitcher_vec <- as.character(selected_pitches$Pitcher)
  pitcher_vec[is.na(pitcher_vec) | pitcher_vec %in% c("NA","NaN","")] <- "Unknown"
  if (!is.null(new_pitcher) && nzchar(new_pitcher)) {
    # Fill any missing pitcher with the override and use override for new_pitcher column
    pitcher_vec[!nzchar(pitcher_vec) | is.na(pitcher_vec)] <- new_pitcher
    new_pitcher_vec <- rep(new_pitcher, nrow(selected_pitches))
  } else {
    # No override provided; still ensure we don't insert blanks
    pitcher_vec[!nzchar(pitcher_vec) | is.na(pitcher_vec) | pitcher_vec %in% c("NA","NaN")] <- "Unknown"
    new_pitcher_vec <- pitcher_vec
  }
  new_mods <- data.frame(
    pitcher = pitcher_vec,
    date = as.character(selected_pitches$Date),
    rel_speed = suppressWarnings(as.numeric(selected_pitches$RelSpeed)),
    horz_break = suppressWarnings(as.numeric(selected_pitches$HorzBreak)),
    induced_vert_break = suppressWarnings(as.numeric(selected_pitches$InducedVertBreak)),
    original_pitch_type = selected_pitches$TaggedPitchType,
    new_pitch_type = new_type,
    new_pitcher = new_pitcher_vec,
    modified_at = as.character(Sys.time()),
    pitch_key = as.character(selected_pitches$PitchKey),
    stringsAsFactors = FALSE
  )
  # Sanitize required NOT NULL fields
  new_mods$date[is.na(new_mods$date) | new_mods$date %in% c("", "NA", "NaN")] <- NA
  new_mods$pitcher[is.na(new_mods$pitcher) | new_mods$pitcher %in% c("", "NA", "NaN")] <- "Unknown"
  new_mods$new_pitcher[is.na(new_mods$new_pitcher) | new_mods$new_pitcher %in% c("", "NA", "NaN")] <- new_mods$pitcher[is.na(new_mods$new_pitcher) | new_mods$new_pitcher %in% c("", "NA", "NaN")]
  new_mods$pitch_key[is.na(new_mods$pitch_key)] <- ""
  # Keep only rows with required fields: pitch_key, pitcher, date
  new_mods <- new_mods[
    nzchar(new_mods$pitch_key) &
      nzchar(new_mods$pitcher) &
      !is.na(new_mods$date),
    , drop = FALSE
  ]
  if (!nrow(new_mods)) {
    return(list(success = FALSE, error = "No valid pitch rows available (missing key/pitcher/date)."))
  }
  res <- tryCatch({
    dbExecute(con, "BEGIN IMMEDIATE")
    for (i in seq_len(nrow(new_mods))) {
      dbExecute(con, "DELETE FROM modifications WHERE pitch_key = ?", list(new_mods$pitch_key[i]))
    }
    dbWriteTable(con, "modifications", new_mods, append = TRUE)
    dbExecute(con, "COMMIT")
    
    # ENHANCED: Always update the export CSV after successful save
    write_modifications_snapshot(con)
    
    # Additional backup: create timestamped backup
    export_path <- get_modifications_export_path()
    if (file.exists(export_path) && nzchar(export_path)) {
      backup_dir <- file.path(dirname(export_path), "backups")
      dir.create(backup_dir, recursive = TRUE, showWarnings = FALSE)
      timestamp <- format(Sys.time(), "%Y%m%d_%H%M%S")
      backup_path <- file.path(backup_dir, paste0("pitch_modifications_", timestamp, ".csv"))
      try(file.copy(export_path, backup_path), silent = TRUE)
    }
    
    list(success = TRUE, count = nrow(new_mods))
  }, error = function(e) {
    try(dbExecute(con, "ROLLBACK"), silent = TRUE)
    list(success = FALSE, error = conditionMessage(e))
  })
  res
}

# Enhanced: Load and apply modifications from database with better matching
mod_memo <- function(db_path, mtime_sig) {
  con <- tryCatch(dbConnect(SQLite(), db_path), error = function(e) e)
  if (inherits(con, "error")) return(NULL)
  on.exit(dbDisconnect(con), add = TRUE)
  mods <- dbGetQuery(con, "SELECT * FROM modifications ORDER BY created_at")
  # Normalize date/time fields to avoid parsing errors
  safe_date <- function(x) {
    tryCatch({
      v <- as.character(x)
      out <- suppressWarnings(lubridate::ymd(v))
      if (all(is.na(out))) out <- suppressWarnings(lubridate::mdy(v))
      if (all(is.na(out))) out <- suppressWarnings(lubridate::dmy(v))
      as.Date(out)
    }, error = function(...) as.Date(NA))
  }
  safe_dt <- function(x) {
    tryCatch({
      v <- as.character(x)
      out <- suppressWarnings(lubridate::parse_date_time(
        v,
        orders = c("ymd HMS", "mdy HMS", "dmy HMS", "ymd HM", "mdy HM", "dmy HM", "ymd", "mdy", "dmy"),
        tz = "UTC"
      ))
      as.POSIXct(out, tz = "UTC")
    }, error = function(...) as.POSIXct(NA))
  }
  mods$date <- safe_date(mods$date)
  mods$modified_at <- safe_dt(mods$modified_at)
  mods$created_at <- safe_dt(mods$created_at)
  mods
}

load_pitch_modifications_db <- function(pitch_data, verbose = TRUE) {
  # Ensure we ALWAYS return valid data, even if everything fails
  fallback_result <- list(
    data = pitch_data %>% mutate(original_row_id = row_number()),
    applied_count = 0,
    total_modifications = 0
  )
  
  # Wrap entire function in tryCatch to ensure we never fail to return data
  tryCatch({
    db_path <- init_modifications_db()
    
    # Check if we're in read-only mode and need to seed DB from CSV
    is_readonly <- tryCatch(file.access(".", 2) != 0, error = function(e) TRUE)
    if (is_readonly) {
      if (verbose) message("Read-only environment detected - seeding temp DB from CSV")
      
      # Load modifications from CSV and populate the temp database
      csv_path <- file.path("data", "pitch_type_modifications_export.csv")
      if (file.exists(csv_path)) {
        tryCatch({
          con <- dbConnect(SQLite(), db_path)
          on.exit(dbDisconnect(con), add = TRUE)
          
          # Check if DB is empty (needs seeding)
          existing_count <- tryCatch({
            dbGetQuery(con, "SELECT COUNT(*) as n FROM modifications")$n
          }, error = function(e) 0)
          
          if (existing_count == 0) {
            # Load and import CSV modifications
            mods_csv <- readr::read_csv(csv_path, show_col_types = FALSE)
            if (nrow(mods_csv) > 0) {
              mods_csv <- as.data.frame(mods_csv, stringsAsFactors = FALSE, check.names = FALSE)
              
              # Prepare data for insertion
              if (!"pitch_key" %in% names(mods_csv)) mods_csv$pitch_key <- NA_character_
              if (!"new_pitcher" %in% names(mods_csv)) mods_csv$new_pitcher <- NA_character_
              
              expected_cols <- c(
                "pitcher", "date", "rel_speed", "horz_break", "induced_vert_break",
                "original_pitch_type", "new_pitch_type", "new_pitcher",
                "modified_at", "pitch_key", "created_at"
              )
              
              for (col in expected_cols) {
                if (!col %in% names(mods_csv)) mods_csv[[col]] <- NA
              }
              
              import_data <- mods_csv[, expected_cols, drop = FALSE]
              dbWriteTable(con, "modifications", import_data, append = TRUE)
              
              if (verbose) {
                message(sprintf("Seeded temp DB with %d modifications from CSV", nrow(import_data)))
              }
            }
          }
        }, error = function(e) {
          warning(sprintf("Could not seed DB from CSV: %s", conditionMessage(e)))
        })
      }
    }
    
    if (!file.exists(db_path)) {
      return(fallback_result)
    }
    
    con <- tryCatch(dbConnect(SQLite(), db_path), error = function(e) e)
    if (inherits(con, "error")) {
      warning(sprintf("Could not open modifications DB while loading (%s)", conditionMessage(con)))
      return(list(
        data = ensure_pitch_keys(pitch_data) %>% mutate(original_row_id = row_number()),
        applied_count = 0,
        total_modifications = 0
      ))
    }
    on.exit(dbDisconnect(con), add = TRUE)
    
    tryCatch({
      mtime_sig <- suppressWarnings(as.character(file.info(db_path)$mtime %||% Sys.time()))
      mods <- mod_memo(db_path, mtime_sig)
      if (is.null(mods)) {
        return(list(
          data = ensure_pitch_keys(pitch_data) %>% mutate(original_row_id = row_number()),
          applied_count = 0,
          total_modifications = 0
        ))
      }
      dropped <- sum(is.na(mods$date))
      if (dropped && verbose) message(sprintf("Dropping %d modifications with unparseable dates", dropped))
      base_data <- ensure_pitch_keys(pitch_data)
      mods <- refresh_missing_pitch_keys(con, mods, base_data)
      
      if (nrow(mods) == 0) {
        return(list(
          data = base_data %>% mutate(original_row_id = row_number()),
          applied_count = 0,
          total_modifications = 0
        ))
      }
      
      temp_data <- base_data %>% mutate(original_row_id = row_number())
      
      # Apply modifications with enhanced matching
      modifications_applied <- 0
      modifications_not_found <- 0
      lookup_df <- get0("lookup_table", ifnotfound = NULL)
      fetch_email <- function(name) {
        if (is.null(lookup_df) || !"Pitcher" %in% names(lookup_df) || !"Email_lookup" %in% names(lookup_df)) {
          return(NA_character_)
        }
        idx <- which(tolower(lookup_df$Pitcher) == tolower(name))
        if (length(idx)) {
          val <- lookup_df$Email_lookup[idx[1]]
          if (is.na(val) || !nzchar(val)) return(NA_character_)
          return(val)
        }
        NA_character_
      }
      
      for (i in 1:nrow(mods)) {
        mod <- mods[i, ]
        
        # Primary matching strategy: exact match on multiple fields
        match_idx <- integer(0)
        if ("PitchKey" %in% names(temp_data) && !is.na(mod$pitch_key) && nzchar(mod$pitch_key)) {
          match_idx <- which(temp_data$PitchKey == mod$pitch_key)
        }
        if (!length(match_idx)) {
          match_idx <- which(
            temp_data$Pitcher == mod$pitcher &
              temp_data$Date == mod$date &
              abs(temp_data$RelSpeed - mod$rel_speed) < 0.1 &
              abs(temp_data$HorzBreak - mod$horz_break) < 0.1 &
              abs(temp_data$InducedVertBreak - mod$induced_vert_break) < 0.1
          )
        }
        
        # Fallback matching: if exact match fails, try looser criteria
        if (length(match_idx) == 0) {
          match_idx <- which(
            temp_data$Pitcher == mod$pitcher &
              temp_data$Date == mod$date &
              abs(temp_data$RelSpeed - mod$rel_speed) < 0.5  # Slightly looser tolerance
          )
        }
        
        if (length(match_idx) > 0) {
          # Apply modification to all matching rows (handles duplicate PitchKey entries)
          temp_data$TaggedPitchType[match_idx] <- mod$new_pitch_type
          if (!is.null(mod$new_pitcher) && nzchar(mod$new_pitcher)) {
            temp_data$Pitcher[match_idx] <- mod$new_pitcher
            new_email <- fetch_email(mod$new_pitcher)
            if (!is.na(new_email) && "Email" %in% names(temp_data)) {
              temp_data$Email[match_idx] <- new_email
            }
          }
          modifications_applied <- modifications_applied + 1
          
          if (verbose) {
            cat(sprintf("Applied: %s on %s - %s -> %s\n", 
                        mod$pitcher, mod$date, mod$original_pitch_type, mod$new_pitch_type))
          }
        } else {
          modifications_not_found <- modifications_not_found + 1
          if (verbose) {
            cat(sprintf("Could not find pitch to modify: %s on %s (%.1f mph)\n", 
                        mod$pitcher, mod$date, mod$rel_speed))
          }
        }
      }
      
      if (verbose && modifications_applied > 0) {
        message(sprintf("Applied %d of %d stored pitch type modifications", 
                        modifications_applied, nrow(mods)))
        if (modifications_not_found > 0) {
          message(sprintf("Warning: %d modifications could not be applied (pitches not found)", 
                          modifications_not_found))
        }
      }
      
      return(list(
        data = temp_data,
        applied_count = modifications_applied,
        total_modifications = nrow(mods)
      ))
      
    }, finally = {
      dbDisconnect(con)
    })
    
  }, error = function(e) {
    warning(sprintf("Error loading pitch modifications: %s", conditionMessage(e)))
    return(fallback_result)
  })
}

# Function to check if data has been updated since last modification load
check_data_freshness <- function() {
  # Check for new_data_flag.txt which gets created by automated_data_sync.R when new data arrives
  flag_file <- file.path("data", "new_data_flag.txt")
  mod_state_file <- "modification_state.txt"
  
  if (file.exists(flag_file)) {
    # New data flag exists - check if we've already processed it
    flag_time <- file.info(flag_file)$mtime
    
    if (!file.exists(mod_state_file)) {
      # First time - create state file and return TRUE
      writeLines(as.character(flag_time), mod_state_file)
      file.remove(flag_file)  # Remove the flag so we don't keep reprocessing
      return(TRUE)
    }
    
    last_processed_time <- as.POSIXct(readLines(mod_state_file)[1])
    
    if (flag_time > last_processed_time) {
      # New data has arrived since we last processed
      writeLines(as.character(flag_time), mod_state_file)
      file.remove(flag_file)  # Remove the flag
      return(TRUE)
    }
  }
  
  # Also check the traditional last_sync.txt approach as backup
  sync_file <- file.path("data", "last_sync.txt")
  if (!file.exists(sync_file)) {
    return(FALSE)  # No sync file means no data sync has occurred
  }
  
  sync_time <- file.info(sync_file)$mtime
  
  if (!file.exists(mod_state_file)) {
    # First time - create state file and return TRUE to trigger reload
    writeLines(as.character(sync_time), mod_state_file)
    return(TRUE)
  }
  
  last_mod_time <- as.POSIXct(readLines(mod_state_file)[1])
  
  if (sync_time > last_mod_time) {
    # Data has been updated since modifications were last applied
    writeLines(as.character(sync_time), mod_state_file)
    return(TRUE)
  }
  
  return(FALSE)
}

# Function to get modification statistics
get_modification_stats <- function() {
  db_path <- "pitch_modifications.db"
  
  if (!file.exists(db_path)) {
    return(list(total = 0, by_player = data.frame(), recent = data.frame()))
  }
  
  con <- dbConnect(SQLite(), db_path)
  
  tryCatch({
    # Get total count
    total <- dbGetQuery(con, "SELECT COUNT(*) as count FROM modifications")$count
    
    # Get count by player
    by_player <- dbGetQuery(con, "
      SELECT pitcher, COUNT(*) as modifications 
      FROM modifications 
      GROUP BY pitcher 
      ORDER BY modifications DESC
    ")
    
    # Get recent modifications
    recent <- dbGetQuery(con, "
      SELECT pitcher, date, original_pitch_type, new_pitch_type, modified_at 
      FROM modifications 
      ORDER BY created_at DESC 
      LIMIT 10
    ")
    
    return(list(total = total, by_player = by_player, recent = recent))
    
  }, finally = {
    dbDisconnect(con)
  })
}


have_akima <- requireNamespace("akima", quietly = TRUE)  # for smoothed means (EV/LA)

HEAT_BINS <- 6
HEAT_EV_THRESHOLD <- 90

# Frequency (keep multi-color)
heat_pal_freq <- function(n = HEAT_BINS) colorRampPalette(
  c("white","pink","red")
)(n)

# All other heat maps → white→red only
heat_pal_red  <- function(n = HEAT_BINS) colorRampPalette(c("white","pink","red"))(n)


# JS sorter: strip HTML, then try numeric (handles %, commas); fallback to lowercase text
js_sort <- 
  "function(data, type, row, meta) {\n" %>% 
  paste0("  if (type === 'sort') {\n") %>%
  paste0("    var text = String(data || '').replace(/<[^>]*>/g, '');\n") %>%
  paste0("    var num = parseFloat(text.replace(/[^0-9.+\\-eE]/g, ''));\n") %>%
  paste0("    if (!isNaN(num)) return num;\n") %>%
  paste0("    return text.toLowerCase();\n") %>%
  paste0("  }\n") %>%
  paste0("  return data;\n") %>%
  paste0("}")

# small helper
# Replace the old %or% with this scalar-safe version
`%or%` <- function(a, b) {
  if (is.null(a) || length(a) == 0) return(b)
  a1 <- a[1]
  if (is.na(a1)) return(b)
  a1c <- as.character(a1)
  if (!nzchar(a1c)) b else a1
}
fmt_mdy <- function(x) ifelse(is.na(x), "", format(as.Date(x), "%m/%d/%Y"))

get_hit_type_col <- function(df) {
  if (is.null(df)) return(character(0))
  if ("HitType" %in% names(df)) return(as.character(df$HitType))
  if ("TaggedHitType" %in% names(df)) return(as.character(df$TaggedHitType))
  rep(NA_character_, if (is.data.frame(df)) nrow(df) else 0)
}

pa_flags_from_counts <- function(df_local) {
  n <- nrow(df_local)
  res <- list(
    is_last      = rep(FALSE, n),
    is_strikeout = rep(FALSE, n),
    is_walk      = rep(FALSE, n)
  )
  if (!n) return(res)
  required <- c("Balls","Strikes","PitchCall")
  if (!all(required %in% names(df_local))) return(res)
  balls   <- suppressWarnings(as.integer(df_local$Balls))
  strikes <- suppressWarnings(as.integer(df_local$Strikes))
  pitchcall <- as.character(df_local$PitchCall)
  valid_counts <- is.finite(balls) & is.finite(strikes)
  if (!any(valid_counts)) return(res)
  prev_valid <- c(FALSE, head(valid_counts, -1))
  new_pa <- valid_counts & ((balls == 0 & strikes == 0) | !prev_valid)
  pa_id <- cumsum(ifelse(valid_counts, new_pa, FALSE))
  if (any(valid_counts) && pa_id[valid_counts][1] == 0) pa_id[valid_counts] <- pa_id[valid_counts] + 1L
  if (all(pa_id[valid_counts] == 0)) pa_id[valid_counts] <- 1L
  pa_id[!valid_counts] <- NA_integer_
  last_idx <- rep(NA_integer_, n)
  if (any(!is.na(pa_id))) {
    last_idx <- ave(seq_len(n), pa_id, FUN = function(idx) rep(max(idx), length(idx)))
  }
  is_last <- seq_len(n) == last_idx
  is_last[is.na(pa_id)] <- FALSE
  strikeout_calls <- c("StrikeSwinging","StrikeCalled","StrikeSwingingBlocked","StrikeSwingingPitchout","StrikeSwingingChecked","StrikeCalledPitchout")
  walk_calls      <- c("BallCalled","BallInDirt","PitchoutBall","IntentBall")
  res$is_last      <- is_last
  res$is_strikeout <- is_last & (strikes == 2) & pitchcall %in% strikeout_calls
  res$is_walk      <- is_last & (balls == 3)   & pitchcall %in% walk_calls
  res
}

compute_pa_flags <- function(df_local) {
  if (!("PlayResult" %in% names(df_local))) df_local$PlayResult <- NA_character_
  if (!("KorBB" %in% names(df_local))) df_local$KorBB <- NA_character_
  if (!("PitchCall" %in% names(df_local))) df_local$PitchCall <- NA_character_
  if (!("Balls" %in% names(df_local))) df_local$Balls <- NA_real_
  if (!("Strikes" %in% names(df_local))) df_local$Strikes <- NA_real_
  
  flags <- pa_flags_from_counts(df_local)
  df_play_result <- as.character(df_local$PlayResult)
  df_korbb       <- as.character(df_local$KorBB)
  df_hit_type    <- as.character(df_local$TaggedHitType %||% NA_character_)
  strikeout_results <- c("Strikeout","StrikeoutSwinging","StrikeoutLooking")
  is_strikeout <- flags$is_strikeout |
    (!is.na(df_play_result) & df_play_result %in% strikeout_results) |
    (!is.na(df_korbb) & df_korbb == "Strikeout")
  is_walk <- flags$is_walk |
    (!is.na(df_play_result) & df_play_result == "Walk") |
    (!is.na(df_korbb) & df_korbb == "Walk")
  is_terminal <- flags$is_last |
    (!is.na(df_play_result) & df_play_result != "Undefined") |
    (!is.na(df_korbb) & df_korbb %in% c("Strikeout","Walk")) |
    (!is.na(df_hit_type) & nzchar(df_hit_type))
  list(df = df_local, is_strikeout = is_strikeout, is_walk = is_walk, is_terminal = is_terminal)
}

default_swing_levels <- function() {
  c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","FoulBall","InPlay")
}

parse_utc_datetime <- function(x) {
  if (is.null(x)) return(as.POSIXct(rep(NA_real_, length(x)), origin = "1970-01-01", tz = "UTC"))
  suppressWarnings({
    a <- as.POSIXct(x, tz = "UTC")  # handles "YYYY-MM-DD HH:MM:SS"
    na <- is.na(a)
    if (any(na)) {
      a2 <- as.POSIXct(strptime(x[na], "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC"))  # ISO-8601
      a[na] <- a2
    }
    na <- is.na(a)
    if (any(na)) {
      a2 <- as.POSIXct(strptime(x[na], "%m/%d/%Y %H:%M:%OS", tz = "UTC"))  # fallback
      a[na] <- a2
    }
    a
  })
}

notes_api_add <- function(author_email, team, page_combo, pitcher, session_type, date_start, date_end, note_text) {
  body <- list(
    token        = NOTES_API_TOKEN,
    author_email = author_email,
    team         = team,
    page         = page_combo,
    pitcher      = pitcher,
    session_type = session_type,
    date_start   = as.character(as.Date(date_start)),
    date_end     = as.character(as.Date(date_end)),
    note_text    = note_text
  )
  
  # --- Try POST first ---
  post_resp <- tryCatch({
    httr2::request(NOTES_API_URL) |>
      httr2::req_method("POST") |>
      httr2::req_body_json(body) |>
      httr2::req_timeout(10) |>
      httr2::req_perform()
  }, error = function(e) e)
  
  if (inherits(post_resp, "httr2_response")) {
    st <- httr2::resp_status(post_resp)
    if (st >= 200 && st < 300) {
      out <- httr2::resp_body_json(post_resp, check_type = FALSE)
      if (!is.null(out$error)) stop(sprintf("Notes API error: %s", out$error))
      return(TRUE)
    }
    # Only special-case 405; anything else bubbles up
    if (st != 405) stop(sprintf("Notes API HTTP %s", st))
  }
  
  # --- 405 path: check for a fresh identical note before fallback ---
  # --- Before any fallback, check if an identical note already exists (robust parse + wider window) ---
  try({
    rows <- notes_api_list()
    if (length(rows)) {
      df <- as.data.frame(rows, stringsAsFactors = FALSE, check.names = FALSE)
      
      ct <- parse_utc_datetime(df$created_at_utc)
      recent <- is.finite(ct) & (as.numeric(difftime(Sys.time(), ct, units = "secs")) <= 90)
      
      same_fields <- (
        df$author_email == author_email &
          df$team         == team &
          df$page         == page_combo &
          (df$pitcher     == pitcher | (is.na(df$pitcher) & pitcher %in% c("", "All"))) &
          (df$session_type== session_type | (is.na(df$session_type) & session_type %in% c("", "All"))) &
          as.character(as.Date(df$date_start)) == as.character(as.Date(date_start)) &
          as.character(as.Date(df$date_end))   == as.character(as.Date(date_end)) &
          df$note_text    == note_text
      )
      
      # If we see the exact same note very recently, or already present at all, skip fallback
      if (any(same_fields & recent, na.rm = TRUE) || any(same_fields, na.rm = TRUE)) {
        return(TRUE)
      }
    }
  }, silent = TRUE)
  
  
  # --- If not already present, do GET fallback once ---
  get_resp <- httr2::request(NOTES_API_URL) |>
    httr2::req_method("GET") |>
    httr2::req_url_query(
      op           = "add",
      token        = body$token,
      author_email = body$author_email,
      team         = body$team,
      page         = body$page,
      pitcher      = body$pitcher,
      session_type = body$session_type,
      date_start   = body$date_start,
      date_end     = body$date_end,
      note_text    = body$note_text
    ) |>
    httr2::req_timeout(10) |>
    httr2::req_perform()
  
  out2 <- httr2::resp_body_json(get_resp, check_type = FALSE)
  if (!is.null(out2$error)) stop(sprintf("Notes API error (GET fallback): %s", out2$error))
  TRUE
}


notes_api_list <- function() {
  req <- httr2::request(NOTES_API_URL) |>
    httr2::req_url_query(token = NOTES_API_TOKEN) |>
    httr2::req_method("GET") |>
    httr2::req_timeout(10)
  resp <- httr2::req_perform(req)
  jsonlite::fromJSON(httr2::resp_body_string(resp))
}


# ---------- Helpers ----------

html_unescape <- function(x) {
  if (is.null(x)) return(x)
  x <- gsub("&lt;",   "<", x, fixed = TRUE)
  x <- gsub("&gt;",   ">", x, fixed = TRUE)
  x <- gsub("&amp;",  "&", x, fixed = TRUE)
  x <- gsub("&quot;", "\"", x, fixed = TRUE)
  x <- gsub("&#39;",  "'", x, fixed = TRUE)
  x
}

# Flexible date parser: ISO (YYYY-MM-DD), m/d/yy, m/d/yyyy, with a 2-digit year pivot
# Anything with a 2-digit year that parses < pivot (default 1970) gets +100 years (e.g., 9/5/25 -> 2025)
parse_date_flex <- function(x, pivot = 1970L) {
  # keep Dates as-is
  if (inherits(x, "Date")) return(x)
  
  x <- trimws(as.character(x))
  x[x %in% c("", "NA", "NaN", "NULL", "null")] <- NA_character_
  
  # parse a bunch of common patterns
  dt <- suppressWarnings(lubridate::parse_date_time(
    x,
    orders = c(
      "Y-m-d", "Ymd",          # 2025-09-05, 20250905
      "m/d/y", "mdy",          # 9/5/25, 09/05/25
      "m/d/Y", "mdy",          # 9/5/2025, 09/05/2025
      "Y-m-d HMS", "mdy HMS",  # with times if present
      "Y-m-d HM",  "mdy HM"
    ),
    tz = "UTC",
    exact = FALSE
  ))
  
  # convert to Date
  d <- as.Date(dt)
  
  # Fix two-digit-year cases that landed in 19xx (or otherwise < pivot)
  yrs <- suppressWarnings(lubridate::year(dt))
  idx <- !is.na(yrs) & yrs < pivot
  if (any(idx)) d[idx] <- as.Date(dt[idx] + lubridate::years(100))
  
  d
}

blank_ea_except_all <- function(df) {
  if (!is.data.frame(df) || !("E+A%" %in% names(df))) return(df)
  
  # Look for any column that might be the grouping/pitch column - expanded list
  pitch_cols <- intersect(c("Pitch","PitchType","TaggedPitchType","SplitColumn",
                            "Batter Hand","Count","After Count","Velocity","IVB","HB",
                            "Batter","Pitcher Hand","Date","Player"), names(df))
  
  # If the table is grouped by Player (leaderboards), keep E+A% values
  if ("Player" %in% pitch_cols) return(df)
  if (!length(pitch_cols)) return(df)
  
  # Safe column access with error handling - check column exists first
  pitch_vals <- tryCatch({
    col_name <- pitch_cols[1]
    if (!col_name %in% names(df)) return(character(0))
    tolower(as.character(df[[col_name]]))
  }, error = function(e) {
    return(character(nrow(df)))
  })
  
  # If couldn't get values or wrong length, return unchanged
  if (!length(pitch_vals) || length(pitch_vals) != nrow(df)) return(df)
  
  keep_all <- is.na(pitch_vals) | pitch_vals == "all"
  # Handle NA values in logical condition
  keep_all[is.na(keep_all)] <- FALSE
  df$`E+A%` <- as.character(df$`E+A%`)
  df$`E+A%`[!keep_all] <- ""
  df
}


# --- DT sanitizers & wrapper (place near other helpers, before UI/server) ---

sanitize_for_dt <- function(dfx) {
  # If someone passed an htmlwidget, just hand it back untouched
  if (inherits(dfx, "htmlwidget") || inherits(dfx, "datatables")) return(dfx)
  
  if (!is.data.frame(dfx)) {
    dfx <- tryCatch(as.data.frame(dfx, stringsAsFactors = FALSE, check.names = FALSE),
                    error = function(e) dfx)
  }
  if (!is.data.frame(dfx)) return(dfx)
  
  dfx <- tibble::as_tibble(dfx)
  
  # Enhanced data sanitization with better error handling
  dfx <- tryCatch({
    dplyr::mutate(
      dfx,
      dplyr::across(where(~ inherits(.x, "POSIXt")), ~ format(.x, "%Y-%m-%d %H:%M:%S")),
      dplyr::across(where(~ inherits(.x, "Date")),    ~ format(.x, "%Y-%m-%d")),
      dplyr::across(where(is.factor), as.character),
      # Enhanced list column handling
      dplyr::across(where(is.list), ~ vapply(.x, function(z) {
        tryCatch({
          if (inherits(z, "shiny.tag") || inherits(z, "shiny.tag.list")) {
            as.character(htmltools::tagList(z))
          } else if (is.null(z) || length(z) == 0) {
            ""
          } else if (length(z) == 1) {
            as.character(z)
          } else {
            paste0(z, collapse = ", ")
          }
        }, error = function(e) "")
      }, FUN.VALUE = character(1))),
      # Ensure all columns are proper types for DT
      dplyr::across(where(is.logical), ~ ifelse(is.na(.x), "FALSE", ifelse(.x, "TRUE", "FALSE"))),
      dplyr::across(where(~ is.numeric(.x) && any(is.infinite(.x), na.rm = TRUE)), 
                    ~ ifelse(is.infinite(.x), ifelse(.x > 0, "Inf", "-Inf"), .x))
    )
  }, error = function(e) {
    message("Error in sanitize_for_dt mutate: ", conditionMessage(e))
    # Return the original data frame if mutation fails
    dfx
  })
  
  dfx
}

# Safe wrapper for compute_process_results with error handling
safe_compute_process_results <- function(df, mode = "All") {
  tryCatch({
    compute_process_results(df, mode)
  }, error = function(e) {
    message("Error in compute_process_results: ", conditionMessage(e))
    # Return a minimal data frame with expected structure
    tibble::tibble(
      PitchType = character(0),
      xWOBA = character(0),
      xISO = character(0),
      BABIP = character(0),
      `Barrel%` = character(0),
      `RV/100` = character(0),
      `GB%` = character(0),
      `CSW%` = character(0)
    )
  })
}

# Safe wrapper for make_summary with error handling (supports alternate grouping)
safe_make_summary <- function(df, group_col = "TaggedPitchType") {
  tryCatch({
    make_summary(df, group_col = group_col)
  }, error = function(e) {
    message("Error in make_summary (group_col = ", group_col, "): ", conditionMessage(e))
    # Return a minimal data frame with expected structure
    tibble::tibble(
      PitchType = character(0),
      PitchCount = integer(0),
      Usage = character(0),
      Overall = character(0),
      BF = integer(0),
      Velo_Avg = numeric(0),
      Velo_Max = numeric(0),
      IVB = numeric(0),
      HB = numeric(0),
      ReleaseTilt = character(0),
      BreakTilt = character(0),
      SpinEff = numeric(0),
      SpinRate = numeric(0),
      RelHeight = numeric(0),
      RelSide = numeric(0),
      VertApprAngle = numeric(0),
      HorzApprAngle = numeric(0),
      Extension = numeric(0),
      InZonePercent = character(0),
      CompPercent = character(0),
      KPercent = character(0),
      BBPercent = character(0),
      FPSPercent = character(0),
      EAPercent = character(0),
      StrikePercent = character(0),
      SwingPercent = character(0),
      WhiffPercent = character(0),
      QPPercent = character(0),
      EV = numeric(0),
      LA = numeric(0),
      `Stuff+` = numeric(0),
      `Ctrl+` = numeric(0),
      `QP+` = numeric(0),
      `Pitching+` = numeric(0)
    )
  })
}

datatable_with_colvis <- function(df, lock = character(0), remember = TRUE, default_visible = names(df), mode = NULL, enable_colors = TRUE) {
  # Enhanced error handling wrapper with validation
  tryCatch({
    # Validate input before processing
    if (!is.data.frame(df) || nrow(df) == 0 || ncol(df) == 0) {
      return(DT::datatable(data.frame(Message = "No data available"), options = list(dom = 't'), rownames = FALSE))
    }
    
    df <- sanitize_for_dt(df)
    
    # Wrap blank_ea_except_all in tryCatch to handle column mismatches gracefully
    df <- tryCatch({
      blank_ea_except_all(df)
    }, error = function(e) {
      message("Warning in blank_ea_except_all: ", e$message)
      df  # Return unchanged if error
    })
    
    default_visible <- intersect(default_visible, names(df))
    
    idx_lock   <- which(names(df) %in% lock) - 1
    all_idx0   <- seq_len(ncol(df)) - 1
    colvis_idx <- setdiff(all_idx0, idx_lock)
    
    defs <- list(
      list(className = "dt-center", targets = "_all"),
      list(targets = "_all", render = DT::JS(js_sort))
    )
    hide_idx <- which(!(names(df) %in% default_visible)) - 1
    if (length(hide_idx)) {
      defs <- c(defs, list(list(visible = FALSE, targets = hide_idx)))
    }
    idx_hash <- which(names(df) == "#") - 1
    if (length(idx_hash)) {
      defs <- c(defs, list(list(
        className = "dt-center clickable-cell",
        targets = idx_hash
      )))
    }
    # Force two-state sorting (asc/desc) on all columns to avoid inconsistent tri-state toggles
    defs <- c(defs, list(list(targets = "_all", orderSequence = c("asc", "desc"))))
    
    build_dt <- function(data) {
      data <- as.data.frame(data, stringsAsFactors = FALSE, check.names = FALSE)
      DT::datatable(
        data,
        rownames   = FALSE,
        extensions = c("Buttons","ColReorder","FixedHeader"),
        escape     = FALSE,
        options = list(
          dom           = "Bfrtip",
          buttons       = list(
            "pageLength",
            list(extend = "colvis", text = "Columns", columns = colvis_idx, postfixButtons = list("colvisRestore"))
          ),
          ordering      = TRUE,
          orderMulti    = TRUE,
          orderClasses  = TRUE,
          colReorder    = TRUE,
          fixedHeader   = TRUE,
          stateSave     = remember,
          stateDuration = -1,
          pageLength    = 10,
          autoWidth     = FALSE,    # Changed from TRUE - lets DataTables calculate proper widths
          scrollX       = TRUE,      # Enable horizontal scrolling
          scrollCollapse = TRUE,     # Allow scroll container to collapse
          columnDefs    = defs
        )
      )
    }
    
    dt <- build_dt(df)
    
    color_modes <- c("Process","Live","Results","Bullpen")
    if (identical(mode, "Usage")) {
      color_modes <- setdiff(color_modes, "Usage")
    }
    # Safe condition checking for color mode - now also checks for split column names
    # Allow colors for any split column (Count, BatterSide, PitcherThrows, InducedVert, HorzBreak, etc.)
    split_col_names <- c("Count", "BatterSide", "Batter Side", "PitcherThrows", "InducedVert", "HorzBreak", 
                         "PitcherSet", "Inning", "TaggedHitType", "Date", "Batter Hand", "After Count", 
                         "Velocity", "Batter")
    has_split_column <- any(split_col_names %in% names(df))
    
    enable_color_mode <- tryCatch({
      !is.null(enable_colors) && 
        !is.na(enable_colors) && 
        isTRUE(enable_colors) &&
        !is.null(mode) &&
        !is.na(mode) &&
        mode %in% color_modes && 
        ("Pitch" %in% names(df) || "Player" %in% names(df) || has_split_column)
    }, error = function(e) FALSE)
    
    if (enable_color_mode) {
      color_cols <- switch(
        mode,
        "Process" = c("InZone%","Comp%","Strike%","Swing%","FPS%","E+A%","QP%","Ctrl+","QP+","Pitching+","RV/100"),
        "Live"    = c("InZone%","Strike%","FPS%","E+A%","QP+","Ctrl+","Pitching+","K%","BB%","Whiff%"),
        "Results" = c("Whiff%","K%","BB%","CSW%","GB%","Barrel%","EV"),
        "Bullpen" = c("InZone%","Comp%","Ctrl+","Stuff+"),
        character(0)
      )
      available_cols <- intersect(color_cols, names(df))
      if (length(available_cols)) {
        df_styled <- as.data.frame(df, stringsAsFactors = FALSE, check.names = FALSE)
        styling_failed <- FALSE
        # Use "all" color scale when split by options other than Pitch are used
        safe_pitch <- if ("Player" %in% names(df_styled) || has_split_column) "all" else NULL
        tryCatch({
          for (col in available_cols) {
            for (i in seq_len(nrow(df_styled))) {
              cell <- df_styled[[col]][i]
              # Check for null, NA, or empty values safely
              cell_check <- tryCatch({
                is.null(cell) || 
                  (length(cell) == 1 && is.na(cell)) || 
                  (length(cell) == 1 && !nzchar(as.character(cell)))
              }, error = function(e) TRUE)
              
              if (cell_check) next
              
              # Safe pitch type extraction with NA protection
              pitch_val <- tryCatch({
                if ("Pitch" %in% names(df_styled) && i <= nrow(df_styled)) {
                  df_styled$Pitch[i]
                } else {
                  NULL
                }
              }, error = function(e) NULL)
              
              pitch_type <- tryCatch({
                if (!is.null(safe_pitch)) {
                  safe_pitch
                } else if (!is.null(pitch_val) && !is.na(pitch_val) && nzchar(as.character(pitch_val))) {
                  as.character(pitch_val)
                } else {
                  "all"
                }
              }, error = function(e) "all")
              
              colors <- get_color_scale(cell, col, pitch_type)
              df_styled[[col]][i] <- paste0(
                '<span style="background-color:', colors$bg,
                '; color:', colors$text,
                '; padding: 2px 4px; border-radius: 3px; display:inline-block; width:100%; text-align:center;">',
                cell, '</span>'
              )
            }
          }
        }, error = function(e) {
          styling_failed <<- TRUE
          msg_mode <- mode %||% "unknown"
          message("datatable_with_colvis color error [mode=", msg_mode, "]: ", conditionMessage(e))
        })
        if (!styling_failed) {
          dt <- build_dt(df_styled)
        }
      }
    }
    
    dt
    
  }, error = function(e) {
    message("datatable_with_colvis error: ", conditionMessage(e))
    # Return a fallback datatable with error message
    DT::datatable(
      data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
      options = list(dom = 't'), rownames = FALSE
    )
  })
}

# Default column sets for the table-mode toggle
stuff_cols        <- c("Pitch","#","Velo","Max","IVB","HB","rTilt","bTilt","SpinEff","Spin","Height","Side","Ext","VAA","HAA","Stuff+")
process_cols      <- c("Pitch","#","BF","RV/100","InZone%","Comp%","Strike%","Swing%","FPS%","E+A%","QP%","Ctrl+","QP+","Pitching+")
results_cols      <- c("Pitch","#","BF","K%","BB%","GB%","Barrel%","Whiff%","CSW%","EV","LA")
results_cols_live <- c("Pitch","#","BF","K%","BB%","GB%","Whiff%","CSW%","EV","LA","Pitching+")
bullpen_cols      <- c("Pitch","#","Velo","Max","IVB","HB","Spin","bTilt","Height","Side","Ext","InZone%","Comp%","Ctrl+","Stuff+")
live_cols         <- c("Pitch","#","Velo","Max","IVB","HB","FPS%","E+A%","InZone%","Strike%","Whiff%","K%","BB%","QP+")
usage_cols        <- c("Pitch","#","Usage","0-0","Behind","Even","Ahead","<2K","2K")
perf_cols         <- c("Pitch","#","BF","RV/100","InZone%","Comp%","Strike%","FPS%","E+A%","K%","BB%","Whiff%","CSW%","EV","LA","Ctrl+","QP+","Pitching+")

# ---- unified list for the pickers + a helper to compute visibility
all_table_cols <- unique(c(stuff_cols, process_cols, results_cols, results_cols_live, bullpen_cols, live_cols, usage_cols, perf_cols, "Overall"))

visible_set_for <- function(mode, custom = character(0), session_type = NULL) {
  if (identical(mode, "Process")) return(process_cols)
  if (identical(mode, "Results")) return(results_cols)
  if (identical(mode, "Bullpen")) return(bullpen_cols)
  if (identical(mode, "Live"))    return(live_cols)
  if (identical(mode, "Usage"))   return(usage_cols)
  if (identical(mode, "Raw Data")) return(c("Pitch","IP","P","BF","P/IP","P/BF","H","XBH","Barrels","BB","HBP","K","Whiffs"))
  if (identical(mode, "Custom"))  return(c("Pitch", custom[!duplicated(custom)]))
  stuff_cols
}

# ---- Custom table storage (shared across suites) ----
custom_tables_file <- "custom_tables.json"
custom_tables <- reactiveVal(list())
load_custom_tables <- function() {
  db_ct <- load_custom_tables_db()
  if (length(db_ct)) return(db_ct)
  if (file.exists(custom_tables_file)) {
    out <- tryCatch(jsonlite::fromJSON(custom_tables_file, simplifyVector = TRUE), error = function(e) NULL)
    if (is.list(out)) {
      out <- lapply(out, function(v) {
        if (is.null(v$school_code)) v$school_code <- current_school()
        v
      })
      out <- out[vapply(out, function(v) v$school_code %in% allowed_school_codes(), logical(1))]
      return(out)
    }
  }
  list()
}
save_custom_tables <- function(x) {
  x <- lapply(x, function(v) {
    if (is.null(v$school_code)) v$school_code <- current_school()
    v
  })
  tryCatch({
    save_custom_tables_db(x)
    # lightweight file backup for convenience
    jsonlite::write_json(x, custom_tables_file, auto_unbox = TRUE, pretty = TRUE)
  }, error = function(e) {
    message("Failed to save custom tables: ", e$message)
  })
}
custom_tables(load_custom_tables())

update_custom_table_choices <- function(session) {
  nms <- names(custom_tables())
  base_modes <- c("Stuff","Process","Results","Swing Decisions","Bullpen","Live","Usage","Raw Data","Batted Ball Data")
  pitch_modes <- setdiff(base_modes, "Swing Decisions")
  safe_update <- function(id) {
    try(updateSelectInput(session, id, choices = c("", nms)), silent = TRUE)
  }
  for (id in c(
    "summaryCustomSaved","dpCustomSaved",
    "cmpA_customSaved","cmpB_customSaved",
    "pp_goal1_customSaved","pp_goal2_customSaved","pp_goal3_customSaved"
  )) safe_update(id)
  # Update table-mode dropdowns to include saved customs (custom always last)
  try(updateSelectInput(session, "summaryTableMode", choices = c(pitch_modes, nms, "Custom"), selected = NULL), silent = TRUE)
  try(updateSelectInput(session, "dpTableMode",       choices = c(pitch_modes, nms, "Custom"), selected = NULL), silent = TRUE)
  for (id in c("cmpA_tableMode","cmpB_tableMode","lbMode")) {
    try(updateSelectInput(session, id, choices = c(base_modes, nms, "Custom"), selected = NULL), silent = TRUE)
  }
}

# Helper to resolve custom table modes (works globally)
resolve_table_mode_global <- function(mode_in, custom_cols_in) {
  ct <- custom_tables()
  if (!is.null(mode_in) && mode_in %in% names(ct)) {
    cols <- ct[[mode_in]]$cols %||% character(0)
    return(list(mode = "Custom", cols = cols))
  }
  list(mode = mode_in %||% "Stuff", cols = custom_cols_in %||% character(0))
}

# ---- Leaderboard: visible set helper (swap Pitch -> Player, drop Overall) ----
visible_set_for_lb <- function(mode, custom = character(0)) {
  v <- visible_set_for(mode, custom)
  v[v == "Pitch"] <- "Player"
  unique(setdiff(v, "Overall"))
}

# -------------------------
# Custom Reports persistence
# -------------------------
custom_reports_file <- "custom_reports.json"
load_custom_reports <- function() {
  db_cr <- load_custom_reports_db()
  if (length(db_cr)) return(db_cr)
  if (file.exists(custom_reports_file)) {
    out <- tryCatch(jsonlite::fromJSON(custom_reports_file, simplifyVector = TRUE), error = function(e) NULL)
    if (is.list(out)) {
      out <- lapply(out, function(v) {
        if (is.null(v$school_code)) v$school_code <- current_school()
        v
      })
      out <- out[vapply(out, function(v) v$school_code %in% allowed_school_codes(), logical(1))]
      return(out)
    }
  }
  list()
}
save_custom_reports <- function(x) {
  x <- lapply(x, function(v) {
    if (is.null(v$school_code)) v$school_code <- current_school()
    v
  })
  tryCatch({
    save_custom_reports_db(x)
    jsonlite::write_json(x, custom_reports_file, auto_unbox = TRUE, pretty = TRUE)
  }, error = function(e) {
    message("Failed to save custom reports: ", e$message)
  })
}
custom_reports_store <- reactiveVal(load_custom_reports())

get_color_scale <- function(value, column_name, pitch_type) {
  # normalize pitch type (fallback to "all" when unknown) - safe checks
  pitch_type <- tryCatch({
    if (length(pitch_type) == 0 || is.na(pitch_type) || !nzchar(as.character(pitch_type))) {
      "all"
    } else {
      tolower(as.character(pitch_type))
    }
  }, error = function(e) "all")
  
  # strip percent/extra chars and coerce to numeric for comparisons - safe checks
  value <- tryCatch({
    if (is.character(value)) {
      val <- gsub("[%\\s]", "", value)
      suppressWarnings(as.numeric(val))
    } else {
      as.numeric(value)
    }
  }, error = function(e) NA_real_)
  
  # Safe value validation
  value_check <- tryCatch({
    length(value) == 0 || is.na(value) || !is.finite(value)
  }, error = function(e) TRUE)
  
  if (value_check) {
    return(list(bg = "white", text = "black"))
  }
  
  thresholds <- get_process_thresholds(column_name, pitch_type)
  if (is.null(thresholds)) return(list(bg = "white", text = "black"))
  poor <- thresholds$poor
  avg  <- thresholds$avg
  great <- thresholds$great
  
  reverse_scale <- column_name %in% c("EV","Barrel%","BB%","RV/100")
  if (reverse_scale) {
    if (value >= poor) return(list(bg = "#0066CC", text = "white"))
    if (value >= (poor + avg)/2) return(list(bg = "#66B2FF", text = "black"))
    if (value >= avg) return(list(bg = "#FFFFFF", text = "black"))
    if (value >= (avg + great)/2) return(list(bg = "#FFB3B3", text = "black"))
    if (value >= great) return(list(bg = "#FF6666", text = "white"))
    return(list(bg = "#CC0000", text = "white"))
  }
  
  if (value <= poor) return(list(bg = "#0066CC", text = "white"))
  if (value <= (poor + avg)/2) return(list(bg = "#66B2FF", text = "black"))
  if (value <= avg) return(list(bg = "#FFFFFF", text = "black"))
  if (value <= (avg + great)/2) return(list(bg = "#FFB3B3", text = "black"))
  if (value <= great) return(list(bg = "#FF6666", text = "white"))
  list(bg = "#CC0000", text = "white")
}

get_process_thresholds <- function(column_name, pitch_type) {
  pitch_type <- tolower(as.character(pitch_type))
  if (column_name == "InZone%") {
    if (pitch_type %in% c("fastball","sinker")) return(list(poor = 43, avg = 50, great = 57))
    if (pitch_type %in% c("cutter","slider","sweeper","curveball")) return(list(poor = 37, avg = 43, great = 49))
    if (pitch_type %in% c("changeup","splitter","knuckleball")) return(list(poor = 30, avg = 37, great = 44))
    if (pitch_type == "all") return(list(poor = 42, avg = 47, great = 52))
  }
  if (column_name == "Comp%") {
    if (pitch_type %in% c("fastball","sinker")) return(list(poor = 79, avg = 83, great = 87))
    if (pitch_type %in% c("cutter","slider","sweeper","curveball")) return(list(poor = 70, avg = 76, great = 82))
    if (pitch_type %in% c("changeup","splitter","knuckleball")) return(list(poor = 65, avg = 74, great = 83))
    if (pitch_type == "all") return(list(poor = 76, avg = 79, great = 82))
  }
  if (column_name == "Strike%") return(list(poor = 57, avg = 62, great = 67))
  if (column_name == "Swing%") {
    if (pitch_type %in% c("fastball","sinker")) return(list(poor = 40, avg = 44, great = 48))
    if (pitch_type %in% c("cutter","slider","sweeper")) return(list(poor = 37, avg = 43, great = 49))
    if (pitch_type == "curveball") return(list(poor = 28, avg = 35, great = 42))
    if (pitch_type %in% c("changeup","splitter")) return(list(poor = 43, avg = 47, great = 51))
    if (pitch_type == "all") return(list(poor = 40, avg = 45, great = 50))
  }
  if (column_name == "FPS%") return(list(poor = 55, avg = 60, great = 65))
  if (column_name == "E+A%" && pitch_type == "all") return(list(poor = 65, avg = 70, great = 75))
  if (column_name == "QP%") return(list(poor = 38, avg = 48, great = 58))
  if (column_name == "Ctrl+") return(list(poor = 75, avg = 85, great = 95))
  if (column_name == "QP+") return(list(poor = 75, avg = 90, great = 105))
  if (column_name == "Pitching+") return(list(poor = 80, avg = 95, great = 110))
  if (column_name == "K%" && pitch_type == "all") return(list(poor = 18, avg = 23, great = 28))
  if (column_name == "BB%" && pitch_type == "all") return(list(poor = 11, avg = 9, great = 7))
  if (column_name == "Whiff%") {
    if (pitch_type == "fastball") return(list(poor = 18, avg = 22, great = 26))
    if (pitch_type == "sinker") return(list(poor = 9, avg = 13, great = 17))
    if (pitch_type == "cutter") return(list(poor = 22, avg = 27, great = 32))
    if (pitch_type %in% c("sweeper","curveball","slider","changeup","splitter")) return(list(poor = 29, avg = 35, great = 41))
    if (pitch_type == "all") return(list(poor = 21, avg = 26, great = 31))
  }
  if (column_name == "CSW%") {
    if (pitch_type %in% c("fastball","sinker")) return(list(poor = 23, avg = 27, great = 31))
    if (pitch_type %in% c("cutter","slider","sweeper","curveball")) return(list(poor = 29, avg = 32, great = 35))
    if (pitch_type %in% c("splitter","changeup")) return(list(poor = 22, avg = 28, great = 34))
    if (pitch_type == "all") return(list(poor = 26, avg = 29, great = 32))
  }
  if (column_name == "GB%") {
    if (pitch_type == "fastball") return(list(poor = 31, avg = 39, great = 47))
    if (pitch_type == "sinker") return(list(poor = 43, avg = 54, great = 65))
    if (pitch_type %in% c("cutter","slider","sweeper","curveball")) return(list(poor = 36, avg = 43, great = 50))
    if (pitch_type %in% c("changeup","splitter")) return(list(poor = 35, avg = 47, great = 59))
    if (pitch_type == "all") return(list(poor = 38, avg = 43, great = 48))
  }
  if (column_name == "Barrel%") return(list(poor = 20, avg = 15, great = 10))
  if (column_name == "EV") return(list(poor = 95, avg = 85, great = 75))
  if (column_name == "Stuff+") return(list(poor = 90, avg = 100, great = 110))
  if (column_name == "RV/100") {
    # lower is better for RV/100
    if (pitch_type == "fastball")   return(list(poor = 1.5, avg = 0.7,  great = -0.1))
    if (pitch_type == "sinker")     return(list(poor = 2.3, avg = 0.9,  great = -0.5))
    if (pitch_type == "cutter")     return(list(poor = 0.9, avg = -0.2, great = -1.3))
    if (pitch_type == "slider")     return(list(poor = -0.4, avg = -1.1, great = -1.8))
    if (pitch_type == "curveball")  return(list(poor = -0.1, avg = -1.3, great = -2.5))
    if (pitch_type == "changeup")   return(list(poor = 0.7, avg = -0.5, great = -1.7))
    if (pitch_type == "splitter")   return(list(poor = 0.0, avg = -1.4, great = -2.8))
    # default / All
    return(list(poor = 0.7, avg = 0.0, great = -0.7))
  }
  NULL
}

# ---- Local helpers (self-contained) ----
.s_nz_mean <- function(x) {
  x <- suppressWarnings(as.numeric(x))
  if (!length(x)) return(NA_real_)
  m <- mean(x, na.rm = TRUE)
  if (is.nan(m)) NA_real_ else m
}
.s_safe_div <- function(num, den) {
  num <- suppressWarnings(as.numeric(num))
  den <- suppressWarnings(as.numeric(den))
  ifelse(is.finite(den) & den != 0, num/den, NA_real_)
}
.s_fmt_pct1 <- function(num, den) {
  p <- .s_safe_div(num, den)
  ifelse(is.finite(p), paste0(round(100*p, 1), "%"), "")
}
.s_ip_fmt <- function(ip_num) {
  if (!is.finite(ip_num)) return(NA_character_)
  outs <- round(ip_num * 3)
  paste0(outs %/% 3, ".", outs %% 3)
}
.s_to_date <- function(x) {
  # Accept Date, POSIX, numeric serial (Excel), ISO, and m/d/y
  if (inherits(x, "Date")) return(x)
  if (inherits(x, "POSIXt")) return(as.Date(x))
  # try numeric Excel serial
  num <- suppressWarnings(as.numeric(x))
  out <- rep(as.Date(NA), length(x))
  if (any(!is.na(num))) {
    is_serial <- !is.na(num) & num > 20000 & num < 60000
    out[is_serial] <- as.Date(num[is_serial], origin = "1899-12-30")
  }
  # try ISO
  bad <- is.na(out)
  if (any(bad)) {
    out[bad] <- suppressWarnings(as.Date(x[bad]))
    bad <- is.na(out)
  }
  # try m/d/y
  if (any(bad)) {
    out[bad] <- suppressWarnings(as.Date(x[bad], format = "%m/%d/%Y"))
    bad <- is.na(out)
    if (any(bad)) out[bad] <- suppressWarnings(as.Date(x[bad], format = "%m/%d/%y"))
  }
  out
}

# --- Shared BF (Batters Faced) calculation ---
# Counts PAs that start at 0-0 and only include them if the final pitch
# ends in a Strikeout/Walk (KorBB) or has a non-Undefined PlayResult.
calculate_bf <- function(df) {
  if (!nrow(df)) return(0L)
  
  balls   <- suppressWarnings(as.numeric(df$Balls))
  strikes <- suppressWarnings(as.numeric(df$Strikes))
  valid   <- is.finite(balls) & is.finite(strikes)
  if (!any(valid)) return(0L)
  
  prev_valid <- c(FALSE, head(valid, -1))
  new_pa     <- valid & ((balls == 0 & strikes == 0) | !prev_valid)
  pa_id      <- cumsum(ifelse(valid, new_pa, FALSE))
  if (any(valid) && pa_id[valid][1] == 0) pa_id[valid] <- pa_id[valid] + 1L
  if (all(pa_id[valid] == 0)) pa_id[valid] <- 1L
  pa_id[!valid] <- NA_integer_
  
  # Identify last pitch per PA
  last_idx <- ave(seq_len(nrow(df)), pa_id, FUN = function(idx) rep(max(idx), length(idx)))
  is_last  <- seq_len(nrow(df)) == last_idx
  
  playres <- as.character(df$PlayResult)
  korbb   <- as.character(df$KorBB)
  terminal_ok <- (!is.na(playres) & playres != "Undefined") |
    (!is.na(korbb) & korbb %in% c("Strikeout","Walk"))
  
  last_ok <- is_last & terminal_ok
  if (!any(!is.na(pa_id))) return(0L)
  valid_pa <- !is.na(pa_id)
  pa_vec   <- pa_id[valid_pa]
  last_vec <- last_ok[valid_pa]
  sum(tapply(last_vec, pa_vec, function(x) any(x, na.rm = TRUE)), na.rm = TRUE)
}

# BF helper used elsewhere; now just calls the unified calculation
calculate_completed_bf <- function(df) calculate_bf(df)

# BF that only counts completed PAs (Live only) — helps avoid partial/empty PAs
calculate_completed_bf <- function(df) {
  d <- df %>% dplyr::filter(SessionType == "Live")
  if (!nrow(d)) return(0L)
  
  balls   <- suppressWarnings(as.numeric(d$Balls))
  strikes <- suppressWarnings(as.numeric(d$Strikes))
  valid   <- is.finite(balls) & is.finite(strikes)
  if (!any(valid)) return(0L)
  
  prev_valid <- c(FALSE, head(valid, -1))
  new_pa     <- valid & ((balls == 0 & strikes == 0) | !prev_valid)
  pa_id      <- cumsum(ifelse(valid, new_pa, FALSE))
  if (any(valid) && pa_id[valid][1] == 0) pa_id[valid] <- pa_id[valid] + 1L
  if (all(pa_id[valid] == 0)) pa_id[valid] <- 1L
  pa_id[!valid] <- NA_integer_
  
  pf <- compute_pa_flags(d)
  is_terminal <- pf$is_terminal
  if (length(is_terminal) != length(pa_id)) is_terminal <- rep(FALSE, length(pa_id))
  
  completed_pa <- tapply(is_terminal, pa_id, function(x) any(x, na.rm = TRUE))
  completed_pa <- completed_pa[!is.na(names(completed_pa))]
  sum(as.logical(completed_pa), na.rm = TRUE)
}

# --- Keep Process tables in canonical order: "#, BF, Usage, ..."
enforce_process_order <- function(df) {
  if (all(c("#","BF") %in% names(df)))   df <- dplyr::relocate(df, `BF`, .after = `#`)
  if (all(c("BF","RV/100") %in% names(df))) df <- dplyr::relocate(df, `RV/100`, .after = `BF`)
  if (all(c("RV/100","Usage") %in% names(df))) df <- dplyr::relocate(df, Usage, .after = `RV/100`)
  else if (all(c("BF","Usage") %in% names(df))) df <- dplyr::relocate(df, Usage, .after = `BF`)
  if (all(c("E+A%","QP%") %in% names(df))) df <- dplyr::relocate(df, `QP%`, .after = `E+A%`)
  df
}

# --- Ensure the “All” row has QP% populated (using the current data frame) ---
fill_all_qp_pct <- function(df_table, src_df) {
  if (missing(src_df) || is.null(src_df) || !is.data.frame(src_df) || !nrow(src_df)) return(df_table)
  if (!("QP%" %in% names(df_table))) return(df_table)
  
  idx <- rep(FALSE, nrow(df_table))
  
  # Look across common split columns first
  for (col in c("Pitch","PitchType","SplitColumn","Player")) {
    if (col %in% names(df_table)) {
      val <- tolower(as.character(df_table[[col]]))
      clean <- gsub("[^a-z0-9]+", "", val)
      idx <- idx | val == "all" | grepl("^all\\b", val) | grepl("^all", clean) | clean == "overall"
    }
  }
  
  # If still none, scan all character columns for an "all"-like label
  if (!any(idx)) {
    char_cols <- vapply(df_table, is.character, logical(1))
    if (any(char_cols)) {
      vals <- apply(df_table[, char_cols, drop = FALSE], 2, function(v) tolower(as.character(v)))
      if (is.vector(vals)) vals <- matrix(vals, ncol = 1)
      clean_vals <- apply(vals, 2, function(v) gsub("[^a-z0-9]+", "", v))
      idx <- apply(vals, 1, function(row) any(grepl("^all", row) | row %in% c("all","all players","all pitchers","all pitch types","(all pitch types)"))) |
        apply(clean_vals, 1, function(row) any(grepl("^all", row) | row == "overall"))
    }
  }
  
  missing_qp <- which(is.na(df_table$`QP%`) | df_table$`QP%` == "")
  idx_any <- isTRUE(any(idx))
  if (!idx_any && length(missing_qp) == 1) {
    idx[missing_qp] <- TRUE
  }
  if (!idx_any && length(missing_qp) > 1) {
    idx[missing_qp] <- TRUE
  }
  if (!isTRUE(any(idx))) return(df_table)
  
  qp_val <- safe_pct(
    sum((compute_qp_points(src_df) * 200) >= 100, na.rm = TRUE),
    nrow(src_df)
  )
  df_table$`QP%`[idx] <- qp_val
  df_table
}

# --- Keep Stuff tables with Ext immediately after Side
enforce_stuff_order <- function(df) {
  # Normalize name if some paths still call it "Extension"
  if ("Extension" %in% names(df) && !("Ext" %in% names(df))) {
    df <- dplyr::rename(df, Ext = Extension)
  }
  if (all(c("Side","Ext") %in% names(df))) {
    df <- dplyr::relocate(df, Ext, .after = Side)
  }
  df
}

# Visible set when we group by Date instead of Pitch
visible_set_for_date <- function(mode, custom = character(0)) {
  base <- if (exists("visible_set_for")) visible_set_for(mode, custom) else names(data.frame())
  base[base == "Pitch"] <- "Date"
  setdiff(base, "Usage")
}

# Build the by-date table (averages & rates), honoring Live/Bullpen via filtered_logs()
make_session_logs_table <- function(df) {
  if (!nrow(df)) return(tibble::tibble())
  
  # Pull a FIP constant if available, otherwise 0 (so it never errors)
  fipc <- if (!is.null(get0("FIP_C"))) get0("FIP_C") else if (!is.null(get0("FIP_CONST"))) get0("FIP_CONST") else 0
  
  # Zone bounds (fallbacks in case globals aren’t visible yet)
  zl <- if (!is.null(get0("ZONE_LEFT")))   get0("ZONE_LEFT")   else -0.83
  zr <- if (!is.null(get0("ZONE_RIGHT")))  get0("ZONE_RIGHT")  else  0.83
  zb <- if (!is.null(get0("ZONE_BOTTOM"))) get0("ZONE_BOTTOM") else  1.5
  zt <- if (!is.null(get0("ZONE_TOP")))    get0("ZONE_TOP")    else  3.5
  
  swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
  
  # Normalize a Date column, regardless of source name
  if (!("Date" %in% names(df))) {
    cand <- intersect(c("GameDate","SessionDate","date","DATE"), names(df))
    if (length(cand)) {
      df$Date <- df[[cand[1]]]
    }
  }
  df$Date <- .s_to_date(df$Date)
  
  # Group and compute
  by_date <- df %>%
    dplyr::filter(!is.na(Date)) %>%
    dplyr::group_by(Date) %>%
    dplyr::group_map(~{
      d <- .x
      
      # PA proxy for Live (first-pitch opportunities)
      PAt      <- sum(d$SessionType == "Live" & d$Balls == 0 & d$Strikes == 0, na.rm = TRUE)
      HBP_all  <- sum(d$PlayResult == "HitByPitch", na.rm = TRUE)
      Sac_all  <- sum(d$PlayResult == "Sacrifice",  na.rm = TRUE)
      H1       <- sum(d$PlayResult == "Single",     na.rm = TRUE)
      H2       <- sum(d$PlayResult == "Double",     na.rm = TRUE)
      H3       <- sum(d$PlayResult == "Triple",     na.rm = TRUE)
      HR       <- sum(d$PlayResult == "HomeRun",    na.rm = TRUE)
      H        <- H1 + H2 + H3 + HR
      Kct_all  <- sum(d$KorBB == "Strikeout" |
                        d$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
      BBc_all  <- sum(d$KorBB == "Walk" | d$PlayResult == "Walk", na.rm = TRUE)
      ABt      <- PAt - (BBc_all + HBP_all + Sac_all)
      
      # Swings/whiffs
      swings   <- sum(!is.na(d$PitchCall) & d$PitchCall %in% swing_levels, na.rm = TRUE)
      whiffs   <- sum(d$PitchCall == "StrikeSwinging", na.rm = TRUE)
      
      # EV/LA from live balls in play
      bbe      <- d %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
      ev_all   <- .s_nz_mean(bbe$ExitSpeed)
      la_all   <- .s_nz_mean(bbe$Angle)
      
      # IP/FIP/WHIP
      Outs_all <- (ABt - H) + Sac_all
      IP_all   <- .s_safe_div(Outs_all, 3)
      FIP_all  <- { tmp <- .s_safe_div(13*HR + 3*(BBc_all + HBP_all) - 2*Kct_all, IP_all)
      ifelse(is.finite(tmp), round(tmp + fipc, 2), NA_real_) }
      WHIP_all <- { tmp <- .s_safe_div(H + BBc_all, IP_all)
      ifelse(is.finite(tmp), round(tmp, 2), NA_real_) }
      
      # Command score (“Ctrl+”) with your 1.47 / 0.73 scoring
      scores <- ifelse(
        d$PlateLocSide  >= zl  & d$PlateLocSide  <= zr &
          d$PlateLocHeight>= zb  & d$PlateLocHeight<= zt, 1.47,
        ifelse(
          d$PlateLocSide >= -1.5 & d$PlateLocSide <= 1.5 &
            d$PlateLocHeight>= (2.65 - 1.5) & d$PlateLocHeight <= (2.65 + 1.5),
          0.73, 0
        )
      )
      ctrl_all  <- round(mean(scores, na.rm = TRUE) * 100, 1)
      stuff_all <- round(.s_nz_mean(d$`Stuff+`), 1)
      
      # QP+ scalar — use your real one if available; else NA
      qp_points <- compute_qp_points(d)
      qp_all <- if (!is.null(get0("safe_qp_scalar"))) get0("safe_qp_scalar")(d) else NA_real_
      qp_pct <- .s_fmt_pct1(sum((qp_points * 200) >= 100, na.rm = TRUE), nrow(d))
      pitc_all <- round(.s_nz_mean(c(stuff_all, qp_all)), 1)
      
      tibble::tibble(
        Date     = as.Date(d$Date[1]),
        `#`      = nrow(d),
        Usage    = "",
        BF       = PAt,
        IP       = .s_ip_fmt(IP_all),
        FIP      = FIP_all,
        WHIP     = WHIP_all,
        Velo     = .s_nz_mean(d$RelSpeed),
        Max      = suppressWarnings(max(d$RelSpeed, na.rm = TRUE)),
        IVB      = .s_nz_mean(d$InducedVertBreak),
        HB       = .s_nz_mean(d$HorzBreak),
        rTilt    = .s_nz_mean(d$ReleaseTilt),
        bTilt    = .s_nz_mean(d$BreakTilt),
        SpinEff  = .s_nz_mean(d$SpinEfficiency),
        Spin     = .s_nz_mean(d$SpinRate),
        Height   = .s_nz_mean(d$RelHeight),
        Side     = .s_nz_mean(d$RelSide),
        VAA      = .s_nz_mean(d$VertApprAngle),
        HAA      = .s_nz_mean(d$HorzApprAngle),
        Ext      = .s_nz_mean(d$Extension),
        `InZone%`= .s_safe_div(
          sum(d$PlateLocSide >= zl & d$PlateLocSide <= zr &
                d$PlateLocHeight >= zb & d$PlateLocHeight <= zt, na.rm = TRUE),
          nrow(d)
        ),
        `Comp%`  = .s_safe_div(
          sum(d$PlateLocSide >= -1.5 & d$PlateLocSide <= 1.5 &
                d$PlateLocHeight >= (2.65 - 1.5) & d$PlateLocHeight <= (2.65 + 1.5), na.rm = TRUE),
          nrow(d)
        ),
        `Strike%`= .s_safe_div(
          sum(d$PitchCall %in% c("StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"),
              na.rm = TRUE),
          nrow(d)
        ),
        `FPS%`   = .s_fmt_pct1(
          sum(d$Balls==0 & d$Strikes==0 &
                d$PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","StrikeCalled"),
              na.rm = TRUE),
          sum(d$Balls==0 & d$Strikes==0, na.rm = TRUE)
        ),
        `E+A%`   = .s_fmt_pct1(
          sum(d$SessionType=="Live" & (
            (d$Balls==0 & d$Strikes==0 & d$PitchCall=="InPlay") |
              (d$Balls==0 & d$Strikes==1 & d$PitchCall %in% c("InPlay","FoulBallNotFieldable", "FoulBallFieldable","StrikeSwinging","StrikeCalled")) |
              (d$Balls==1 & d$Strikes==0 & d$PitchCall=="InPlay") |
              (d$Balls==1 & d$Strikes==1 & d$PitchCall %in% c("InPlay","FoulBallNotFieldable","StrikeSwinging","StrikeCalled", "FoulBallFieldable"))
          ), na.rm = TRUE),
          sum(d$SessionType=="Live" & d$Balls==0 & d$Strikes==0, na.rm = TRUE)
        ),
        `QP%`    = qp_pct,
        `K%`     = .s_safe_div(Kct_all, PAt),
        `BB%`    = .s_safe_div(BBc_all, PAt),
        `Whiff%` = .s_safe_div(whiffs, swings),
        `CSW%` = .s_safe_div(
          sum(d$PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE),
          nrow(d)
        ),
        EV       = ev_all,
        LA       = la_all,
        `Stuff+` = stuff_all,
        `Ctrl+`  = ctrl_all,
        `QP+`    = qp_all,
        `Pitching+` = pitc_all
      )
    }) %>%
    dplyr::bind_rows() %>%
    dplyr::arrange(dplyr::desc(Date))
  
  by_date
}

assign_where <- function(vec, cond, value) {
  idx <- which(!is.na(cond) & cond)
  if (length(idx)) vec[idx] <- value
  vec
}

# ----- Hover tooltip helpers -----
inzone_label <- function(side, height) {
  comp   <- !is.na(side) & !is.na(height) &
    side >= -1.5 & side <= 1.5 &
    height >= (2.65 - 1.5) & height <= (2.65 + 1.5)
  inzone <- !is.na(side) & !is.na(height) &
    side >= ZONE_LEFT & side <= ZONE_RIGHT &
    height >= ZONE_BOTTOM & height <= ZONE_TOP
  ifelse(inzone, "Yes", ifelse(comp, "Competitive", "No"))
}

# ---- NEW: display helpers ----
# ---- NEW: display helpers (can live near other helpers) ----
fmt_rate3 <- function(x) {
  x <- suppressWarnings(as.numeric(x))
  s <- ifelse(is.finite(x), sprintf("%.3f", x), "")
  sub("^0\\.", ".", s)  # .303 style (no leading 0) for 0.xxx
}
fmt_num2  <- function(x) ifelse(is.finite(x), sprintf("%.2f", x), "")
fmt_pct1  <- function(num, den) {
  num <- suppressWarnings(as.numeric(num)); den <- suppressWarnings(as.numeric(den))
  if (is.finite(den) && den > 0 && is.finite(num)) paste0(round(100*num/den, 1), "%") else ""
}

make_hover_tt <- function(df) {
  paste0(
    "Session: ", as.character(df$SessionType),
    "<br>Velo: ", ifelse(is.na(df$RelSpeed), "", sprintf("%.1f mph", df$RelSpeed)),
    "<br>IVB: " , ifelse(is.na(df$InducedVertBreak), "", sprintf("%.1f in", df$InducedVertBreak)),
    "<br>HB: "  , ifelse(is.na(df$HorzBreak), "", sprintf("%.1f in", df$HorzBreak)),
    "<br>Stuff+: ", ifelse(is.na(df$`Stuff+`), "", sprintf("%.1f", df$`Stuff+`)),
    "<br>In Zone: ", inzone_label(df$PlateLocSide, df$PlateLocHeight)
  )
}

make_release_tt <- function(df) {
  paste0(
    "Session: ", as.character(df$SessionType),
    "<br>Height: ", ifelse(is.na(df$RelHeight), "", sprintf("%.2f ft", df$RelHeight)),
    "<br>Side: ", ifelse(is.na(df$RelSide), "", sprintf("%.2f ft", df$RelSide)),
    "<br>Extension: ", ifelse(is.na(df$Extension), "", sprintf("%.2f ft", df$Extension))
  )
}


# ---- Outcomes & helpers (GLOBAL) ----
result_levels <- c(
  "Called Strike", "Ball", "Foul", "Whiff",
  "In Play (Out)", "In Play (Hit)",
  "Single", "Double", "Triple", "HomeRun", "Error"
)

# Hitting play results (for spray charts)
hit_levels <- c("Single", "Double", "Triple", "HomeRun")

shape_map <- c(
  "Called Strike" = 19,  # filled circle
  "Ball"          = 1,   # hollow circle
  "Foul"          = 2,   # hollow triangle
  "Whiff"         = 8,   # star
  "In Play (Out)" = 17,  # filled triangle
  "In Play (Hit)" = 15,  # filled square
  "Single"        = 15,  # use In Play (Hit) icon
  "Double"        = 15,  # use In Play (Hit) icon
  "Triple"        = 15,  # use In Play (Hit) icon
  "HomeRun"       = 15,  # use In Play (Hit) icon
  "Error"         = 0    # hollow square
)

# Hitting shape map (for location plots with hitting data)
hit_shape_map <- c(
  "Called Strike" = 19,
  "Ball"          = 1,
  "Foul"          = 2,
  "Whiff"         = 8,
  "In Play"       = 17,
  "Error"         = 0
)

compute_result <- function(pitch_call, play_result) {
  dplyr::case_when(
    pitch_call == "StrikeCalled" ~ "Called Strike",
    pitch_call == "BallCalled"   ~ "Ball",
    pitch_call %in% c("FoulBallNotFieldable","FoulBallFieldable") ~ "Foul",
    pitch_call == "StrikeSwinging" ~ "Whiff",
    pitch_call == "InPlay" & play_result %in% c("Out","FieldersChoice","Sacrifice") ~ "In Play (Out)",
    pitch_call == "InPlay" & play_result %in% c("Single","Double","Triple","HomeRun")       ~ "In Play (Hit)",
    pitch_call == "InPlay" & play_result == "Error" ~ "Error",
    TRUE ~ NA_character_
  )
}

# QP+ Locations plotting function - creates a grid of strike zones for each pitch type
create_qp_locations_plot <- function(data, count_state, pitcher_hand, batter_hand) {
  # Validate inputs
  if (is.null(data) || nrow(data) == 0) {
    return(ggplot() + 
             annotate("text", x = 0, y = 2.5, label = "No data available", size = 6) +
             theme_void())
  }
  
  if (is.null(count_state) || is.null(pitcher_hand) || is.null(batter_hand)) {
    return(ggplot() + 
             annotate("text", x = 0, y = 2.5, label = "Missing parameters", size = 6) +
             theme_void())
  }
  
  # Try to filter data safely
  tryCatch({
    # Filter data for the specific count state
    state_data <- data %>%
      dplyr::filter(
        !is.na(PlateLocSide), !is.na(PlateLocHeight),
        !is.na(Balls), !is.na(Strikes)
      ) %>%
      dplyr::mutate(
        count_group = count_state_vec(Balls, Strikes)
      ) %>%
      dplyr::filter(count_group == count_state)
    
    if (nrow(state_data) == 0) {
      return(ggplot() + 
               annotate("text", x = 0, y = 2.5, label = paste("No data for", count_state, "counts"), size = 5) +
               theme_void())
    }
    
    # Get unique pitch types in the data
    pitch_types <- sort(unique(state_data$TaggedPitchType))
    pitch_types <- pitch_types[!is.na(pitch_types)]
    
    if (length(pitch_types) == 0) {
      return(ggplot() + 
               annotate("text", x = 0, y = 2.5, label = "No pitch types available", size = 6) +
               theme_void())
    }
    
    # Helper function to get custom seeds for count-specific adjustments
    get_custom_seeds_for_count <- function(pt, hand, state) {
      pt <- as.character(pt)
      hand <- ifelse(hand %in% c("Left","Right"), hand, "Right")
      
      glove_col <- ifelse(hand == "Left", 3, 1)
      arm_col   <- ifelse(glove_col == 1, 3, 1)
      
      r_top <- 1; r_mid <- 2; r_bot <- 3
      c_mid <- 2; c_g  <- glove_col; c_a <- arm_col
      
      # Apply count-specific modifications
      if (pt == "Fastball") {
        if (state == "Behind") {
          # For Behind fastballs: make middle very blue, bottom light red
          return(data.frame(r = c(r_top, r_top, r_top, r_mid, r_mid, r_mid, r_bot, r_bot, r_bot),
                            c = c(c_mid, c_g,   c_a,   c_mid, c_g,   c_a,   c_mid, c_g,   c_a),
                            w = c(1.00,  1.00,  1.00,  0.05,  0.05,  0.05,  0.85,  0.85,  0.85)))
        } else if (state == "Ahead") {
          # For Ahead fastballs: make red bottom zone thinner (closer to actual bottom)
          # Add more middle positions that are blue, keep only bottom edge red
          return(data.frame(r = c(r_top, r_top, r_top, r_mid, r_mid, r_mid, r_bot, r_bot, r_bot),
                            c = c(c_mid, c_g,   c_a,   c_mid, c_g,   c_a,   c_mid, c_g,   c_a),
                            w = c(1.00,  1.00,  1.00,  0.30,  0.30,  0.30,  0.50,  0.50,  0.50)))
        } else {
          # For Even fastballs: standard middle/bottom switch
          return(data.frame(r = c(r_top, r_top, r_top, r_mid, r_mid, r_mid, r_bot, r_bot, r_bot),
                            c = c(c_mid, c_g,   c_a,   c_mid, c_g,   c_a,   c_mid, c_g,   c_a),
                            w = c(1.00,  1.00,  1.00,  0.30,  0.30,  0.30,  0.70,  0.70,  0.70)))
        }
      } else if (pt == "Cutter") {
        # For Cutter: make bottom glove side same intensity as middle/upper glove side
        return(data.frame(r = c(r_mid, r_top, r_top, r_bot),
                          c = c(c_g,   c_g,   c_mid, c_g),
                          w = c(1.00,  1.00,  0.75,  1.00)))  # Bottom glove now 1.00 instead of 0.80
      }
      
      # Return NULL to use original seeds for other pitch types/counts
      return(NULL)
    }
    
    # Shared scorer so tiles and pitch tooltips stay in sync (includes out-of-zone penalties)
    score_location <- function(x, y, pt, p_hand, state, session_type = NULL) {
      # Only score live pitches when we have session metadata
      if (!is.null(session_type) && !is.na(session_type) && session_type != "Live") {
        return(NA_real_)
      }
      if (is.na(x) || is.na(y) || is.na(pt)) return(NA_real_)
      
      sq <- zone9_square(x, y)
      
      # Start with base QP+ score (0-200 scale)
      if (is.na(sq)) {
        base_score <- 0  # Outside competitive zone
      } else {
        custom_seeds <- get_custom_seeds_for_count(pt, p_hand, state)
        if (!is.null(custom_seeds)) {
          # Count-specific seed weighting
          rc <- sq_to_rc(sq)
          dec <- qp_decay(state)
          best <- 0
          for (j in seq_len(nrow(custom_seeds))) {
            d  <- abs(custom_seeds$r[j] - rc$r) + abs(custom_seeds$c[j] - rc$c)
            di <- ifelse(d >= 3, 4, d + 1)
            best <- max(best, custom_seeds$w[j] * dec[di])
          }
          base_score <- best * 200
        } else {
          # Default weighting
          base_score <- qp_weight_for_square(sq, pt, p_hand, state) * 200
        }
      }
      
      # Apply count/state penalties for out-of-zone locations
      if (state %in% c("Behind", "Even", "Ahead")) {
        outside_zone <- (x < ZONE_LEFT || x > ZONE_RIGHT ||
                           y < ZONE_BOTTOM || y > ZONE_TOP)
        
        if (outside_zone) {
          # Distance to the nearest part of the strike zone
          x_dist <- pmax(0, pmax(ZONE_LEFT - x, x - ZONE_RIGHT))
          y_dist <- pmax(0, pmax(ZONE_BOTTOM - y, y - ZONE_TOP))
          zone_distance <- sqrt(x_dist^2 + y_dist^2)
          
          below_zone <- y < ZONE_BOTTOM
          over_plate <- x >= ZONE_LEFT && x <= ZONE_RIGHT
          plate_width <- ZONE_RIGHT - ZONE_LEFT
          expanded_plate <- x >= (ZONE_LEFT - plate_width/3) && x <= (ZONE_RIGHT + plate_width/3)
          very_low_over_plate <- below_zone && over_plate && y >= (ZONE_BOTTOM - 0.4)
          low_over_expanded_plate <- below_zone && expanded_plate
          is_non_fastball_sinker <- pt %in% c("Cutter", "Slider", "Sweeper", "Curveball", "ChangeUp", "Splitter")
          
          if (state == "Behind") {
            distance_penalty <- pmin(0.9, 0.5 + zone_distance * 0.8)
            if (zone_distance > 0.5) {
              distance_penalty <- pmin(0.95, 0.7 + zone_distance * 1.2)
            }
          } else if (state == "Even") {
            if (below_zone && is_non_fastball_sinker) {
              distance_penalty <- pmin(0.6, 0.15 + zone_distance * 0.4)
              if (zone_distance > 0.5) {
                distance_penalty <- pmin(0.75, 0.25 + zone_distance * 0.5)
              }
            } else {
              distance_penalty <- pmin(0.75, 0.3 + zone_distance * 0.6)
              if (zone_distance > 0.5) {
                distance_penalty <- pmin(0.85, 0.5 + zone_distance * 0.8)
              }
            }
          } else { # Ahead
            if (low_over_expanded_plate && is_non_fastball_sinker) {
              base_score <- pmax(base_score, 120)
              distance_penalty <- pmin(0.1, 0.01 + zone_distance * 0.05)
            } else if (below_zone && is_non_fastball_sinker) {
              distance_penalty <- pmin(0.6, 0.2 + zone_distance * 0.4)
              if (zone_distance > 0.5) {
                distance_penalty <- pmin(0.75, 0.3 + zone_distance * 0.5)
              }
            } else {
              distance_penalty <- pmin(0.6, 0.2 + zone_distance * 0.4)
              if (zone_distance > 0.5) {
                distance_penalty <- pmin(0.75, 0.4 + zone_distance * 0.6)
              }
            }
          }
          
          base_score <- base_score * (1 - distance_penalty)
        }
      }
      
      base_score
    }
    
    # Function to create QP+ heatmap data for the competitive zone
    create_qp_heatmap_data <- function(pt, p_hand, b_hand, state) {
      # Create a larger grid that extends beyond the competitive zone for better color range
      x_seq <- seq(COMP_LEFT - 0.3, COMP_RIGHT + 0.3, length.out = 18)
      y_seq <- seq(COMP_BOTTOM - 0.3, COMP_TOP + 0.3, length.out = 18)
      grid_data <- expand.grid(x = x_seq, y = y_seq)
      
      grid_data$qp_score <- vapply(
        seq_len(nrow(grid_data)),
        function(i) score_location(grid_data$x[i], grid_data$y[i], pt, p_hand, state),
        numeric(1)
      )
      
      grid_data$pitch_type <- pt
      return(grid_data)
    }
    
    # Prepare QP+ heatmap data for all pitch types
    all_heatmap_data <- do.call(rbind, lapply(pitch_types, function(pt) {
      create_qp_heatmap_data(pt, pitcher_hand, batter_hand, count_state)
    }))
    
    # Ensure per-pitch QP+ (scaled to 0-200) is present for tooltips
    state_data <- tryCatch({
      if (!nrow(state_data)) return(state_data)
      qp_scored <- vapply(
        seq_len(nrow(state_data)),
        function(i) score_location(
          state_data$PlateLocSide[i],
          state_data$PlateLocHeight[i],
          state_data$TaggedPitchType[i],
          pitcher_hand,
          count_state,
          if ("SessionType" %in% names(state_data)) state_data$SessionType[i] else NULL
        ),
        numeric(1)
      )
      state_data %>% dplyr::mutate(`QP+` = round(qp_scored, 1))
    }, error = function(e) state_data)
    
    # Add pitch data with results and colors (includes QP+ for hover)
    state_data_with_result <- state_data %>%
      dplyr::mutate(
        Result = compute_result(PitchCall, PlayResult),
        tooltip = make_hover_tt(.),
        pitch_type = factor(TaggedPitchType, levels = pitch_types),
        # Add pitch type colors
        pitch_color = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray")
      ) %>%
      dplyr::filter(!is.na(Result))
    
    # Create strike zone and home plate data for faceting
    strike_zone_all <- do.call(rbind, lapply(pitch_types, function(pt) {
      data.frame(
        xmin = ZONE_LEFT, xmax = ZONE_RIGHT, 
        ymin = ZONE_BOTTOM, ymax = ZONE_TOP,
        pitch_type = pt
      )
    }))
    
    home_plate_all <- do.call(rbind, lapply(pitch_types, function(pt) {
      data.frame(
        x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
        y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5,
        pitch_type = pt
      )
    }))
    
    # Create the plot with QP+ heatmap and colored pitches
    p <- ggplot() +
      # Add QP+ heatmap
      geom_tile(data = all_heatmap_data, 
                aes(x = x, y = y, fill = qp_score), 
                alpha = 0.6) +
      # Blue to red color scale for QP+
      scale_fill_gradient2(
        low = "blue", mid = "white", high = "red",
        midpoint = 100, name = "QP+",
        limits = c(0, 200),
        guide = "none"
      ) +
      # Add home plate
      geom_polygon(data = home_plate_all, 
                   aes(x = x, y = y, group = pitch_type), 
                   fill = NA, color = "black", linewidth = 1) +
      # Add strike zone
      geom_rect(data = strike_zone_all, 
                aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = "black", linewidth = 1) +
      # Add pitched balls with interactive tooltips and pitch type colors
      {if (nrow(state_data_with_result) > 0) {
        ggiraph::geom_point_interactive(
          data = state_data_with_result,
          aes(x = PlateLocSide, y = PlateLocHeight, 
              shape = Result, tooltip = tooltip, color = pitch_color),
          size = 2.5, alpha = 0.9, stroke = 1.2
        )
      }} +
      scale_shape_manual(
        values = shape_map,
        name = "Result",
        guide = "none"
      ) +
      scale_color_identity() +  # Use the actual colors from pitch_color column
      facet_wrap(~ pitch_type, nrow = 1) +
      coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0.5, 4.5)) +
      theme_void() +
      theme(
        strip.text = element_text(size = 11, face = "bold"),
        panel.spacing = unit(0.5, "lines"),
        legend.position = "none"
      )
    
    return(p)
    
  }, error = function(e) {
    # Return error message plot if something goes wrong
    return(ggplot() + 
             annotate("text", x = 0, y = 2.5, label = paste("Error:", e$message), size = 4) +
             theme_void())
  })
}

# vectorized clock converter
convert_to_clock <- Vectorize(function(x) {
  if (is.na(x)) return(NA_character_)
  h24 <- 6 + x/30
  if (h24 < 13) {
    hour <- floor(h24)
    mins <- round((h24 - hour) * 60)
    sprintf("%d:%02d", hour, mins)
  } else {
    h12  <- h24 - 12
    hour <- floor(h12)
    mins <- round((h12 - hour) * 60)
    sprintf("%d:%02d", hour, mins)
  }
}, USE.NAMES = FALSE)


fmt_date <- function(d) format(d, "%m/%d/%y")

transparent_bg_theme <- theme(
  panel.background = element_rect(fill = "transparent", color = NA),
  plot.background  = element_rect(fill = "transparent", color = NA),
  legend.background = element_rect(fill = "transparent", color = NA),
  legend.box.background = element_rect(fill = "transparent", color = NA),
  strip.background = element_rect(fill = "transparent", color = NA)
)

axis_theme <- theme(
  axis.text.x  = element_text(color="black", face="bold"),
  axis.text.y  = element_text(color="black", face="bold"),
  axis.title.x = element_text(color="black", face="bold"),
  axis.title.y = element_text(color="black", face="bold")
) + transparent_bg_theme

grid_theme <- function(dark_on = FALSE) {
  grid_col <- adjustcolor(if (dark_on) "white" else "black",
                          alpha.f = if (dark_on) 0.18 else 0.12)
  theme(
    panel.grid.major = element_line(color = grid_col),
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "transparent", color = NA),
    plot.background  = element_rect(fill = "transparent", color = NA)
  )
}

# ----- Shared heatmap palette (identical to current heat maps) -----
heat_pal <- function(bins = 10) {
  colorRampPalette(c("white","blue","lightblue","turquoise","yellow","orange","red"))(bins)
}

# ---- Per-base weight scales for Stuff+ ----
pitch_weights_fb <- tibble(
  TaggedPitchType = c("Fastball","Sinker",
                      "Cutter","Slider","Sweeper","Curveball",
                      "ChangeUp","Splitter"),
  w_vel = c(0.6, 0.5, 0.5, 0.4, 0.3, 0.5, 0.2, 0.1),
  w_ivb = c(0.3, 0.3, 0.2, 0.4, 0.1, 0.5, 0.6, 0.85),
  w_hb  = c(0.1, 0.2, 0.3, 0.2, 0.6, 0.0, 0.2, 0.05)
)

pitch_weights_si <- tibble(
  TaggedPitchType = c("Fastball","Sinker",
                      "Cutter","Slider","Sweeper","Curveball",
                      "ChangeUp","Splitter"),
  w_vel = c(0.6, 0.5, 0.5, 0.4, 0.3, 0.5, 0.2, 0.1),
  w_ivb = c(0.3, 0.3, 0.2, 0.4, 0.1, 0.5, 0.7, 0.85),
  w_hb  = c(0.1, 0.2, 0.3, 0.2, 0.6, 0.0, 0.1, 0.05)
)

# ---- Simplified Stuff+ Helper (vectorized, RelHeight-based FB/SI) ----
compute_stuff_simple <- function(df, base_type, level) {
  # select appropriate weights
  weight_tbl <- if (base_type == "Fastball") pitch_weights_fb else pitch_weights_si
  
  # prepare data and join weights
  df2 <- df %>%
    dplyr::mutate(
      TaggedPitchType = as.character(TaggedPitchType),
      HB_adj = ifelse(PitcherThrows == "Left", HorzBreak, -HorzBreak)
    ) %>%
    dplyr::left_join(weight_tbl, by = "TaggedPitchType")
  
  # velocity baselines
  base_vel <- mean(df2$RelSpeed[df2$TaggedPitchType == base_type], na.rm = TRUE)
  vel_avg  <- c(Pro = 94, College = 89, `High School` = 82)[level]
  
  # off-speed break specs
  off_off <- c(Cutter = 5, Slider = 8, Sweeper = 12,
               Curveball = 14, ChangeUp = 8, Splitter = 7)
  sep_fb <- tibble(
    TaggedPitchType = names(off_off),
    sep_ivb = c(-7, -15, -16, -27, -12, -13),
    sep_hb  = c(10, 12, 22, 18, -7, -4)
  )
  sep_si <- tibble(
    TaggedPitchType = names(off_off),
    sep_ivb = c(2, -6, -7, -18, -4, -5),
    sep_hb  = c(18, 20, 30, 25, 1, 2)
  )
  seps <- if (base_type == "Fastball") sep_fb else sep_si
  
  # league-standard baselines by release height
  std_ivb <- case_when(
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 6.2 ~ 17,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.8 ~ 15.5,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.4 ~ 15,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.0 ~ 12.5,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 4.5 ~ 11,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight <  4.5 ~ 10,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 6.2 ~ 10,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.8 ~ 7,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.4 ~ 6,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.0 ~ 4,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 4.5 ~ 3,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight <  4.5 ~ 3,
    TRUE ~ NA_real_
  )
  std_hb_right <- case_when(
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 6.2 ~ 9,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.8 ~ 10,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.4 ~ 11,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 5.0 ~ 12,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight >= 4.5 ~ 13,
    df2$TaggedPitchType == "Fastball" & df2$RelHeight <  4.5 ~ 11,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 6.2 ~ 15,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.8 ~ 15.5,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.4 ~ 16.7,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 5.0 ~ 17,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight >= 4.5 ~ 17,
    df2$TaggedPitchType == "Sinker"    & df2$RelHeight <  4.5 ~ 17.5,
    TRUE ~ NA_real_
  )
  std_hb <- ifelse(df2$PitcherThrows == "Left", -std_hb_right, std_hb_right)
  
  # personal baselines for off-speed
  base_ivb_val <- mean(df2$InducedVertBreak[df2$TaggedPitchType == base_type], na.rm = TRUE)
  base_hb_val  <- mean(df2$HB_adj[df2$TaggedPitchType == base_type], na.rm = TRUE)
  
  # compute per-pitch ratios
  r_vel <- ifelse(
    df2$TaggedPitchType %in% c("Fastball","Sinker"),
    df2$RelSpeed / vel_avg,
    df2$RelSpeed / pmax(1e-6, base_vel - off_off[df2$TaggedPitchType])
  )
  
  # exaggerate velocity deviations:
  #   below average → square the ratio (shrinks <1 even more)
  #   above average → optional root (or power>1) to tune reward
  alpha <- 4    # exponent for penalizing below-avg
  beta  <- 2  # exponent for rewarding above-avg (tweak as you like)
  
  r_vel <- ifelse(
    r_vel < 1,
    r_vel^alpha,
    r_vel^beta
  )
  
  # Invert velocity scoring for ChangeUp & Splitter so larger FB/SI gap is rewarded
  r_vel <- ifelse(df2$TaggedPitchType %in% c("ChangeUp","Splitter"),
                  1 / pmax(r_vel, 1e-6), r_vel)
  # ---- Updated r_ivb: endpoint-based for Sweeper off Sinker ----
  r_ivb <- case_when(
    df2$TaggedPitchType == "Fastball" ~
      df2$InducedVertBreak / std_ivb,
    
    df2$TaggedPitchType == "Sinker"   ~
      ifelse(df2$InducedVertBreak > 0,
             std_ivb / df2$InducedVertBreak,
             1),
    
    base_type == "Sinker" & df2$TaggedPitchType == "Cutter" ~ {
      endpoint_ivb <- base_ivb_val +
        seps$sep_ivb[match("Cutter", seps$TaggedPitchType)]
      # compute difference (could be negative), then abs() makes it positive
      ivb_diff <- df2$InducedVertBreak - endpoint_ivb
      abs(ivb_diff) / endpoint_ivb
    },
    
    # reward deviations in either direction for Sweeper off Sinker
    base_type == "Sinker" & df2$TaggedPitchType == "Sweeper" ~ {
      endpoint_ivb <- base_ivb_val +
        seps$sep_ivb[match("Sweeper", seps$TaggedPitchType)]
      # compute difference (could be negative), then abs() makes it positive
      ivb_diff <- df2$InducedVertBreak - endpoint_ivb
      abs(ivb_diff) / endpoint_ivb
    },
    
    TRUE ~
      (base_ivb_val - df2$InducedVertBreak) /
      abs(seps$sep_ivb[match(df2$TaggedPitchType, seps$TaggedPitchType)])
  )
  
  # ---- Updated r_hb: endpoint-based for Sweeper off Sinker ----
  r_hb <- case_when(
    # NEW: Fastball HB → reward both below-avg and above-avg HB (symmetric),
    # with a small deadband so tiny differences score ~1.0
    df2$TaggedPitchType == "Fastball" ~ {
      hb_mag  <- abs(df2$HB_adj)
      std_mag <- abs(std_hb)
      # symmetric reward: less HB → std/hb ; more HB → hb/std
      r <- pmax(hb_mag / std_mag, std_mag / pmax(hb_mag, 1e-6))
      # optional deadband (e.g., within 2 in of "standard" HB scores 1.0)
      r <- ifelse(abs(hb_mag - std_mag) < 2, 1, r)
      r
    },
    df2$TaggedPitchType == "Sinker" ~
      abs(df2$HB_adj / std_hb),
    
    df2$TaggedPitchType == "Curveball" ~
      abs(df2$HorzBreak - base_hb_val) /
      abs(seps$sep_hb[match("Curveball", seps$TaggedPitchType)]),
    
    # ← NEW: Sweeper off Sinker uses endpoint (base_hb_val + sep_hb)
    base_type == "Sinker" & df2$TaggedPitchType == "Sweeper" ~ {
      endpoint_hb <- base_hb_val +
        seps$sep_hb[match("Sweeper", seps$TaggedPitchType)]
      abs(df2$HB_adj) / abs(endpoint_hb)
    },
    
    base_type == "Sinker" & df2$TaggedPitchType == "Cutter" ~ {
      endpoint_hb <- base_hb_val +
        seps$sep_hb[match("Cutter", seps$TaggedPitchType)]
      abs(df2$HB_adj) / abs(endpoint_hb)
    },
    
    base_type == "Sinker" & df2$TaggedPitchType == "ChangeUp" ~ {
      (base_hb_val - df2$HB_adj) /
        seps$sep_hb[match("ChangeUp", seps$TaggedPitchType)]
    },
    base_type == "Sinker" & df2$TaggedPitchType == "Splitter" ~ {
      (base_hb_val - df2$HB_adj) /
        seps$sep_hb[match("Splitter", seps$TaggedPitchType)]
    },
    
    TRUE ~
      (df2$HB_adj - base_hb_val) /
      seps$sep_hb[match(df2$TaggedPitchType, seps$TaggedPitchType)]
  )
  
  # ← INSERT YOUR CAPS HERE
  r_ivb <- pmin(r_ivb, 2)   # cap vertical ratio at 2× baseline
  r_hb  <- pmin(r_hb,  2)   # cap horizontal ratio at 2× baseline
  
  # combine into Stuff+
  df2 %>%
    mutate(
      raw      = w_vel * r_vel + w_ivb * r_ivb + w_hb * r_hb,
      `Stuff+` = round(raw * 100, 1)
    )
}


# Strike zone constants
ZONE_LEFT   <- -0.88
ZONE_RIGHT  <-  0.88
ZONE_BOTTOM <-  1.5
ZONE_TOP    <-  3.6

# =========================
# ===== QP+  HELPERS  =====
# =========================

# Competitive rectangle (same as your dashed box)
COMP_LEFT   <- -1.5
COMP_RIGHT  <-  1.5
COMP_BOTTOM <-  2.65 - 1.5   # 1.15
COMP_TOP    <-  2.65 + 1.5   # 4.15

# Map (Balls, Strikes) to Ahead / Even / Behind like your count filter
count_state_vec <- function(b, s) {
  b <- suppressWarnings(as.integer(b)); s <- suppressWarnings(as.integer(s))
  out <- rep("Even", length(b))
  ahead  <- ( (b==0 & s==1) | (b==0 & s==2) | (b==1 & s==2) )
  behind <- ( (b==1 & s==0) | (b==2 & s==0) | (b==3 & s==0) |
                (b==3 & s==1) | (b==2 & s==1) )
  even   <- ( (b==0 & s==0) | (b==1 & s==1) | (b==2 & s==2) | (b==3 & s==2) )
  
  out[behind] <- "Behind"
  out[ahead]  <- "Ahead"
  out[even]   <- "Even"
  out[is.na(b) | is.na(s)] <- "Even"
  out
}

# 9-square index (1..9) or NA if OUTSIDE competitive box
# Numbering (LEFT → RIGHT per row):
# Top row:    1,2,3
# Middle row: 4,5,6
# Bottom row: 7,8,9
# 9-square index (1..9) or NA if OUTSIDE competitive box
# Numbering (LEFT→RIGHT per row): Top: 1,2,3  |  Middle: 4,5,6  |  Bottom: 7,8,9
zone9_square <- function(x, y) {
  x <- suppressWarnings(as.numeric(x))
  y <- suppressWarnings(as.numeric(y))
  
  # guard missing + bounds (avoid NA in logical index)
  ok <- !is.na(x) & !is.na(y) &
    x >= COMP_LEFT & x <= COMP_RIGHT &
    y >= COMP_BOTTOM & y <= COMP_TOP
  
  sq <- rep(NA_integer_, length(x))
  idx <- which(ok)  # <- integer indices (drops NA/FALSE safely)
  if (!length(idx)) return(sq)
  
  w <- (COMP_RIGHT - COMP_LEFT)
  h <- (COMP_TOP   - COMP_BOTTOM)
  
  # normalized positions in [0,1]
  gx <- pmax(0, pmin(1, (x[idx] - COMP_LEFT)   / w))
  gy <- pmax(0, pmin(1, (y[idx] - COMP_BOTTOM) / h))
  
  # columns: LEFT(1)→RIGHT(3)
  col <- ifelse(gx < 1/3, 1L, ifelse(gx < 2/3, 2L, 3L))
  # rows: TOP(1)→BOTTOM(3)
  row <- ifelse(gy >= 2/3, 1L, ifelse(gy >= 1/3, 2L, 3L))
  
  sq[idx] <- (row - 1L) * 3L + col
  sq
}

# Convenience to convert square to (row,col)
sq_to_rc <- function(sq) {
  r <- ((sq - 1) %/% 3) + 1
  c <- ((sq - 1) %%  3) + 1
  list(r = r, c = c)
}

# Count strictness decay by Manhattan distance from target
# Behind = loosest, Even = moderate, Ahead = strict
qp_decay <- function(state) {
  if (identical(state, "Ahead"))      c(1.00, 0.35, 0.15, 0.05)
  else if (identical(state, "Even"))  c(1.00, 0.55, 0.25, 0.10)
  else                                c(1.00, 0.75, 0.45, 0.20)  # Behind
}

# Seed targets (row, col, base weight) per pitch type & pitcher hand
# UI columns numbered LEFT→RIGHT:
# - RHP glove side → UI col 1 → squares 1/4/7
# - LHP glove side → UI col 3 → squares 3/6/9
qp_seeds_for <- function(pt, hand) {
  pt   <- as.character(pt)
  hand <- ifelse(hand %in% c("Left","Right"), hand, "Right")
  
  glove_col <- ifelse(hand == "Left", 3, 1)
  arm_col   <- ifelse(glove_col == 1, 3, 1)
  
  r_top <- 1; r_mid <- 2; r_bot <- 3
  c_mid <- 2; c_g  <- glove_col; c_a <- arm_col
  
  # Weights reflect your guidance:
  # FB up; SI down; CT middle & up glove; SL/SW down glove;
  # CB down + slight glove; CH/SPL down over plate + slight arm.
  switch(pt,
         "Fastball"  = data.frame(r = c(r_top, r_top, r_top),
                                  c = c(c_mid, c_g,   c_a),
                                  w = c(1.00,  1.00,  1.00)),
         "Sinker"    = data.frame(r = c(r_bot, r_bot, r_bot),
                                  c = c(c_mid, c_a,   c_g),
                                  w = c(0.8,  1.00,  0.90)),
         "Cutter"    = data.frame(r = c(r_mid, r_top, r_top, r_bot),
                                  c = c(c_g,   c_g,   c_mid, c_g),
                                  w = c(1.00,  1.00,  0.75,  0.80)),
         "Slider"    = data.frame(r = c(r_bot, r_bot, r_mid),
                                  c = c(c_g,   c_mid, c_g),
                                  w = c(1.00,  0.80,  0.70)),
         "Sweeper"   = data.frame(r = c(r_bot, r_bot, r_mid),
                                  c = c(c_g,   c_mid, c_g),
                                  w = c(1.00,  0.75,  0.65)),
         "Curveball" = data.frame(r = c(r_bot, r_bot, r_bot),
                                  c = c(c_mid, c_g,   c_a),
                                  w = c(1.00,  1.00,  1.00)),
         "ChangeUp"  = data.frame(r = c(r_bot, r_bot, r_bot),
                                  c = c(c_mid, c_a,   c_g),
                                  w = c(1.00,  0.90,  0.70)),
         "Splitter"  = data.frame(r = c(r_bot, r_bot, r_bot),
                                  c = c(c_mid, c_a,   c_g),
                                  w = c(1.00,  1.00,  1.00)),
         # Fallback: neutral center if unknown pitch label
         data.frame(r = r_mid, c = c_mid, w = 0.60)
  )
}

# Best weight for a given square given pitch, hand, count macro
qp_weight_for_square <- function(sq, pt, hand, state) {
  if (is.na(sq)) return(0)
  seeds <- qp_seeds_for(pt, hand)
  rc    <- sq_to_rc(sq)
  dec   <- qp_decay(state)
  best  <- 0
  for (i in seq_len(nrow(seeds))) {
    d <- abs(seeds$r[i] - rc$r) + abs(seeds$c[i] - rc$c)  # Manhattan distance
    di <- ifelse(d >= 3, 4, d + 1)
    best <- max(best, seeds$w[i] * dec[di])
  }
  best
}

# Vectorized per-pitch QP points (0..1)
# - Live only (non-Live → NA, so not counted)
# - 0 if outside COMP box (non-competitive)
compute_qp_points <- function(df) {
  n <- nrow(df)
  if (!n) return(numeric(0))
  
  live  <- !is.na(df$SessionType) & as.character(df$SessionType) == "Live"
  sq    <- zone9_square(df$PlateLocSide, df$PlateLocHeight)
  state <- count_state_vec(df$Balls, df$Strikes)
  pt    <- as.character(df$TaggedPitchType)
  hand  <- as.character(df$PitcherThrows)
  
  out <- rep(NA_real_, n)
  
  # live & non-competitive = 0  (use integer indices)
  idx_noncomp <- which(live & is.na(sq))
  if (length(idx_noncomp)) out[idx_noncomp] <- 0
  
  # live & inside competitive box
  idx <- which(live & !is.na(sq))
  if (length(idx)) {
    out[idx] <- mapply(
      function(sqi, pti, hnd, st)
        qp_weight_for_square(sqi, pti, hnd, ifelse(is.na(st), "Even", st)),
      sq[idx], pt[idx], hand[idx], state[idx]
    )
  }
  out
}

# QP Locations filter: determine if pitch locations are good (red/QP+ >= 100) or bad (blue/white/QP+ < 100)
# This function calculates QP+ scores for pitch locations and classifies them
filter_qp_locations <- function(df, qp_choice) {
  # Pass-through if "All" or invalid choice
  if (is.null(qp_choice) || qp_choice == "All" || !qp_choice %in% c("Yes", "No")) {
    return(df)
  }
  
  # Need location data to calculate QP+ scores
  if (!all(c("PlateLocSide", "PlateLocHeight", "TaggedPitchType", "PitcherThrows", "Balls", "Strikes") %in% names(df))) {
    return(df)
  }
  
  # Calculate QP+ scores for each pitch
  n <- nrow(df)
  if (!n) return(df)
  
  x <- suppressWarnings(as.numeric(df$PlateLocSide))
  y <- suppressWarnings(as.numeric(df$PlateLocHeight))
  pt <- as.character(df$TaggedPitchType)
  hand <- as.character(df$PitcherThrows)
  state <- count_state_vec(df$Balls, df$Strikes)
  
  # Calculate QP+ scores (0-200 scale)
  qp_scores <- rep(NA_real_, n)
  
  for (i in seq_len(n)) {
    if (is.na(x[i]) || is.na(y[i])) {
      qp_scores[i] <- 0  # Missing location = poor
      next
    }
    
    # Get square position in competitive zone
    sq <- zone9_square(x[i], y[i])
    
    if (is.na(sq)) {
      qp_scores[i] <- 0  # Outside competitive zone = poor
    } else {
      # Calculate QP+ score using existing function
      qp_weight <- qp_weight_for_square(sq, pt[i], hand[i], ifelse(is.na(state[i]), "Even", state[i]))
      qp_scores[i] <- qp_weight * 200
    }
  }
  
  # Apply filter based on choice
  if (qp_choice == "Yes") {
    # Show only good locations (red areas, QP+ >= 100)
    return(df[qp_scores >= 100 & !is.na(qp_scores), , drop = FALSE])
  } else if (qp_choice == "No") {
    # Show only poor locations (blue/white areas, QP+ < 100)
    return(df[qp_scores < 100 & !is.na(qp_scores), , drop = FALSE])
  }
  
  return(df)
}


# Colors & factor levels
all_colors <- c(
  Fastball   = "black",
  Sinker     = "orange",
  Cutter     = "brown",
  Slider     = "red",
  Sweeper    = "purple",
  Curveball  = "blue",
  ChangeUp   = "darkgreen",
  Splitter   = "turquoise",
  Knuckleball= "darkblue"
)
colors_for_mode <- function(dark_on = FALSE) {
  cols <- all_colors
  if (isTRUE(dark_on) && "Fastball" %in% names(cols)) cols["Fastball"] <- "#ffffff"
  cols
}
force_pitch_levels <- function(df) df %>% mutate(
  TaggedPitchType = factor(TaggedPitchType, levels = names(all_colors))
)

# Session colors for Trend when "All" is selected
session_cols <- c(Live = "red", Bullpen = "black")
session_cols_for_mode <- function(dark_on = FALSE) {
  cols <- session_cols
  if (isTRUE(dark_on) && "Bullpen" %in% names(cols)) cols["Bullpen"] <- "#ffffff"
  cols
}

# Filters
# ---- Filters: Zone & In-Zone ----

# Multi-select halves/thirds with INTERSECTION logic, bounded to the strike zone
# ---- Filters: Zone bands that extend beyond the zone ----
# Halves/Thirds act as threshold lines:
#   - Upper Half      => y >= mid_y      (and above the zone)
#   - Bottom Half     => y <= mid_y      (and below the zone)
#   - Upper 3rd       => y >= B + 2*dy   (and above the zone)
#   - Bottom 3rd      => y <= B + dy     (and below the zone)
#   - Left Half       => x <= mid_x      (and left of the zone)
#   - Right Half      => x >= mid_x      (and right of the zone)
#   - Left 3rd        => x <= L + dx     (and left of the zone)
#   - Right 3rd       => x >= L + 2*dx   (and right of the zone)
# Multiple selections are ANDed together (intersection).
enforce_zone <- function(df, choice) {
  # Pass-through if nothing picked or "All"
  if (is.null(choice) || !length(choice)) return(df)
  choice <- unique(as.character(choice))
  if ("All" %in% choice) return(df)
  
  # Coords
  x <- suppressWarnings(as.numeric(df$PlateLocSide))
  y <- suppressWarnings(as.numeric(df$PlateLocHeight))
  ok <- is.finite(x) & is.finite(y)
  if (!any(ok)) return(df[0, , drop = FALSE])
  
  # Zone geometry
  mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
  mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
  dx <- (ZONE_RIGHT - ZONE_LEFT) / 3
  dy <- (ZONE_TOP   - ZONE_BOTTOM) / 3
  L <- ZONE_LEFT; R <- ZONE_RIGHT; B <- ZONE_BOTTOM; T <- ZONE_TOP
  
  # Start with TRUE everywhere (don’t clamp to the zone here)
  mask_vert <- rep(TRUE, length(x))
  mask_horz <- rep(TRUE, length(x))
  
  # Apply each token as a threshold restriction
  for (tok in choice) {
    if (tok %in% c("Upper Half", "Bottom Half", "Upper 3rd", "Bottom 3rd")) {
      cond <- switch(tok,
                     "Upper Half"  = (y >= mid_y),
                     "Bottom Half" = (y <= mid_y),
                     "Upper 3rd"   = (y >= (B + 2*dy)),
                     "Bottom 3rd"  = (y <= (B + dy))
      )
      mask_vert <- mask_vert & cond
    } else if (tok %in% c("Left Half", "Right Half", "Left 3rd", "Right 3rd")) {
      cond <- switch(tok,
                     "Left Half"  = (x <= mid_x),
                     "Right Half" = (x >= mid_x),
                     "Left 3rd"   = (x <= (L + dx)),
                     "Right 3rd"  = (x >= (L + 2*dx))
      )
      mask_horz <- mask_horz & cond
    } else {
      # Unknown token → no change
    }
  }
  
  m <- ok & mask_vert & mask_horz
  df[m, , drop = FALSE]
}


# Keep the legacy in-zone toggle that other code expects
# Values typically: "All", "Yes", "No", "Competitive"
enforce_inzone <- function(df, choice) {
  if (is.null(choice) || identical(choice, "All")) return(df)
  
  x <- suppressWarnings(as.numeric(df$PlateLocSide))
  y <- suppressWarnings(as.numeric(df$PlateLocHeight))
  
  in_zone <- (x >= ZONE_LEFT & x <= ZONE_RIGHT &
                y >= ZONE_BOTTOM & y <= ZONE_TOP)
  
  if (identical(choice, "Yes")) {
    df[in_zone, , drop = FALSE]
  } else if (identical(choice, "No")) {
    df[!in_zone, , drop = FALSE]
  } else if (identical(choice, "Competitive")) {
    comp <- (x >= -1.5 & x <= 1.5 &
               y >= (2.65 - 1.5) & y <= (2.65 + 1.5))
    df[comp, , drop = FALSE]
  } else {
    df
  }
}

# ---- Multi-select "All" helper ----
enforce_all_multiselect <- function(input, session, id) {
  observeEvent(input[[id]], {
    sel <- input[[id]]
    if (is.null(sel) || !length(sel)) {
      updateSelectInput(session, id, selected = "All")
    } else if ("All" %in% sel && length(sel) > 1) {
      updateSelectInput(session, id, selected = setdiff(sel, "All"))
    }
  }, ignoreInit = TRUE)
}


# ---- Count filter helper (supports macros + exact counts) ----
apply_count_filter <- function(df, selection) {
  # If nothing or "All" selected -> no filtering
  if (is.null(selection) || !length(selection) || "All" %in% selection) return(df)
  
  # Build allowed (Balls, Strikes) pairs from exact and macro options
  allowed <- list()
  
  # Exact counts like "1-2"
  exact <- selection[grepl("^\\d-\\d$", selection)]
  if (length(exact)) {
    for (val in exact) {
      sp <- strsplit(val, "-", fixed = TRUE)[[1]]
      allowed <- append(allowed, list(c(as.integer(sp[1]), as.integer(sp[2]))))
    }
  }
  
  # Macros
  if ("Even" %in% selection)  allowed <- append(allowed, list(c(0,0), c(1,1), c(2,2), c(3,2)))
  if ("Behind" %in% selection) allowed <- append(allowed, list(c(1,0), c(2,0), c(3,0), c(3,1), c(2,1)))
  if ("Ahead" %in% selection)  allowed <- append(allowed, list(c(0,1), c(0,2), c(1,2)))
  if ("2KNF" %in% selection)   allowed <- append(allowed, list(c(0,2), c(1,2), c(2,2)))
  
  if (!length(allowed)) return(df)
  
  mat <- do.call(rbind, allowed)  # Nx2 (Balls, Strikes)
  ok  <- is.finite(df$Balls) & is.finite(df$Strikes)
  keep <- rep(FALSE, nrow(df))
  if (nrow(mat)) {
    for (i in seq_len(nrow(mat))) {
      keep <- keep | (df$Balls == mat[i,1] & df$Strikes == mat[i,2])
    }
  }
  df[ ok & keep, , drop = FALSE ]
}

# ---- After Count filter helper - filters pitches that occurred AFTER specific counts ----
apply_after_count_filter <- function(df, selection) {
  # If nothing or "All" selected -> no filtering
  if (is.null(selection) || !length(selection) || "All" %in% selection) return(df)
  
  # First compute the "prior count" for each pitch
  # Group by at-bat identifiers and calculate previous balls/strikes
  if (!all(c("PAofInning", "Inning", "Date") %in% names(df))) {
    # If we don't have at-bat identifiers, can't compute after count
    return(df)
  }
  
  df <- df %>%
    dplyr::arrange(Date, Inning, PAofInning, PitchofPA) %>%
    dplyr::group_by(Date, Inning, PAofInning) %>%
    dplyr::mutate(
      PrevBalls = dplyr::lag(Balls, default = 0),
      PrevStrikes = dplyr::lag(Strikes, default = 0)
    ) %>%
    dplyr::ungroup()
  
  # Build allowed (Balls, Strikes) pairs from selection
  allowed <- list()
  
  # Exact counts like "1-2"
  exact <- selection[grepl("^\\d-\\d$", selection)]
  if (length(exact)) {
    for (val in exact) {
      sp <- strsplit(val, "-", fixed = TRUE)[[1]]
      allowed <- append(allowed, list(c(as.integer(sp[1]), as.integer(sp[2]))))
    }
  }
  
  # Macros
  if ("Even" %in% selection)  allowed <- append(allowed, list(c(0,0), c(1,1), c(2,2), c(3,2)))
  if ("Behind" %in% selection) allowed <- append(allowed, list(c(1,0), c(2,0), c(3,0), c(3,1), c(2,1)))
  if ("Ahead" %in% selection)  allowed <- append(allowed, list(c(0,1), c(0,2), c(1,2)))
  if ("2KNF" %in% selection)   allowed <- append(allowed, list(c(0,2), c(1,2), c(2,2)))
  
  if (!length(allowed)) return(df)
  
  mat <- do.call(rbind, allowed)  # Nx2 (Balls, Strikes)
  ok  <- is.finite(df$PrevBalls) & is.finite(df$PrevStrikes)
  keep <- rep(FALSE, nrow(df))
  if (nrow(mat)) {
    for (i in seq_len(nrow(mat))) {
      keep <- keep | (df$PrevBalls == mat[i,1] & df$PrevStrikes == mat[i,2])
    }
  }
  df[ ok & keep, , drop = FALSE ]
}

# ---- Split By helper - adds a column for grouping based on split selection ----
apply_split_by <- function(df, split_choice) {
  if (is.null(split_choice)) split_choice <- "Pitch Types"
  
  df <- switch(
    split_choice,
    
    "Pitch Types" = {
      df %>% dplyr::mutate(SplitColumn = as.character(TaggedPitchType))
    },
    
    "Batter Hand" = {
      df %>% dplyr::mutate(SplitColumn = ifelse(
        !is.na(BatterSide) & BatterSide != "", 
        as.character(BatterSide), 
        "Unknown"
      ))
    },
    
    "Pitcher Hand" = {
      df %>% dplyr::mutate(SplitColumn = ifelse(
        !is.na(PitcherThrows) & PitcherThrows != "", 
        as.character(PitcherThrows), 
        "Unknown"
      ))
    },
    
    "Count" = {
      df %>% dplyr::mutate(
        SplitColumn = ifelse(
          is.finite(Balls) & is.finite(Strikes),
          paste0(Balls, "-", Strikes),
          "Unknown"
        ),
        CountState = count_state_vec(Balls, Strikes)
      )
    },
    
    "After Count" = {
      # Compute previous count if not already present
      if (!all(c("PAofInning", "Inning", "Date") %in% names(df))) {
        df %>% dplyr::mutate(SplitColumn = "Unknown")
      } else {
        df %>%
          dplyr::arrange(Date, Inning, PAofInning, PitchofPA) %>%
          dplyr::group_by(Date, Inning, PAofInning) %>%
          dplyr::mutate(
            PrevBalls = dplyr::lag(Balls, default = 0),
            PrevStrikes = dplyr::lag(Strikes, default = 0),
            SplitColumn = ifelse(
              is.finite(PrevBalls) & is.finite(PrevStrikes),
              paste0(PrevBalls, "-", PrevStrikes),
              "Unknown"
            )
          ) %>%
          dplyr::ungroup()
      }
    },
    
    "Velocity" = {
      df %>% dplyr::mutate(SplitColumn = dplyr::case_when(
        !is.finite(RelSpeed) ~ "Unknown",
        RelSpeed < 70 ~ "<70",
        RelSpeed >= 100 ~ ">99",
        TRUE ~ paste0(floor(RelSpeed/2)*2, "-", floor(RelSpeed/2)*2 + 1)
      ))
    },
    
    "IVB" = {
      df %>% dplyr::mutate(SplitColumn = dplyr::case_when(
        !is.finite(InducedVertBreak) ~ "Unknown",
        InducedVertBreak < -22 ~ "<-22",
        InducedVertBreak > 22 ~ ">22",
        TRUE ~ paste0(floor(InducedVertBreak/2)*2, "-", floor(InducedVertBreak/2)*2 + 1)
      ))
    },
    
    "HB" = {
      df %>% dplyr::mutate(SplitColumn = dplyr::case_when(
        !is.finite(HorzBreak) ~ "Unknown",
        HorzBreak < -22 ~ "<-22",
        HorzBreak > 22 ~ ">22",
        TRUE ~ paste0(floor(HorzBreak/2)*2, "-", floor(HorzBreak/2)*2 + 1)
      ))
    },
    
    "Batter" = {
      df %>% dplyr::mutate(SplitColumn = ifelse(
        !is.na(Batter) & nzchar(Batter), 
        as.character(Batter), 
        "Unknown"
      ))
    },
    
    "Pitcher" = {
      df %>% dplyr::mutate(SplitColumn = ifelse(
        !is.na(Pitcher) & nzchar(Pitcher), 
        as.character(Pitcher), 
        "Unknown"
      ))
    },
    
    # Default: Pitch Types
    {
      df %>% dplyr::mutate(SplitColumn = as.character(TaggedPitchType))
    }
  )
  attr(df, "split_choice") <- split_choice
  df
}

# Apply Pitch Results filter (multi-select)
apply_pitch_results_filter <- function(df, selection) {
  # If nothing or "All" selected -> no filtering
  if (is.null(selection) || !length(selection) || "All" %in% selection) return(df)
  
  # Separate individual hit types from regular result categories
  hit_types <- c("Single", "Double", "Triple", "HomeRun", "Error")
  selected_hits <- intersect(selection, hit_types)
  selected_results <- setdiff(selection, hit_types)
  
  # If "In Play (Hit)" is selected, expand it to include all hit types
  if ("In Play (Hit)" %in% selected_results) {
    selected_hits <- unique(c(selected_hits, "Single", "Double", "Triple", "HomeRun"))
  }
  
  # Create Result column if not already present (for regular results)
  if (!"Result" %in% names(df)) {
    df$Result <- compute_result(df$PitchCall, df$PlayResult)
  }
  
  # Build filter conditions
  keep_rows <- rep(FALSE, nrow(df))
  
  # Filter by regular result categories (using Result column)
  if (length(selected_results) > 0) {
    keep_rows <- keep_rows | (!is.na(df$Result) & df$Result %in% selected_results)
  }
  
  # Filter by specific hit types (using PlayResult column directly)
  if (length(selected_hits) > 0) {
    keep_rows <- keep_rows | (!is.na(df$PlayResult) & df$PlayResult %in% selected_hits)
  }
  
  df[keep_rows, , drop = FALSE]
}

# Sort table by IVB/HB ranges in descending order
sort_by_range <- function(df, col_name, split_choice) {
  if (!split_choice %in% c("IVB", "HB")) return(df)
  if (!col_name %in% names(df)) return(df)
  
  # Extract numeric values from range strings for sorting
  df <- df %>%
    dplyr::mutate(
      .sort_key = dplyr::case_when(
        grepl("Unknown", .data[[col_name]]) ~ -9999,
        grepl("^<-", .data[[col_name]]) ~ -23,
        grepl("^>", .data[[col_name]]) ~ 23,
        grepl("Even|Ahead|Behind|All", .data[[col_name]]) ~ 9999,  # Keep these at bottom
        TRUE ~ {
          # Extract first number from range like "10-11" or "-10--9"
          val_str <- as.character(.data[[col_name]])
          first_num <- suppressWarnings(as.numeric(sub("(-?\\d+).*", "\\1", val_str)))
          ifelse(is.na(first_num), -9999, first_num)
        }
      )
    ) %>%
    dplyr::arrange(desc(.sort_key)) %>%
    dplyr::select(-.sort_key)
  
  df
}

# Keep "All" semantics tidy (like locResult)


# Robust m/d/y date parser for mixed inputs
parse_date_mdy <- function(x) {
  parse_date_flex(x)
}


# returns a named vector of usage % by pitch type for a given filtered df
usage_by_type <- function(df) {
  # Determine which column to use for pitch type grouping
  pitch_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
  
  total <- nrow(df)
  if (!total) return(setNames(numeric(0), character(0)))
  
  result <- df %>%
    dplyr::count(.data[[pitch_col]], name = "n") %>%
    dplyr::mutate(pct = 100 * n / total)
  
  setNames(result$pct, result[[pitch_col]])
}

# ---- Data import + cleaning (recursive from data/practice and data/V3[/CSV]) ----
library(readr)
library(stringr)   # explicit, even though tidyverse includes it

# Point to the app's local data folder (works locally & on shinyapps.io)
data_parent <- normalizePath(file.path(getwd(), "data"), mustWork = TRUE)

# Find every CSV under data/, keep only those under practice/ or V3/
all_csvs <- list.files(
  path       = data_parent,
  pattern    = "\\.csv$",
  recursive  = TRUE,
  full.names = TRUE
)
all_csvs <- all_csvs[ grepl("([/\\\\]practice[/\\\\])|([/\\\\]v3[/\\\\])", tolower(all_csvs)) ]

if (!length(all_csvs)) stop("No CSVs found under: ", data_parent)

# Map folder → SessionType
infer_session_from_path <- function(fp) {
  fpl <- tolower(fp)
  if (grepl("[/\\\\]practice[/\\\\]", fpl)) "Bullpen"
  else if (grepl("[/\\\\]v3[/\\\\]", fpl)) "Live"
  else "Live"
}

# Grab the LAST YYYY/MM/DD in the path (handles .../V3/2025/08/13/CSV/file.csv)
extract_folder_date <- function(fp) {
  m <- stringr::str_match_all(fp, "(20\\d{2})[\\/](0[1-9]|1[0-2])[\\/](0[1-9]|[12]\\d|3[01])")[[1]]
  if (nrow(m)) as.Date(paste(m[nrow(m),2], m[nrow(m),3], m[nrow(m),4], sep = "-")) else NA
}

read_one <- function(fp) {
  df <- suppressMessages(readr::read_csv(
    fp,
    col_types = readr::cols(.default = readr::col_character())
  ))
  
  # --- NEW: SessionType from folder with CSV fallback/normalization ---
  path_st <- infer_session_from_path(fp)  # "Bullpen" if /practice/, "Live" if /v3/
  if (!"SessionType" %in% names(df)) df$SessionType <- NA_character_
  st_chr <- tolower(trimws(as.character(df$SessionType)))
  
  df$SessionType <- dplyr::case_when(
    grepl("bull|prac", st_chr) ~ "Bullpen",
    grepl("live|game|ab", st_chr) ~ "Live",
    TRUE ~ path_st  # fallback to folder mapping when blank/unknown
  )
  
  
  # Canonicalize to the names used throughout the app (case-insensitive).
  # For each canonical name, if it's missing but an alias exists, rename alias -> canonical.
  canon_aliases <- list(
    InducedVertBreak = c("IVB"),
    HorzBreak        = c("HB"),
    RelSpeed         = c("Velo"),
    ReleaseTilt      = c("ReleaseAngle", "SpinAxis3dTransverseAngle"),
    BreakTilt        = c("BreakAngle",   "SpinAxis"),
    SpinEfficiency   = c("SpinEff",      "SpinAxis3dSpinEfficiency"),
    SpinRate         = c("Spin"),
    RelHeight        = c("RelZ"),
    RelSide          = c("RelX"),
    VertApprAngle    = c("VAA"),
    HorzApprAngle    = c("HAA"),
    PlateLocSide     = c("PlateX"),
    PlateLocHeight   = c("PlateZ")
  )
  
  nm <- names(df)
  for (canon in names(canon_aliases)) {
    if (!(canon %in% nm)) {
      for (al in canon_aliases[[canon]]) {
        hit <- which(tolower(nm) == tolower(al))
        if (length(hit) == 1) {
          names(df)[hit] <- canon
          nm <- names(df)
          break
        }
      }
    }
  }
  
  # --- Date: prefer a real date; fall back to folder date if the CSV "Date" is bad ---
  looks_like_time <- function(x) {
    s <- tolower(trimws(as.character(x)))
    grepl("^\\d{1,2}:\\d{2}(\\.\\d+)?$", s)
  }
  can_parse_as_date <- function(x) {
    x <- as.character(x)
    a <- suppressWarnings(as.Date(x, "%m/%d/%Y"))
    b <- suppressWarnings(as.Date(x, "%m/%d/%y"))
    c <- suppressWarnings(as.Date(x, format = "%Y-%m-%d"))
    num <- suppressWarnings(as.numeric(x))         # Excel serials
    serial_ok <- !is.na(num) & num > 20000 & num < 60000
    any(!is.na(a) | !is.na(b) | !is.na(c) | serial_ok)
  }
  
  needs_folder_date <-
    (!"Date" %in% names(df)) ||
    all(is.na(df$Date)) ||
    all(looks_like_time(df$Date) | !nzchar(as.character(df$Date)), na.rm = TRUE) ||
    !can_parse_as_date(df$Date)
  
  if (needs_folder_date) {
    df$Date <- as.character(extract_folder_date(fp))
  }
  # -------------------------------------------------------------------------------
  
  # Normalize unlabeled pitch types (unchanged)
  if ("TaggedPitchType" %in% names(df)) {
    df$TaggedPitchType <- ifelse(
      is.na(df$TaggedPitchType) | df$TaggedPitchType == "",
      "Undefined",
      df$TaggedPitchType
    )
  }
  
  df$SourceFile <- fp
  df
}


# Build a KDE-based posterior P(Y=1 | x,y) = p1 * f1(x,y) / f_all(x,y)
kde_ratio_grid <- function(x, y, y_is_one, lims = c(-2.5,2.5,0,4.5), n = 180, h = NULL) {
  ok   <- is.finite(x) & is.finite(y) & is.finite(y_is_one)
  x    <- x[ok]; y <- y[ok]; y1 <- y_is_one[ok] > 0
  if (!length(x) || sum(y1) == 0) {
    return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
  }
  p1 <- mean(y1)
  # only pass 'h' if it's not NULL (avoids rep(NULL, ...) warnings inside MASS)
  if (is.null(h)) {
    d_all <- MASS::kde2d(x,      y,      n = n, lims = lims)
    d_pos <- MASS::kde2d(x[y1],  y[y1],  n = n, lims = lims)
  } else {
    d_all <- MASS::kde2d(x,      y,      n = n, lims = lims, h = h)
    d_pos <- MASS::kde2d(x[y1],  y[y1],  n = n, lims = lims, h = h)
  }
  z <- (p1 * d_pos$z) / pmax(d_all$z, 1e-12)
  z <- pmin(pmax(z, 0), 1)  # clamp
  expand.grid(x = d_all$x, y = d_all$y) |> transform(z = as.vector(z))
}


# Smooth mean over space for EV / LA (uses akima if available, else bin+loess fallback)
# replace your smooth_mean_grid() with this version
smooth_mean_grid <- function(x, y, val, lims = c(-2.5,2.5,0,4.5), n = 160,
                             method = c("auto","loess","akima"), span = 0.6) {
  method <- match.arg(method)
  ok <- is.finite(x) & is.finite(y) & is.finite(val)
  x <- x[ok]; y <- y[ok]; val <- val[ok]
  if (!length(x)) return(data.frame(x=numeric(0), y=numeric(0), z=numeric(0)))
  
  xs <- seq(lims[1], lims[2], length.out = n)
  ys <- seq(lims[3], lims[4], length.out = n)
  
  if (method == "akima" || (method == "auto" && have_akima)) {
    surf <- akima::interp(x, y, val, xo = xs, yo = ys,
                          linear = TRUE, extrap = TRUE, duplicate = "mean")
    expand.grid(x = surf$x, y = surf$y) |> transform(z = as.vector(surf$z))
  } else {
    df <- data.frame(x = x, y = y, z = val)
    fit <- suppressWarnings(loess(z ~ x * y, data = df, span = span,
                                  control = loess.control(surface = "direct")))
    grid <- expand.grid(x = xs, y = ys)
    grid$z <- as.numeric(predict(fit, newdata = grid))
    grid
  }
}

# Drawing helper (strike zone + plate + filled contours with your palette)
# replace your current draw_heat() with this version
# Drawing helper (strike zone + plate + filled contours with your palette)
# Updated version with scale legend support
draw_heat <- function(grid, bins = HEAT_BINS, pal_fun = heat_pal_red,
                      title = NULL, mark_max = TRUE, breaks = NULL,
                      show_scale = FALSE, scale_label = NULL, scale_limits = NULL,
                      scale_breaks = NULL, scale_labels = NULL) {
  if (!nrow(grid)) return(ggplot() + theme_void())
  
  home <- data.frame(
    x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
    y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
  )
  sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
  
  peak_df <- NULL
  if (mark_max) {
    i <- which.max(grid$z)
    if (length(i) && is.finite(grid$z[i])) {
      peak_df <- data.frame(px = grid$x[i], py = grid$y[i])
    }
  }
  
  n_bins <- if (is.null(breaks)) bins else max(1, length(breaks) - 1)
  
  # Main heatmap plot
  p_heat <- ggplot(grid, aes(x, y, z = z)) +
    {
      if (is.null(breaks))
        geom_contour_filled(aes(fill = after_stat(level)), bins = bins, show.legend = FALSE)
      else
        geom_contour_filled(aes(fill = after_stat(level)), breaks = breaks, show.legend = FALSE)
    } +
    scale_fill_manual(values = pal_fun(n_bins), guide = "none") +
    geom_polygon(data = home, aes(x, y), fill = NA, color = "black", inherit.aes = FALSE) +
    geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
              fill = NA, color = "black", inherit.aes = FALSE) +
    { if (!is.null(peak_df))
      geom_point(data = peak_df, aes(x = px, y = py), inherit.aes = FALSE,
                 size = 3.8, shape = 21, fill = "red", color = "black", stroke = 0.5)
    } +
    coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
    theme_void() + 
    theme(legend.position = "none",
          plot.title = element_text(face = "bold", hjust = 0.5),
          plot.background = element_rect(fill = "transparent", color = NA),
          panel.background = element_rect(fill = "transparent", color = NA)) +
    labs(title = title)
  
  # If show_scale, add gradient bar on top
  if (show_scale && !is.null(scale_limits)) {
    # Create scale bar data matching strike zone width
    sz_width <- ZONE_RIGHT - ZONE_LEFT  # ~1.66 feet
    scale_data <- data.frame(
      x = seq(scale_limits[1], scale_limits[2], length.out = 200),
      y = 1,
      z = seq(scale_limits[1], scale_limits[2], length.out = 200)
    )
    
    scale_breaks_final <- if (!is.null(scale_breaks)) {
      scale_breaks
    } else if (!is.null(scale_limits) && length(scale_limits) >= 2) {
      c(scale_limits[1], mean(scale_limits), scale_limits[length(scale_limits)])
    } else if (is.null(breaks)) {
      pretty(scale_limits, n = 5)
    } else {
      fin <- breaks[is.finite(breaks)]
      fin[c(1, round(length(fin) / 2), length(fin))]
    }
    
    scale_labels_final <- scale_labels
    if (identical(scale_label, "Pitch Frequency") && length(scale_limits) >= 2) {
      scale_breaks_final <- scale_limits[c(1, length(scale_limits))]
      scale_labels_final <- c("Least", "Most")
    }
    
    p_scale <- ggplot(scale_data, aes(x = z, y = y, fill = z)) +
      geom_tile(width = (scale_limits[2] - scale_limits[1]) / 200, height = 1) +
      scale_fill_gradientn(colors = pal_fun(100), limits = scale_limits) +
      scale_x_continuous(
        breaks = scale_breaks_final,
        labels = if (is.null(scale_labels_final)) ggplot2::waiver() else scale_labels_final,
        limits = scale_limits,
        expand = c(0, 0)
      ) +
      coord_cartesian(xlim = scale_limits, ylim = c(0.5, 1.5)) +
      theme_void() +
      theme(
        legend.position = "none",
        axis.text.x = element_text(size = 10, face = "bold", margin = margin(t = 3)),
        axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 8)),
        plot.margin = margin(5, 0, 10, 0),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.background = element_rect(fill = "transparent", color = NA),
        aspect.ratio = 0.15  # Make scale bar much narrower
      ) +
      labs(x = scale_label)
    
    # Combine scale bar on top of heatmap with tighter layout
    return(p_scale / p_heat + plot_layout(heights = c(0.08, 1), widths = c(sz_width)))
  }
  
  p_heat
}


pitch_data <- purrr::map_dfr(all_csvs, read_one)

# Ensure required columns exist since downstream code expects them
# ------ add to need_cols ------
need_cols <- c(
  "Date","Pitcher","Email","PitcherThrows","TaggedPitchType",
  "InducedVertBreak","HorzBreak","RelSpeed","ReleaseTilt","BreakTilt",
  "SpinEfficiency","SpinRate","RelHeight","RelSide","Extension",
  "VertApprAngle","HorzApprAngle","PlateLocSide","PlateLocHeight",
  "PitchCall","KorBB","Balls","Strikes","SessionType","PlayID",
  "ExitSpeed","Angle","BatterSide",
  "PlayResult","TaggedHitType","OutsOnPlay",
  "Batter", "Catcher",
  "VideoClip","VideoClip2","VideoClip3"
)



for (nm in need_cols) if (!nm %in% names(pitch_data)) pitch_data[[nm]] <- NA_character_

# Type cleanup + standardization (now safe to coerce)
pitch_data <- pitch_data %>%
  mutate(
    Date            = parse_date_mdy(Date),
    Pitcher         = as.character(Pitcher),
    Email           = as.character(Email),
    PitcherThrows   = as.character(PitcherThrows),
    TaggedPitchType = trimws(as.character(TaggedPitchType)),
    InducedVertBreak= as.numeric(InducedVertBreak),
    HorzBreak       = as.numeric(HorzBreak),
    RelSpeed        = as.numeric(RelSpeed),
    ReleaseTilt     = as.numeric(ReleaseTilt),
    BreakTilt       = as.numeric(BreakTilt),
    SpinEfficiency  = as.numeric(SpinEfficiency),
    SpinRate        = as.numeric(SpinRate),
    RelHeight       = as.numeric(RelHeight),
    RelSide         = as.numeric(RelSide),
    VertApprAngle   = as.numeric(VertApprAngle),
    HorzApprAngle   = as.numeric(HorzApprAngle),
    PlateLocSide    = as.numeric(PlateLocSide),
    PlateLocHeight  = as.numeric(PlateLocHeight),
    Extension       = as.numeric(Extension),
    ExitSpeed       = as.numeric(ExitSpeed),   # ← NEW
    Angle           = as.numeric(Angle),       # ← NEW
    BatterSide      = as.character(BatterSide), # ← NEW
    PlayResult      = as.character(PlayResult),
    Batter         = as.character(Batter),
    Catcher = as.character(Catcher),
    SessionType = factor(
      dplyr::case_when(
        grepl("bull|prac", tolower(as.character(SessionType))) ~ "Bullpen",
        grepl("live|game|ab", tolower(as.character(SessionType))) ~ "Live",
        grepl("[/\\\\]practice[/\\\\]", tolower(SourceFile)) ~ "Bullpen",  # fallback: folder
        grepl("[/\\\\]v3[/\\\\]",       tolower(SourceFile)) ~ "Live",
        TRUE ~ NA_character_
      ),
      levels = c("Bullpen","Live")
    ),
    KorBB           = as.character(KorBB),
    Balls           = as.numeric(Balls),
    Strikes         = as.numeric(Strikes),
    # Convert FourSeamFastBall to Fastball
    TaggedPitchType = ifelse(TaggedPitchType == "FourSeamFastBall", "Fastball", TaggedPitchType)
  ) %>%
  dplyr::filter(!is.na(TaggedPitchType) & tolower(TaggedPitchType) != "undefined") %>%
  force_pitch_levels()

# ---- Attach Cloudinary video URLs when available ----
video_map_path <- file.path(data_parent, "video_map.csv")
manual_map_path <- file.path(data_parent, "video_map_manual.csv")
if (!"VideoClip"  %in% names(pitch_data)) pitch_data$VideoClip  <- NA_character_
if (!"VideoClip2" %in% names(pitch_data)) pitch_data$VideoClip2 <- NA_character_
if (!"VideoClip3" %in% names(pitch_data)) pitch_data$VideoClip3 <- NA_character_

# Combine EdgeR and manual/iPhone video maps
video_maps <- list()
if (file.exists(video_map_path)) {
  edger_raw <- suppressMessages(readr::read_csv(video_map_path, show_col_types = FALSE))
  if (nrow(edger_raw) > 0) {
    video_maps[["edger"]] <- edger_raw
    message("📹 Loaded ", nrow(edger_raw), " EdgeR videos")
  }
}
if (file.exists(manual_map_path)) {
  manual_raw <- suppressMessages(readr::read_csv(manual_map_path, show_col_types = FALSE))
  if (nrow(manual_raw) > 0) {
    video_maps[["manual"]] <- manual_raw
    message("📱 Loaded ", nrow(manual_raw), " iPhone videos")
  }
}

if (length(video_maps) > 0) {
  vm_raw <- dplyr::bind_rows(video_maps) %>% dplyr::distinct()
  message("🎬 Combined total: ", nrow(vm_raw), " videos available")
  if (nrow(vm_raw)) {
    vm_wide <- vm_raw %>%
      dplyr::mutate(
        play_id = tolower(as.character(play_id)),
        camera_slot = dplyr::case_when(
          camera_slot %in% c("VideoClip","VideoClip2","VideoClip3") ~ camera_slot,
          TRUE ~ NA_character_
        ),
        uploaded_at = suppressWarnings(lubridate::ymd_hms(uploaded_at, quiet = TRUE, tz = "UTC"))
      ) %>%
      dplyr::filter(
        nzchar(play_id),
        !is.na(camera_slot),
        nzchar(cloudinary_url)
      ) %>%
      dplyr::arrange(play_id, camera_slot, dplyr::desc(uploaded_at)) %>%
      dplyr::group_by(play_id, camera_slot) %>%
      dplyr::slice_head(n = 1) %>%
      dplyr::ungroup() %>%
      tidyr::pivot_wider(
        id_cols = play_id,
        names_from = camera_slot,
        values_from = cloudinary_url
      )
    
    if (nrow(vm_wide)) {
      pitch_data <- pitch_data %>%
        dplyr::mutate(.play_lower = tolower(as.character(PlayID))) %>%
        dplyr::left_join(vm_wide, by = c(".play_lower" = "play_id"), suffix = c("", ".vm")) %>%
        { 
          vm_cols <- paste0(c("VideoClip","VideoClip2","VideoClip3"), ".vm")
          for (vm_col in vm_cols) {
            if (!vm_col %in% names(.)) .[[vm_col]] <- NA_character_
          }
          .
        } %>%
        dplyr::mutate(
          VideoClip  = dplyr::coalesce(.data[["VideoClip.vm"]],  VideoClip),
          VideoClip2 = dplyr::coalesce(.data[["VideoClip2.vm"]], VideoClip2),
          VideoClip3 = dplyr::coalesce(.data[["VideoClip3.vm"]], VideoClip3)
        ) %>%
        dplyr::select(-dplyr::ends_with(".vm"), -.play_lower)
      matched_videos <- sum(nzchar(pitch_data$VideoClip %||% ""))
      message("✅ Attached videos for ", matched_videos, " pitches from combined maps")
    } else {
      message("⚠️  Video maps loaded but no rows matched PlayID in pitch data.")
    }
  }
}

pitch_data <- ensure_pitch_keys(pitch_data)

# Friendly load message
counts <- table(pitch_data$SessionType, useNA = "no")
bcount <- if ("Bullpen" %in% names(counts)) counts[["Bullpen"]] else 0
lcount <- if ("Live"    %in% names(counts)) counts[["Live"]]    else 0
message("Loaded ", nrow(pitch_data), " rows from ", length(all_csvs),
        " files | Bullpen: ", bcount, " | Live: ", lcount,
        " | root: ", data_parent)


# Read lookup table and keep Email in a separate column to avoid .x/.y
lookup_table <- if (file.exists("lookup_table.csv")) {
  read.csv("lookup_table.csv", stringsAsFactors = FALSE) %>%
    dplyr::rename(Pitcher = PlayerName, Email_lookup = Email)
} else {
  data.frame(Pitcher = character(), Email_lookup = character(), stringsAsFactors = FALSE)
}

# Join, then coalesce into a single Email column
pitch_data <- dplyr::left_join(pitch_data, lookup_table, by = "Pitcher") %>%
  dplyr::mutate(Email = dplyr::coalesce(Email, Email_lookup)) %>%
  dplyr::select(-Email_lookup)


# (keep your name_map construction the same)
raw_names <- sort(unique(pitch_data$Pitcher))
display_names <- ifelse(
  grepl(",", raw_names),
  vapply(strsplit(raw_names, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_names
)
name_map <- setNames(raw_names, display_names)

raw_hitters <- sort(unique(na.omit(as.character(pitch_data$Batter))))
hit_display <- ifelse(
  grepl(",", raw_hitters),
  vapply(strsplit(raw_hitters, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_hitters
)
batter_map <- setNames(raw_hitters, hit_display)

# Opponent pitchers map (for hitting suite - pitchers who threw against our batters)
raw_opp_pitchers <- sort(unique(na.omit(as.character(pitch_data$Pitcher))))
opp_pitch_display <- ifelse(
  grepl(",", raw_opp_pitchers),
  vapply(strsplit(raw_opp_pitchers, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_opp_pitchers
)
opponent_pitcher_map <- setNames(raw_opp_pitchers, opp_pitch_display)

raw_catchers <- sort(unique(na.omit(as.character(pitch_data$Catcher))))
catch_display <- ifelse(
  grepl(",", raw_catchers),
  vapply(strsplit(raw_catchers, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_catchers
)
catcher_map <- setNames(raw_catchers, catch_display)


# ==== PITCHERS-ONLY WHITELIST ====
ALLOWED_PITCHERS <- school_setting("allowed_pitchers", c(
  "Wentworth, TP",
  "LeBlanc, Bryce",
  "Lund, Ethan",
  "Fyke, Kai",
  "Rhodes, Stormy",
  "Wech, Noah",
  "Brown, Matthew",
  "Phillips, Brennan",
  "Blake, Drew",
  "Glendinning, Lucas",
  "Golden, Josiah",
  "Kennedy, Jake",
  "Barrett, Hudson",
  "Zagar, Kyler",
  "Albright, Gaige",
  "Sramek, Caden",
  "Jennings, Parker",
  "Burns, Zane",
  "Winslow, Drew",
  "Pearcy, Kyle",
  "Turner, Cael",
  "Pesca, Mario",
  "Watkins, Hunter",
  "Thompson, Brock",
  "Meola, Aidan",
  "Bowen, Terrance",
  "Smithwick, Campbell",
  "Shull, Garrett",
  "Indomenico, Remo",
  "Ortiz, Avery",
  "Wallace, Danny",
  "Brueggemann, Colin",
  "Ritchie, Kollin",
  "Conover, Alex",
  "Norman, Sebastian",
  "Essex, Ezra",
  "Saunders, Evan",
  "Pladson, Cole",
  "Schambow, Quinn",
  "Kennedy, Ty",
  "Francisco, Brady",
  "Pomeroy, Deacon",
  "Kennedy, Jacob"
))

# Mirror list for hitters (GCU hitters)
ALLOWED_HITTERS <- school_setting("allowed_hitters", c(
  "Wentworth, TP",
  "LeBlanc, Bryce",
  "Lund, Ethan",
  "Fyke, Kai",
  "Rhodes, Stormy",
  "Wech, Noah",
  "Brown, Matthew",
  "Phillips, Brennan",
  "Blake, Drew",
  "Glendinning, Lucas",
  "Golden, Josiah",
  "Kennedy, Jake",
  "Barrett, Hudson",
  "Zagar, Kyler",
  "Albright, Gaige",
  "Sramek, Caden",
  "Jennings, Parker",
  "Burns, Zane",
  "Winslow, Drew",
  "Pearcy, Kyle",
  "Turner, Cael",
  "Pesca, Mario",
  "Watkins, Hunter",
  "Thompson, Brock",
  "Meola, Aidan",
  "Bowen, Terrance",
  "Smithwick, Campbell",
  "Shull, Garrett",
  "Indomenico, Remo",
  "Ortiz, Avery",
  "Wallace, Danny",
  "Brueggemann, Colin",
  "Ritchie, Kollin",
  "Conover, Alex",
  "Norman, Sebastian",
  "Essex, Ezra",
  "Saunders, Evan",
  "Pladson, Cole",
  "Schambow, Quinn",
  "Kennedy, Ty",
  "Francisco, Brady",
  "Pomeroy, Deacon"
))

# CAMPS SUITE - Allowed campers for camps module
ALLOWED_CAMPERS <- school_setting("allowed_campers", c(
  "Bowman, Brock",
  "Daniels, Tyke",
  "Pearson, Blake",
  "Rodriguez, Josiah",
  "James, Brody",
  "Nevarez, Matthew",
  "Nunes, Nolan",
  "Parks, Jaeden",
  "Hill, Grant",
  "McGinnis, Ayden",
  "Morton, Ryker",
  "McGuire, John",
  "Willson, Brandon",
  "Lauterbach, Camden",
  "Turnquist, Dylan",
  "Bournonville, Tanner",
  "Evans, Lincoln",
  "Gnirk, Will",
  "Mann, Tyson",
  "Neneman, Chase",
  "Warmus, Joaquin",
  "Kapadia, Taylor",
  "Stoner, Timothy",
  "Bergloff, Cameron",
  "Hamm, Jacob",
  "Hofmeister, Ben",
  "Moo, Eriksen",
  "Peltz, Zayden",
  "Huff, Tyler",
  "Moseman, Cody"
))


`%in_ci%` <- function(x, y) tolower(x) %in% tolower(y)

# NEW: normalize for case, spaces, punctuation (so "D.J." == "DJ")
norm_name_ci <- function(x) gsub("[^a-z]", "", tolower(trimws(as.character(x))))

# Keep the full dataset for Hitting & global refs
# but build a PITCHING-ONLY copy that is filtered to the whitelist
# (affects Pitching, Comparison, Leaderboard modules that use pitch_data_pitching)
# If you ever want admins to bypass this, wrap the filter in `if (!is_admin()) { ... }`.
pitch_data_pitching <- pitch_data %>%
  dplyr::mutate(
    Pitcher = as.character(Pitcher),
    # Build a "First Last" display from "Last, First" for matching either style
    .disp = ifelse(grepl(",", Pitcher),
                   paste0(trimws(sub(".*,", "", Pitcher)), " ", trimws(sub(",.*", "", Pitcher))),
                   Pitcher)
  )

# Accept either "Last, First" or "First Last" in ALLOWED_PITCHERS
ALLOWED_PITCHERS_DL <- unique(c(
  ALLOWED_PITCHERS,
  ifelse(grepl(",", ALLOWED_PITCHERS),
         paste0(trimws(sub(".*,", "", ALLOWED_PITCHERS)), " ", trimws(sub(",.*", "", ALLOWED_PITCHERS))),
         ALLOWED_PITCHERS)
))
ALLOWED_HITTERS_DL <- unique(c(
  ALLOWED_HITTERS,
  ifelse(grepl(",", ALLOWED_HITTERS),
         paste0(trimws(sub(".*,", "", ALLOWED_HITTERS)), " ", trimws(sub(",.*", "", ALLOWED_HITTERS))),
         ALLOWED_HITTERS)
))

# Also include ALLOWED_CAMPERS in the pitching dataset
ALLOWED_CAMPERS_DL <- unique(c(
  ALLOWED_CAMPERS,
  ifelse(grepl(",", ALLOWED_CAMPERS),
         paste0(trimws(sub(".*,", "", ALLOWED_CAMPERS)), " ", trimws(sub(",.*", "", ALLOWED_CAMPERS))),
         ALLOWED_CAMPERS)
))

# Combine both allowed lists for the pitching dataset
ALL_ALLOWED_PITCHERS <- unique(c(ALLOWED_PITCHERS_DL, ALLOWED_CAMPERS_DL))
ALL_ALLOWED_HITTERS  <- unique(c(ALLOWED_HITTERS_DL,  ALLOWED_CAMPERS_DL))

# Robust, case/spacing/punctuation-insensitive filter
allowed_norm <- norm_name_ci(ALL_ALLOWED_PITCHERS)
pitch_data_pitching <- pitch_data_pitching %>%
  dplyr::mutate(.norm_raw  = norm_name_ci(Pitcher),
                .norm_disp = norm_name_ci(.disp)) %>%
  dplyr::filter(.norm_raw %in% allowed_norm | .norm_disp %in% allowed_norm) %>%
  dplyr::select(-.disp, -.norm_raw, -.norm_disp)

pitch_data_pitching <- ensure_pitch_keys(pitch_data_pitching)

# Name map for Pitching UI (restricted to the filtered set)
raw_names_p <- sort(unique(pitch_data_pitching$Pitcher))
display_names_p <- ifelse(
  grepl(",", raw_names_p),
  vapply(strsplit(raw_names_p, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_names_p
)
name_map_pitching <- setNames(raw_names_p, display_names_p)


# ---- NEW: xStat reference bins from your data ----
xbin_ref <- pitch_data %>%
  dplyr::filter(SessionType == "Live",
                PitchCall == "InPlay",
                is.finite(ExitSpeed), is.finite(Angle)) %>%
  dplyr::mutate(
    EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
    LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
  ) %>%
  dplyr::group_by(EVb, LAb) %>%
  dplyr::summarise(
    n   = dplyr::n(),
    p1B = mean(PlayResult == "Single", na.rm = TRUE),
    p2B = mean(PlayResult == "Double", na.rm = TRUE),
    p3B = mean(PlayResult == "Triple", na.rm = TRUE),
    pHR = mean(PlayResult == "HomeRun",na.rm = TRUE),
    .groups = "drop"
  )

# Fallback weighted means in case some bins are empty
x_overall <- xbin_ref %>%
  dplyr::summarise(
    p1B = weighted.mean(p1B, n), p2B = weighted.mean(p2B, n),
    p3B = weighted.mean(p3B, n), pHR = weighted.mean(pHR, n)
  )

# FanGraphs-like wOBA weights (approx)
W_BB <- 0.69; W_1B <- 0.90; W_2B <- 1.24; W_3B <- 1.56; W_HR <- 1.95

# ---- Usage calculations for count-based usage percentages ----
compute_usage_by_count <- function(df, original_df = NULL) {
  # Determine which column to use for pitch type grouping
  pitch_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
  
  denom_df <- if (!is.null(original_df)) original_df else df
  by_pt <- split(df, ifelse(is.na(df[[pitch_col]]) | !nzchar(as.character(df[[pitch_col]])), "Undefined", as.character(df[[pitch_col]])))
  
  total_pitches <- nrow(denom_df)
  total_0_0 <- sum(denom_df$Balls == 0 & denom_df$Strikes == 0, na.rm = TRUE)
  total_behind <- sum(denom_df$Balls %in% c(1,2,3) & denom_df$Strikes %in% c(0,1) &
                        ((denom_df$Balls == 1 & denom_df$Strikes == 0) |
                           (denom_df$Balls == 2 & denom_df$Strikes %in% c(0,1)) |
                           (denom_df$Balls == 3 & denom_df$Strikes %in% c(0,1))), na.rm = TRUE)
  total_even <- sum((denom_df$Balls == 0 & denom_df$Strikes == 0) |
                      (denom_df$Balls == 1 & denom_df$Strikes == 1) |
                      (denom_df$Balls == 2 & denom_df$Strikes == 2) |
                      (denom_df$Balls == 3 & denom_df$Strikes == 2), na.rm = TRUE)
  total_ahead <- sum((denom_df$Balls == 0 & denom_df$Strikes %in% c(1,2)) |
                       (denom_df$Balls == 1 & denom_df$Strikes == 2), na.rm = TRUE)
  total_less_2k <- sum(denom_df$Strikes < 2, na.rm = TRUE)
  total_2k <- sum(denom_df$Strikes == 2, na.rm = TRUE)
  
  pct_string <- function(num, den) {
    if (is.na(den) || den <= 0) return("0.0%")
    paste0(round(100 * num / den, 1), "%")
  }
  
  calc_usage <- function(dfi) {
    pitch_lab <- dfi[[pitch_col]][1]
    if (is.factor(pitch_lab)) pitch_lab <- as.character(pitch_lab)
    pitch_lab <- ifelse(is.na(pitch_lab) || !nzchar(pitch_lab), "Undefined", pitch_lab)
    
    overall <- pct_string(nrow(dfi), total_pitches)
    usage_0_0 <- pct_string(sum(dfi$Balls == 0 & dfi$Strikes == 0, na.rm = TRUE), total_0_0)
    usage_behind <- pct_string(
      sum(dfi$Balls %in% c(1,2,3) & dfi$Strikes %in% c(0,1) &
            ((dfi$Balls == 1 & dfi$Strikes == 0) |
               (dfi$Balls == 2 & dfi$Strikes %in% c(0,1)) |
               (dfi$Balls == 3 & dfi$Strikes %in% c(0,1))), na.rm = TRUE),
      total_behind
    )
    usage_even <- pct_string(
      sum((dfi$Balls == 0 & dfi$Strikes == 0) |
            (dfi$Balls == 1 & dfi$Strikes == 1) |
            (dfi$Balls == 2 & dfi$Strikes == 2) |
            (dfi$Balls == 3 & dfi$Strikes == 2), na.rm = TRUE),
      total_even
    )
    usage_ahead <- pct_string(
      sum((dfi$Balls == 0 & dfi$Strikes %in% c(1,2)) |
            (dfi$Balls == 1 & dfi$Strikes == 2), na.rm = TRUE),
      total_ahead
    )
    usage_less_2k <- pct_string(sum(dfi$Strikes < 2, na.rm = TRUE), total_less_2k)
    usage_2k <- pct_string(sum(dfi$Strikes == 2, na.rm = TRUE), total_2k)
    
    tibble::tibble(
      PitchType = pitch_lab,
      Usage     = overall,
      `0-0`     = usage_0_0,
      Behind    = usage_behind,
      Even      = usage_even,
      Ahead     = usage_ahead,
      `<2K`     = usage_less_2k,
      `2K`      = usage_2k
    )
  }
  
  out <- purrr::map_dfr(by_pt, calc_usage) %>%
    dplyr::mutate(PitchType = as.character(PitchType))
  all_row <- calc_usage(df) %>%
    dplyr::mutate(PitchType = "All")
  dplyr::bind_rows(out, all_row)
}

# ---- NEW: calculator for Process/Results metrics per pitch type (+ All) ----
compute_process_results <- function(df, mode = "All") {
  return(tryCatch({
    # Flatten any list columns early to avoid list inputs in downstream sums
    df <- flatten_metrics_df(df)
    # Force key fields to atomic types
    chr_fields <- intersect(c("PitchCall","PlayResult","TaggedHitType","KorBB","SessionType","SplitColumn","TaggedPitchType"), names(df))
    num_fields <- intersect(c("ExitSpeed","Angle","OutsOnPlay","Balls","Strikes"), names(df))
    for (nm in chr_fields) {
      if (is.list(df[[nm]])) {
        df[[nm]] <- vapply(df[[nm]], function(v) if (length(v)) as.character(v[[1]]) else NA_character_, character(1))
      } else {
        df[[nm]] <- as.character(df[[nm]])
      }
    }
    for (nm in num_fields) {
      if (is.list(df[[nm]])) {
        df[[nm]] <- vapply(df[[nm]], function(v) if (length(v)) suppressWarnings(as.numeric(v[[1]])) else NA_real_, numeric(1))
      } else {
        df[[nm]] <- suppressWarnings(as.numeric(df[[nm]]))
      }
    }
    # Last sweep: collapse any remaining list columns to character
    for (nm in names(df)) {
      if (is.list(df[[nm]])) {
        df[[nm]] <- vapply(df[[nm]], function(v) if (length(v)) as.character(v[[1]]) else NA_character_, character(1))
      }
    }
    
    # Determine which column to use for pitch type grouping
    # Prefer SplitColumn if it exists (Split By mode), otherwise use TaggedPitchType
    pitch_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
  
  calc_run_value <- function(pitch_call, play_result, korbb = NA) {
    pitch_call  <- as.character(pitch_call)
    play_result <- as.character(play_result)
    korbb       <- as.character(korbb)
    
    if (!is.na(korbb) && nzchar(korbb) && korbb != "NA") {
      if (korbb == "Strikeout") return(-0.27)
      if (korbb == "Walk")     return(0.33)
    }
    if (pitch_call %in% c("BallCalled", "BallIntentional", "BallinDirt")) return(0.03)
    if (pitch_call %in% c("StrikeCalled", "StrikeSwinging", "FoulBall",
                          "FoulBallFieldable", "FoulBallNotFieldable"))  return(-0.03)
    if (pitch_call == "HitByPitch" || play_result %in% c("Walk","IntentionalWalk","HitByPitch")) return(0.33)
    if (pitch_call == "InPlay") {
      if (play_result == "Single")   return(0.47)
      if (play_result == "Double")   return(0.78)
      if (play_result == "Triple")   return(1.09)
      if (play_result == "HomeRun")  return(1.40)
      if (play_result == "Error")    return(0.33)
      return(-0.27)
    }
    0
  }
  
  # split by pitch *as character*, not factor (prevents int/chr mixups later)
  by_pt <- split(
    df,
    ifelse(
      is.na(df[[pitch_col]]) | !nzchar(as.character(df[[pitch_col]])),
      "Undefined",
      as.character(df[[pitch_col]])
    )
  )
  
  calc_one <- function(dfi) {
    # Per-group safety: flatten again after split
    dfi <- as.data.frame(dfi, stringsAsFactors = FALSE, check.names = FALSE)
    for (nm in names(dfi)) {
      col <- dfi[[nm]]
      if (is.list(col)) {
        # If list of scalars, unlist; else take first element
        if (all(lengths(col) <= 1)) {
          dfi[[nm]] <- vapply(col, function(v) if (length(v)) v[[1]] else NA, FUN.VALUE = NA_character_)
        } else {
          dfi[[nm]] <- vapply(col, function(v) if (length(v)) as.character(v[[1]]) else NA_character_, character(1))
        }
      }
    }
    # Coerce key fields per group
    chr_fields_g <- intersect(c("PitchCall","PlayResult","TaggedHitType","KorBB","SessionType","SplitColumn", pitch_col), names(dfi))
    num_fields_g <- intersect(c("Balls","Strikes","OutsOnPlay","ExitSpeed","Angle"), names(dfi))
    for (nm in chr_fields_g) dfi[[nm]] <- as.character(dfi[[nm]])
    for (nm in num_fields_g) dfi[[nm]] <- suppressWarnings(as.numeric(dfi[[nm]]))

    # label for this group (force character, fall back to "Undefined")
    pitch_lab <- dfi[[pitch_col]][1]
    if (is.factor(pitch_lab)) pitch_lab <- as.character(pitch_lab)
    pitch_lab <- ifelse(is.na(pitch_lab) || !nzchar(pitch_lab), "Undefined", pitch_lab)
    
    pitch_n   <- nrow(dfi)
    dfi_live  <- dfi %>% dplyr::filter(SessionType == "Live")
    # Use the shared completed-PA BF calc (same as Leaderboard), Live only
    BF_live   <- calculate_bf(dfi_live)
    K_ct      <- sum(dfi_live$KorBB == "Strikeout", na.rm = TRUE)
    BB_ct     <- sum(dfi_live$KorBB == "Walk",      na.rm = TRUE)
    
    # CSW% (prefer PitchResult if present)
    # --- CSW% (from PitchCall only) ---
    csw_num <- if ("PitchCall" %in% names(dfi)) {
      sum(dfi$PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE)
    } else 0L
    
    `CSW%` <- fmt_pct1(csw_num, nrow(dfi))  # 1-decimal percent string
    
    
    # In-play denominators
    inplay_all  <- sum(dfi$PitchCall == "InPlay", na.rm = TRUE)
    inplay_live <- sum(dfi$SessionType == "Live" & dfi$PitchCall == "InPlay", na.rm = TRUE)
    
    # BABIP
    H_bip <- sum(dfi$PlayResult %in% c("Single","Double","Triple","HomeRun"), na.rm = TRUE)
    BABIP <- if (inplay_all > 0) fmt_rate3(H_bip / inplay_all) else ""
    
    # GB%
    GB_pct <- if (inplay_all > 0)
      paste0(round(100 * sum(dfi$TaggedHitType == "GroundBall", na.rm = TRUE) / inplay_all, 1), "%") else ""
    
    # Barrel%
    barrel_n <- sum(dfi$SessionType == "Live" & dfi$PitchCall == "InPlay" &
                      is.finite(dfi$ExitSpeed) & is.finite(dfi$Angle) &
                      dfi$ExitSpeed >= 95 & dfi$Angle >= 10 & dfi$Angle <= 35, na.rm = TRUE)
    Barrel_pct <- if (inplay_live > 0) paste0(round(100 * barrel_n / inplay_live, 1), "%") else ""
    
    # AVG / SLG over AB (exclude Undefined, Sacrifice)
    is_ab   <- !is.na(dfi$PlayResult) & !(dfi$PlayResult %in% c("Undefined","Sacrifice"))
    AB_ct   <- sum(is_ab, na.rm = TRUE)
    s1 <- sum(dfi$PlayResult == "Single",   na.rm = TRUE)
    s2 <- sum(dfi$PlayResult == "Double",   na.rm = TRUE)
    s3 <- sum(dfi$PlayResult == "Triple",   na.rm = TRUE)
    hr <- sum(dfi$PlayResult == "HomeRun",  na.rm = TRUE)
    H  <- s1 + s2 + s3 + hr
    TB <- 1*s1 + 2*s2 + 3*s3 + 4*hr
    
    AVG <- if (AB_ct > 0) fmt_rate3(H  / AB_ct) else ""
    SLG <- if (AB_ct > 0) fmt_rate3(TB / AB_ct) else ""
    
    # Expected hits/total bases from EV/LA bins (uses globals: xbin_ref, x_overall)
    bip_evla <- dfi %>%
      dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                    is.finite(ExitSpeed), is.finite(Angle)) %>%
      dplyr::mutate(
        EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
        LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
      ) %>%
      dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
    
    if (nrow(bip_evla)) {
      for (nm in c("p1B","p2B","p3B","pHR")) {
        bip_evla[[nm]][!is.finite(bip_evla[[nm]])] <- x_overall[[nm]]
      }
      x1B <- sum(bip_evla$p1B, na.rm = TRUE)
      x2B <- sum(bip_evla$p2B, na.rm = TRUE)
      x3B <- sum(bip_evla$p3B, na.rm = TRUE)
      xHR <- sum(bip_evla$pHR, na.rm = TRUE)
    } else {
      x1B <- x2B <- x3B <- xHR <- 0
    }
    
    xH   <- x1B + x2B + x3B + xHR
    xTB  <- 1*x1B + 2*x2B + 3*x3B + 4*xHR
    
    xAVG <- if (AB_ct > 0) fmt_rate3(xH / AB_ct)  else ""
    xSLG <- if (AB_ct > 0) fmt_rate3(xTB / AB_ct) else ""
    xISO <- if (AB_ct > 0) {
      as_num <- function(s) if (nzchar(s)) as.numeric(paste0("0", s)) else NA_real_
      v <- as_num(xSLG) - as_num(xAVG); fmt_rate3(v)
    } else ""
    
    # xWOBA per BF (globals: W_BB, W_1B, W_2B, W_3B, W_HR)
    xWOBA <- if (BF_live > 0) {
      w_num <- W_BB*BB_ct + W_1B*(x1B) + W_2B*(x2B) + W_3B*(x3B) + W_HR*(xHR)
      fmt_rate3(w_num / BF_live)
    } else ""
    
    # --- Outs / IP / FIP / WHIP (now includes strikeout outs) ---
    o_on_play <- suppressWarnings(sum(as.numeric(dfi$OutsOnPlay), na.rm = TRUE))
    k_outs    <- K_ct                              # each strikeout = 1 out
    tot_outs  <- o_on_play + k_outs
    ip_num    <- tot_outs / 3
    
    # RV/100 (sum of run values per pitch, scaled)
    # RV/100 (Live only; leave blank for bullpens/other sessions)
    rv_vals <- mapply(
      calc_run_value,
      dfi_live$PitchCall,
      dfi_live$PlayResult,
      if ("KorBB" %in% names(dfi_live)) dfi_live$KorBB else NA
    )
    rv_sum <- sum(rv_vals, na.rm = TRUE)
    pitch_n_live <- nrow(dfi_live)
    rv100  <- if (pitch_n_live > 0) ((rv_sum / pitch_n_live) * 100) - 0.43 else NA_real_
    rv100_fmt <- ifelse(is.finite(rv100), sprintf("%.1f", rv100), "")
    
    # Baseball-style IP text (e.g., 2.1, 3.2)
    IP_txt <- {
      inns <- tot_outs %/% 3
      rem  <- tot_outs %% 3
      paste0(inns, if (rem == 0) "" else paste0(".", rem))
    }
    
    # FIP (no constant), per IP
    FIP <- if (tot_outs > 0) {
      val <- (13*hr + 3*BB_ct - 2*K_ct) / ip_num
      fmt_num2(val)
    } else ""
    
    # WHIP = (H + BB) / IP   ← now counts K outs via tot_outs → ip_num
    WHIP <- if (tot_outs > 0) fmt_num2((H + BB_ct) / ip_num) else ""
    
    tibble::tibble(
      PitchType = pitch_lab,
      `CSW%`    = fmt_pct1(
        sum(dfi$PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE),
        nrow(dfi)
      ),
      IP        = IP_txt,
      BABIP     = BABIP,
      `GB%`     = GB_pct,
      `Barrel%` = Barrel_pct,
      AVG       = AVG,
      SLG       = SLG,
      xWOBA     = xWOBA,
      xISO      = xISO,
      FIP       = FIP,
      WHIP      = WHIP,
      `RV/100`  = rv100_fmt
    )
  }
  
  # build per-type rows (force character), then append the "All" row
  out <- purrr::map_dfr(by_pt, calc_one) %>%
    dplyr::mutate(PitchType = as.character(PitchType))
  
  all_row <- calc_one(df) %>%
    dplyr::mutate(PitchType = "All")
  
  dplyr::bind_rows(out, all_row)
  }, error = function(e) {
    message("compute_process_results fallback (error): ", conditionMessage(e))
    tibble::tibble(
      PitchType = character(0),
      `CSW%`    = character(0),
      IP        = character(0),
      BABIP     = character(0),
      `GB%`     = character(0),
      `Barrel%` = character(0),
      AVG       = character(0),
      SLG       = character(0),
      xWOBA     = character(0),
      xISO      = character(0),
      FIP       = character(0),
      WHIP      = character(0),
      `RV/100`  = character(0)
    )
  }))
}

# ---- Global table helpers shared by Pitching & Hitting ----
safe_pct <- function(num, den) {
  num <- suppressWarnings(as.numeric(num))
  den <- suppressWarnings(as.numeric(den))
  ifelse(is.finite(den) & den > 0 & is.finite(num),
         paste0(round(100 * num / den, 1), "%"),
         "")
}

nz_mean <- function(x) {
  x <- suppressWarnings(as.numeric(x))
  m <- mean(x, na.rm = TRUE)
  if (is.finite(m)) m else NA_real_
}

.make_summary_legacy <- function(df) {
  if (!nrow(df)) {
    return(tibble::tibble(
      PitchType = character(), PitchCount = integer(), Usage = character(),
      BF = integer(), Velo_Avg = numeric(), Velo_Max = numeric(), IVB = numeric(), HB = numeric(),
      ReleaseTilt = character(), BreakTilt = character(),  # <- now character
      SpinEff = character(), InZonePercent = character(), CompPercent = character(),
      KPercent = character(), BBPercent = character(), FPSPercent = character(),
      EAPercent = character(), StrikePercent = character(), WhiffPercent = character(),
      SpinRate = numeric(), RelHeight = numeric(), RelSide = numeric(),
      VertApprAngle = numeric(), HorzApprAngle = numeric(), Extension = numeric(),
      EV = numeric(), LA = numeric(), `Stuff+` = numeric(), `Ctrl+` = numeric(),
      `QP+` = numeric(), `Pitching+` = numeric()
    ))
  }
  
  
  nz_mean <- function(x) { x <- suppressWarnings(as.numeric(x)); m <- mean(x, na.rm = TRUE); if (is.finite(m)) m else NA_real_ }
  safe_div <- function(num, den) ifelse(den > 0, num/den, NA_real_)
  
  # BF usage map for % column - with error handling
  usage_map <- tryCatch({
    df %>%
      dplyr::filter(SessionType == "Live", Balls == 0, Strikes == 0) %>%
      dplyr::count(TaggedPitchType, name = "BF") %>%
      dplyr::mutate(Usage = ifelse(sum(BF) > 0, 100*BF/sum(BF), 0)) %>%
      { stats::setNames(.$Usage, .$TaggedPitchType) }
  }, error = function(e) {
    message("Error creating usage_map: ", conditionMessage(e))
    # Return empty named vector
    stats::setNames(numeric(0), character(0))
  })
  
  # NEW: per-pitch QP points (0..1); NA for non-live or out of competitive box
  df <- df %>% dplyr::mutate(QP_pts = compute_qp_points(.))
  
  df %>%
    dplyr::group_by(TaggedPitchType) %>%
    dplyr::summarise(
      PitchCount     = dplyr::n(),
      BF_live        = sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE),
      
      Velo_Avg       = nz_mean(RelSpeed),
      Velo_Max       = suppressWarnings(max(RelSpeed, na.rm = TRUE)),
      IVB            = nz_mean(InducedVertBreak),
      HB             = nz_mean(HorzBreak),
      ReleaseTilt    = convert_to_clock(nz_mean(ReleaseTilt)),
      BreakTilt      = convert_to_clock(nz_mean(BreakTilt)),
      SpinEff        = nz_mean(SpinEfficiency),
      SpinRate       = nz_mean(SpinRate),
      RelHeight      = nz_mean(RelHeight),
      RelSide        = nz_mean(RelSide),
      VertApprAngle  = nz_mean(VertApprAngle),
      HorzApprAngle  = nz_mean(HorzApprAngle),
      Extension      = nz_mean(Extension),
      
      InZonePercent  = safe_div(
        sum(PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
              PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, na.rm = TRUE),
        dplyr::n()
      ),
      CompPercent    = safe_div(
        sum(PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
              PlateLocHeight >= (2.65-1.5) & PlateLocHeight <= (2.65+1.5), na.rm = TRUE),
        dplyr::n()
      ),
      StrikePercent  = safe_div(
        sum(PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE),
        sum(!is.na(PitchCall))
      ),
      FPSPercent     = safe_div(
        sum(SessionType == "Live" & Balls == 0 & Strikes == 0 &
              PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","StrikeCalled","FoulBallFieldable"), na.rm = TRUE),
        BF_live
      ),
      EAPercent      = safe_div(
        sum(SessionType == "Live" & Balls == 0 & Strikes == 0 &
              PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE),
        BF_live
      ),
      KPercent       = safe_div(sum(SessionType == "Live" & KorBB == "Strikeout", na.rm = TRUE), BF_live),
      BBPercent      = safe_div(sum(SessionType == "Live" & KorBB == "Walk",      na.rm = TRUE), BF_live),
      WhiffPercent   = safe_div(sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
                                sum(PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)),
      
      EV             = nz_mean(ifelse(SessionType == "Live", ExitSpeed, NA_real_)),
      LA             = nz_mean(ifelse(SessionType == "Live", Angle,     NA_real_)),
      
      `Stuff+`       = round(nz_mean(`Stuff+`), 1),
      
      # Keep Command+ available for users/tables that still show it
      `Ctrl+`     = round(nz_mean(ifelse(
        PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
          PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, 1.47,
        ifelse(PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                 PlateLocHeight >= (2.65-1.5) & PlateLocHeight <= (2.65+1.5), 0.73, 0)
      )) * 100, 1),
      
      # NEW: QP+ per pitch type, then Pitching+ from Stuff+ and QP+
      `QP+`          = round(nz_mean(QP_pts) * 200, 1),
      `Pitching+`    = round((`Stuff+` + `QP+`) / 2, 1),
      .groups = "drop"
    ) %>%
    {
      # Handle both TaggedPitchType and SplitColumn cases
      if ("TaggedPitchType" %in% names(.)) {
        dplyr::rename(., PitchType = TaggedPitchType)
      } else if ("SplitColumn" %in% names(.)) {
        dplyr::rename(., PitchType = SplitColumn)
      } else {
        .
      }
    } %>%
    dplyr::mutate(PitchType = as.character(PitchType)) %>%
    dplyr::arrange(factor(PitchType, levels = names(all_colors))) %>%
    dplyr::mutate(
      Usage = paste0(dplyr::coalesce(round(usage_map[as.character(PitchType)], 1), 0), "%")
    ) %>%
    dplyr::select(
      PitchType, PitchCount, Usage, BF = BF_live,
      Velo_Avg, Velo_Max, IVB, HB,
      ReleaseTilt, BreakTilt, SpinEff, SpinRate,
      RelHeight, RelSide, VertApprAngle, HorzApprAngle, Extension,
      InZonePercent, CompPercent, KPercent, BBPercent, FPSPercent, EAPercent,
      StrikePercent, WhiffPercent, EV, LA, `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
    )
}


# modern summary builder (aligned with app-21, retains Usage/Overall columns)
make_summary <- function(df, group_col = "TaggedPitchType") {
  if (!nrow(df)) {
    return(tibble::tibble(
      PitchType     = character(),
      PitchCount    = integer(),
      Usage         = character(),
      Overall       = character(),
      BF            = integer(),
      Velo_Avg      = numeric(),
      Velo_Max      = numeric(),
      IVB           = numeric(),
      HB            = numeric(),
      ReleaseTilt   = character(),
      BreakTilt     = character(),
      SpinEff       = numeric(),
      SpinRate      = numeric(),
      RelHeight     = numeric(),
      RelSide       = numeric(),
      VertApprAngle = numeric(),
      HorzApprAngle = numeric(),
      Extension     = numeric(),
      InZonePercent = character(),
      CompPercent   = character(),
      KPercent      = character(),
      BBPercent     = character(),
      FPSPercent    = character(),
      EAPercent     = character(),
      StrikePercent = character(),
      SwingPercent  = character(),
      WhiffPercent  = character(),
      QPPercent     = character(),
      EV            = numeric(),
      LA            = numeric(),
      `Stuff+`      = numeric(),
      `Ctrl+`       = numeric(),
      `QP+`         = numeric(),
      `Pitching+`   = numeric()
    ))
  }
  
  usage_map    <- tryCatch(
    usage_by_type(df),
    error = function(e) {
      message("Error in usage_by_type: ", conditionMessage(e))
      stats::setNames(numeric(0), character(0))
    }
  )
  swing_levels <- default_swing_levels()
  
  pf <- compute_pa_flags(df)
  df <- pf$df %>%
    dplyr::mutate(
      .is_strikeout = pf$is_strikeout,
      .is_walk      = pf$is_walk,
      .is_swing     = ifelse(!is.na(PitchCall) & PitchCall %in% swing_levels, 1, 0)
    )
  
  df <- df %>% dplyr::mutate(QP_pts = compute_qp_points(.))
  
  df %>%
    dplyr::group_by(.data[[group_col]]) %>%
    dplyr::summarise(
      PitchCount    = dplyr::n(),
      Velo_Avg      = round(nz_mean(RelSpeed), 1),
      Velo_Max      = round(suppressWarnings(max(as.numeric(RelSpeed), na.rm = TRUE)), 1),
      IVB           = round(nz_mean(InducedVertBreak), 1),
      HB            = round(nz_mean(HorzBreak), 1),
      ReleaseTilt   = convert_to_clock(nz_mean(ReleaseTilt)),
      BreakTilt     = convert_to_clock(nz_mean(BreakTilt)),
      SpinEff       = nz_mean(SpinEfficiency),
      SpinRate      = round(nz_mean(SpinRate), 0),
      RelHeight     = round(nz_mean(RelHeight), 1),
      RelSide       = round(nz_mean(RelSide), 1),
      VertApprAngle = round(nz_mean(VertApprAngle), 1),
      HorzApprAngle = round(nz_mean(HorzApprAngle), 1),
      Extension     = round(nz_mean(Extension), 1),
      
      InZonePercent = {
        inzone <- (PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                     PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP)
        safe_pct(sum(inzone, na.rm = TRUE), sum(!is.na(inzone)))
      },
      CompPercent   = {
        comp <- (PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                   PlateLocHeight >= (2.65-1.7) & PlateLocHeight <= (2.65+1.3))
        safe_pct(sum(comp, na.rm = TRUE), sum(!is.na(comp)))
      },
      
      # Use shared BF calculation
      BF_live = calculate_bf(dplyr::cur_data_all()),
      BF_all  = calculate_bf(dplyr::cur_data_all()),
      K_all   = sum(!is.na(Strikes) & Strikes == 2 & !is.na(PitchCall) & PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE),
      BB_all  = sum(!is.na(Balls) & Balls == 3 & !is.na(PitchCall) & PitchCall == "BallCalled", na.rm = TRUE),
      
      KPercent  = safe_pct(K_all,  BF_all),
      BBPercent = safe_pct(BB_all, BF_all),
      QPCount   = sum((QP_pts * 200) >= 100, na.rm = TRUE),
      fps_opp  = sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE),
      
      FPS_all = sum(SessionType == "Live" & !is.na(Balls) & !is.na(Strikes) & Balls == 0 & Strikes == 0 &
                      !is.na(PitchCall) & PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBall","FoulBallFieldable"), na.rm = TRUE),
      EA_all  = sum(
        SessionType == "Live" & (!is.na(Balls) & !is.na(Strikes) & !is.na(PitchCall)) & (
          (Balls == 0 & Strikes == 0 & PitchCall == "InPlay") |
            (Balls == 0 & Strikes == 1 & PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable","FoulBall"
            )) |
            (Balls == 1 & Strikes == 0 & PitchCall == "InPlay") |
            (Balls == 1 & Strikes == 1 & PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable","FoulBall"
            ))
        ), na.rm = TRUE
      ),
      
      FPSPercent = safe_pct(FPS_all, fps_opp),
      EAPercent  = safe_pct(EA_all,  fps_opp),
      QPPercent  = safe_pct(QPCount, PitchCount),
      
      StrikePercent = {
        strike_calls <- c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable","FoulBall")
        strikes <- sum(PitchCall %in% strike_calls, na.rm = TRUE)
        safe_pct(strikes, PitchCount)
      },
      SwingPercent = safe_pct(sum(.is_swing, na.rm = TRUE), PitchCount),
      WhiffPercent  = {
        sw  <- sum(PitchCall == "StrikeSwinging", na.rm = TRUE)
        den <- sum(PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay","FoulBall"), na.rm = TRUE)
        safe_pct(sw, den)
      },
      
      EV = round(nz_mean(ifelse(SessionType == "Live", ExitSpeed, NA_real_)), 1),
      LA = round(nz_mean(ifelse(SessionType == "Live", Angle,     NA_real_)), 1),
      
      `Stuff+`   = round(nz_mean(`Stuff+`), 1),
      `Ctrl+` = round(nz_mean(ifelse(
        PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
          PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, 1.47,
        ifelse(
          PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
            PlateLocHeight >= (2.65-1.7) & PlateLocHeight <= (2.65+1.3),
          0.73, 0
        )
      )) * 100, 1),
      
      `QP+`       = round(mean(QP_pts, na.rm = TRUE) * 200, 1),
      `Pitching+` = round((`Stuff+` + `QP+`) / 2, 1),
      .groups = "drop"
    ) %>%
    {
      # The group_by column will have the name specified in group_col
      # Rename it to PitchType for consistency
      current_names <- names(.)
      if (group_col %in% current_names && group_col != "PitchType") {
        dplyr::rename(., PitchType = !!rlang::sym(group_col))
      } else {
        .
      }
    } %>%
    dplyr::mutate(PitchType = as.character(PitchType)) %>%
    dplyr::arrange(factor(PitchType, levels = names(all_colors))) %>%
    dplyr::mutate(
      UsagePct = tryCatch(
        dplyr::coalesce(round(usage_map[as.character(PitchType)], 1), 0),
        error = function(e) 0
      ),
      Usage    = paste0(UsagePct, "%"),
      Overall  = Usage
    ) %>%
    dplyr::select(
      PitchType, PitchCount, Usage, Overall, BF = BF_all,
      Velo_Avg, Velo_Max, IVB, HB,
      ReleaseTilt, BreakTilt, SpinEff, SpinRate,
      RelHeight, RelSide, VertApprAngle, HorzApprAngle, Extension,
      InZonePercent, CompPercent, KPercent, BBPercent, FPSPercent, EAPercent, QPPercent,
      StrikePercent, SwingPercent, WhiffPercent, EV, LA,
      `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
    ) %>%
    # Conditionally remove UsagePct if it exists
    {if ("UsagePct" %in% names(.)) dplyr::select(., -UsagePct) else .}
}


# --- UI ----
# === ui wrapper ===
pitch_ui <- function(show_header = FALSE) {
  # ⬇️ Pitching UI (updated: ggiraphOutput → girafeOutput)
  fluidPage(
    tags$head(
    tags$style(HTML(colorize_css(
        '@media print { .tab-content>.tab-pane{display:block!important;opacity:1!important;page-break-after:always;} .tab-content>.tab-pane:last-child{page-break-after:auto;} .nav-tabs,.sidebar,.form-group,#printBtn{display:none!important;} }
        #pitchingSidebarToggle { 
          position: fixed; 
          bottom: 20px; 
          left: 20px; 
          z-index: 1000; 
          background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
          color: white; 
          border: none; 
          padding: 15px 18px; 
          border-radius: 50px;
          cursor: pointer;
          box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
          transition: all 0.3s ease;
          font-size: 20px;
          width: 56px;
          height: 56px;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        #pitchingSidebarToggle:hover { 
          transform: translateY(-2px);
          box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
          background: linear-gradient(135deg, #ff8c1a 0%, #e35205 100%);
        }
        #pitchingSidebarToggle:active {
          transform: translateY(0);
        }
        /* Hide the sidebar column */
        .pitching-sidebar-hidden .col-sm-3,
        .pitching-sidebar-hidden .sidebar { 
          display: none !important; 
        }
        /* Force the entire page to full width */
        .pitching-sidebar-hidden,
        .pitching-sidebar-hidden body,
        .pitching-sidebar-hidden .container-fluid,
        .pitching-sidebar-hidden .tab-content {
          width: 100vw !important;
          max-width: 100vw !important;
          margin: 0 !important;
          padding-left: 15px !important;
          padding-right: 15px !important;
        }
        /* Force sidebarLayout and all rows to full viewport width */
        .pitching-sidebar-hidden .row {
          width: 100vw !important;
          max-width: 100vw !important;
          margin-left: -15px !important;
          margin-right: -15px !important;
          padding-left: 15px !important;
          padding-right: 15px !important;
        }
        /* Expand main content to absolute full viewport width */
        .pitching-sidebar-hidden .col-sm-9,
        .pitching-sidebar-hidden .main-panel { 
          width: 100vw !important; 
          max-width: 100vw !important;
          flex: 0 0 100vw !important;
          margin-left: -15px !important;
          margin-right: -15px !important;
          padding: 15px !important;
          float: none !important;
        }
        /* Force all inner rows to full width */
        .pitching-sidebar-hidden .col-sm-9 > .row,
        .pitching-sidebar-hidden .tab-pane > .row {
          width: calc(100vw - 30px) !important;
          max-width: calc(100vw - 30px) !important;
          margin: 0 !important;
        }
        /* Force inner columns to expand and fill space */
        .pitching-sidebar-hidden .col-sm-9 .col-sm-4,
        .pitching-sidebar-hidden .tab-pane .col-sm-4 {
          width: calc((100vw - 60px) / 3) !important;
          max-width: calc((100vw - 60px) / 3) !important;
          flex: 0 0 calc((100vw - 60px) / 3) !important;
        }
        .pitching-sidebar-hidden .col-sm-9 .col-sm-6,
        .pitching-sidebar-hidden .tab-pane .col-sm-6 {
          width: calc((100vw - 45px) / 2) !important;
          max-width: calc((100vw - 45px) / 2) !important;
          flex: 0 0 calc((100vw - 45px) / 2) !important;
        }
        .pitching-sidebar-hidden .col-sm-9 .col-sm-8,
        .pitching-sidebar-hidden .tab-pane .col-sm-8 {
          width: calc((100vw - 60px) * 2 / 3) !important;
          max-width: calc((100vw - 60px) * 2 / 3) !important;
          flex: 0 0 calc((100vw - 60px) * 2 / 3) !important;
        }
        .pitching-sidebar-hidden .col-sm-9 .col-sm-12,
        .pitching-sidebar-hidden .tab-pane .col-sm-12 {
          width: calc(100vw - 30px) !important;
          max-width: calc(100vw - 30px) !important;
          flex: 0 0 calc(100vw - 30px) !important;
        }
        /* Expand all charts and plots to fill their containers */
        .pitching-sidebar-hidden .shiny-plot-output,
        .pitching-sidebar-hidden .plotly,
        .pitching-sidebar-hidden canvas,
        .pitching-sidebar-hidden svg {
          width: 100% !important;
          max-width: 100% !important;
          height: auto !important;
        }
        /* Expand all tables */
        .pitching-sidebar-hidden .dataTables_wrapper,
        .pitching-sidebar-hidden .dataTable,
        .pitching-sidebar-hidden table {
          width: 100% !important;
          max-width: 100% !important;
        }
        /* Expand ggiraph outputs */
        .pitching-sidebar-hidden .ggiraph-output,
        .pitching-sidebar-hidden .girafe_container_std {
          width: 100% !important;
          max-width: 100% !important;
        }
        /* Force tab content to full width */
        .pitching-sidebar-hidden .tab-pane {
          width: 100% !important;
          max-width: 100% !important;
        }
        .pitching-sidebar-hidden .tab-pane:not(.active) {
          display: none !important;
        }
        .pitching-sidebar-hidden .tab-pane.active {
          display: block !important;
        }',
      accent_color, accent_secondary_color, background_color, background_secondary_color))),
      tags$script(HTML("
        $(document).ready(function() {
          $('#pitchingSidebarToggle').click(function() {
            $('body').toggleClass('pitching-sidebar-hidden');
            var btn = $(this);
            var icon = btn.find('i');
            if ($('body').hasClass('pitching-sidebar-hidden')) {
              icon.removeClass('fa-angle-double-left').addClass('fa-angle-double-right');
              btn.attr('title', 'Show Filters');
              // Force resize event to trigger chart redraws
              setTimeout(function() { 
                $(window).trigger('resize');
                // Force Plotly charts to resize
                if (window.Plotly) {
                  $('.plotly').each(function() {
                    Plotly.Plots.resize(this);
                  });
                }
                // Force DataTables to recalculate column widths
                if ($.fn.DataTable) {
                  $.fn.dataTable.tables({visible: true, api: true}).columns.adjust().draw();
                }
              }, 350);
            } else {
              icon.removeClass('fa-angle-double-right').addClass('fa-angle-double-left');
              btn.attr('title', 'Hide Filters');
              setTimeout(function() { 
                $(window).trigger('resize');
                if (window.Plotly) {
                  $('.plotly').each(function() {
                    Plotly.Plots.resize(this);
                  });
                }
                if ($.fn.DataTable) {
                  $.fn.dataTable.tables({visible: true, api: true}).columns.adjust().draw();
                }
              }, 350);
            }
          });
        });
      "))
    ),
    
    # Sidebar toggle button (floating in bottom left)
    tags$button(
      id = "pitchingSidebarToggle",
      class = "btn",
      title = "Hide Filters",
      HTML('<i class="fa fa-angle-double-left"></i>')
    ),
    
    # Anchored dark mode toggle (under navbar, above sidebar)
    fluidRow(
      column(
        width = 3,
        div(
          style = "padding: 6px 0 4px 4px;",
          tags$div(
            class = "dark-toggle inline-toggle",
            tags$label(
              class = "switch-label",
              tags$input(id = "dark_mode", type = "checkbox"),
              tags$span(class = "switch-track", tags$span(class = "switch-thumb")),
              tags$span(class = "switch-text", "Dark mode")
            )
          )
        )
      )
    ),
    
    # Optional header (logos + title). Hidden by default.
    if (isTRUE(show_header)) {
      fluidRow(
        class = "suite-header",
        column(2, tags$img(src = "PCUlogo.png", height = "100px")),
        column(
          8,
          div(
            style = "height:100%; display:flex; justify-content:center; align-items:flex-start;",
            tags$h1("Pitching Dashboard", style = "margin-top:25px; font-weight:bold;")
          )
        ),
        column(
          2,
          div(style = "text-align:right; margin-top:10px;",
              tags$img(src = school_logo, height = "80px", alt = school_display_name))
        )
      )
    },
    sidebarLayout(
      sidebarPanel(
        selectInput(
          "sessionType", "Session Type:",
          choices = c("All", "Bullpen", "Live"),
          selected = "All"
        ),
        selectInput(
          "withVideo", "With Video:",
          choices = c("All", "Yes", "No"),
          selected = "All"
        ),
        selectInput(
          "teamType", "Team:",
          choices = TEAM_CHOICES,
          selected = "All"
        ),
        uiOutput("pitcher_ui"),
        selectInput(
          "oppHitter", "Select Hitter:",
          choices = c("All" = "All", batter_map),
          selected = "All"
        ),
        dateRangeInput(
          "dates", "Date Range:",
          start  = if(exists("pitch_data") && nrow(pitch_data) > 0) max(pitch_data$Date, na.rm = TRUE) else Sys.Date(),
          end    = if(exists("pitch_data") && nrow(pitch_data) > 0) max(pitch_data$Date, na.rm = TRUE) else Sys.Date(),
          format = "mm/dd/yyyy"
        ),
        selectInput(
          "hand", "Pitcher Hand:",
          choices = c("All", "Left", "Right"), selected = "All"
        ),
        selectInput(
          "pitchType", "Pitch Type:",
          choices = c("All", if(exists("pitch_data") && nrow(pitch_data) > 0) levels(pitch_data$TaggedPitchType) else character(0)),
          selected = "All", multiple = TRUE
        ),
        selectInput(
          "zoneLoc", "Zone Location:",
          choices = c("All",
                      "Upper Half","Bottom Half","Left Half","Right Half",
                      "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
          selected = "All",
          multiple = TRUE
        ),
        selectInput(
          "inZone", "In Zone:",
          choices = c("All", "Yes", "No", "Competitive"),
          selected = "All"
        ),
        selectInput(
          "batterSide", "Batter Hand:",
          choices = c("All","Left","Right"), selected = "All"
        ),
        selectInput(
          "qpLocations", "QP Locations:",
          choices = c("All", "Yes", "No"), selected = "All"
        ),
        
        # NEW: Pitch Results filter (multi-select)
        selectInput(
          "pitchResults", "Pitch Results:",
          choices = c("All", result_levels),
          selected = "All",
          multiple = TRUE
        ),
        
        # NEW: Count filter (multi-select)
        selectInput(
          "countFilter", "Count:",
          choices = c(
            "All" = "All",
            "Even"   = "Even",
            "Behind" = "Behind",
            "Ahead"      = "Ahead",
            "2K Not Full"= "2KNF",
            "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
          ),
          selected = "All",
          multiple = TRUE
        ),
        
        # NEW: After Count filter (multi-select)
        selectInput(
          "afterCountFilter", "After Count:",
          choices = c(
            "All" = "All",
            "Even"   = "Even",
            "Behind" = "Behind",
            "Ahead"      = "Ahead",
            "2K Not Full"= "2KNF",
            "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
          ),
          selected = "All",
          multiple = TRUE
        ),
        selectInput(
          "breakLines", "Break Lines:",
          choices = c("None", "Fastball", "Sinker"), selected = "None"
        ),
        selectInput(
          "stuffLevel", "Stuff+ Level:",
          choices = c("Pro", "College", "High School"), selected = "College"
        ),
        selectInput(
          "stuffBase", "Stuff+ Base Pitch:",
          choices = c("Fastball", "Sinker"), selected = "Fastball"
        ),
        fluidRow(
          column(6, numericInput("veloMin", "Velocity Min (MPH):", value = NA)),
          column(6, numericInput("veloMax", "Velocity Max (MPH):", value = NA))
        ),
        fluidRow(
          column(6, numericInput("ivbMin", "IVB Min (inches):", value = NA)),
          column(6, numericInput("ivbMax", "IVB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput("hbMin", "HB Min (inches):", value = NA)),
          column(6, numericInput("hbMax", "HB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput("pcMin", "Pitch Count Min:", value = NA, min = 1)),
          column(6, numericInput("pcMax", "Pitch Count Max:", value = NA, min = 1))
        ),
        
        # Data refresh section
        hr(),
        div(
          style = "text-align:center; margin: 10px 0;",
          radioButtons(
            "pitch_click_action",
            label = NULL,
            choices = c("Play video" = "video", "Edit pitch" = "edit"),
            selected = "video",
            inline = TRUE,
            width = "100%"
          ),
          actionButton(
            "refreshModifications", 
            "Refresh Pitch Edits",
            icon = icon("refresh"),
            class = "btn-info btn-sm",
            style = "margin: 6px 0 4px 0;"
          ),
          downloadButton(
            "downloadPitchMods",
            "Download Pitch Edits",
            class = "btn-default btn-sm",
            style = "margin-top: 5px;"
          ),
          br(),
          div(
            id = "modificationStatus",
            style = "font-size: 12px; color: #666; margin-top: 5px;",
            textOutput("modificationStatusText")
          )
        ),
        
        width = 3,
        class = "sidebar"
      ),
      mainPanel(
        tabsetPanel(
          id = "tabs",
          tabPanel(
            "Summary",
            uiOutput("summaryHeader"), br(),
            fluidRow(
              column(
                4,
                div("Release",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px; text-align:center;"),
                div(
                  style = "text-align:center; margin-bottom:5px;",
                  selectInput("summaryReleaseDisplay", NULL,
                              choices = c("Averages Only", "Averages and Pitches", "Pitches"),
                              selected = "Averages Only",
                              multiple = FALSE,
                              width = "100%")
                ),
                ggiraph::girafeOutput("summary_releasePlot", height = "300px", width = "100%")
              ),              
              column(
                4,
                div("Movement",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px; text-align:center;"),
                div(
                  style = "text-align:center; margin-bottom:5px;",
                  selectInput("summaryMovementDisplay", NULL,
                              choices = c("Averages Only", "Averages and Pitches", 
                                          "Target Shapes Only", "Target Shapes and Pitches"),
                              selected = c("Averages and Pitches"),
                              multiple = TRUE,
                              width = "100%"),
                  actionButton("targetShapesSettings", "Target Settings", size = "xs", 
                               style = "padding:2px 8px; font-size:11px; margin-top:-5px;")
                ),
                ggiraph::girafeOutput("summary_movementPlot", height = "300px", width = "100%")
              ),
              column(
                4,
                div(
                  style = "text-align:center;",
                  div(
                    "HeatMaps",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px;"
                  ),
                  div(
                    style = "display:inline-block; width:80%;",
                    selectInput(
                      "summaryLocType",
                      label    = NULL,
                      choices  = c(
                        "Pitch",
                        "Frequency",
                        "Whiff Rate",
                        "GB Rate",
                        "Contact Rate",
                        "Swing Rate",
                        "Exit Velocity",
                        "Run Values"
                      ),
                      selected = "Pitch",
                      width    = "100%"
                    )
                  )
                ),
                conditionalPanel(
                  "input.summaryLocType=='Pitch'",
                  ggiraph::girafeOutput("summary_zonePlot", height = "300px", width = "100%")
                ),
                conditionalPanel(
                  "input.summaryLocType!='Pitch'",
                  plotOutput("summary_heatZonePlot", height = "300px")
                )
              )
            ),
            fluidRow(
              column(
                12,
                div(
                  class = "legend-plot-wrap",
                  style = "display:flex; flex-direction:column; align-items:center; justify-content:center; gap:0px; min-height: 130px;",
                  plotOutput("summary_legend", height = "70px", width = "100%"),
                  plotOutput("summary_result_legend", height = "70px", width = "100%")
                )
              )
            ),
            tags$style(HTML("
              #summary_legend, #summary_result_legend {
                background: transparent !important;
                border: none !important;
                box-shadow: none !important;
              }
            ")),
            br(),
            div(style = "margin: 8px 0;", uiOutput("summaryTableButtons")),
            DT::dataTableOutput("summaryTablePage")
          ),
          # --- Pitching → AB Report tab ---
          tabPanel(
            "AB Report",
            value = "pitch_ab_report",
            sidebarLayout(
              sidebarPanel(width = 3, uiOutput("abpSidebar")),
              mainPanel(
                width = 9,
                div(style = "display:flex; align-items:baseline; gap:12px; margin-bottom:8px;",
                    uiOutput("abpHeader")),
                uiOutput("abpPanels")
              )
            )
          ),
          tabPanel("Release",
                   div(
                     style = "text-align:center; margin-bottom:10px;",
                     selectInput("releaseComboDisplay", NULL,
                                 choices = c("Averages Only", "Averages and Pitches", "Pitches"),
                                 selected = "Averages Only",
                                 multiple = FALSE,
                                 width = "30%")
                   ),
                   ggiraph::girafeOutput("releaseCombo", height = "950px", width = "100%")),
          tabPanel(
            "Movement Plot",
            div(
              style = "text-align:center; margin-bottom:10px;",
              selectInput("movementPlotDisplay", NULL,
                          choices = c("Averages Only", "Averages and Pitches", 
                                      "Target Shapes Only", "Target Shapes and Pitches"),
                          selected = c("Averages and Pitches"),
                          multiple = TRUE,
                          width = "50%"),
              actionButton("targetShapesSettings", "Target Shapes Settings", 
                           style = "margin-top:-10px;")
            ),
            ggiraph::girafeOutput("movementPlot", height = "400px")
          ),
          tabPanel(
            "Data and Performance",
            div(style = "margin: 8px 0;", uiOutput("dpTableButtons")),
            DT::dataTableOutput("summaryTable")
          ),
          tabPanel(
            "Velocity",
            ggiraph::girafeOutput("velocityPlot", height = "450px"),
            ggiraph::girafeOutput("velocityByGamePlot", height = "450px"),
            ggiraph::girafeOutput("velocityInningPlot", height = "450px")
          ),
          # --- PITCHING HEATMAPS TAB (NON-MODULE UI) ---
          tabPanel(
            "HeatMaps",
            sidebarLayout(
              sidebarPanel(
                selectInput("hmChartType", "Select Chart:", choices = c("Heat","Pitch","QP+"), selected = "Heat"),
                conditionalPanel(
                  "input.hmChartType=='Heat'",
                  selectInput(
                    "hmStat", "Select Stat:",
                    choices = c(
                      "Frequency"      = "Frequency",
                      "Whiff Rate"     = "Whiff Rate",
                      "Exit Velocity"  = "EV",
                      "GB Rate"        = "GB Rate",
                      "Contact Rate"   = "Contact Rate",
                      "Swing Rate"     = "Swing Rate",
                      "Run Values"     = "Run Values"
                    ),
                    selected = "Frequency"
                  ),
                  uiOutput("hmNote")
                ),
                conditionalPanel(
                  "input.hmChartType=='QP+'",
                  helpText("Requires batter hand + counts from the same family (Ahead, Even, or Behind).")
                ),
                uiOutput("locLegend"),
                width = 3
              ),
              mainPanel(
                conditionalPanel("input.hmChartType=='Heat'",  plotOutput("heatmapsHeatPlot", height = "500px")),
                conditionalPanel("input.hmChartType=='Pitch'", ggiraph::girafeOutput("heatmapsPitchPlot", height = "500px")),
                conditionalPanel("input.hmChartType=='QP+'",   ggiraph::girafeOutput("heatmapsQPPlot",   height = "500px"))
              )
            )
          ),
          # --- QP LOCATIONS TAB ---
          tabPanel(
            "QP Locations",
            value = "qp_locations",
            fluidRow(
              column(2,
                     div(style = "padding: 10px;",
                         h5("Pitch Results", style = "font-weight: bold; margin-bottom: 10px;"),
                         div(style = "font-size: 12px;",
                             div(style = "margin-bottom: 3px;", "\u25CF Called Strike"),  # ●
                             div(style = "margin-bottom: 3px;", "\u25CB Ball"),           # ○
                             div(style = "margin-bottom: 3px;", "\u25B3 Foul"),           # △
                             div(style = "margin-bottom: 3px;", "\u2605 Whiff"),          # ★
                             div(style = "margin-bottom: 3px;", "\u25B2 In Play (Out)"),  # ▲
                             div(style = "margin-bottom: 3px;", "\u25A0 In Play (Hit)"),  # ■
                             div(style = "margin-bottom: 3px;", "\u25A1 Error")           # □
                         ),
                         br(),
                         h5("Pitch Type", style = "font-weight: bold; margin-bottom: 10px;"),
                         uiOutput("qpPitchTypeColors"),
                         br(),
                         h5("QP+ Heatmap", style = "font-weight: bold; margin-bottom: 10px;"),
                         div(style = "font-size: 12px;",
                             div(style = "display: flex; align-items: center; margin-bottom: 3px;",
                                 div(style = "width: 20px; height: 10px; background: linear-gradient(to right, blue, white, red); margin-right: 8px; border: 1px solid #ccc;"),
                                 "Blue (Low) → Red (High)"
                             ),
                             p(style = "font-size: 11px; color: #666; margin-top: 5px;",
                               "Shows optimal QP+ locations for each pitch type based on count situation."
                             )
                         )
                     )
              ),
              column(10,
                     # Main content area - all controlled by qpLocationsMessage
                     uiOutput("qpLocationsMessage")
              )
            )
          ),
          tabPanel(
            "Trend",
            sidebarLayout(
              sidebarPanel(
                selectInput(
                  "trendMetric", "Select Metric:",
                  choices = c(
                    "Velocity (Avg)",
                    "Velocity (Max)",
                    "InZone %",
                    "Comp %",
                    "FPS%",
                    "E+A%",
                    "Whiff%",
                    "CSW%",
                    "Strike%",
                    "K%",
                    "BB%",
                    "Stuff+",
                    "Ctrl+",
                    "QP+",
                    "QP%",
                    "Pitching+",
                    "IVB",
                    "HB",
                    "Release Height",
                    "Extension"
                  ),
                  selected = "Velocity (Avg)"
                ),
                width = 3
              ),
              mainPanel(
                uiOutput("trendPlotUI"),
                width = 9
              )
            )
          )
          
          , tabPanel(
            "Stuff+ Calculator",
            value = "stuff_calc",
            fluidRow(
              column(6,
                     h3("Pitch A"),
                     wellPanel(
                       selectInput("calc1_hand", "Pitcher Hand", choices = c("Right","Left"), selected = "Right"),
                       selectInput("calc1_pitch", "Pitch Type",
                                   choices = c("Fastball","Sinker","Cutter","Slider","Sweeper","Curveball","ChangeUp","Splitter"),
                                   selected = "Fastball"
                       ),
                       selectInput("calc1_level","Level", choices = c("High School","College","Pro"), selected = "College"),
                       numericInput("calc1_vel","Velocity (mph)", value = 92, min = 60, max = 110, step = 0.1),
                       numericInput("calc1_ivb","IVB (in)", value = 15, min = -40, max = 40, step = 0.1),
                       numericInput("calc1_hb","HB (in)", value = 10, min = -40, max = 40, step = 0.1),
                       numericInput("calc1_relheight","RelHeight (ft)", value = 5.8, min = 3.5, max = 7.5, step = 0.1),
                       conditionalPanel("!(['Fastball','Sinker'].includes(input.calc1_pitch))",
                                        tags$hr(),
                                        strong("Base pitch for off-speed context"),
                                        radioButtons("calc1_base_type","Base Type", choices = c("Fastball","Sinker"), selected = "Fastball", inline = TRUE),
                                        numericInput("calc1_base_vel","Base Velo (mph)", value = 92, min = 60, max = 110, step = 0.1),
                                        numericInput("calc1_base_ivb","Base IVB (in)", value = 15, min = -40, max = 40, step = 0.1),
                                        numericInput("calc1_base_hb","Base HB (in)", value = 10, min = -40, max = 40, step = 0.1)
                       ),
                       div(em("HB_adj (hand-agnostic): "), textOutput("calc1_hb_adj"))
                     ),
                     h2(textOutput("calc1_stuff"))
              ),
              column(6,
                     h3("Pitch B"),
                     wellPanel(
                       selectInput("calc2_hand", "Pitcher Hand", choices = c("Right","Left"), selected = "Right"),
                       selectInput("calc2_pitch", "Pitch Type",
                                   choices = c("Fastball","Sinker","Cutter","Slider","Sweeper","Curveball","ChangeUp","Splitter"),
                                   selected = "Slider"
                       ),
                       selectInput("calc2_level","Level", choices = c("High School","College","Pro"), selected = "College"),
                       numericInput("calc2_vel","Velocity (mph)", value = 85, min = 60, max = 110, step = 0.1),
                       numericInput("calc2_ivb","IVB (in)", value = -2, min = -40, max = 40, step = 0.1),
                       numericInput("calc2_hb","HB (in)", value = 15, min = -40, max = 40, step = 0.1),
                       numericInput("calc2_relheight","RelHeight (ft)", value = 5.8, min = 3.5, max = 7.5, step = 0.1),
                       conditionalPanel("!(['Fastball','Sinker'].includes(input.calc2_pitch))",
                                        tags$hr(),
                                        strong("Base pitch for off-speed context"),
                                        radioButtons("calc2_base_type","Base Type", choices = c("Fastball","Sinker"), selected = "Fastball", inline = TRUE),
                                        numericInput("calc2_base_vel","Base Velo (mph)", value = 92, min = 60, max = 110, step = 0.1),
                                        numericInput("calc2_base_ivb","Base IVB (in)", value = 15, min = -40, max = 40, step = 0.1),
                                        numericInput("calc2_base_hb","Base HB (in)", value = 10, min = -40, max = 40, step = 0.1)
                       ),
                       div(em("HB_adj (hand-agnostic): "), textOutput("calc2_hb_adj"))
                     ),
                     h2(textOutput("calc2_stuff"))
              )
            )
          )
        )
      )
    )
  )
}

# =========================
# == Hitting Suite (v1) ==
# =========================

mod_hit_ui <- function(id, show_header = FALSE) {
  ns <- NS(id)
  fluidPage(
    if (isTRUE(show_header)) {
      fluidRow(
        class = "suite-header",
        column(2, tags$img(src = "PCUlogo.png", height = "100px")),
        column(
          8,
          div(
            style = "height:100%; display:flex; justify-content:center; align-items:flex-start;",
            tags$h1("Hitting Dashboard", style = "margin-top:25px; font-weight:bold;")
          )
        ),
        column(
          2,
          div(style = "text-align:right; margin-top:10px;",
              tags$img(src = school_logo, height = "80px", alt = school_display_name))
        )
      )
    },
    sidebarLayout(
      sidebarPanel(
        selectInput(ns("hitter"), "Select Hitter:", choices = c("All" = "All", batter_map), selected = "All"),
        selectInput(ns("oppPitcher"), "Select Pitcher:", choices = c("All" = "All", opponent_pitcher_map), selected = "All"),
        selectInput(
          ns("teamType"), "Team:",
          choices = TEAM_CHOICES,
          selected = "All"
        ),
        dateRangeInput(ns("dates"), "Date Range:",
                       start = max(pitch_data$Date, na.rm = TRUE),
                       end   = max(pitch_data$Date, na.rm = TRUE),
                       format = "mm/dd/yyyy"),
        selectInput(ns("hand"),       "Pitcher Hand:",  choices = c("All","Left","Right"), selected = "All"),
        selectInput(
          ns("pitchType"), "Pitch Type:",
          choices = c("All", levels(pitch_data$TaggedPitchType)),
          selected = "All", multiple = TRUE
        ),
        selectInput(
          ns("zoneLoc"), "Zone Location:",
          choices = c("All",
                      "Upper Half","Bottom Half","Left Half","Right Half",
                      "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
          selected = "All",
          multiple = TRUE
        ),
        selectInput(ns("inZone"),     "In Zone:",       choices = c("All","Yes","No","Competitive"), selected = "All"),
        selectInput(ns("batterSide"), "Batter Hand:",   choices = c("All","Left","Right"), selected = "All"),
        
        # NEW: Pitch Results filter (multi-select)
        selectInput(
          ns("pitchResults"), "Pitch Results:",
          choices = c("All", result_levels),
          selected = "All",
          multiple = TRUE
        ),
        
        selectInput(
          ns("countFilter"), "Count:",
          choices  = c("All"="All","Even"="Even","Behind"="Behind","Ahead"="Ahead","2K Not Full"="2KNF",
                       "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
          selected = "All", multiple = TRUE
        ),
        selectInput(
          ns("afterCountFilter"), "After Count:",
          choices  = c("All"="All","Even"="Even","Behind"="Behind","Ahead"="Ahead","2K Not Full"="2KNF",
                       "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
          selected = "All", multiple = TRUE
        ),
        selectInput(
          ns("bipResult"), "BIP Result:",
          choices  = c("All","Single","Double","Triple","HomeRun","Out"),
          selected = "All", multiple = TRUE
        ),
        fluidRow(
          column(6, numericInput(ns("veloMin"), "Velocity Min (MPH):", value = NA)),
          column(6, numericInput(ns("veloMax"), "Velocity Max (MPH):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("ivbMin"), "IVB Min (inches):", value = NA)),
          column(6, numericInput(ns("ivbMax"), "IVB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("hbMin"), "HB Min (inches):", value = NA)),
          column(6, numericInput(ns("hbMax"), "HB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("pcMin"), "Pitch Count Min:", value = NA, min = 1)),
          column(6, numericInput(ns("pcMax"), "Pitch Count Max:", value = NA, min = 1))
        ),
        width = 3,
        class = "sidebar"
      ),
      mainPanel(
        tabsetPanel(
          id = ns("tabs"),
          tabPanel(
            "Summary",
            tagList(
              fluidRow(
                column(
                  4,
                  tags$div(
                    "vs. RHP",
                    style = "font-weight:bold; text-align:center; margin-bottom:6px;"
                  ),
                  ggiraph::girafeOutput(ns("loc_rhp"), height = "340px", width = "100%")
                ),
                column(
                  4,
                  tags$div(
                    "Spray Chart",
                    style = "font-weight:bold; text-align:center; margin-bottom:6px;"
                  ),
                  ggiraph::girafeOutput(ns("sprayChart"), height = "340px", width = "100%")
                ),
                column(
                  4,
                  tags$div(
                    "vs. LHP",
                    style = "font-weight:bold; text-align:center; margin-bottom:6px;"
                  ),
                  ggiraph::girafeOutput(ns("loc_lhp"), height = "340px", width = "100%")
                )
              ),
              div(
                style = "display:flex; justify-content:center; align-items:center; gap:60px; margin:12px 0;",
                div(style = "flex:1;", plotOutput(ns("result_key"), height = 120, width = "100%")),
                div(style = "flex:1;", plotOutput(ns("pitch_type_key"), height = 100, width = "100%"))
              ),
              div(style = "margin: 8px 0;", uiOutput(ns("dpButtons"))),
              DT::DTOutput(ns("dpTable"))
            )
          ),
          tabPanel(
            "AB Report",
            sidebarLayout(
              sidebarPanel(
                # Select Game control and legend live here
                uiOutput(ns("abSidebar")),
                width = 3
              ),
              mainPanel(
                # top-right header with player and date
                div(style = "display:flex; justify-content:flex-start; margin-bottom:8px;",
                    uiOutput(ns("abHeader"))),
                # all AB charts + tables (2 per row)
                uiOutput(ns("abPanels"))
              )
            )
          ),
          tabPanel(
            "HeatMaps",
            sidebarLayout(
              sidebarPanel(
                selectInput(
                  ns("hmChartType"), "Select Chart:",
                  choices = c("Heat", "Pitch"),
                  selected = "Heat"
                ),
                selectInput(
                  ns("hmStat"), "Select Stat:",
                  choices = c("Frequency","Whiff Rate","Exit Velocity","GB Rate","Contact Rate","Swing Rate","Run Values"),
                  selected = "Frequency"
                ),
                uiOutput(ns("hmNote")),
                width = 3
              ),
              mainPanel(
                conditionalPanel(
                  sprintf("input['%s']=='Heat'", ns("hmChartType")),
                  plotOutput(ns("heatmapsHeatPlot"), height = "500px")
                ),
                conditionalPanel(
                  sprintf("input['%s']=='Pitch'", ns("hmChartType")),
                  ggiraph::girafeOutput(ns("heatmapsPitchPlot"), height = "500px")
                )
              )
            )
          )
        )
      )
    )
  )
}

# -- Valid date range guard
is_valid_dates <- function(d) { !is.null(d) && length(d) == 2 && all(is.finite(d)) }

# -- Safe numeric mean
nz_mean <- function(x) {
  x <- suppressWarnings(as.numeric(x))
  if (!length(x)) return(NA_real_)
  m <- mean(x, na.rm = TRUE)
  if (is.finite(m)) m else NA_real_
}

# -- Safe clock conversion
safe_clock <- function(x) {
  if (!is.finite(x) || is.na(x)) return("")
  tryCatch(convert_to_clock(x), error = function(...) "")
}

# -- Safe QP+ scalar
safe_qp_scalar <- function(df) {
  out <- tryCatch(compute_qp_points(df), error = function(...) NA_real_)
  out <- suppressWarnings(as.numeric(out))
  if (!length(out)) return(NA_real_)
  round(mean(out, na.rm = TRUE) * 200, 1)
}

# Flatten list/matrix/factor/date cols so DT never sees objects
collapse_list_cols <- function(dat) {
  if (!nrow(dat)) return(dat)
  dat %>%
    dplyr::mutate(dplyr::across(
      where(is.list),
      ~ vapply(., function(x) {
        if (is.null(x)) "" else if (length(x) == 1 && !is.list(x)) as.character(x)
        else paste0(unlist(x), collapse = ", ")
      }, character(1))
    ))
}

safe_for_dt <- function(df) {
  if (!nrow(df)) return(df)
  out <- collapse_list_cols(df)
  out[] <- lapply(out, function(col) {
    if (is.factor(col)) as.character(col)
    else if (inherits(col, c("POSIXct","POSIXt","Date"))) as.character(col)
    else if (is.matrix(col)) apply(col, 1, paste, collapse = ", ")
    else col
  })
  as.data.frame(out, stringsAsFactors = FALSE, check.names = FALSE)
}

# Flatten list columns (preferring numeric when possible) so downstream math
# never sees list/NULL values (bullpen data occasionally carries nested cells)
flatten_metrics_df <- function(df) {
  if (!is.data.frame(df) || !nrow(df)) return(df)

  # NUCLEAR OPTION: Force to plain data.frame first
  df <- as.data.frame(df, stringsAsFactors = FALSE)

  flatten_col <- function(col) {
    if (is.factor(col)) col <- as.character(col)
    # Use is.atomic to catch all non-atomic types
    if (is.atomic(col) && !is.list(col)) return(col)

    # First pass: extract first element from each list item
    vals <- lapply(col, function(x) {
      if (is.null(x) || length(x) == 0) return(NA)
      # Handle nested lists
      val <- x[[1]]
      if (is.list(val)) val <- val[[1]]
      if (is.null(val) || length(val) == 0) return(NA)
      val
    })

    vals_chr <- vapply(vals, function(v) {
      if (is.null(v) || length(v) == 0 || (length(v) == 1 && is.na(v))) return(NA_character_)
      as.character(v[1])
    }, character(1))
    vals_num <- suppressWarnings(as.numeric(vals_chr))

    if (sum(!is.na(vals_num)) >= sum(!is.na(vals_chr)) * 0.6) {
      vals_num
    } else {
      vals_chr
    }
  }

  # Apply flattening to all columns
  df[] <- lapply(df, flatten_col)

  # Second pass: ensure no non-atomic columns remain
  for (nm in names(df)) {
    col <- df[[nm]]
    if (!is.atomic(col) || is.list(col)) {
      df[[nm]] <- tryCatch({
        vapply(col, function(x) {
          if (is.null(x) || length(x) == 0) NA_character_
          else as.character(x[[1]])
        }, character(1))
      }, error = function(e) {
        as.character(unlist(col))
      })
    }
  }

  df
}

mod_hit_server <- function(id, is_active = shiny::reactive(TRUE), global_date_range = NULL) {
  moduleServer(id, function(input, output, session) {
    # Global dark-mode flag (root scope toggle)
    is_dark_mode <- reactive({
      dm <- NULL
      # Prefer root scope (non-namespaced) dark_mode toggle
      dm <- tryCatch({
        rs <- session$rootScope()
        if (!is.null(rs) && !is.null(rs$input$dark_mode)) rs$input$dark_mode else NULL
      }, error = function(...) NULL)
      # Fallback to local (in case running outside root)
      if (is.null(dm) && !is.null(input$dark_mode)) dm <- input$dark_mode
      isTRUE(dm)
    })
    observe({
      custom_tables()
      update_custom_table_choices(session)
    })
    
    # Render per-cell filters UI based on selection
    output_filters_for_cell <- function(cell_id) {
      renderUI({
        sel <- input[[paste0("cell_filter_select_", cell_id)]]
        out <- list()
        if ("Dates" %in% sel) {
          # default date range from available data
          all_dates <- c(pitch_data_pitching$Date, pitch_data$Date)
          d_min <- suppressWarnings(min(all_dates, na.rm = TRUE)); d_max <- suppressWarnings(max(all_dates, na.rm = TRUE))
          if (!is.finite(d_min)) d_min <- Sys.Date() - 30
          if (!is.finite(d_max)) d_max <- Sys.Date()
          out <- c(out, list(
            dateRangeInput(ns(paste0("cell_dates_", cell_id)), "Dates:",
                           start = d_max - 30, end = d_max, min = d_min, max = d_max,
                           format = "mm/dd/yyyy")
          ))
        }
        if ("Session Type" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_session_", cell_id)), "Session Type:", choices = c("All","Bullpen","Live"), selected = "All")
          ))
        }
        if ("Pitch Types" %in% sel) {
          pts <- if (input$report_type == "Pitching") {
            sort(unique(as.character(pitch_data_pitching$TaggedPitchType)))
          } else {
            sort(unique(as.character(pitch_data$TaggedPitchType)))
          }
          out <- c(out, list(
            selectizeInput(ns(paste0("cell_pitch_types_", cell_id)), "Pitch Types:", choices = c("All", pts), multiple = TRUE, selected = "All")
          ))
        }
        if ("Batter Hand" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_batter_side_", cell_id)), "Batter Hand:", choices = c("All","Left","Right"), selected = "All")
          ))
        }
        if ("Pitcher Hand" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_pitcher_hand_", cell_id)), "Pitcher Hand:", choices = c("All","Left","Right"), selected = "All")
          ))
        }
        if ("Pitch Results" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_results_", cell_id)), "Pitch Results:", choices = c("All", result_levels), selected = "All", multiple = TRUE)
          ))
        }
        if ("QP Locations" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_qp_", cell_id)), "QP Locations:", choices = c("All","Yes","No"), selected = "All")
          ))
        }
        if ("Count" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_count_", cell_id)), "Count:", choices = c("All","Even","Behind","Ahead","2KNF",
                                                                                  "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
                        selected = "All", multiple = TRUE)
          ))
        }
        if ("After Count" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_after_count_", cell_id)), "After Count:", choices = c("All","Even","Behind","Ahead","2KNF",
                                                                                              "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
                        selected = "All", multiple = TRUE)
          ))
        }
        if ("Zone Location" %in% sel) {
          out <- c(out, list(
            selectInput(ns(paste0("cell_zone_", cell_id)), "Zone Location:", choices = c("All",
                                                                                         "Upper Half","Bottom Half","Left Half","Right Half",
                                                                                         "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
                        selected = "All", multiple = TRUE)
          ))
        }
        if ("Velo Min/Max" %in% sel) {
          out <- c(out, list(
            numericInput(ns(paste0("cell_velo_min_", cell_id)), "Velo Min", value = NA),
            numericInput(ns(paste0("cell_velo_max_", cell_id)), "Velo Max", value = NA)
          ))
        }
        if ("IVB Min/Max" %in% sel) {
          out <- c(out, list(
            numericInput(ns(paste0("cell_ivb_min_", cell_id)), "IVB Min", value = NA),
            numericInput(ns(paste0("cell_ivb_max_", cell_id)), "IVB Max", value = NA)
          ))
        }
        if ("HB Min/Max" %in% sel) {
          out <- c(out, list(
            numericInput(ns(paste0("cell_hb_min_", cell_id)), "HB Min", value = NA),
            numericInput(ns(paste0("cell_hb_max_", cell_id)), "HB Max", value = NA)
          ))
        }
        if (length(out)) tagList(out) else div("No filters selected")
      })
    }
    
    observe({
      rows <- suppressWarnings(as.integer(input$report_rows))
      cols <- suppressWarnings(as.integer(input$report_cols))
      if (is.null(rows) || length(rows)==0 || is.na(rows) || rows < 1) return()
      if (is.null(cols) || length(cols)==0 || is.na(cols) || cols < 1) return()
      for (r in seq_len(rows)) for (c in seq_len(cols)) {
        local({
          rid <- r; cid <- c
          cell_id <- paste0("r", rid, "c", cid)
          output[[paste0("cell_filters_", cell_id)]] <- output_filters_for_cell(cell_id)
        })
      }
    })
    # Sync local date input with global date range
    if (!is.null(global_date_range)) {
      observe({
        if (!is.null(global_date_range()) && length(global_date_range()) == 2) {
          updateDateRangeInput(session, "dates", 
                               start = global_date_range()[1], 
                               end = global_date_range()[2])
        }
      })
      
      # Update global date range when local input changes
      observeEvent(input$dates, {
        if (!is.null(input$dates) && length(input$dates) == 2) {
          global_date_range(input$dates)
        }
      })
    }
    ns <- session$ns
    
    # ----- TEAM FILTER (GCU/Campers/Opponents) -----
    pd_team <- reactive({
      req(is_active())
      d <- pitch_data
      
      # If specific hitter or pitcher is selected, skip team filtering
      # This allows selecting any opponent player
      has_specific_hitter <- !is.null(input$hitter) && input$hitter != "All"
      has_specific_pitcher <- !is.null(input$oppPitcher) && input$oppPitcher != "All"
      
      if (has_specific_hitter || has_specific_pitcher) {
        # When specific player selected, show all data (team filter ignored)
        return(d)
      }
      
      # Apply team filtering based on selection when no specific player chosen
      # For HITTING suite: filter by Batter (our hitters)
      if (!is.null(input$teamType)) {
        if (input$teamType == "Campers") {
          # Filter to only allowed campers (as batters)
          d <- dplyr::filter(d, Batter %in% ALLOWED_CAMPERS)
        } else if (input$teamType == TEAM_CODE) {
          # For GCU hitting: show all non-camper batters
          d <- dplyr::filter(d, !(Batter %in% ALLOWED_CAMPERS))
        } else if (input$teamType == "Opponents") {
          # Show only opponent batters
          all_known <- unique(c(ALLOWED_HITTERS, ALLOWED_CAMPERS))
          d <- dplyr::filter(d, !(Batter %in% all_known))
        }
        # If "All" is selected, don't filter - show all data
      }
      d
    })
    
    # Update hitter choices based on team selection
    observeEvent(input$teamType, {
      d <- pd_team()
      hitters <- sort(unique(as.character(d$Batter)))
      # Map "Last, First" -> "First Last" for labels
      pretty <- if (length(hitters)) {
        stats::setNames(hitters, sapply(hitters, function(x) {
          x <- as.character(x)
          if (grepl(",", x)) paste0(trimws(sub(".*,", "", x)), " ", trimws(sub(",.*", "", x))) else x
        }))
      } else character(0)
      updateSelectInput(session, "hitter",
                        choices = c("All" = "All", pretty),
                        selected = "All")
      if (nrow(d)) {
        rng <- range(d$Date, na.rm = TRUE)
        if (all(is.finite(rng))) {
          updateDateRangeInput(session, "dates", start = rng[1], end = rng[2])
        }
      }
    }, ignoreInit = FALSE)
    
    # On init: set initial choices
    observeEvent(is_active(), {
      # This will trigger the teamType observer above
    }, ignoreInit = FALSE, once = TRUE)
    
    # ---- small helpers ----
    # ---------- AB Report: utilities ----------
    # Detect terminal pitches for PA segmentation (include HBP via PitchCall)
    .ab_is_terminal <- function(df) {
      (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
        (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk")) |
        (!is.na(df$PitchCall) & df$PitchCall == "HitByPitch")
    }
    
    fmt_mdy <- function(d) format(as.Date(d), "%m/%d/%Y")
    
    .pretty_name <- function(x) {
      x <- as.character(x)
      ifelse(grepl(",", x), paste0(trimws(sub(".*,", "", x)), " ", trimws(sub(",.*", "", x))), x)
    }
    
    # Pretty pitcher name: "Last, First" -> "First Last"
    .pretty_pitcher <- function(x) {
      x <- as.character(x)
      sub("^\\s*,\\s*", "",
          paste0(trimws(sub(".*,", "", x)), " ", trimws(sub(",.*", "", x))))
    }
    
    # Build the PA-level result label per your rules
    .pa_result_label <- function(last_row) {
      pr <- as.character(last_row$PlayResult)
      kc <- as.character(last_row$KorBB)
      pc <- as.character(last_row$PitchCall)
      th <- as.character(last_row$TaggedHitType)
      
      if (!is.na(pc) && pc == "HitByPitch") return("HitByPitch")
      
      if (!is.na(kc) && kc %in% c("Strikeout","Walk")) return(kc)
      
      if (!is.na(pr) && pr != "" && !identical(pr, "Undefined")) {
        if (pr == "HomeRun") return("HomeRun")
        # In play – include TaggedHitType first (except HR)
        th_clean <- ifelse(is.na(th) | th == "", "", paste0(th, " "))
        return(paste0(th_clean, pr))
      }
      
      # Fallback
      if (!is.na(pr) && pr != "") return(pr)
      if (!is.na(pc) && pc != "") return(pc)
      "Result"
    }
    
    # Small ggplot bits to draw the zone + dashed competitive box
    .ab_geom_zone <- function() {
      dark_on <- is_dark_mode()
      line_col <- if (dark_on) "#ffffff" else "black"
      home <- data.frame(
        x=c(-0.75,0.75,0.75,0.00,-0.75),
        y=c(1.05,1.05,1.15,1.25,1.15)-0.5
      )
      cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      list(
        geom_polygon(data = home, aes(x, y), fill = NA, color = line_col),
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col, linetype = "dashed"),
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col)
      )
    }
    
    # ---------- AB Report: date choices + default ----------
    # Dates where this hitter has at least one terminal pitch (a completed PA)
    ab_dates <- reactive({
      req(is_active())
      hit <- input$hitter
      if (is.null(hit) || identical(hit, "All")) return(as.Date(character(0)))
      
      # Use LSU-only data (ignore main date filter for this page)
      d <- pd_team() %>% dplyr::filter(Batter == hit)
      term <- (!is.na(d$PlayResult) & d$PlayResult != "Undefined") |
        (!is.na(d$KorBB) & d$KorBB %in% c("Strikeout","Walk")) |
        (!is.na(d$PitchCall) & d$PitchCall == "HitByPitch")
      dates <- sort(unique(as.Date(d$Date[term])))
      dates
    })
    
    
    # Build the sidebar UI (Select Game + legend or an info message)
    output$abSidebar <- renderUI({
      hit <- input$hitter
      if (is.null(hit) || identical(hit, "All")) {
        return(tagList(
          tags$em("Select a single hitter in the main sidebar to enable AB Report.")
        ))
      }
      dark_on <- is_dark_mode()
      cols <- colors_for_mode(dark_on)
      border_col <- if (dark_on) "rgba(255,255,255,0.35)" else "rgba(0,0,0,.25)"
      
      dates <- ab_dates()
      if (!length(dates)) return(tagList(tags$em("No completed plate appearances found for this hitter.")))
      
      vals <- as.character(as.Date(dates))  # stable values
      labs <- fmt_mdy(dates)                # pretty labels
      choices <- stats::setNames(vals, labs)
      
      cur <- isolate(input$abGameDate)
      sel <- if (!is.null(cur) && cur %in% vals) cur else vals[length(vals)]
      
      # Pitch-type legend (color chips) – LSU only
      types_for_legend <- {
        d <- pd_team() %>% dplyr::filter(Batter == hit)
        intersect(names(all_colors), as.character(unique(d$TaggedPitchType)))
      }
      
      # Shape legend: plain rows (no bullets)
      shape_rows <- tagList(
        tags$div("\u25CF Called Strike"),  # ●
        tags$div("\u25CB Ball"),           # ○
        tags$div("\u25B3 Foul"),           # △
        tags$div("\u2605 Whiff"),          # ★
        tags$div("\u25B2 In Play (Out)"),  # ▲
        tags$div("\u25A0 In Play (Hit)"),  # ■
        tags$div("\u25A1 Error")           # □
      )
      
      tagList(
        selectInput(ns("abGameDate"), "Select Game:", choices = choices, selected = sel),
        tags$hr(),
        tags$div(tags$strong("Pitch Result Key")),
        shape_rows,
        tags$br(),
        tags$div(tags$strong("Pitch Types")),
        tags$div(lapply(types_for_legend, function(tt) {
          col <- cols[[as.character(tt)]]; if (is.null(col)) col <- "gray"
          tags$div(style="display:flex;align-items:center;margin:2px 0;",
                   tags$span(style=paste0("display:inline-block;width:12px;height:12px;",
                                          "background:", col, ";margin-right:6px;",
                                          "border:1px solid ", border_col, ";border-radius:2px;")),
                   tags$span(as.character(tt))
          )
        }))
      )
    })
    
    # Header at top-right: Player + Date
    output$abHeader <- renderUI({
      hit <- input$hitter
      if (is.null(hit) || identical(hit, "All")) return(NULL)
      dt_val <- input$abGameDate
      if (is.null(dt_val)) {
        ds <- ab_dates(); if (!length(ds)) return(NULL)
        dt_val <- as.character(max(ds))
      }
      tags$div(
        style = "text-align:left;",
        tags$strong(.pretty_name(hit)), tags$br(),
        fmt_mdy(as.Date(dt_val))
      )
    })
    
    # ---------- AB Report: panels (charts + tables) ----------
    output$abPanels <- renderUI({
      req(is_active())
      hit <- input$hitter
      if (is.null(hit) || identical(hit, "All"))
        return(div(style="margin:8px 0;", tags$em("Select a single hitter to view the AB Report.")))
      
      dt_chr <- input$abGameDate; req(!is.null(dt_chr))
      dt <- as.Date(dt_chr)
      
      # Ignore main date range for this page, LSU only:
      df <- pd_team() %>% dplyr::filter(Batter == hit, as.Date(Date) == dt)
      if (!nrow(df)) return(div(tags$em("No pitches for this hitter on the selected date.")))
      
      term <- (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
        (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk")) |
        (!is.na(df$PitchCall) & df$PitchCall == "HitByPitch")
      
      pa_id <- cumsum(c(1L, as.integer(utils::head(term, -1))))
      df$._pa_id <- pa_id
      done_ids <- unique(df$._pa_id[term])
      df <- dplyr::filter(df, ._pa_id %in% done_ids)
      if (!nrow(df)) return(div(tags$em("No completed plate appearances on this date.")))
      
      pa_list <- split(df, df$._pa_id)
      n_pa <- length(pa_list)
      
      # ---------- CHART grid (2 per row) ----------
      chart_rows <- list()
      for (i in seq_len(n_pa)) {
        dat <- pa_list[[i]] %>% dplyr::mutate(
          pitch_idx = dplyr::row_number(),
          Result    = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
          tt_fill   = dplyr::coalesce(colors_for_mode(is_dark_mode())[as.character(TaggedPitchType)], "gray80"),
          tt        = paste0(
            "EV: ", ifelse(is.finite(ExitSpeed), sprintf("%.1f", ExitSpeed), "—"), " mph\n",
            "LA: ", ifelse(is.finite(Angle),     sprintf("%.1f", Angle),     "—"), "°\n",
            "Distance: ", ifelse(is.finite(Distance), sprintf("%.0f", Distance), "—"), "\n",
            "Pitch: ", TaggedPitchType, "\n",
            "Result: ", ifelse(PitchCall == "InPlay" & !is.na(PlayResult), PlayResult, coalesce(as.character(PitchCall), ""))
          )
        )
        pid <- names(pa_list)[i]
        out_plot_id <- ns(paste0("abPlot_", pid))
        
        # Build title text (result line)
        title_result <- {
          last_row <- dat[nrow(dat), , drop = FALSE]
          pr <- as.character(last_row$PlayResult)
          kc <- as.character(last_row$KorBB)
          pc <- as.character(last_row$PitchCall)
          th <- as.character(last_row$TaggedHitType)
          if (!is.na(pc) && pc == "HitByPitch") "HitByPitch"
          else if (!is.na(kc) && kc %in% c("Strikeout","Walk")) kc
          else if (!is.na(pr) && pr != "" && pr != "Undefined") {
            if (pr == "HomeRun") "HomeRun" else paste0(ifelse(is.na(th) | th=="","", paste0(th," ")), pr)
          } else dplyr::coalesce(pr, pc, "Result")
        }
        
        # Register plot renderer
        local({
          dat_local <- dat
          out_plot_id_local <- paste0("abPlot_", pid)
          output[[out_plot_id_local]] <- ggiraph::renderGirafe({
            types <- as.character(intersect(names(all_colors), unique(dat_local$TaggedPitchType)))
            cols <- colors_for_mode(is_dark_mode())
            col_vals <- cols[types]
            col_vals[is.na(col_vals)] <- "gray70"
            p <- ggplot() +
              .ab_geom_zone() +
              # visible points
              ggiraph::geom_point_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight,
                    color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
                    tooltip = tt, data_id = pitch_idx),
                size = 5, alpha = 0.95, stroke = 0.8
              ) +
              # bigger pitch number next to dot
              ggiraph::geom_text_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight, label = pitch_idx, tooltip = tt, data_id = pitch_idx),
                nudge_y = 0.21, size = 5.5
              ) +
              # invisible hover pad to ensure tooltip bg shows over hollow shapes
              ggiraph::geom_point_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = pitch_idx, fill = I(tt_fill)),
                shape = 21, size = 7, alpha = 0.001, stroke = 0, inherit.aes = FALSE
              ) +
              scale_color_manual(values = col_vals, limits = types, name = NULL) +
              scale_fill_manual(values  = col_vals, limits = types, name = NULL) +
              scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
              coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
              theme_void() + theme(legend.position = "none")
            
            girafe_transparent(
              ggobj = p,
              options = list(
                ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                      css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"),
                ggiraph::opts_hover(css = "stroke-width:1.5px;"),
                ggiraph::opts_hover_inv(css = "opacity:0.15;")
              )
            )
          })
        })
        
        # Panel UI: centered "PA #i" then result line under it
        panel_ui <- div(
          tags$div(style="text-align:center; margin-top:6px;",
                   tags$div(tags$strong(paste0("PA #", i))),
                   tags$div(title_result)
          ),
          ggiraph::girafeOutput(out_plot_id, height = "350px")
        )
        
        if ((i %% 2) == 1) {
          chart_rows[[length(chart_rows) + 1]] <- fluidRow(
            column(6, panel_ui),
            column(6, if (i + 1 <= n_pa) div(id = ns(paste0("abChartCol_", i+1))) else NULL)
          )
        } else {
          chart_rows[[length(chart_rows)]]$children[[2]] <- column(6, panel_ui)
        }
      }
      
      # ---------- TABLES (bottom, one per row) ----------
      table_rows <- list()
      for (i in seq_len(n_pa)) {
        dat <- pa_list[[i]] %>% dplyr::mutate(pitch_idx = dplyr::row_number())
        pid <- names(pa_list)[i]
        out_table_id <- ns(paste0("abTable_", pid))
        
        local({
          dat_local <- pa_list[[i]] %>% dplyr::mutate(pitch_idx = dplyr::row_number())
          out_table_id_local <- paste0("abTable_", pid)
          output[[out_table_id_local]] <- DT::renderDT({
            tbl <- dat_local %>% dplyr::transmute(
              `Pitch #` = pitch_idx,
              Pitch     = as.character(TaggedPitchType),
              Velo      = ifelse(is.finite(RelSpeed), round(RelSpeed, 1), NA_real_),
              IVB       = ifelse(is.finite(InducedVertBreak), round(InducedVertBreak, 1), NA_real_),
              HB        = ifelse(is.finite(HorzBreak), round(HorzBreak, 1), NA_real_),
              EV        = ifelse(is.finite(ExitSpeed), round(ExitSpeed, 1), NA_real_),
              LA        = ifelse(is.finite(Angle), round(Angle, 1), NA_real_),
              Distance  = ifelse(is.finite(Distance), round(Distance, 0), NA_real_),
              Result    = dplyr::case_when(
                PitchCall == "InPlay" & !is.na(PlayResult) ~ PlayResult,
                TRUE ~ as.character(PitchCall)
              )
            )
            nd <- function(x) { x[is.na(x)] <- "-"; x }
            tbl$EV <- nd(tbl$EV); tbl$LA <- nd(tbl$LA); tbl$Distance <- nd(tbl$Distance)
            
            DT::datatable(
              tbl,
              options = list(dom = 't', pageLength = nrow(tbl), ordering = FALSE),
              rownames = FALSE
            )
          })
        })
        
        pitcher_label <- {
          p <- as.character(dat$Pitcher[nrow(dat)])
          paste0(trimws(sub(".*,", "", p)), " ", trimws(sub(",.*", "", p)))
        }
        
        table_rows[[i]] <- fluidRow(
          column(12,
                 tags$div(style="margin:8px 0 4px 0;",
                          tags$strong(paste0("PA #", i, " vs. ", pitcher_label))
                 ),
                 DT::DTOutput(out_table_id)
          )
        )
      }
      
      tagList(chart_rows, tags$hr(), table_rows)
    })
    
    fmt_avg  <- function(x) { z <- ifelse(is.finite(x), sprintf("%.3f", x), NA_character_); sub("^0", "", z) }
    safe_div <- function(num, den) ifelse(den > 0, num/den, NA_real_)
    parse_num <- function(x) {
      if (is.numeric(x)) return(x)
      x1 <- trimws(as.character(x)); x1[x1 == ""] <- NA_character_
      ifelse(grepl("%$", x1), suppressWarnings(as.numeric(sub("%$","",x1)))/100,
             suppressWarnings(as.numeric(x1)))
    }
    swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
    hit_levels   <- c("Single","Double","Triple","HomeRun")
    
    # Shape map for hitting results
    hit_shape_map <- c(
      "Called Strike" = 19,
      "Ball"          = 1,
      "Foul"          = 2,
      "Whiff"         = 8,
      "In Play"       = 17,
      "Error"         = 0
    )
    
    # Helper to create location plot with green box
    make_location_plot <- function(df_subset) {
      if (!"Result" %in% names(df_subset)) {
        df_subset$Result <- compute_result(df_subset$PitchCall, df_subset$PlayResult)
      }
      dark_on <- is_dark_mode()
      line_col <- if (dark_on) "#ffffff" else "black"
      grid_col <- if (dark_on) "#d1d5db" else "black"
      cols <- colors_for_mode(dark_on)
      
      # Use hit_shape_map levels for the hitting suite
      hit_result_levels <- names(hit_shape_map)
      
      df_subset <- df_subset %>%
        dplyr::mutate(
          ResultDisplay = dplyr::case_when(
            Result %in% c("In Play (Out)", "In Play (Hit)") ~ "In Play",
            TRUE ~ as.character(Result)
          )
        )
      
      df_plot <- df_subset %>%
        dplyr::filter(is.finite(as.numeric(PlateLocSide)), is.finite(as.numeric(PlateLocHeight))) %>%
        dplyr::mutate(
          PlateLocSide = as.numeric(PlateLocSide),
          PlateLocHeight = as.numeric(PlateLocHeight),
          TaggedPitchType = as.character(TaggedPitchType),
          ResultDisplay = dplyr::case_when(
            ResultDisplay %in% hit_result_levels ~ ResultDisplay,
            TRUE ~ NA_character_
          ),
          ResultDisplay = factor(ResultDisplay, levels = hit_result_levels),
          tooltip = paste0(
            "<b>", TaggedPitchType, "</b><br>",
            "PitchCall: ", ifelse(is.na(PitchCall), "—", as.character(PitchCall)), "<br>",
            "Result: ", ifelse(is.na(ResultDisplay), "—", as.character(ResultDisplay)), "<br>",
            "Velo: ", ifelse(is.finite(as.numeric(RelSpeed)), sprintf("%.1f mph", as.numeric(RelSpeed)), "—"), "<br>",
            "EV: ", ifelse(is.finite(as.numeric(ExitSpeed)), sprintf("%.1f mph", as.numeric(ExitSpeed)), "—"), "<br>",
            "LA: ", ifelse(is.finite(as.numeric(Angle)), sprintf("%.1f°", as.numeric(Angle)), "—")
          ),
          rid = dplyr::row_number()
        )
      
      if (!nrow(df_plot)) {
        p_empty <- ggplot() + 
          annotate("text", x = 0, y = 2.5, label = "No pitches", size = 5) +
          theme_void()
        return(girafe_transparent(ggobj = p_empty))
      }
      
      types_chr <- intersect(names(cols), unique(df_plot$TaggedPitchType))
      if (!length(types_chr)) types_chr <- unique(df_plot$TaggedPitchType)
      col_vals <- cols[types_chr]
      col_vals[is.na(col_vals)] <- "gray70"
      
      home <- data.frame(
        x = c(-0.75, 0.75, 0.75, 0, -0.75),
        y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
      )
      sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
      mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
      dx <- (ZONE_RIGHT - ZONE_LEFT) / 3
      dy <- (ZONE_TOP - ZONE_BOTTOM) / 3
      grid_vertical <- data.frame(
        x = c(ZONE_LEFT + dx, ZONE_LEFT + 2 * dx),
        ymin = ZONE_BOTTOM,
        ymax = ZONE_TOP
      )
      grid_horizontal <- data.frame(
        y = c(ZONE_BOTTOM + dy, ZONE_BOTTOM + 2 * dy),
        xmin = ZONE_LEFT,
        xmax = ZONE_RIGHT
      )
      inner_half <- 7 / 12  # 7 inches converted to feet
      green_box <- data.frame(
        xmin = mid_x - inner_half,
        xmax = mid_x + inner_half,
        ymin = mid_y - inner_half,
        ymax = mid_y + inner_half
      )
      
      df_known <- dplyr::filter(df_plot, !is.na(ResultDisplay))
      df_other <- dplyr::filter(df_plot, is.na(ResultDisplay))
      
      tooltip_css <- "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), inherit.aes = FALSE, fill = NA, color = line_col) +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  inherit.aes = FALSE, fill = NA, color = line_col) +
        geom_rect(data = green_box,
                  aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  inherit.aes = FALSE,
                  fill = "#66c87a", alpha = 0.18, color = NA) +
        geom_segment(data = grid_vertical,
                     aes(x = x, xend = x, y = ymin, yend = ymax),
                     inherit.aes = FALSE, color = grid_col, linewidth = 0.4) +
        geom_segment(data = grid_horizontal,
                     aes(x = xmin, xend = xmax, y = y, yend = y),
                     inherit.aes = FALSE, color = grid_col, linewidth = 0.4) +
        ggiraph::geom_point_interactive(
          data = df_other,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tooltip, data_id = rid),
          size = 4.5, alpha = 0.9, shape = 21, stroke = 0.4
        ) +
        ggiraph::geom_point_interactive(
          data = df_known,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType, shape = ResultDisplay,
              tooltip = tooltip, data_id = rid),
          size = 5, alpha = 0.95, stroke = 0.8
        ) +
        scale_color_manual(values = col_vals, limits = types_chr, drop = FALSE, name = NULL) +
        scale_fill_manual(values = col_vals, limits = types_chr, drop = FALSE, name = NULL) +
        scale_shape_manual(values = hit_shape_map, drop = TRUE) +
        coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
        theme_void() +
        theme(legend.position = "none")
      
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    }
    
    # Keep count filter tidy
    observeEvent(input$countFilter, {
      sel <- input$countFilter
      if (is.null(sel) || !length(sel)) {
        updateSelectInput(session, "countFilter", selected = "All")
      } else if ("All" %in% sel && length(sel) > 1) {
        updateSelectInput(session, "countFilter", selected = setdiff(sel, "All"))
      }
    }, ignoreInit = TRUE)
    
    # Keep BIP Result tidy (handle "All")
    observeEvent(input$bipResult, {
      sel <- input$bipResult
      if (is.null(sel) || !length(sel)) {
        updateSelectInput(session, "bipResult", selected = "All")
      } else if ("All" %in% sel && length(sel) > 1) {
        updateSelectInput(session, "bipResult", selected = setdiff(sel, "All"))
      }
    }, ignoreInit = TRUE)
    
    # Track if user has manually changed dates
    user_changed_dates <- reactiveVal(FALSE)
    
    # Detect manual date changes
    observeEvent(input$dates, {
      user_changed_dates(TRUE)
    }, ignoreInit = TRUE)
    
    # Default date range to last date for selected hitter (LSU only)
    # Only update if user hasn't manually changed dates
    observeEvent(input$hitter, {
      req(is_active())
      
      # Skip if user has manually changed dates
      if (user_changed_dates()) return()
      
      d <- pd_team()
      last_date <- if (isTRUE(input$hitter == "All")) {
        max(d$Date, na.rm = TRUE)
      } else {
        mx <- max(d$Date[d$Batter == input$hitter], na.rm = TRUE)
        if (is.finite(mx)) mx else max(d$Date, na.rm = TRUE)
      }
      if (is.finite(last_date)) {
        updateDateRangeInput(session, "dates", start = last_date, end = last_date)
      }
    }, ignoreInit = TRUE)
    
    # --- Filtered data for Hitting (LSU only; no Session Type input) ---
    filtered_hit <- reactive({
      req(is_active(), input$dates, input$hand, input$zoneLoc, input$inZone)
      pitch_types <- if (is.null(input$pitchType)) "All" else input$pitchType
      
      df <- pd_team() %>% dplyr::filter(Date >= input$dates[1], Date <= input$dates[2])
      
      hit_pick <- input$hitter
      if (!is.null(hit_pick) && hit_pick != "All") df <- dplyr::filter(df, Batter == hit_pick)
      
      # NEW: Filter by opponent pitcher
      pitch_pick <- input$oppPitcher
      if (!is.null(pitch_pick) && pitch_pick != "All") df <- dplyr::filter(df, Pitcher == pitch_pick)
      
      if (input$hand != "All") df <- dplyr::filter(df, PitcherThrows == input$hand)
      
      if (!is.null(input$batterSide) && input$batterSide != "All") {
        df <- df %>% dplyr::filter(SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide))
      }
      
      df <- enforce_zone(df, input$zoneLoc)
      df <- enforce_inzone(df, input$inZone)
      # Note: No QP Locations filter in hitting suite
      df <- apply_count_filter(df, input$countFilter)
      df <- apply_after_count_filter(df, input$afterCountFilter)
      df <- apply_pitch_results_filter(df, input$pitchResults)
      
      # ---- Apply BIP Result filter (balls in play only) ----
      bip <- input$bipResult
      if (!is.null(bip) && !("All" %in% bip)) {
        inplay <- !is.na(df$PitchCall) & df$PitchCall == "InPlay"
        pr     <- as.character(df$PlayResult)
        hit_opts <- c("Single","Double","Triple")
        
        mask <- rep(FALSE, nrow(df))
        
        # Selected BIP hits (Single/Double/Triple)
        sel_hits <- intersect(bip, hit_opts)
        if (length(sel_hits)) {
          mask <- mask | (inplay & pr %in% sel_hits)
        }
        
        # Selected BIP outs (exclude HR so HR isn't counted as Out)
        if ("Out" %in% bip) {
          mask <- mask | (inplay & !(pr %in% c(hit_opts, "HomeRun")) & !is.na(pr))
        }
        
        df <- df[mask, , drop = FALSE]
      }
      
      nnz <- function(x) !is.null(x) && !is.na(x)
      if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed >= input$veloMin)
      if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed <= input$veloMax)
      if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
      if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
      if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak >= input$hbMin)
      if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak <= input$hbMax)
      
      df <- df %>% dplyr::arrange(Date) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
      if (nnz(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
      if (nnz(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
      
      df2 <- compute_stuff_simple(df, base_type = "Fastball", level = "College") %>% force_pitch_levels()
      if (!("All" %in% pitch_types)) df2 <- dplyr::filter(df2, TaggedPitchType %in% pitch_types)
      df2
    })
    
    # ---- HeatMaps note ----
    output$hmNote <- renderUI({
      stat <- input$hmStat
      if (is.null(stat)) return(NULL)
      if (identical(stat, "Exit Velocity")) {
        HTML(sprintf("<small><em>Shows Live in-play balls with EV ≥ %d mph; lower-density areas are floored for readability.</em></small>", HEAT_EV_THRESHOLD))
      } else if (identical(stat, "Whiff Rate")) {
        HTML("<small><em>Locations of swinging strikes.</em></small>")
      } else if (identical(stat, "GB Rate")) {
        HTML("<small><em>Locations of ground balls (Live only).</em></small>")
      } else if (identical(stat, "Contact Rate")) {
        HTML("<small><em>Locations of balls put in play (Live only).</em></small>")
      } else if (identical(stat, "Swing Rate")) {
        HTML("<small><em>Locations of swings (whiffs, fouls, balls in play).</em></small>")
      } else {
        HTML("<small><em>Kernel density of pitch locations.</em></small>")
      }
    })
    
    # Local helper for 2D KDE grid (like the pitching version)
    make_kde_grid <- function(x, y, lims = c(-2.5,2.5,0,4.5), n = 180) {
      ok <- is.finite(x) & is.finite(y)
      x <- x[ok]; y <- y[ok]
      if (length(x) < 2 || length(unique(x)) < 2 || length(unique(y)) < 2) {
        return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
      }
      d <- MASS::kde2d(x, y, n = n, lims = lims)
      expand.grid(x = d$x, y = d$y) |> transform(z = as.vector(d$z))
    }
    
    # Helper to create binned rate heatmap data
    make_rate_grid <- function(df, numerator_condition, denominator_condition = NULL, 
                               bin_size = 0.75, x_range = c(-2.5, 2.5), y_range = c(0, 4.5),
                               min_sample = 3) {
      # If no denominator condition provided, use all data
      if (is.null(denominator_condition)) {
        df_denom <- df
      } else {
        df_denom <- df[denominator_condition, ]
      }
      df_numer <- df[numerator_condition, ]
      
      # Create bins
      x_breaks <- seq(x_range[1], x_range[2], by = bin_size)
      y_breaks <- seq(y_range[1], y_range[2], by = bin_size)
      
      # Bin the denominator data
      df_denom$x_bin <- cut(df_denom$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
      df_denom$y_bin <- cut(df_denom$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
      
      # Count denominator
      denom_counts <- df_denom %>%
        filter(!is.na(x_bin) & !is.na(y_bin)) %>%
        group_by(x_bin, y_bin) %>%
        summarise(denom = n(), .groups = 'drop')
      
      # Bin the numerator data
      df_numer$x_bin <- cut(df_numer$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
      df_numer$y_bin <- cut(df_numer$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
      
      # Count numerator
      numer_counts <- df_numer %>%
        filter(!is.na(x_bin) & !is.na(y_bin)) %>%
        group_by(x_bin, y_bin) %>%
        summarise(numer = n(), .groups = 'drop')
      
      # Merge and calculate rate
      rate_data <- denom_counts %>%
        left_join(numer_counts, by = c("x_bin", "y_bin")) %>%
        mutate(
          numer = ifelse(is.na(numer), 0, numer),
          rate = (numer / denom) * 100
        ) %>%
        filter(denom >= min_sample)
      
      # Get bin centers for plotting
      rate_data <- rate_data %>%
        mutate(
          x = (as.numeric(sub("\\((.+),.*", "\\1", x_bin)) + 
                 as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", x_bin))) / 2,
          y = (as.numeric(sub("\\((.+),.*", "\\1", y_bin)) + 
                 as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", y_bin))) / 2
        ) %>%
        dplyr::select(x, y, z = rate)
      
      return(rate_data)
    }
    
    # Helper to smooth binned data using interpolation
    smooth_grid <- function(grid_data, n = 100, x_range = c(-2.5, 2.5), y_range = c(0, 4.5)) {
      if (nrow(grid_data) < 4) return(grid_data)  # Need minimum points to interpolate
      
      # Remove any rows with NA or Inf values
      grid_data <- grid_data %>%
        filter(is.finite(x) & is.finite(y) & is.finite(z))
      
      if (nrow(grid_data) < 4) return(grid_data)
      
      # Use akima for smooth interpolation
      if (!requireNamespace("akima", quietly = TRUE)) {
        return(grid_data)  # Fall back to binned data if akima not available
      }
      
      # Wrap in tryCatch to handle any interpolation errors
      smooth_data <- tryCatch({
        interp_result <- akima::interp(
          x = grid_data$x,
          y = grid_data$y,
          z = grid_data$z,
          xo = seq(x_range[1], x_range[2], length.out = n),
          yo = seq(y_range[1], y_range[2], length.out = n),
          linear = FALSE,
          extrap = TRUE,  # Allow light extrapolation to avoid white holes
          duplicate = "mean"
        )
        
        result <- expand.grid(x = interp_result$x, y = interp_result$y) %>%
          mutate(z = as.vector(interp_result$z)) %>%
          filter(is.finite(z))
        
        # If we lost too much data, add back original bins to fill gaps
        if (nrow(result) < nrow(grid_data) * 2) {
          result <- bind_rows(result, grid_data) %>%
            distinct(x, y, .keep_all = TRUE)
        }
        
        result
      }, error = function(e) {
        # If interpolation fails, return original binned data
        grid_data
      })
      
      return(smooth_data)
    }
    
    # Helper to create binned average heatmap data (for EV)
    make_avg_grid <- function(df, value_col, bin_size = 0.75, 
                              x_range = c(-2.5, 2.5), y_range = c(0, 4.5), min_sample = 2) {
      # Filter to valid values
      df <- df[is.finite(df[[value_col]]), ]
      
      # Create bins
      x_breaks <- seq(x_range[1], x_range[2], by = bin_size)
      y_breaks <- seq(y_range[1], y_range[2], by = bin_size)
      
      df$x_bin <- cut(df$PlateLocSide, breaks = x_breaks, include.lowest = TRUE)
      df$y_bin <- cut(df$PlateLocHeight, breaks = y_breaks, include.lowest = TRUE)
      
      # Calculate average per bin
      avg_data <- df %>%
        filter(!is.na(x_bin) & !is.na(y_bin)) %>%
        group_by(x_bin, y_bin) %>%
        summarise(
          count = n(),
          avg_value = mean(.data[[value_col]], na.rm = TRUE),
          .groups = 'drop'
        ) %>%
        filter(count >= min_sample)
      
      # Get bin centers
      avg_data <- avg_data %>%
        mutate(
          x = (as.numeric(sub("\\((.+),.*", "\\1", x_bin)) + 
                 as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", x_bin))) / 2,
          y = (as.numeric(sub("\\((.+),.*", "\\1", y_bin)) + 
                 as.numeric(sub("[^,]*,([^]]+)\\]", "\\1", y_bin))) / 2
        ) %>%
        dplyr::select(x, y, z = avg_value)
      
      return(avg_data)
    }
    
    # ---- HeatMaps → Heat plot ----
    output$heatmapsHeatPlot <- renderPlot({
      df <- filtered_hit(); if (!nrow(df)) return()
      stat <- input$hmStat
      if (identical(stat, "Exit Velocity")) stat <- "EV"
      
      pitch_type <- input$hmPitchType
      if (!is.null(pitch_type) && pitch_type != "All") {
        df <- df %>% filter(TaggedPitchType == pitch_type)
        if (!nrow(df)) return(ggplot() + theme_void())
      }
      
      render_heatmap_stat(df, stat)
    }, bg = "transparent")
    
    # ---- HeatMaps → Pitch (interactive scatter) ----
    output$heatmapsPitchPlot <- ggiraph::renderGirafe({
      req(input$hmChartType == "Pitch")
      df <- filtered_hit(); if (!nrow(df)) return(NULL)
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      types_chr <- as.character(types)
      
      df_i <- df %>%
        dplyr::mutate(
          Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
          tt  = make_hover_tt(.),
          rid = dplyr::row_number()
        )
      
      home <- data.frame(x=c(-0.75,0.75,0.75,0.00,-0.75),
                         y=c(1.05,1.05,1.15,1.25,1.15)-0.5)
      cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      
      df_known <- dplyr::filter(df_i, !is.na(Result))
      df_other <- dplyr::filter(df_i,  is.na(Result))
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), fill = NA, color = line_col) +
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col, linetype = "dashed") +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col) +
        ggiraph::geom_point_interactive(
          data = df_other,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
        ) +
        ggiraph::geom_point_interactive(
          data = df_known,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
              tooltip = tt, data_id = rid),
          size = 4.0, alpha = 0.95, stroke = 0.8
        ) +
        scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
        scale_fill_manual(values  = cols[types_chr], limits = types_chr, name = NULL) +
        scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
        coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
        theme_void() + theme(legend.position = "none")
      
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
    # ---- Location plots (strike zones with green box) ----
    output$loc_rhp <- ggiraph::renderGirafe({
      df <- filtered_hit()
      df <- dplyr::filter(df, PitcherThrows == "Right")
      make_location_plot(df)
    })
    
    output$loc_lhp <- ggiraph::renderGirafe({
      df <- filtered_hit()
      df <- dplyr::filter(df, PitcherThrows == "Left")
      make_location_plot(df)
    })
    
    # ---- Result key (legend for pitch results) ----
    output$result_key <- renderPlot({
      dark_on <- is_dark_mode()
      text_col <- if (dark_on) "#e5e7eb" else "#333333"
      stroke_col <- text_col
      fill_inplay <- if (dark_on) "#e5e7eb" else "#333333"
      fill_other  <- if (dark_on) "#0f172a" else "#ffffff"
      df <- data.frame(
        Result = factor(names(hit_shape_map), levels = names(hit_shape_map)),
        x = seq_along(hit_shape_map)
      )
      df$fill <- ifelse(df$Result == "In Play", fill_inplay, fill_other)
      
      ggplot(df, aes(x = x, y = 0)) +
        geom_point(aes(shape = Result, fill = fill), color = stroke_col, size = 5.5, stroke = 1.1, show.legend = FALSE) +
        geom_text(aes(y = -0.48, label = Result), size = 4, fontface = "bold", color = text_col) +
        scale_shape_manual(values = hit_shape_map, drop = FALSE) +
        scale_fill_identity() +
        coord_cartesian(xlim = c(0.5, length(hit_shape_map) + 0.5), ylim = c(-0.85, 0.35)) +
        theme_void() +
        theme(
          plot.background = element_rect(fill = "transparent", color = NA),
          panel.background = element_rect(fill = "transparent", color = NA)
        )
    }, bg = "transparent")
    
    # ---- Pitch type key (legend for pitch types) ----
    output$pitch_type_key <- renderPlot({
      dark_on <- is_dark_mode()
      text_col <- if (dark_on) "#e5e7eb" else "#333333"
      stroke_col <- text_col
      df <- filtered_hit()
      if (is.null(df) || !nrow(df)) return(NULL)
      
      # Safe extraction of pitch types with error handling
      types <- tryCatch({
        unique_types <- unique(df$TaggedPitchType)
        unique_types[!is.na(unique_types) & nzchar(as.character(unique_types))]
      }, error = function(e) {
        character(0)
      })
      
      if (!length(types)) return(NULL)
      
      # Convert to character
      types <- as.character(types)
      
      # Sort types in the canonical order (Fastball, Sinker, Cutter, Slider, Sweeper, Curveball, ChangeUp, Splitter, Knuckleball)
      # First, filter to types that exist in all_colors (in order), then append any unknown types
      canonical_order <- names(all_colors)
      known_types <- canonical_order[canonical_order %in% types]
      unknown_types <- setdiff(types, canonical_order)
      types <- c(known_types, sort(unknown_types))
      
      # Create color mapping - use default gray for any unknown types
      cols <- colors_for_mode(dark_on)
      type_colors <- sapply(types, function(t) {
        if (t %in% names(cols)) {
          cols[t]
        } else {
          if (dark_on) "#e5e7eb" else "gray50"
        }
      })
      names(type_colors) <- types
      
      leg_df <- data.frame(
        TaggedPitchType = factor(types, levels = types),
        x = seq_along(types),
        stringsAsFactors = FALSE
      )
      
      ggplot(leg_df, aes(x = x, y = 0)) +
        geom_point(aes(fill = TaggedPitchType), shape = 21, size = 6, color = stroke_col, stroke = 1.1) +
        geom_text(aes(label = TaggedPitchType, y = -0.48), size = 4, fontface = "bold", color = text_col) +
        scale_fill_manual(values = type_colors, limits = types, drop = FALSE, guide = "none") +
        coord_cartesian(xlim = c(0.5, length(types) + 0.5), ylim = c(-0.9, 0.35)) +
        theme_void() +
        theme(
          plot.background = element_rect(fill = "transparent", color = NA),
          panel.background = element_rect(fill = "transparent", color = NA)
        )
    }, bg = "transparent")
    
    # ---- Spray chart (interactive) ----
    output$sprayChart <- ggiraph::renderGirafe({
      df <- filtered_hit(); if (!nrow(df)) return(NULL)
      dark_on <- is_dark_mode()
      cols <- colors_for_mode(dark_on)
      field_fill  <- if (dark_on) "transparent" else "#f3f5f7"
      field_alpha <- if (dark_on) 0 else 0.6
      foul_line_col <- if (dark_on) "#e5e7eb" else "grey50"
      fence_col  <- if (dark_on) "#9ca3af" else "grey40"
      infield_col <- if (dark_on) "#cbd5e1" else "grey70"
      text_col   <- if (dark_on) "#e5e7eb" else "black"
      
      # Accept any live-like session text
      st <- tolower(trimws(as.character(df$SessionType)))
      live_mask <- grepl("live|game|ab", st)
      
      # Require in-play with numeric distance/direction
      dist_num <- suppressWarnings(as.numeric(df$Distance))
      dir_num  <- suppressWarnings(as.numeric(df$Direction))
      ok <- which(live_mask & df$PitchCall == "InPlay" &
                    is.finite(dist_num) & is.finite(dir_num))
      
      # --- Field geometry (±45°, 330/370/400/370/330) ---
      fence_pts <- data.frame(deg = c(-45,-22.5,0,22.5,45),
                              r   = c(330,370,400,370,330))
      deg_seq <- seq(-45, 45, length.out = 301)
      r_seq   <- stats::spline(fence_pts$deg, fence_pts$r, xout = deg_seq)$y
      fence   <- data.frame(x = r_seq * sin(deg_seq*pi/180),
                            y = r_seq * cos(deg_seq*pi/180))
      fl_l <- data.frame(x = c(0, 330*sin(-45*pi/180)),
                         y = c(0, 330*cos(-45*pi/180)))
      fl_r <- data.frame(x = c(0, 330*sin( 45*pi/180)),
                         y = c(0, 330*cos( 45*pi/180)))
      th_in <- seq(-45, 45, length.out = 121)
      infield <- data.frame(x = 95 * sin(th_in*pi/180),
                            y = 95 * cos(th_in*pi/180))
      # home plate (simple)
      home <- data.frame(
        x = c(-0.75, 0.75, 0.75, 0, -0.75),
        y = c( 1.05, 1.05, 1.15, 1.25, 1.15) - 2.0
      )
      
      # If nothing to plot, show field + message
      if (!length(ok)) {
        p_empty <- ggplot() +
          geom_polygon(data = home, aes(x, y), fill = NA, color = foul_line_col) +
          geom_path(data = fence, aes(x, y), color = fence_col, linewidth = 0.8) +
          geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                       fill = field_fill, color = NA, alpha = field_alpha) +
          geom_path(data = fl_l, aes(x, y), color = foul_line_col) +
          geom_path(data = fl_r, aes(x, y), color = foul_line_col) +
          geom_path(data = infield, aes(x, y), color = infield_col) +
          annotate("text", x = 0, y = 200, label = "No balls in play for current filters", size = 5, color = text_col) +
          coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
          theme_void()
        return(girafe_transparent(ggobj = p_empty))
      }
      
      # --- Points to plot ---
      bbe <- df[ok, , drop = FALSE]
      bbe$Distance  <- dist_num[ok]
      bbe$Direction <- dir_num[ok]
      
      # Fixed mapping: raw Direction ±75 -> on-field ±45 (foul lines)
      FOUL_DEG_RAW  <- 90    # raw "down the line"
      FOUL_DEG_GEOM <- 110    # field drawing foul line angle
      angle_scale   <- FOUL_DEG_GEOM / FOUL_DEG_RAW
      
      # Polar (0° = CF, +RF, −LF) → cartesian
      th     <- bbe$Direction * angle_scale * pi/180
      bbe$x  <- bbe$Distance * sin(th)
      bbe$y  <- bbe$Distance * cos(th)
      
      # Outcome colors
      outcome <- dplyr::case_when(bbe$PlayResult %in% hit_levels ~ bbe$PlayResult, TRUE ~ "Out")
      bbe$Outcome <- factor(outcome, levels = c("Out", hit_levels))
      outcome_cols <- if (dark_on) {
        c("Single"="#34d399","Double"="#60a5fa","Triple"="#c084fc","HomeRun"="#f87171","Out"="#e5e7eb")
      } else {
        c("Single"="#1fab54","Double"="#1f77b4","Triple"="#7b1fa2","HomeRun"="#d62728","Out"="#222222")
      }
      
      # Tooltip + tooltip fill by pitch type color
      bbe <- bbe %>%
        dplyr::mutate(
          rid     = dplyr::row_number(),
          tt      = paste0(
            "EV: ", ifelse(is.finite(ExitSpeed), sprintf("%.1f", ExitSpeed), "—"), " mph\n",
            "LA: ", ifelse(is.finite(Angle),     sprintf("%.1f", Angle),     "—"), "°\n",
            "Distance: ", ifelse(is.finite(Distance), paste0(sprintf("%.0f", Distance), " ft"), "—"), "\n",
            "Pitch: ", TaggedPitchType, "\n",
            "Result: ", PlayResult
          ),
          tt_fill = dplyr::coalesce(cols[as.character(TaggedPitchType)], "gray80")
        )
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), fill = NA, color = foul_line_col) +
        geom_path(data = fence, aes(x, y), color = fence_col, linewidth = 0.8) +
        geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                     fill = field_fill, color = NA, alpha = field_alpha) +
        geom_path(data = fl_l, aes(x, y), color = foul_line_col) +
        geom_path(data = fl_r, aes(x, y), color = foul_line_col) +
        geom_path(data = infield, aes(x, y), color = infield_col) +
        
        ggiraph::geom_point_interactive(
          data = bbe,
          aes(x, y, color = Outcome, tooltip = tt, data_id = rid),
          size = 2.8, alpha = 0.95
        ) +
        ggiraph::geom_point_interactive( # invisible hover pad to color tooltip bg by pitch type
          data = bbe,
          aes(x, y, tooltip = tt, data_id = rid, fill = I(tt_fill)),
          shape = 21, size = 8, alpha = 0.001, stroke = 0, inherit.aes = FALSE
        ) +
        scale_color_manual(values = outcome_cols, name = NULL) +
        coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
        theme_void() + theme(
          legend.position = "bottom",
          legend.direction = "horizontal",
          legend.box = "horizontal",
          legend.margin = margin(t = -4, r = 0, b = -12, l = 0),
          legend.box.margin = margin(t = -6, r = 0, b = -14, l = 0),
          plot.margin = margin(t = 0, r = 0, b = -16, l = 0),
          legend.text = element_text(size = 11, face = "bold", color = text_col),
          legend.background = element_rect(fill = "transparent", color = NA),
          legend.box.background = element_rect(fill = "transparent", color = NA),
          legend.key = element_rect(fill = "transparent", color = NA)
        ) +
        guides(
          color = guide_legend(
            direction = "horizontal",
            title.position = "top",
            title.hjust = 0.5,
            nrow = 1,
            keywidth = grid::unit(1.2, "lines"),
            keyheight = grid::unit(0.5, "lines")
          )
        )
      
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_sizing(rescale = TRUE),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.35);"),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
    # --- “Results” only toggle (UI) ---
    output$dpButtons <- renderUI({
      sel <- isolate(input$dpMode); if (is.null(sel)) sel <- "Results"
      tagList(
        div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Tables:"),
        selectInput(
          ns("dpMode"), label = NULL,
          choices  = c("Results", "Swing Decisions", "Custom"),
          selected = sel,
          width = "200px"
        ),
        div(style = "display:inline-block; margin-left:10px;",
            tags$div(
              "Split By:",
              style = "font-weight:bold; font-size:12px; margin-bottom:2px;"
            ),
            selectInput(
              ns("dpSplitBy"), label = NULL,
              choices = c("Pitch Types", "Pitcher Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Pitcher"),
              selected = "Pitch Types",
              width = "140px"
            )
        ),
        conditionalPanel(
          sprintf("input['%s']=='Custom'", ns("dpMode")),
          tagList(
            selectInput(ns("dpCustomSaved"), "Saved Table:", choices = c("", names(custom_tables())), selected = ""),
            textInput(ns("dpCustomName"), "Name:", value = ""),
            selectizeInput(
              ns("dpCustomCols"), label = "Columns (drag to order):",
              choices  = c("PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
                           "Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%","EV","LA"),
              multiple = TRUE,
              options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
            ),
            actionButton(ns("dpSaveCustom"), "Save / Update", class = "btn-primary btn-sm"),
            actionButton(ns("dpDeleteCustom"), "Delete", class = "btn-danger btn-sm")
          )
        )
      )
    })
    
    # --- Data & Performance table (Results-only custom view for Hitting) ---
    output$dpTable <- DT::renderDT({
      tryCatch({
        req(is_active())
        df <- filtered_hit()
        if (is.null(df) || !nrow(df)) {
          return(DT::datatable(
            data.frame(Message = "No data available for current filters"),
            options = list(dom = 't'),
            rownames = FALSE
          ))
        }
        
        # Apply Split By transformation
        split_choice <- if (!is.null(input$dpSplitBy)) input$dpSplitBy else "Pitch Types"
        df <- apply_split_by(df, split_choice)
        
        # Determine column name based on split choice
        split_col_name <- switch(
          split_choice,
          "Pitch Types" = "Pitch",
          "Pitcher Hand" = "Pitcher Hand",
          "Count" = "Count",
          "After Count" = "After Count",
          "Velocity" = "Velocity",
          "IVB" = "InducedVert",
          "HB" = "HorzBreak",
          "Pitcher" = "Pitcher",
          "Pitch"  # default
        )
        
        # More helpful validation message
        if (nrow(df) == 0) {
          # Check what filters are active
          active_filters <- c()
          if (!is.null(input$hitter) && input$hitter != "All") {
            active_filters <- c(active_filters, paste("Hitter:", input$hitter))
          }
          if (!is.null(input$oppPitcher) && input$oppPitcher != "All") {
            active_filters <- c(active_filters, paste("Pitcher:", input$oppPitcher))
          }
          if (!is.null(input$dates) && length(input$dates) == 2) {
            active_filters <- c(active_filters, paste("Dates:", format(input$dates[1], "%m/%d/%y"), "-", format(input$dates[2], "%m/%d/%y")))
          }
          
          msg <- if (length(active_filters) > 0) {
            paste("No data found with these filters:", paste(active_filters, collapse = ", "))
          } else {
            "No data for selected filters"
          }
          
          validate(need(FALSE, msg))
        }
        
        swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
        parse_pct_prop <- function(x) {
          x_num <- suppressWarnings(as.numeric(sub("%$", "", as.character(x))))
          ifelse(is.finite(x_num), x_num / 100, NA_real_)
        }
        
        # ----- Terminal PA logic (match v1 behavior) -----
        # Add safety checks for NA values
        safe_terminal_check <- function(play_result, korbb) {
          play_ok <- !is.na(play_result) & play_result != "Undefined"
          korbb_ok <- !is.na(korbb) & korbb %in% c("Strikeout","Walk")
          return(play_ok | korbb_ok)
        }
        
        is_terminal <- safe_terminal_check(df$PlayResult, df$KorBB)
        term <- df[is_terminal, , drop = FALSE]
        
        # Ensure we have some terminal data
        if (nrow(term) == 0) {
          return(DT::datatable(
            data.frame(Message = "No completed plate appearances in selected data"),
            options = list(dom = 't'), rownames = FALSE
          ))
        }
        
        # Pitch totals for Swing%/Whiff%
        pitch_totals <- tryCatch({
          df %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              Pitches = dplyr::n(),
              Swings  = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
              Whiffs  = sum(!is.na(PitchCall) & PitchCall == "StrikeSwinging", na.rm = TRUE),
              CalledStrikes = sum(!is.na(PitchCall) & PitchCall == "StrikeCalled", na.rm = TRUE),
              .groups = "drop"
            )
        }, error = function(e) {
          # Return minimal structure if grouping fails
          data.frame(
            SplitColumn = "All",
            Pitches = nrow(df),
            Swings = sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE),
            Whiffs = sum(!is.na(df$PitchCall) & df$PitchCall == "StrikeSwinging", na.rm = TRUE),
            CalledStrikes = sum(!is.na(df$PitchCall) & df$PitchCall == "StrikeCalled", na.rm = TRUE),
            stringsAsFactors = FALSE
          )
        })
        total_pitches <- sum(pitch_totals$Pitches, na.rm = TRUE)
        
        # EV/LA from live balls in play
        bbe <- tryCatch({
          df %>%
            dplyr::filter(
              !is.na(SessionType),
              grepl("live|game|ab", tolower(SessionType)), 
              !is.na(PitchCall),
              PitchCall == "InPlay"
            )
        }, error = function(e) {
          # Return empty data frame if filtering fails
          df[FALSE, , drop = FALSE]
        })
        
        evla <- tryCatch({
          if (nrow(bbe) > 0) {
            bbe %>%
              dplyr::group_by(SplitColumn) %>%
              dplyr::summarise(
                EV = nz_mean(ExitSpeed), 
                LA = nz_mean(Angle), 
                .groups = "drop"
              )
          } else {
            data.frame(
              SplitColumn = character(0),
              EV = numeric(0),
              LA = numeric(0),
              stringsAsFactors = FALSE
            )
          }
        }, error = function(e) {
          data.frame(
            SplitColumn = character(0),
            EV = numeric(0),
            LA = numeric(0),
            stringsAsFactors = FALSE
          )
        })
        
        # GB%
        gb <- tryCatch({
          if (nrow(bbe) > 0) {
            bbe %>%
              dplyr::group_by(SplitColumn) %>%
              dplyr::summarise(
                GBpct = safe_div(
                  sum(!is.na(TaggedHitType) & TaggedHitType == "GroundBall", na.rm = TRUE),
                  sum(!is.na(TaggedHitType), na.rm = TRUE)
                ),
                .groups = "drop"
              )
          } else {
            data.frame(
              SplitColumn = character(0),
              GBpct = numeric(0),
              stringsAsFactors = FALSE
            )
          }
        }, error = function(e) {
          data.frame(
            SplitColumn = character(0),
            GBpct = numeric(0),
            stringsAsFactors = FALSE
          )
        })
        
        # Per-pitch-type PA/AB/hit/K/BB tallies (match v1 K/BB logic)
        per_type <- term %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            PA   = dplyr::n(),
            HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
            SFct = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
            IBBct= sum(PlayResult == "IntentionalWalk", na.rm = TRUE),
            `1B` = sum(PlayResult == "Single",  na.rm = TRUE),
            `2B` = sum(PlayResult == "Double",  na.rm = TRUE),
            `3B` = sum(PlayResult == "Triple",  na.rm = TRUE),
            HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
            Kct  = sum(KorBB == "Strikeout" |
                         PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
            BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
            .groups = "drop"
          ) %>%
          dplyr::mutate(
            AB  = PA - (BBct + HBP + Sac),
            H   = `1B` + `2B` + `3B` + HR,
            TB  = 1*`1B` + 2*`2B` + 3*`3B` + 4*HR,
            AVG = safe_div(H, AB),
            SLG = safe_div(TB, AB),
            OBP = safe_div(H + BBct + HBP, PA),
            OPS = SLG + OBP,
            ISO = SLG - AVG,
            uBB = BBct - IBBct,
            wOBA_num = 0.690*uBB + 0.722*HBP + 0.888*`1B` + 1.271*`2B` + 1.616*`3B` + 2.101*HR,
            wOBA_den = AB + BBct - IBBct + SFct + HBP,
            wOBA = safe_div(wOBA_num, wOBA_den)
          )
        
        # Extras (xWOBA/xISO/BABIP/Barrel%) — force numeric & use correct name
        extras_raw <- compute_process_results(df)
        extras <- extras_raw %>%
          {
            df_proc <- .
            if (!"SplitColumn" %in% names(df_proc) && "PitchType" %in% names(df_proc)) {
              df_proc <- dplyr::rename(df_proc, SplitColumn = PitchType)
            }
            df_proc
          } %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_pct_prop(`Barrel%`)
          ) %>%
          dplyr::select(SplitColumn, xWOBA, xISO, BABIP, `Barrel%`) %>%
          dplyr::rename(!!split_col_name := SplitColumn)
        
        # Join and build output rows per pitch type
        out <- per_type %>%
          dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
          dplyr::left_join(evla,         by = "SplitColumn") %>%
          dplyr::left_join(gb,           by = "SplitColumn") %>%
          dplyr::mutate(
            `Swing%` = safe_div(Swings, Pitches),
            `Whiff%` = safe_div(Whiffs, Swings),
            `GB%`    = GBpct,
            `K%`     = safe_div(Kct, PA),
            `BB%`    = safe_div(BBct, PA)
          ) %>%
          dplyr::transmute(
            !!split_col_name := as.character(SplitColumn),
            PA, AB, AVG, SLG, OBP, OPS,
            wOBA, xWOBA = NA_real_,
            ISO, xISO = NA_real_, BABIP = NA_real_,
            `Swing%`, `Whiff%`, `GB%`, `K%`, `BB%`,
            `Barrel%` = NA_real_, EV, LA
          )
        
        # Join extras if we have the right column
        out <- out %>% dplyr::left_join(extras, by = split_col_name)
        if (any(c("xWOBA.x","xWOBA.y") %in% names(out) |
                c("xISO.x","xISO.y") %in% names(out) |
                c("BABIP.x","BABIP.y") %in% names(out) |
                c("Barrel%.x","Barrel%.y") %in% names(out))) {
          for (nm in c("xWOBA","xISO","BABIP","Barrel%")) {
            if (!nm %in% names(out)) out[[nm]] <- NA_real_
          }
          out <- out %>%
            dplyr::mutate(
              xWOBA     = dplyr::coalesce(.data[["xWOBA.y"]], .data[["xWOBA.x"]], .data[["xWOBA"]]),
              xISO      = dplyr::coalesce(.data[["xISO.y"]],  .data[["xISO.x"]],  .data[["xISO"]]),
              BABIP     = dplyr::coalesce(.data[["BABIP.y"]], .data[["BABIP.x"]], .data[["BABIP"]]),
              `Barrel%` = dplyr::coalesce(.data[["Barrel%.y"]], .data[["Barrel%.x"]], .data[["Barrel%"]])
            ) %>%
            dplyr::select(-dplyr::matches("\\.(x|y)$"))
        }
        
        # ----- ALL row (same definitions as above, but ungrouped; keep your guards) -----
        PAt <- nrow(term)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
        H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
        H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
        HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        H   <- H1 + H2 + H3 + HR
        IBB_all <- sum(term$PlayResult == "IntentionalWalk", na.rm = TRUE)
        TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
        Kct_all <- sum(term$KorBB == "Strikeout" |
                         term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
        BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        ABt <- PAt - (BBc_all + HBP_all + Sac_all)
        
        swings  <- sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE)
        whiffs  <- sum(df$PitchCall == "StrikeSwinging",                      na.rm = TRUE)
        pitches <- nrow(df)
        csw_all_num <- sum(df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
        
        gbpct_all <- {
          d <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
          safe_div(sum(d$TaggedHitType == "GroundBall", na.rm = TRUE),
                   sum(!is.na(d$TaggedHitType),         na.rm = TRUE))
        }
        
        # Create all_row with dynamic column name
        all_row_data <- list(
          PA = PAt, AB = ABt,
          AVG = safe_div(H, ABt),
          SLG = safe_div(TB, ABt),
          OBP = safe_div(H + BBc_all + HBP_all, PAt),
          OPS = NA_real_,  # filled just below
          xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
          `Swing%` = safe_div(swings, total_pitches),
          `Whiff%` = safe_div(whiffs, swings),
          `CSW%`   = safe_div(csw_all_num, total_pitches),
          `GB%`    = gbpct_all,
          `K%`     = safe_div(Kct_all, PAt),
          `BB%`    = safe_div(BBc_all, PAt),
          `Barrel%`= NA_real_,
          EV = nz_mean(bbe$ExitSpeed),
          LA = nz_mean(bbe$Angle),
          ISO = safe_div(TB, ABt) - safe_div(H, ABt),
          wOBA = {
            uBB_all <- BBc_all - IBB_all
            num <- 0.690*uBB_all + 0.722*HBP_all + 0.888*H1 + 1.271*H2 + 1.616*H3 + 2.101*HR
            den <- ABt + BBc_all - IBB_all + Sac_all + HBP_all
            safe_div(num, den)
          }
        )
        all_row_data[[split_col_name]] <- "All"
        all_row <- tibble::as_tibble(all_row_data)
        all_row$OPS <- all_row$SLG + all_row$OBP
        
        extras_all <- {
          df_all <- df
          df_all$SplitColumn <- "All"
          compute_process_results(df_all) %>%
            dplyr::mutate(
              xWOBA     = parse_num(xWOBA),
              xISO      = parse_num(xISO),
              BABIP     = parse_num(BABIP),
              `Barrel%` = parse_pct_prop(`Barrel%`)
            ) %>%
            dplyr::summarise(
              xWOBA     = nz_mean(xWOBA),
              xISO      = nz_mean(xISO),
              BABIP     = nz_mean(BABIP),
              `Barrel%` = nz_mean(`Barrel%`),
              .groups = "drop"
            )
        }
        if (nrow(extras_all)) {
          all_row$xWOBA     <- extras_all$xWOBA[1]
          all_row$xISO      <- extras_all$xISO[1]
          all_row$BABIP     <- extras_all$BABIP[1]
          all_row$`Barrel%` <- extras_all$`Barrel%`[1]
        }
        
        # Add Even/Ahead/Behind summary rows if splitting by Count (Hitting Suite)
        hit_count_state_rows <- NULL
        if (split_choice == "Count" && "CountState" %in% names(df)) {
          for (state in c("Even", "Ahead", "Behind")) {
            state_df <- df %>% dplyr::filter(CountState == state)
            state_term <- term %>% dplyr::filter(CountState == state)
            
            if (nrow(state_df) > 0) {
              # Calculate stats for this count state
              state_PA <- nrow(state_term)
              state_HBP <- sum(state_term$PlayResult == "HitByPitch", na.rm = TRUE)
              state_Sac <- sum(state_term$PlayResult == "Sacrifice", na.rm = TRUE)
              state_H1 <- sum(state_term$PlayResult == "Single", na.rm = TRUE)
              state_H2 <- sum(state_term$PlayResult == "Double", na.rm = TRUE)
              state_H3 <- sum(state_term$PlayResult == "Triple", na.rm = TRUE)
              state_HR <- sum(state_term$PlayResult == "HomeRun", na.rm = TRUE)
              state_H <- state_H1 + state_H2 + state_H3 + state_HR
              state_TB <- 1*state_H1 + 2*state_H2 + 3*state_H3 + 4*state_HR
              state_Kct <- sum(state_term$KorBB == "Strikeout" |
                                 state_term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
              state_BBct <- sum(state_term$KorBB == "Walk" | state_term$PlayResult == "Walk", na.rm = TRUE)
              state_AB <- state_PA - (state_BBct + state_HBP + state_Sac)
              
              state_swings <- sum(!is.na(state_df$PitchCall) & state_df$PitchCall %in% swing_levels, na.rm = TRUE)
              state_whiffs <- sum(state_df$PitchCall == "StrikeSwinging", na.rm = TRUE)
              state_pitches <- nrow(state_df)
              state_bbe <- state_df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
              state_gbpct <- safe_div(sum(state_bbe$TaggedHitType == "GroundBall", na.rm = TRUE),
                                      sum(!is.na(state_bbe$TaggedHitType), na.rm = TRUE))
              
              # Calculate BABIP for count state
              state_inplay_all <- sum(state_df$PitchCall == "InPlay", na.rm = TRUE)
              state_BABIP <- safe_div(state_H, state_inplay_all)
              
              # Calculate Barrel% for count state
              state_barrels <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay" &
                                     is.finite(state_df$ExitSpeed) & is.finite(state_df$Angle) &
                                     state_df$ExitSpeed >= 95 & state_df$Angle >= 10 & state_df$Angle <= 35, na.rm = TRUE)
              state_inplay_live <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay", na.rm = TRUE)
              state_BarrelPct <- safe_div(state_barrels, state_inplay_live)
              
              # Calculate xWOBA and xISO for count state (using expected stats if available)
              state_bip_evla <- state_df %>%
                dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                              is.finite(ExitSpeed), is.finite(Angle)) %>%
                dplyr::mutate(
                  EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
                  LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
                )
              if (exists("xbin_ref") && nrow(state_bip_evla) > 0) {
                state_bip_evla <- state_bip_evla %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
                for (nm in c("p1B","p2B","p3B","pHR")) {
                  if (exists("x_overall") && nm %in% names(x_overall)) {
                    state_bip_evla[[nm]][!is.finite(state_bip_evla[[nm]])] <- x_overall[[nm]]
                  }
                }
                state_x1B <- sum(state_bip_evla$p1B, na.rm = TRUE)
                state_x2B <- sum(state_bip_evla$p2B, na.rm = TRUE)
                state_x3B <- sum(state_bip_evla$p3B, na.rm = TRUE)
                state_xHR <- sum(state_bip_evla$pHR, na.rm = TRUE)
                state_xH   <- state_x1B + state_x2B + state_x3B + state_xHR
                state_xTB  <- 1*state_x1B + 2*state_x2B + 3*state_x3B + 4*state_xHR
                state_xAVG <- safe_div(state_xH, state_AB)
                state_xSLG <- safe_div(state_xTB, state_AB)
                state_xISO <- state_xSLG - state_xAVG
                # xWOBA calculation (using weights if they exist)
                state_BF_live <- sum(state_df$SessionType == "Live" & state_df$Balls == 0 & state_df$Strikes == 0, na.rm = TRUE)
                if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
                  state_xWOBA <- safe_div(W_BB*state_BBct + W_1B*state_x1B + W_2B*state_x2B + W_3B*state_x3B + W_HR*state_xHR, state_BF_live)
                } else {
                  state_xWOBA <- NA_real_
                }
              } else {
                state_xWOBA <- NA_real_
                state_xISO <- NA_real_
              }
              
              state_row_data <- list(
                PA = state_PA,
                AB = state_AB,
                AVG = safe_div(state_H, state_AB),
                SLG = safe_div(state_TB, state_AB),
                OBP = safe_div(state_H + state_BBct + state_HBP, state_PA),
                OPS = NA_real_,
                wOBA = NA_real_,
                xWOBA = state_xWOBA,
                ISO = safe_div(state_TB, state_AB) - safe_div(state_H, state_AB),
                xISO = state_xISO,
                BABIP = state_BABIP,
                `Swing%` = safe_div(state_swings, state_pitches),
                `Whiff%` = safe_div(state_whiffs, state_swings),
                `GB%` = state_gbpct,
                `K%` = safe_div(state_Kct, state_PA),
                `BB%` = safe_div(state_BBct, state_PA),
                `Barrel%` = state_BarrelPct,
                EV = nz_mean(state_bbe$ExitSpeed),
                LA = nz_mean(state_bbe$Angle)
              )
              state_row_data[[split_col_name]] <- state
              state_row <- tibble::as_tibble(state_row_data)
              state_row$OPS <- state_row$SLG + state_row$OBP
              
              hit_count_state_rows <- dplyr::bind_rows(hit_count_state_rows, state_row)
            }
          }
        }
        
        # Bind, coerce numerics (prevents blanks), then format
        num_cols <- c("PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
                      "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
        
        df_out <- dplyr::bind_rows(out, hit_count_state_rows, all_row) %>%
          dplyr::mutate(
            dplyr::across(dplyr::all_of(num_cols), ~ suppressWarnings(as.numeric(.)))
          )
        
        # Keep pitch type order consistent with other suites
        if (split_choice == "Pitch Types" && split_col_name %in% names(df_out)) {
          ord <- names(all_colors)
          other <- setdiff(as.character(df_out[[split_col_name]]), c(ord, "All"))
          df_out[[split_col_name]] <- factor(
            df_out[[split_col_name]],
            levels = c(ord, other, "All")
          )
          df_out <- df_out %>%
            dplyr::arrange(.data[[split_col_name]]) %>%
            dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
          all_rows <- df_out[df_out[[split_col_name]] == "All", , drop = FALSE]
          other_rows <- df_out[df_out[[split_col_name]] != "All", , drop = FALSE]
          df_out <- dplyr::bind_rows(other_rows, all_rows)
        }
        
        # Sort by IVB/HB in descending order if applicable
        df_out <- sort_by_range(df_out, split_col_name, split_choice)
        
        # Display formatting
        tryCatch({
          pct_cols  <- c("Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%")
          rate_cols <- c("AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP")
          
          # Only format columns that exist
          existing_pct <- intersect(pct_cols, names(df_out))
          existing_rate <- intersect(rate_cols, names(df_out))
          
          if (length(existing_pct)) {
            df_out[existing_pct] <- lapply(df_out[existing_pct], function(z) {
              ifelse(is.finite(suppressWarnings(as.numeric(z))), 
                     paste0(round(suppressWarnings(as.numeric(z))*100,1), "%"), "")
            })
          }
          
          if (length(existing_rate)) {
            df_out[existing_rate] <- lapply(df_out[existing_rate], function(z) {
              ifelse(is.finite(suppressWarnings(as.numeric(z))), fmt_avg(as.numeric(z)), "")
            })
          }
          
          if ("EV" %in% names(df_out)) {
            df_out$EV <- ifelse(is.finite(suppressWarnings(as.numeric(df_out$EV))), 
                                round(suppressWarnings(as.numeric(df_out$EV)), 1), "")
          }
          if ("LA" %in% names(df_out)) {
            df_out$LA <- ifelse(is.finite(suppressWarnings(as.numeric(df_out$LA))), 
                                round(suppressWarnings(as.numeric(df_out$LA)), 1), "")
          }
        }, error = function(e) {
          # If formatting fails, continue with unformatted data
          message("Formatting error: ", conditionMessage(e))
        })
        
        # ===== SWING DECISION TABLE =====
        mode_check <- input$dpMode
        if (!is.null(mode_check) && mode_check == "Swing Decisions") {
          # Define green box boundaries (7 inches = 7/12 feet)
          inner_half <- 7 / 12
          mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
          mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
          green_xmin <- mid_x - inner_half
          green_xmax <- mid_x + inner_half
          green_ymin <- mid_y - inner_half
          green_ymax <- mid_y + inner_half
          
          # Pre-calculate PosSD points for each pitch
          df_with_possd <- df %>%
            dplyr::mutate(
              possd_point = {
                pc <- PitchCall
                ps <- PlateLocSide
                ph <- PlateLocHeight
                
                is_swing <- !is.na(pc) & pc %in% swing_levels
                in_green <- !is.na(ps) & !is.na(ph) & 
                  ps >= green_xmin & ps <= green_xmax & ph >= green_ymin & ph <= green_ymax
                in_zone <- !is.na(ps) & !is.na(ph) & 
                  ps >= ZONE_LEFT & ps <= ZONE_RIGHT & ph >= ZONE_BOTTOM & ph <= ZONE_TOP
                out_zone <- !in_zone
                
                dplyr::case_when(
                  in_green & is_swing ~ 2,      # +2: swing in green
                  in_green & !is_swing ~ -1,    # -1: take in green
                  in_zone & !in_green & is_swing ~ 1,   # +1: swing in zone but not green
                  in_zone & !in_green & !is_swing ~ 0,  # +0: take in zone but not green
                  out_zone & is_swing ~ -1,     # -1: swing out of zone
                  out_zone & !is_swing ~ 1,     # +1: take out of zone
                  TRUE ~ 0
                )
              }
            )
          
          # Compute stats by pitch type
          swing_decision_by_type <- df_with_possd %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              # Total pitches
              total_pitches = dplyr::n(),
              
              # Swings
              swings = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
              
              # FPS% - swings on 0-0 count
              fps_num = sum(
                !is.na(Balls) & !is.na(Strikes) & Balls == 0 & Strikes == 0 &
                  !is.na(PitchCall) & PitchCall %in% c("StrikeSwinging","InPlay","FoulBall","FoulBallNotFieldable","FoulBallFieldable"),
                na.rm = TRUE
              ),
              fps_den = sum(!is.na(Balls) & !is.na(Strikes) & Balls == 0 & Strikes == 0, na.rm = TRUE),
              
              # Called%
              called = sum(!is.na(PitchCall) & PitchCall == "StrikeCalled", na.rm = TRUE),
              
              # Chase% - swings outside zone
              chase_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  (PlateLocSide < ZONE_LEFT | PlateLocSide > ZONE_RIGHT | 
                     PlateLocHeight < ZONE_BOTTOM | PlateLocHeight > ZONE_TOP),
                na.rm = TRUE
              ),
              chase_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  (PlateLocSide < ZONE_LEFT | PlateLocSide > ZONE_RIGHT | 
                     PlateLocHeight < ZONE_BOTTOM | PlateLocHeight > ZONE_TOP),
                na.rm = TRUE
              ),
              
              # GoZoneSw% - swings in green box / pitches in green box
              gozone_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                  PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
                na.rm = TRUE
              ),
              gozone_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                  PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
                na.rm = TRUE
              ),
              
              # IZswing% - swings in zone / pitches in zone
              iz_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
                na.rm = TRUE
              ),
              iz_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
                na.rm = TRUE
              ),
              
              # EdgeSwing% - swings in zone but not green / pitches in zone but not green
              edge_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP &
                  !(PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                      PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax),
                na.rm = TRUE
              ),
              edge_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP &
                  !(PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                      PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax),
                na.rm = TRUE
              ),
              
              # PosSD% - Positive Swing Decision percentage
              possd_points = sum(possd_point, na.rm = TRUE),
              
              .groups = "drop"
            ) %>%
            dplyr::mutate(
              `Swing%` = safe_div(swings, total_pitches) * 100,
              `FPS%` = safe_div(fps_num, fps_den) * 100,
              `Called%` = safe_div(called, total_pitches) * 100,
              `Chase%` = safe_div(chase_num, chase_den) * 100,
              `GoZoneSw%` = safe_div(gozone_sw_num, gozone_sw_den) * 100,
              `IZswing%` = safe_div(iz_sw_num, iz_sw_den) * 100,
              `EdgeSwing%` = safe_div(edge_sw_num, edge_sw_den) * 100,
              `PosSD%` = safe_div(possd_points, total_pitches) * 100
            ) %>%
            dplyr::select(SplitColumn, `Swing%`, `FPS%`, `Called%`, `Chase%`, 
                          `GoZoneSw%`, `IZswing%`, `EdgeSwing%`, `PosSD%`) %>%
            dplyr::rename(!!split_col_name := SplitColumn)
          
          # Compute "All" row
          all_swing_decision <- df_with_possd %>%
            dplyr::summarise(
              total_pitches = dplyr::n(),
              swings = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
              fps_num = sum(
                !is.na(Balls) & !is.na(Strikes) & Balls == 0 & Strikes == 0 &
                  !is.na(PitchCall) & PitchCall %in% c("StrikeSwinging","InPlay","FoulBall","FoulBallNotFieldable","FoulBallFieldable"),
                na.rm = TRUE
              ),
              fps_den = sum(!is.na(Balls) & !is.na(Strikes) & Balls == 0 & Strikes == 0, na.rm = TRUE),
              called = sum(!is.na(PitchCall) & PitchCall == "StrikeCalled", na.rm = TRUE),
              chase_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  (PlateLocSide < ZONE_LEFT | PlateLocSide > ZONE_RIGHT | 
                     PlateLocHeight < ZONE_BOTTOM | PlateLocHeight > ZONE_TOP),
                na.rm = TRUE
              ),
              chase_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  (PlateLocSide < ZONE_LEFT | PlateLocSide > ZONE_RIGHT | 
                     PlateLocHeight < ZONE_BOTTOM | PlateLocHeight > ZONE_TOP),
                na.rm = TRUE
              ),
              gozone_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                  PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
                na.rm = TRUE
              ),
              gozone_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                  PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
                na.rm = TRUE
              ),
              iz_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
                na.rm = TRUE
              ),
              iz_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
                na.rm = TRUE
              ),
              edge_sw_num = sum(
                !is.na(PitchCall) & PitchCall %in% swing_levels &
                  !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP &
                  !(PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                      PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax),
                na.rm = TRUE
              ),
              edge_sw_den = sum(
                !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                  PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                  PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP &
                  !(PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                      PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax),
                na.rm = TRUE
              ),
              possd_points = sum(possd_point, na.rm = TRUE)
            ) %>%
            dplyr::mutate(
              !!split_col_name := "All",
              `Swing%` = safe_div(swings, total_pitches) * 100,
              `FPS%` = safe_div(fps_num, fps_den) * 100,
              `Called%` = safe_div(called, total_pitches) * 100,
              `Chase%` = safe_div(chase_num, chase_den) * 100,
              `GoZoneSw%` = safe_div(gozone_sw_num, gozone_sw_den) * 100,
              `IZswing%` = safe_div(iz_sw_num, iz_sw_den) * 100,
              `EdgeSwing%` = safe_div(edge_sw_num, edge_sw_den) * 100,
              `PosSD%` = safe_div(possd_points, total_pitches) * 100
            ) %>%
            dplyr::select(.data[[split_col_name]], `Swing%`, `FPS%`, `Called%`, `Chase%`, 
                          `GoZoneSw%`, `IZswing%`, `EdgeSwing%`, `PosSD%`)
          
          # Combine and format
          df_swing_decision <- dplyr::bind_rows(swing_decision_by_type, all_swing_decision)
          
          # Format to 1 decimal
          pct_cols_sd <- c("Swing%", "FPS%", "Called%", "Chase%", "GoZoneSw%", "IZswing%", "EdgeSwing%", "PosSD%")
          for (col in pct_cols_sd) {
            if (col %in% names(df_swing_decision)) {
              df_swing_decision[[col]] <- ifelse(
                is.finite(df_swing_decision[[col]]),
                paste0(round(df_swing_decision[[col]], 1), "%"),
                ""
              )
            }
          }
          
          # EdgeSwing% was missing, let me add it
          if (!"EdgeSwing%" %in% names(df_swing_decision)) {
            df_swing_decision$`EdgeSwing%` <- ""
          }
          
          df_dt <- if (exists("safe_for_dt")) safe_for_dt(df_swing_decision) else df_swing_decision
          
          return(datatable_with_colvis(
            df_dt,
            lock            = split_col_name,
            remember        = FALSE,
            default_visible = c(split_col_name, pct_cols_sd),
            mode            = NULL,
            enable_colors   = FALSE
          ))
        }
        
        # Clean for DT + final guard for All-row % blanks
        df_dt <- if (exists("safe_for_dt")) safe_for_dt(df_out) else df_out
        
        # Ensure split column has no NAs to avoid logical errors
        if (!split_col_name %in% names(df_dt)) df_dt[[split_col_name]] <- "Unknown"
        df_dt[[split_col_name]][is.na(df_dt[[split_col_name]])] <- "Unknown"
        
        is_all <- !is.na(df_dt[[split_col_name]]) & df_dt[[split_col_name]] == "All"
        for (nm in c("Swing%","Whiff%","CSW%","GB%","K%","BB%")) {
          if (nm %in% names(df_dt)) {
            z <- df_dt[[nm]]
            z[is_all & (is.na(z) | trimws(as.character(z)) == "")] <- "0.0%"
            df_dt[[nm]] <- z
          }
        }
        
        # Visible set: Results vs Custom
        mode   <- input$dpMode
        if (is.null(mode)) mode <- "Results"
        custom <- input$dpCustomCols; if (is.null(custom)) custom <- character(0)
        base_cols <- c(split_col_name,"PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
                       "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
        # Replace "Pitch" with split_col_name in custom if present
        if ("Pitch" %in% custom && split_col_name != "Pitch") {
          custom <- c(split_col_name, setdiff(custom, "Pitch"))
        }
        visible_set <- if (identical(mode, "Custom")) unique(c(split_col_name, custom)) else base_cols
        
        # Ensure visible_set only contains valid column names
        valid_visible <- intersect(visible_set, names(df_dt))
        if (!length(valid_visible)) valid_visible <- split_col_name
        
        datatable_with_colvis(
          df_dt,
          lock            = split_col_name,
          remember        = FALSE,
          default_visible = valid_visible,
          mode            = NULL,
          enable_colors   = FALSE  # Disable colors for hitting suite
        )
      }, error = function(e) {
        # Provide detailed error information for debugging
        error_msg <- conditionMessage(e)
        error_details <- paste(
          "Detailed error in Hitting dpTable:",
          "Error:", error_msg,
          "Call stack available in R console",
          sep = "\n"
        )
        
        # Log the full error for debugging
        cat("Hitting dpTable error:\n")
        cat("Message:", error_msg, "\n")
        cat("Traceback:\n")
        traceback()
        
        DT::datatable(
          data.frame(
            Error_Type = "Table Generation Error",
            Error_Message = error_msg,
            Suggestion = "Check console for full error details"
          ),
          options = list(dom = 't'), rownames = FALSE
        )
      })
    }, server = FALSE)
  })
}


# =============================
# 0) DATA HOOKS (top-level)
#    • Add "Catcher" to need_cols
#    • Coerce to character like other columns
#    • Build catcher_map (display names)
# =============================

# --- A) need_cols: add Catcher ---
# Find your existing need_cols <- c(...). Add "Catcher" at the end:
#   "Batter", "Catcher"   # ← add this

# --- B) After the for(nm in need_cols) loop and before force_pitch_levels(),
# in the big mutate(...) where you coerce types, add:
#   Catcher         = as.character(Catcher),

# --- C) Build catcher_map (just after batter_map is created) ---
raw_catchers <- sort(unique(na.omit(as.character(pitch_data$Catcher))))
catch_display <- ifelse(
  grepl(",", raw_catchers),
  vapply(strsplit(raw_catchers, ",\\s*"), function(x) paste(x[2], x[1]), ""),
  raw_catchers
)
catcher_map <- setNames(raw_catchers, catch_display)


# ==================================
# 1) CATCHING UI MODULE (replace stub)
# ==================================
mod_catch_ui <- function(id, show_header = FALSE) {
  ns <- NS(id)
  shiny::fluidPage(
    if (isTRUE(show_header)) {
      fluidRow(
        class = "suite-header",
        column(2, tags$img(src = "PCUlogo.png", height = "100px")),
        column(
          8,
          div(
            style = "height:100%; display:flex; justify-content:center; align-items:flex-start;",
            tags$h1("Catching Dashboard", style = "margin-top:25px; font-weight:bold;")
          )
        ),
        column(
          2,
          div(style = "text-align:right; margin-top:10px;",
              tags$img(src = school_logo, height = "80px", alt = school_display_name))
        )
      )
    },
    sidebarLayout(
      sidebarPanel(
        # Exact same main sidebar as Pitching, but with Catcher selector
        selectInput(ns("sessionType"), "Session Type:", choices = c("All","Bullpen","Live"), selected = "All"),
        selectInput(ns("catcher"), "Select Catcher:", choices = c("All" = "All", catcher_map), selected = "All"),
        selectInput(
          ns("teamType"), "Team:",
          choices = TEAM_CHOICES,
          selected = "All"
        ),
        dateRangeInput(ns("dates"), "Date Range:",
                       start = max(pitch_data$Date, na.rm = TRUE),
                       end   = max(pitch_data$Date, na.rm = TRUE),
                       format = "mm/dd/yyyy"),
        selectInput(ns("hand"), "Pitcher Hand:", choices = c("All","Left","Right"), selected = "All"),
        selectInput(ns("pitchType"), "Pitch Type:",
                    choices = c("All", levels(pitch_data$TaggedPitchType)), selected = "All", multiple = TRUE),
        selectInput(
          ns("zoneLoc"), "Zone Location:",
          choices = c("All",
                      "Upper Half","Bottom Half","Left Half","Right Half",
                      "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
          selected = "All",
          multiple = TRUE
        ),
        selectInput(ns("inZone"), "In Zone:", choices = c("All","Yes","No","Competitive"), selected = "All"),
        selectInput(ns("batterSide"), "Batter Hand:", choices = c("All","Left","Right"), selected = "All"),
        selectInput(
          ns("countFilter"), "Count:",
          choices = c("All"="All","Even"="Even","Behind"="Behind","Ahead"="Ahead","2K Not Full"="2KNF",
                      "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
          selected = "All", multiple = TRUE
        ),
        selectInput(ns("breakLines"), "Break Lines:", choices = c("None","Fastball","Sinker"), selected = "None"),
        selectInput(ns("stuffLevel"), "Stuff+ Level:", choices = c("Pro","College","High School"), selected = "College"),
        selectInput(ns("stuffBase"),  "Stuff+ Base Pitch:", choices = c("Fastball","Sinker"), selected = "Fastball"),
        fluidRow(column(6, numericInput(ns("veloMin"), "Velocity Min (MPH):", value = NA)),
                 column(6, numericInput(ns("veloMax"), "Velocity Max (MPH):", value = NA))),
        fluidRow(column(6, numericInput(ns("ivbMin"), "IVB Min (inches):", value = NA)),
                 column(6, numericInput(ns("ivbMax"), "IVB Max (inches):", value = NA))),
        fluidRow(column(6, numericInput(ns("hbMin"), "HB Min (inches):", value = NA)),
                 column(6, numericInput(ns("hbMax"), "HB Max (inches):", value = NA))),
        fluidRow(column(6, numericInput(ns("pcMin"), "Pitch Count Min:", value = NA, min = 1)),
                 column(6, numericInput(ns("pcMax"), "Pitch Count Max:", value = NA, min = 1))),
        width = 3,
        class = "sidebar"
      ),
      mainPanel(
        tabsetPanel(
          id = ns("tabs"),
          tabPanel(
            "Data and Performance",
            div(style = "margin: 8px 0;", uiOutput(ns("dpButtons"))),
            DT::dataTableOutput(ns("dpTable"))
          ),
          # ---- Catching: Location page (UI) ----
          tabPanel(
            "Location",
            fluidRow(
              column(
                3,
                selectInput(ns("loc_targetBase"), "Target Base:", c("2B","3B","1B"), selected = "2B"),
                selectInput(ns("loc_units"), "Units:", c("auto","feet","inches","meters"), selected = "auto"),
                sliderInput(ns("loc_zoom"), "Zoom (half-width, ft):", min = 2, max = 12, value = 6, step = 0.5),
                helpText("Only rows with PopTime and ThrowSpeed ≥ 70 mph are counted as throws.")
              ),
              column(
                9,
                tabsetPanel(
                  id = ns("loc_tabs"),
                  tabPanel("Top-down", ggiraph::girafeOutput(ns("loc_topdown"), height = "420px"),
                           verbatimTextOutput(ns("loc_td_summary"))),
                  tabPanel("3D",       plotly::plotlyOutput(ns("loc_3d"), height = "520px"))
                )
              )
            )
          ),
          tabPanel(
            "HeatMaps",
            sidebarLayout(
              sidebarPanel(
                selectInput(ns("hmChartType"), "Select Chart:", choices = c("Heat","Pitch"), selected = "Heat"),
                
                # NEW: server-driven multi-select for results (so choices load safely)
                uiOutput(ns("hmResultsUI")),
                
                uiOutput(ns("hmNote")),
                width = 3
              ),
              mainPanel(
                div(style = "background: transparent !important;",
                    conditionalPanel(sprintf("input['%s']=='Heat'", ns("hmChartType")),
                                     plotOutput(ns("heatPlot"), height = "500px")),
                    conditionalPanel(sprintf("input['%s']=='Pitch'", ns("hmChartType")),
                                     ggiraph::girafeOutput(ns("pitchPlot"), height = "500px"))
                )
              )
            )
          )
        )
      )
    )
  )
}


# =====================================
# 2) CATCHING SERVER MODULE (replace stub)
# =====================================
mod_catch_server <- function(id, is_active = shiny::reactive(TRUE), global_date_range = NULL) {
  moduleServer(id, function(input, output, session) {
    
    # Sync local date input with global date range
    if (!is.null(global_date_range)) {
      observe({
        if (!is.null(global_date_range()) && length(global_date_range()) == 2) {
          updateDateRangeInput(session, "dates", 
                               start = global_date_range()[1], 
                               end = global_date_range()[2])
        }
      })
      
      # Update global date range when local input changes
      observeEvent(input$dates, {
        if (!is.null(input$dates) && length(input$dates) == 2) {
          global_date_range(input$dates)
        }
      })
    }
    ns <- session$ns
    
    MIN_THROW_MPH <- 70  # only count throws at/above this speed
    
    output$hmResultsUI <- renderUI({
      # Prefer global result_levels; fall back to what’s present in the filtered data
      ch <- if (exists("result_levels")) {
        result_levels
      } else {
        df0 <- filtered_catch()
        sort(unique(na.omit(as.character(df0$Result))))
      }
      if (length(ch) == 0) ch <- character(0)
      
      selectizeInput(
        session$ns("hmResults"),
        "Pitch Results:",
        choices  = ch,
        selected = ch,
        multiple = TRUE,
        options  = list(plugins = list("remove_button"))
      )
    })
    
    # ---- Default date to last live/game/AB (one-time on load) ----
    .local_once_set <- reactiveVal(FALSE)
    observeEvent(filtered_catch(), {
      if (isTRUE(.local_once_set())) return()
      df <- filtered_catch(); if (!nrow(df)) return()
      
      st <- tolower(trimws(as.character(df$SessionType)))
      live_mask <- grepl("live|game|ab", st)
      
      # Parse dates robustly
      parse_date_safely <- function(x) {
        if (inherits(x, "Date")) return(x)
        d <- suppressWarnings(as.Date(x))
        if (all(is.na(d))) {
          d <- suppressWarnings(lubridate::ymd(x))
          if (all(is.na(d))) d <- suppressWarnings(lubridate::mdy(x))
        }
        as.Date(d)
      }
      d <- parse_date_safely(df$Date)
      
      if (any(live_mask & !is.na(d))) {
        last_dt <- max(d[live_mask], na.rm = TRUE)
        updateDateRangeInput(session, "dateRange", start = last_dt, end = last_dt)
        .local_once_set(TRUE)  # prevent re-trigger loops
      }
    }, ignoreInit = FALSE)  # <— run on initial load
    
    
    # Flatten any list columns before sending to DT
    collapse_list_cols <- function(dat) {
      if (!nrow(dat)) return(dat)
      dat %>%
        dplyr::mutate(dplyr::across(
          dplyr::where(is.list),
          ~ vapply(., function(x) {
            if (is.null(x)) "" else if (length(x) == 1 && !is.list(x)) as.character(x)
            else paste0(unlist(x), collapse = ", ")
          }, character(1))
        ))
    }
    
    # Keep count filter tidy
    observeEvent(input$countFilter, {
      sel <- input$countFilter
      if (is.null(sel) || !length(sel)) {
        updateSelectInput(session, "countFilter", selected = "All")
      } else if ("All" %in% sel && length(sel) > 1) {
        updateSelectInput(session, "countFilter", selected = setdiff(sel, "All"))
      }
    }, ignoreInit = TRUE)
    
    # Default dates to last date for selected catcher (or global last)
    observeEvent(input$catcher, {
      req(is_active())
      last_date <- if (isTRUE(input$catcher == "All")) {
        max(pitch_data$Date, na.rm = TRUE)
      } else {
        mx <- max(pitch_data$Date[pitch_data$Catcher == input$catcher], na.rm = TRUE)
        if (is.finite(mx)) mx else max(pitch_data$Date, na.rm = TRUE)
      }
      if (is.finite(last_date)) {
        updateDateRangeInput(session, "dates", start = last_date, end = last_date)
      }
    }, ignoreInit = TRUE)
    
    # Filtered data for Catching
    filtered_catch <- reactive({
      req(is_active(), input$teamType)
      
      # helpers
      is_valid_dates <- function(d) !is.null(d) && length(d) == 2 && all(is.finite(d))
      nnz <- function(x) !is.null(x) && !is.na(x)
      
      # Guard: if dates are mid-update, return empty quickly
      if (!is_valid_dates(input$dates)) return(pitch_data[0, , drop = FALSE])
      
      pitch_types <- if (is.null(input$pitchType)) "All" else input$pitchType
      
      # Session type first
      df <- if (identical(input$sessionType, "All")) pitch_data
      else dplyr::filter(pitch_data, SessionType == input$sessionType)
      
      # ⛔️ Team filtering - Filter by team selection ⛔️
      if (!is.null(input$teamType)) {
        all_osu_and_campers <- unique(c(ALLOWED_PITCHERS, ALLOWED_CAMPERS))
        
        if (input$teamType == "Campers") {
          # Filter to only allowed campers (as pitchers)
          df <- dplyr::filter(df, Pitcher %in% ALLOWED_CAMPERS)
        } else if (input$teamType == TEAM_CODE) {
          # Filter to GCU allowed pitchers
          df <- dplyr::filter(df, Pitcher %in% ALLOWED_PITCHERS)
        } else if (input$teamType == "Opponents") {
          # Show only opponent pitchers (anyone NOT in GCU or Campers lists)
          df <- dplyr::filter(df, !(Pitcher %in% all_osu_and_campers))
        }
        # If "All" is selected, don't filter - show all data
      }
      
      # ⛔️ Drop warmups & blank pitch types
      if ("TaggedPitchType" %in% names(df)) {
        df <- df %>%
          dplyr::mutate(.tpt = trimws(as.character(TaggedPitchType))) %>%
          dplyr::filter(!is.na(.tpt) & nzchar(.tpt)) %>%
          dplyr::select(-.tpt)
      }
      if ("PitchSession" %in% names(df)) {
        df <- dplyr::filter(df, is.na(PitchSession) | PitchSession != "Warmup")
      }
      
      # Catcher filter
      cat_pick <- input$catcher
      if (!is.null(cat_pick) && cat_pick != "All") {
        df <- dplyr::filter(df, Catcher == cat_pick)
      }
      
      
      # Date range
      df <- dplyr::filter(df, Date >= input$dates[1], Date <= input$dates[2])
      
      # Pitcher hand
      if (input$hand != "All") df <- dplyr::filter(df, PitcherThrows == input$hand)
      
      # NEW: Opponent Hitter filter (for pitching suite)
      if (!is.null(input$oppHitter) && input$oppHitter != "All") {
        df <- dplyr::filter(df, Batter == input$oppHitter)
      }
      
      # Batter side (Live only)
      if (!is.null(input$batterSide) && input$batterSide != "All") {
        df <- df %>% dplyr::filter(SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide))
      }
      
      # Spatial & count filters
      df <- enforce_zone(df, input$zoneLoc)
      df <- enforce_inzone(df, input$inZone)
      df <- filter_qp_locations(df, input$qpLocations)
      df <- apply_count_filter(df, input$countFilter)
      df <- apply_after_count_filter(df, input$afterCountFilter)
      df <- apply_pitch_results_filter(df, input$pitchResults)
      df <- apply_after_count_filter(df, input$afterCountFilter)
      df <- apply_pitch_results_filter(df, input$pitchResults)
      df <- apply_pitch_results_filter(df, input$pitchResults)
      
      # Numeric ranges
      if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed >= input$veloMin)
      if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed <= input$veloMax)
      if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
      if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
      if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak >= input$hbMin)
      if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak <= input$hbMax)
      
      # Pitch number window
      df <- df %>% dplyr::arrange(Date) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
      if (nnz(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
      if (nnz(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
      
      # Stuff+ calc
      df2 <- compute_stuff_simple(df, base_type = input$stuffBase, level = input$stuffLevel) %>%
        force_pitch_levels() %>%
        dplyr::mutate(Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels))
      
      # Pitch types (post-derive)
      if (!("All" %in% pitch_types)) df2 <- dplyr::filter(df2, TaggedPitchType %in% pitch_types)
      
      df2
    })
    
    # ---- Catching: Data/Custom controls ----
    output$dpButtons <- renderUI({
      sel <- isolate(input$dpMode); if (is.null(sel)) sel <- "Data"
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("dpMode"), label = NULL,
                            choices = c("Data","Custom"),
                            selected = sel, width = "100px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("dpColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']==='Custom'", ns("dpMode")),
          selectizeInput(
            ns("dpCustomCols"), label = NULL,
            choices = c("#","Velo","ExchangeTime","PopTime","SL+"),  # <— added "#"
            multiple = TRUE,
            options = list(placeholder = "Choose columns to show…")
          )
        )
      )
    })
    
    
    # ---- Catching: Data/Custom table (PopTime-gated throws; ALL last) ----
    output$dpTable <- DT::renderDataTable({
      req(is_active())
      df_all <- filtered_catch()
      if (!nrow(df_all)) {
        return(DT::datatable(data.frame(Note = "No rows for current filters."),
                             options = list(dom = 't'), rownames = FALSE))
      }
      
      to_num <- function(x) suppressWarnings(as.numeric(x))
      
      # ---------- SL+ on TAKES from the full dataset ----------
      # Safe logical operations for takes calculation
      takes <- tryCatch({
        pitch_call_safe <- as.character(df_all$PitchCall)
        (!is.na(pitch_call_safe)) & (pitch_call_safe %in% c("StrikeCalled","BallCalled", "BallinDirt"))
      }, error = function(e) {
        rep(FALSE, nrow(df_all))
      })
      buckets <- inzone_label(df_all$PlateLocSide, df_all$PlateLocHeight)
      
      base_tbl <- dplyr::tibble(
        take   = takes,
        bucket = buckets,
        is_cs  = tryCatch({
          pitch_call_safe <- as.character(df_all$PitchCall)
          pitch_call_safe == "StrikeCalled"
        }, error = function(e) rep(FALSE, nrow(df_all)))
      ) %>%
        dplyr::filter(take) %>%
        dplyr::group_by(bucket) %>%
        dplyr::summarise(cs_rate = mean(is_cs, na.rm = TRUE), n = dplyr::n(), .groups = "drop")
      
      overall_rate <- if (nrow(base_tbl) && sum(base_tbl$n) > 0) {
        sum(base_tbl$cs_rate * base_tbl$n) / sum(base_tbl$n)
      } else NA_real_
      
      rate_for_bucket <- function(b) {
        r <- base_tbl$cs_rate[match(b, base_tbl$bucket)]
        ifelse(is.na(r), overall_rate, r)
      }
      
      sl_by_pitch <- df_all %>%
        dplyr::mutate(
          Pitch  = as.character(TaggedPitchType),
          take   = takes,
          bucket = buckets
        ) %>%
        dplyr::group_by(Pitch) %>%
        dplyr::summarise(
          `SL+` = {
            any_take <- tryCatch(any(take, na.rm = TRUE), error = function(e) FALSE)
            if (!any_take) {
              NA_real_
            } else {
              # Safe comparison for PitchCall
              pitch_call_subset <- tryCatch({
                as.character(PitchCall[take])
              }, error = function(e) character(0))
              
              obs <- if (length(pitch_call_subset) > 0) {
                mean(pitch_call_subset == "StrikeCalled", na.rm = TRUE)
              } else {
                NA_real_
              }
              
              tb  <- table(bucket[take])
              if (length(tb)) {
                exp <- sum(as.numeric(tb) * vapply(names(tb), rate_for_bucket, numeric(1))) / sum(tb)
                exp_check <- tryCatch(is.finite(exp) && exp > 0, error = function(e) FALSE)
                if (exp_check) round(100 * obs / exp, 1) else NA_real_
              } else NA_real_
            }
          },
          .groups = "drop"
        )
      
      # ---------- Define "throws" as rows WITH PopTime present ----------
      df_throw <- df_all %>%
        dplyr::mutate(
          Pitch            = as.character(TaggedPitchType),
          ThrowSpeed_num   = to_num(ThrowSpeed),
          ExchangeTime_num = to_num(ExchangeTime),
          PopTime_num      = to_num(PopTime)
        ) %>%
        dplyr::filter(
          is.finite(PopTime_num),
          is.finite(ThrowSpeed_num),
          ThrowSpeed_num >= MIN_THROW_MPH   # or use 70 directly
        )
      
      # Per-pitch stats + count of throws (“#”) over PopTime-present rows
      stats_throw <- if (nrow(df_throw)) {
        df_throw %>%
          dplyr::group_by(Pitch) %>%
          dplyr::summarise(
            `#`           = dplyr::n(),                                # <-- throws counted by PopTime presence
            Velo          = round(mean(ThrowSpeed_num,   na.rm = TRUE), 1),  # may be NA if no ThrowSpeed for that pitch
            ExchangeTime  = round(mean(ExchangeTime_num, na.rm = TRUE), 1),
            PopTime       = round(mean(PopTime_num,      na.rm = TRUE), 2),
            .groups = "drop"
          )
      } else {
        dplyr::tibble(Pitch = character(), `#` = integer(),
                      Velo = numeric(), ExchangeTime = numeric(), PopTime = numeric())
      }
      
      # ---------- Join SL+ and order pitches ----------
      out <- stats_throw %>%
        dplyr::left_join(sl_by_pitch, by = "Pitch")
      
      # robust pitch ordering (works with your helpers)
      safe_pitch_order <- function(v) {
        v_chr <- as.character(v)
        if (exists("ordered_types")) {
          ord_try <- tryCatch({
            o <- ordered_types(v_chr)
            if (is.factor(o)) levels(o) else unique(as.character(o))
          }, error = function(e) NULL)
          if (length(ord_try)) return(ord_try)
        }
        if (exists("force_pitch_levels")) {
          ord_try2 <- tryCatch({
            tmp <- data.frame(TaggedPitchType = v_chr, stringsAsFactors = FALSE)
            o <- force_pitch_levels(tmp)
            if ("TaggedPitchType" %in% names(o)) {
              if (is.factor(o$TaggedPitchType)) levels(o$TaggedPitchType)
              else unique(as.character(o$TaggedPitchType))
            } else NULL
          }, error = function(e) NULL)
          if (length(ord_try2)) return(ord_try2)
        }
        unique(na.omit(v_chr))
      }
      ord <- safe_pitch_order(df_all$TaggedPitchType)
      
      out <- out %>%
        dplyr::mutate(Pitch = factor(Pitch, levels = ord)) %>%
        dplyr::arrange(Pitch) %>%
        dplyr::mutate(Pitch = as.character(Pitch))
      
      # ---------- ALL row LAST (totals also over PopTime-present rows) ----------
      total_throws <- nrow(df_throw)  # <-- total PopTime-present throws
      all_velo <- if (total_throws) round(mean(df_throw$ThrowSpeed_num,   na.rm = TRUE), 1) else NA_real_
      all_xch  <- if (total_throws) round(mean(df_throw$ExchangeTime_num, na.rm = TRUE), 1) else NA_real_
      all_pop  <- if (total_throws) round(mean(df_throw$PopTime_num,      na.rm = TRUE), 2) else NA_real_
      obs_all  <- tryCatch({
        any_takes <- tryCatch(any(takes, na.rm = TRUE), error = function(e) FALSE)
        if (any_takes) {
          pitch_call_takes <- as.character(df_all$PitchCall[takes])
          if (length(pitch_call_takes) > 0) {
            mean(pitch_call_takes == "StrikeCalled", na.rm = TRUE)
          } else {
            NA_real_
          }
        } else {
          NA_real_
        }
      }, error = function(e) NA_real_)
      exp_all  <- overall_rate
      sl_all   <- tryCatch({
        if (is.finite(obs_all) && is.finite(exp_all) && exp_all > 0) {
          round(100 * obs_all / exp_all, 1)
        } else {
          NA_real_
        }
      }, error = function(e) NA_real_)
      
      all_row <- dplyr::tibble(Pitch = "ALL", `#` = total_throws,
                               Velo = all_velo, ExchangeTime = all_xch, PopTime = all_pop, `SL+` = sl_all)
      
      final <- dplyr::bind_rows(out, all_row)  # ALL last
      
      # ---------- Visible set based on mode ----------
      mode <- if (is.null(input$dpMode)) "Data" else input$dpMode
      default_visible <- if (identical(mode, "Custom")) {
        unique(c("Pitch", "#", input$dpCustomCols))
      } else {
        c("Pitch","#","Velo","ExchangeTime","PopTime","SL+")
      }
      
      datatable_with_colvis(
        final,
        lock            = "Pitch",
        remember        = TRUE,
        default_visible = default_visible
      )
    }, server = FALSE)
    
    # =========================
    # Catching: Location server
    # =========================
    
    # ---- tiny helpers (scoped to this module) ----
    loc_to_num <- function(x) suppressWarnings(as.numeric(x))
    loc_convert_to_feet <- function(x, mode = "auto") {
      x <- as.numeric(x)
      if (mode == "feet")   return(x)
      if (mode == "inches") return(x/12)
      if (mode == "meters") return(x*3.28084)
      p95 <- suppressWarnings(stats::quantile(abs(x), 0.95, na.rm = TRUE))
      if (is.na(p95)) return(x)
      if (p95 > 20)       x/12      else if (p95 < 2) x*3.28084 else x
    }
    loc_guess_cols_xy  <- function(df) {
      nms <- names(df)
      pick <- function(...) { pats <- c(...); for (p in pats) { hit <- nms[grepl(p, nms, ignore.case=TRUE)]; if (length(hit)) return(hit[1]) }; "" }
      list(
        x  = pick("BasePositionX","BagX","ThrowEndX","ArrivalX","BaseX"),
        y  = pick("BasePositionY","BagY","ThrowEndY","ArrivalY","BaseY"),
        cx = pick("SecondBaseX","BagCenterX","BaseCenterX","TargetBaseX"),
        cy = pick("SecondBaseY","BagCenterY","BaseCenterY","TargetBaseY")
      )
    }
    loc_guess_cols_xyz <- function(df) {
      nms <- names(df)
      pick <- function(...) { pats <- c(...); for (p in pats) { hit <- nms[grepl(p, nms, ignore.case=TRUE)]; if (length(hit)) return(hit[1]) }; "" }
      list(
        x  = pick("BasePositionX","BagX","ThrowEndX","ArrivalX","BaseX"),
        y  = pick("BasePositionY","BagY","ThrowEndY","ArrivalY","BaseY"),
        z  = pick("BasePositionZ","BagZ","ThrowEndZ","ArrivalZ","BaseZ","Height"),
        cx = pick("SecondBaseX","BagCenterX","BaseCenterX","TargetBaseX"),
        cy = pick("SecondBaseY","BagCenterY","BaseCenterY","TargetBaseY"),
        cz = pick("SecondBaseZ","BagCenterZ","BaseCenterZ","TargetBaseZ")
      )
    }
    loc_make_bag_poly <- function(size_in = 18) {
      sft <- size_in/12; r <- sft/sqrt(2)
      data.frame(x = c(0, r, 0, -r, 0), y = c(r, 0, -r, 0, r))
    }
    loc_inside_bag <- function(x, y, size_in = 18) {
      r <- (size_in/12)/sqrt(2); (abs(x)+abs(y)) <= r
    }
    
    # ---- common reactive: throws filtered to PopTime present & base selection ----
    loc_throws <- reactive({
      df <- filtered_catch()
      if (!nrow(df)) return(df[0, , drop=FALSE])
      
      # Only rows with PopTime AND ThrowSpeed ≥ 70 mph are considered throws
      df$PopTime_num     <- loc_to_num(df$PopTime)
      df$ThrowSpeed_num  <- loc_to_num(df$ThrowSpeed)
      df <- df[
        is.finite(df$PopTime_num) &
          is.finite(df$ThrowSpeed_num) &
          df$ThrowSpeed_num >= (if (exists("MIN_THROW_MPH")) MIN_THROW_MPH else 70),
        ,
        drop = FALSE
      ]
      if (!nrow(df)) return(df)
      
      tgt <- if (is.null(input$loc_targetBase)) "2B" else input$loc_targetBase
      if ("TargetBase" %in% names(df)) {
        df <- df[as.character(df$TargetBase) == tgt, , drop = FALSE]
      }
      df
    })
    
    
    # ---- TOP-DOWN (2D) ----
    output$loc_topdown <- ggiraph::renderGirafe({
      req(is_active())
      df <- loc_throws(); if (!nrow(df)) return(NULL)
      
      gc <- loc_guess_cols_xy(df)
      if (!nzchar(gc$x) || !nzchar(gc$y)) {
        return(girafe_transparent(code = print(ggplot2::ggplot() +
                                                 ggplot2::annotate("text", x=0, y=0, label="No base-arrival X/Y columns found") +
                                                 ggplot2::theme_void())))
      }
      
      mode <- if (is.null(input$loc_units)) "auto" else input$loc_units
      x <- loc_convert_to_feet(loc_to_num(df[[gc$x]]), mode)
      y <- loc_convert_to_feet(loc_to_num(df[[gc$y]]), mode)
      
      # center to bag: prefer explicit bag center cols; else median-center
      if (nzchar(gc$cx) && nzchar(gc$cy)) {
        cx <- loc_convert_to_feet(loc_to_num(df[[gc$cx]]), mode)
        cy <- loc_convert_to_feet(loc_to_num(df[[gc$cy]]), mode)
        dx <- x - cx; dy <- y - cy
      } else {
        dx <- x - stats::median(x, na.rm = TRUE)
        dy <- y - stats::median(y, na.rm = TRUE)
      }
      
      bag <- loc_make_bag_poly(18)
      zoom <- if (is.null(input$loc_zoom)) 6 else input$loc_zoom
      
      tip <- paste0(
        "dx: ", sprintf("%.2f", dx), " ft\n",
        "dy: ", sprintf("%.2f", dy), " ft\n",
        "Pop: ", ifelse(is.na(df$PopTime), "", df$PopTime), "\n",
        "Velo: ", ifelse(is.na(df$ThrowSpeed), "", df$ThrowSpeed)
      )
      
      p <- ggplot2::ggplot() +
        ggplot2::geom_polygon(data = bag, ggplot2::aes(x, y), fill = NA, linewidth = 1) +
        ggplot2::annotate("point", x=0, y=0, shape=3, size=3) +
        ggplot2::geom_hline(yintercept = 0, linetype = 3) +
        ggplot2::geom_vline(xintercept = 0, linetype = 3) +
        ggiraph::geom_point_interactive(
          ggplot2::aes(dx, dy, tooltip = tip),
          data = data.frame(dx, dy, tip)
        ) +
        ggplot2::coord_fixed(xlim = c(-zoom, zoom), ylim = c(-zoom, zoom)) +
        ggplot2::labs(x = "Across-bag (ft)", y = "Up/down-bag (ft)",
                      title = paste("Throw Location (Top-down) →", if (is.null(input$loc_targetBase)) "2B" else input$loc_targetBase)) +
        ggplot2::theme_minimal() +
        transparent_bg_theme
      
      girafe_transparent(
        code = print(p),
        options = list(
          ggiraph::opts_hover(css = "opacity:0.9;"),
          ggiraph::opts_toolbar(saveaspng = TRUE)
        )
      )
    })
    
    output$loc_td_summary <- renderText({
      req(is_active())
      df <- loc_throws(); if (!nrow(df)) return("No throws with PopTime in current filters.")
      gc <- loc_guess_cols_xy(df); if (!nzchar(gc$x) || !nzchar(gc$y)) return("No base-arrival X/Y columns found.")
      
      mode <- if (is.null(input$loc_units)) "auto" else input$loc_units
      x <- loc_convert_to_feet(loc_to_num(df[[gc$x]]), mode)
      y <- loc_convert_to_feet(loc_to_num(df[[gc$y]]), mode)
      
      if (nzchar(gc$cx) && nzchar(gc$cy)) {
        cx <- loc_convert_to_feet(loc_to_num(df[[gc$cx]]), mode)
        cy <- loc_convert_to_feet(loc_to_num(df[[gc$cy]]), mode)
        dx <- x - cx; dy <- y - cy
      } else {
        dx <- x - stats::median(x, na.rm = TRUE)
        dy <- y - stats::median(y, na.rm = TRUE)
      }
      
      r <- sqrt(dx^2 + dy^2)
      pct_on <- mean(loc_inside_bag(dx, dy, size_in = 18), na.rm = TRUE)
      paste0(
        "# throws: ", length(r), "\n",
        "Avg miss radius: ", sprintf("%.2f", mean(r, na.rm = TRUE)), " ft\n",
        "68% radius: ",     sprintf("%.2f", stats::quantile(r, 0.68, na.rm = TRUE)), " ft\n",
        "% on bag: ",       sprintf("%.1f%%", 100*pct_on), "\n",
        "Bias (dx, dy): ",  sprintf("%.2f, %.2f", mean(dx, na.rm = TRUE), mean(dy, na.rm = TRUE)), " ft"
      )
    })
    
    # ---- 3D view ----
    output$loc_3d <- plotly::renderPlotly({
      req(is_active())
      df <- loc_throws(); if (!nrow(df)) return(NULL)
      
      gc <- loc_guess_cols_xyz(df)
      if (!nzchar(gc$x) || !nzchar(gc$y) || !nzchar(gc$z)) {
        return(plotly::plot_ly() |> plotly::add_text(x=0, y=0, text="No BasePosition X/Y/Z found"))
      }
      
      mode <- if (is.null(input$loc_units)) "auto" else input$loc_units
      x <- loc_convert_to_feet(loc_to_num(df[[gc$x]]), mode)
      y <- loc_convert_to_feet(loc_to_num(df[[gc$y]]), mode)
      z <- loc_convert_to_feet(loc_to_num(df[[gc$z]]), mode)
      
      if (nzchar(gc$cx) && nzchar(gc$cy)) {
        cx <- loc_convert_to_feet(loc_to_num(df[[gc$cx]]), mode)
        cy <- loc_convert_to_feet(loc_to_num(df[[gc$cy]]), mode)
      } else {
        cx <- stats::median(x, na.rm = TRUE)
        cy <- stats::median(y, na.rm = TRUE)
      }
      cz <- if (nzchar(gc$cz)) loc_convert_to_feet(loc_to_num(df[[gc$cz]]), mode) else 0
      
      dx <- x - cx; dy <- y - cy; dz <- z - cz
      r  <- sqrt(dx^2 + dy^2 + dz^2)
      
      # bag outline at z=0
      side_ft <- 18/12; rbag <- side_ft/sqrt(2)
      bag <- data.frame(x = c(0, rbag, 0, -rbag, 0), y = c(rbag, 0, -rbag, 0, rbag), z = 0)
      
      tip <- paste0(
        "dx=", sprintf("%.2f", dx)," ft<br>",
        "dy=", sprintf("%.2f", dy)," ft<br>",
        "dz=", sprintf("%.2f", dz)," ft<br>",
        "3D miss=", sprintf("%.2f", r)," ft<br>",
        "Pop=", ifelse(is.na(df$PopTime), "", df$PopTime), "<br>",
        "Velo=", ifelse(is.na(df$ThrowSpeed), "", df$ThrowSpeed)
      )
      
      zoom <- if (is.null(input$loc_zoom)) 6 else input$loc_zoom
      lim  <- c(-zoom, zoom)
      
      plotly::plot_ly() |>
        plotly::add_trace(type="scatter3d", mode="lines",
                          x=bag$x, y=bag$y, z=bag$z,
                          line = list(width = 6), hoverinfo="skip", name="Bag") |>
        plotly::add_markers(x = dx, y = dy, z = dz, type = "scatter3d", mode = "markers",
                            marker = list(size = 4, opacity = 0.8),
                            text = tip, hoverinfo = "text", name = "Throws") |>
        plotly::layout(
          scene = list(
            xaxis = list(title = "Across-bag (ft)", range = lim),
            yaxis = list(title = "Up/down-bag (ft)", range = lim),
            zaxis = list(title = "Height (ft)"),
            aspectmode = "cube",
            bgcolor = "rgba(0,0,0,0)"
          ),
          title = paste("Throw Location (3D) →", if (is.null(input$loc_targetBase)) "2B" else input$loc_targetBase),
          paper_bgcolor = "rgba(0,0,0,0)",
          plot_bgcolor = "rgba(0,0,0,0)"
        )
    })
    
    
    # ---- HeatMaps: note ----
    output$hmNote <- renderUI({
      HTML("<small><em>Heat shows Called-Strike% by location (per taken-pitch opportunity = called strike or called ball). Use the Pitch Results filter to include/exclude outcomes.</em></small>")
    })
    
    
    # --- NEW helpers for Heat surface (place inside mod_catch_server, above output$heatPlot) ---
    
    .safe_heat_cols <- function(n = 256) {
      if (exists("heat_pal_red")) {
        heat_pal_red(n)
      } else {
        grDevices::colorRampPalette(c("#ffffff", "#ffc0c0", "#ff6666", "#d7301f"))(n)
      }
    }
    
    # Fit a smooth Called-Strike% surface (per taken opportunity) and an alpha map for opportunity density
    .fit_cs_surface <- function(df_taken, lims = c(-2.5, 2.5, 0, 4.5), n = 180) {
      stopifnot(all(c("PlateLocSide","PlateLocHeight","PitchCall") %in% names(df_taken)))
      df_taken <- df_taken[is.finite(df_taken$PlateLocSide) & is.finite(df_taken$PlateLocHeight), , drop = FALSE]
      if (!nrow(df_taken)) return(NULL)
      df_taken$cs <- as.integer(df_taken$PitchCall == "StrikeCalled")
      
      grid <- expand.grid(
        x = seq(lims[1], lims[2], length.out = n),
        y = seq(lims[3], lims[4], length.out = n)
      )
      
      # Primary: smooth logistic surface with mgcv (best) ; Fallback: binned ratio with Beta prior
      p_hat <- NULL
      if (requireNamespace("mgcv", quietly = TRUE) &&
          length(unique(df_taken$cs)) > 1 && nrow(df_taken) >= 60) {
        m <- mgcv::gam(cs ~ s(PlateLocSide, PlateLocHeight, k = 60),
                       data = df_taken, family = stats::binomial(link = "logit"))
        p_hat <- stats::plogis(stats::predict(m, newdata = data.frame(
          PlateLocSide = grid$x, PlateLocHeight = grid$y
        )))
      } else {
        # Fallback: 2D binned CS% with prior shrinkage toward global rate
        nx <- 60; ny <- 60
        xbreaks <- seq(lims[1], lims[2], length.out = nx + 1)
        ybreaks <- seq(lims[3], lims[4], length.out = ny + 1)
        xi <- cut(df_taken$PlateLocSide, xbreaks, include.lowest = TRUE)
        yi <- cut(df_taken$PlateLocHeight, ybreaks, include.lowest = TRUE)
        opp  <- as.matrix(stats::xtabs(~ xi + yi))
        num  <- as.matrix(stats::xtabs(cs ~ xi + yi))
        p0   <- mean(df_taken$cs, na.rm = TRUE)
        alpha <- 20  # prior sample size
        p_bin <- (num + alpha * p0) / (opp + alpha)
        grid <- expand.grid(
          x = head(xbreaks, -1) + diff(xbreaks) / 2,
          y = head(ybreaks, -1) + diff(ybreaks) / 2
        )
        p_hat <- as.vector(p_bin)
      }
      
      # Opportunity alpha: denser regions more opaque (fade sparse)
      if (requireNamespace("MASS", quietly = TRUE)) {
        den <- MASS::kde2d(df_taken$PlateLocSide, df_taken$PlateLocHeight, n = n, lims = lims)$z
        den <- den / max(den, na.rm = TRUE)
        alpha <- pmax(0.25, as.vector(den))  # 0.25..1
      } else {
        alpha <- rep(1, length(p_hat))
      }
      
      data.frame(x = grid$x, y = grid$y, p = p_hat, a = alpha)
    }
    
    # ---- HeatMaps: Heat (Called-Strike% per opportunity) ----
    # ---- HeatMaps: Heat (Called-Strike% per taken opportunity, smooth; alpha = opportunity) ----
    output$heatPlot <- renderPlot({
      df <- filtered_catch(); if (!nrow(df)) return()
      # NEW: filter by selected pitch results (matches pitching suite behavior)
      res_sel <- input$hmResults
      if (!is.null(res_sel) && length(res_sel)) {
        df <- dplyr::filter(df, Result %in% res_sel)
      }
      
      
      # taken-pitch opportunities only (called strike/ball; include BID as "ball" opportunity)
      df_taken <- dplyr::filter(
        df,
        !is.na(PitchCall) & PitchCall %in% c("StrikeCalled","BallCalled","BallinDirt"),
        is.finite(PlateLocSide), is.finite(PlateLocHeight)
      )
      if (!nrow(df_taken) || length(unique(df_taken$PitchCall)) < 2) {
        return(ggplot() + theme_void() + labs(title = "Insufficient taken-pitch data"))
      }
      
      lims <- c(-2, 2, 0, 4.5); n <- 180
      surf <- .fit_cs_surface(df_taken, lims = lims, n = n)
      if (is.null(surf)) return(ggplot() + theme_void())
      
      # Overlays (same geometry you use elsewhere)
      home <- data.frame(x = c(-0.75,0.75,0.75,0.00,-0.75), y = c(1.05,1.05,1.15,1.25,1.15) - 0.5)
      cz   <- data.frame(xmin = -1.5, xmax =  1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz   <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      
      cols <- .safe_heat_cols(256)
      
      ggplot() +
        geom_raster(data = surf, aes(x, y, fill = p, alpha = a), interpolate = TRUE) +
        scale_fill_gradientn(colors = cols, limits = c(0, 1), name = "CS%") +
        scale_alpha(range = c(0.25, 1), guide = "none") +
        geom_polygon(data = home, aes(x, y), fill = NA, color = "black", linewidth = 0.6) +
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = "black", linetype = "dashed", linewidth = 0.6) +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = "black", linewidth = 0.8) +
        coord_fixed(ratio = 1, xlim = c(lims[1], lims[2]), ylim = c(lims[3], lims[4])) +
        labs(title = "Called-Strike%", x = NULL, y = NULL) +
        theme_void() +
        theme(plot.title = element_text(face = "bold", hjust = 0.5))
    }, bg = "transparent")
    
    
    # ---- HeatMaps: Pitch (interactive scatter) ----
    output$pitchPlot <- ggiraph::renderGirafe({
      req(input$hmChartType == "Pitch")
      df <- filtered_catch(); if (!nrow(df)) return(NULL)
      # NEW: filter by selected pitch results
      res_sel <- input$hmResults
      if (!is.null(res_sel) && length(res_sel)) {
        df <- dplyr::filter(df, Result %in% res_sel)
      }
      
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      types_chr <- as.character(types)
      
      df_i <- df %>% dplyr::mutate(tt = make_hover_tt(.), rid = dplyr::row_number(),
                                   Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels))
      
      home <- data.frame(x=c(-0.75,0.75,0.75,0.00,-0.75), y=c(1.05,1.05,1.15,1.25,1.15)-0.5)
      cz   <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz   <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      
      df_known <- dplyr::filter(df_i, !is.na(Result))
      df_other <- dplyr::filter(df_i,  is.na(Result))
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), fill = NA, color = "black") +
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = NA, color = "black", linetype = "dashed") +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = NA, color = "black") +
        ggiraph::geom_point_interactive(
          data = df_other,
          aes(PlateLocSide, PlateLocHeight, color = TaggedPitchType, fill = TaggedPitchType, tooltip = tt, data_id = rid),
          size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
        ) +
        ggiraph::geom_point_interactive(
          data = df_known,
          aes(PlateLocSide, PlateLocHeight, color = TaggedPitchType, fill = TaggedPitchType, shape = Result, tooltip = tt, data_id = rid),
          size = 4.0, alpha = 0.95, stroke = 0.8
        ) +
        scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
        scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
        scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
        coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
        theme_void() + theme(legend.position = "none")
      
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
  })  # <-- closes moduleServer(id, function(...) { ... })
}     # <-- closes mod_catch_server()

# ==========================
# == Leaderboard (new)    ==
# ==========================
mod_camps_ui <- function(id, show_header = FALSE) {
  ns <- NS(id)
  fluidPage(
    # No header (hidden to match other suites)
    sidebarLayout(
      sidebarPanel(
        # Same as Pitching suite, but no Session Type + label changed
        selectInput(ns("player"), "Select Player:", choices = c("All" = "All"), selected = "All"),
        dateRangeInput(ns("dates"), "Date Range:",
                       start = Sys.Date() - 30, end = Sys.Date(),
                       format = "mm/dd/yyyy"),
        selectInput(ns("hand"),       "Pitcher Hand:",  choices = c("All","Left","Right"), selected = "All"),
        selectInput(ns("pitchType"),  "Pitch Type:",    choices = "All", selected = "All", multiple = TRUE),
        selectInput(
          ns("zoneLoc"), "Zone Location:",
          choices = c("All",
                      "Upper Half","Bottom Half","Left Half","Right Half",
                      "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
          selected = "All", multiple = TRUE
        ),
        selectInput(ns("inZone"),     "In Zone:",       choices = c("All","Yes","No","Competitive"), selected = "All"),
        selectInput(ns("batterSide"), "Batter Hand:",   choices = c("All","Left","Right"), selected = "All"),
        selectInput(
          ns("countFilter"), "Count:",
          choices  = c("All"="All","Even"="Even","Behind"="Behind","Ahead"="Ahead","2K Not Full"="2KNF",
                       "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
          selected = "All", multiple = TRUE
        ),
        fluidRow(
          column(6, numericInput(ns("veloMin"), "Velocity Min (MPH):", value = NA)),
          column(6, numericInput(ns("veloMax"), "Velocity Max (MPH):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("ivbMin"), "IVB Min (inches):", value = NA)),
          column(6, numericInput(ns("ivbMax"), "IVB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("hbMin"), "HB Min (inches):", value = NA)),
          column(6, numericInput(ns("hbMax"), "HB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("pcMin"), "Pitch Count Min:", value = NA, min = 1)),
          column(6, numericInput(ns("pcMax"), "Pitch Count Max:", value = NA, min = 1))
        ),
        width = 3,
        class = "sidebar"
      ),
      mainPanel(
        tabsetPanel(
          id = ns("tabs"),
          
          # --- SUMMARY (Summary page layout) ---
          tabPanel(
            "Summary",
            uiOutput(ns("campSummaryHeader")), br(),
            fluidRow(
              column(
                4,
                div("Release",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px; text-align:center;"),
                ggiraph::girafeOutput(ns("campSummaryReleasePlot"), height = "300px", width = "100%")
              ),              
              column(
                4,
                div("Movement",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px; text-align:center;"),
                ggiraph::girafeOutput(ns("campSummaryMovementPlot"), height = "300px", width = "100%")
              ),
              column(
                4,
                div(
                  style = "text-align:center;",
                  div(
                    "Location",
                    style = "font-weight:bold; font-size:15px; margin-bottom:5px;"
                  ),
                  div(
                    style = "display:inline-block; width:80%;",
                    selectInput(
                      ns("campSummaryLocType"),
                      label    = NULL,
                      choices  = c("Pitch", "Heat"),
                      selected = "Pitch",
                      width    = "100%"
                    )
                  )
                ),
                conditionalPanel(
                  paste0("input['", ns("campSummaryLocType"), "']=='Pitch'"),
                  ggiraph::girafeOutput(ns("campSummaryZonePlot"), height = "300px", width = "100%")
                ),
                conditionalPanel(
                  paste0("input['", ns("campSummaryLocType"), "']=='Heat'"),
                  plotOutput(ns("campSummaryHeatZonePlot"), height = "300px")
                )
              )
            ),
            fluidRow(column(12, plotOutput(ns("campSummaryLegend"), height = "70px"))),
            br(),
            div(style = "margin: 8px 0;", uiOutput(ns("campSummaryTableButtons"))),
            DT::dataTableOutput(ns("campSummaryTablePage"))
          ),
          
          # --- HITTING (Data & Performance) ---
          tabPanel(
            "Hitting",
            div(style = "margin: 8px 0;", uiOutput(ns("campHitButtons"))),
            div(style = "margin: 8px 0;", ggiraph::girafeOutput(ns("campSprayChart"), height = "460px")),
            DT::dataTableOutput(ns("campHitTable"))
          ),
          
          # --- CATCHING (Data & Performance) ---
          tabPanel(
            "Catching",
            div(style = "margin: 8px 0;", uiOutput(ns("campCatchButtons"))),
            DT::dataTableOutput(ns("campCatchTable"))
          )
        )
      )
    )
  )
}

mod_camps_server <- function(id, is_active = shiny::reactive(TRUE)) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    dp_like_table_fn <- tryCatch(get(".dp_like_table", envir = .GlobalEnv), error = function(...) NULL)
    
    # ---------------------------
    # Load allowed campers configuration
    # ---------------------------
    load_allowed_campers <- function() {
      # Return hardcoded list of allowed campers
      return(ALLOWED_CAMPERS)
    }
    
    # ---------------------------
    # Camps data hooks (Camps-only)
    # ---------------------------
    get_camps_pitching <- function() {
      # Use the unfiltered main dataset (pitch_data) for camps to be independent of ALLOWED_PITCHERS
      if (exists("pitch_data", inherits = TRUE)) return(get("pitch_data", inherits = TRUE))
      if (exists("load_camps_pitching", inherits = TRUE)) return(get("load_camps_pitching", inherits = TRUE)())
      data.frame(Date = as.Date(character()),
                 Pitcher = character(), PitcherThrows = character(),
                 TaggedPitchType = factor(character()),
                 PlateLocSide = numeric(), PlateLocHeight = numeric(),
                 RelSpeed = numeric(), InducedVertBreak = numeric(), HorzBreak = numeric(),
                 ReleaseTilt = numeric(), BreakTilt = numeric(),
                 SpinEfficiency = numeric(), SpinRate = numeric(),
                 RelHeight = numeric(), RelSide = numeric(),
                 VertApprAngle = numeric(), HorzApprAngle = numeric(),
                 Extension = numeric(), Balls = integer(), Strikes = integer(),
                 SessionType = character(), PitchCall = character(),
                 ExitSpeed = numeric(), Angle = numeric(),
                 KorBB = character(), PlayResult = character(),
                 stringsAsFactors = FALSE)
    }
    get_camps_all <- function() {
      # Use the main dataset (pitch_data)
      if (exists("pitch_data", inherits = TRUE)) return(get("pitch_data", inherits = TRUE))
      if (exists("load_camps_all", inherits = TRUE)) return(get("load_camps_all", inherits = TRUE)())
      data.frame(Date = as.Date(character()),
                 Pitcher = character(), Batter = character(), Catcher = character(),
                 PitcherThrows = character(), BatterSide = character(),
                 TaggedPitchType = factor(character()),
                 PlateLocSide = numeric(), PlateLocHeight = numeric(),
                 RelSpeed = numeric(), InducedVertBreak = numeric(), HorzBreak = numeric(),
                 ReleaseTilt = numeric(), BreakTilt = numeric(),
                 SpinEfficiency = numeric(), SpinRate = numeric(),
                 RelHeight = numeric(), RelSide = numeric(),
                 VertApprAngle = numeric(), HorzApprAngle = numeric(),
                 Extension = numeric(), Balls = integer(), Strikes = integer(),
                 SessionType = character(), PitchCall = character(),
                 ExitSpeed = numeric(), Angle = numeric(), Distance = numeric(), Direction = numeric(),
                 KorBB = character(), PlayResult = character(),
                 stringsAsFactors = FALSE)
    }
    
    # ---------------------------
    # Helpers
    # ---------------------------
    as_date_any <- function(x) {
      if (inherits(x, "Date")) return(x)
      if (inherits(x, c("POSIXct","POSIXt"))) return(as.Date(x))
      x_chr <- as.character(x)
      suppressWarnings(
        as.Date(x_chr, tryFormats = c("%Y-%m-%d", "%m/%d/%Y", "%m/%d/%y"))
      )
    }
    nnz <- function(x) !is.null(x) && !is.na(x)
    nz_mean <- function(x) { x <- suppressWarnings(as.numeric(x)); m <- mean(x, na.rm = TRUE); if (is.finite(m)) m else NA_real_ }
    safe_div <- function(a,b) { a <- suppressWarnings(as.numeric(a)); b <- suppressWarnings(as.numeric(b)); ifelse(is.finite(b) & b != 0 & is.finite(a), a/b, NA_real_) }
    fmt_rate3 <- function(x) { x <- suppressWarnings(as.numeric(x)); s <- ifelse(is.finite(x), sprintf("%.3f", x), ""); sub("^0\\.", ".", s) }
    parse_num <- function(x) {
      if (is.numeric(x)) return(x)
      sx <- trimws(as.character(x)); sx[sx==""] <- NA_character_
      is_pct <- grepl("%", sx)
      val <- suppressWarnings(as.numeric(gsub("[^0-9eE.+-]", "", sx)))
      val[is_pct] <- val[is_pct] / 100
      val
    }
    
    # ---------------------------
    # Load & normalize Camps data (filtered by allowed campers)
    # ---------------------------
    camps_pitching <- shiny::reactive({
      d <- get_camps_pitching()
      d$Date <- as_date_any(d$Date)
      
      # TEMPORARY: Disable filtering to test
      # allowed_campers <- load_allowed_campers()
      # if (length(allowed_campers) > 0) {
      #   d <- d[d$Pitcher %in% allowed_campers, ]
      # }
      
      d
    })
    camps_all <- shiny::reactive({
      d <- get_camps_all()
      d$Date <- as_date_any(d$Date)
      
      # TEMPORARY: Disable filtering to test
      # allowed_campers <- load_allowed_campers()
      # if (length(allowed_campers) > 0) {
      #   d <- d[d$Pitcher %in% allowed_campers, ]
      # }
      
      d
    })
    
    # ---------------------------
    # Populate sidebar choices from Camps datasets
    # ---------------------------
    observe({
      req(is_active())
      # Player choices (TEMPORARY: show all players for testing)
      d <- camps_all()
      
      # TEMPORARY: Disable allowed campers filtering
      # allowed_campers <- load_allowed_campers()
      # if (length(allowed_campers) > 0) {
      #   # Use allowed campers list
      #   player_choices <- c("All" = "All", setNames(allowed_campers, allowed_campers))
      # } else {
      # Show all players in data for testing
      all_players <- unique(d$Pitcher)
      all_players <- all_players[!is.na(all_players) & nzchar(all_players)]
      player_choices <- c("All" = "All", setNames(all_players, all_players))
      # }
      
      updateSelectInput(session, "player", choices = player_choices)
      
      # Pitch types (from Camps)
      lv <- levels(d$TaggedPitchType)
      pt_levels <- if (is.null(lv)) unique(as.character(d$TaggedPitchType)) else lv
      updateSelectInput(session, "pitchType",
                        choices = c("All", pt_levels),
                        selected = "All")
    })
    
    observe({
      req(is_active())
      # Date range bounds reflect Camps-only data; robust to POSIX/char
      d1 <- camps_pitching(); d2 <- camps_all()
      all_dates <- c(as_date_any(d1$Date), as_date_any(d2$Date))
      all_dates <- all_dates[is.finite(all_dates)]
      if (!length(all_dates)) return()
      first_date <- min(all_dates, na.rm = TRUE)
      last_date  <- max(all_dates, na.rm = TRUE)
      if (is.finite(first_date) && is.finite(last_date)) {
        updateDateRangeInput(session, "dates", start = first_date, end = last_date)
      }
    })
    
    observe({
      req(is_active())
      # Player list = union of Pitchers, Batters, Catchers (Camps only)
      d1 <- camps_pitching(); d2 <- camps_all()
      players <- sort(unique(c(
        as.character(d1$Pitcher),
        as.character(d2$Pitcher),
        as.character(d2$Batter),
        as.character(d2$Catcher)
      )))
      players <- players[nzchar(players)]
      .pretty_name <- function(x) {
        x <- as.character(x)
        ifelse(grepl(",", x), paste0(trimws(sub(".*,", "", x)), " ", trimws(sub(",.*", "", x))), x)
      }
      named <- stats::setNames(players, .pretty_name(players))
      updateSelectInput(session, "player",
                        choices = c("All" = "All", named),
                        selected = "All")
    })
    
    # ---------------------------
    # Common filtering (Camps-only base)
    # ---------------------------
    filtered_base <- reactive({
      req(is_active(), input$dates, input$hand, input$zoneLoc, input$inZone, input$qpLocations)
      # Use the same base as Leaderboard when available; otherwise fall back to camps_all
      df <- tryCatch(team_base(), error = function(...) camps_all())
      
      # Align with leaderboard filtering: drop warmups and blank pitch types
      if ("TaggedPitchType" %in% names(df)) {
        df <- df %>%
          dplyr::mutate(.tpt = trimws(as.character(TaggedPitchType))) %>%
          dplyr::filter(!is.na(.tpt) & nzchar(.tpt)) %>%
          dplyr::select(-.tpt)
      }
      if ("PitchSession" %in% names(df)) {
        df <- df %>% dplyr::filter(is.na(PitchSession) | PitchSession != "Warmup")
      }
      # Per-user visibility: Coaches see all, Players see only their own data
      is_coach_val <- tryCatch({
        exists("is_coach", inherits = TRUE) && isTRUE(get("is_coach", inherits = TRUE)())
      }, error = function(...) FALSE)
      admin_val <- tryCatch({
        exists("is_admin", inherits = TRUE) && isTRUE(get("is_admin", inherits = TRUE)())
      }, error = function(...) FALSE)
      
      if (!admin_val && !is_coach_val && "Email" %in% names(df)) {
        norm_email_local <- function(x) tolower(trimws(x))
        ue <- tryCatch({
          if (exists("user_email", inherits = TRUE)) get("user_email", inherits = TRUE)() else NA_character_
        }, error = function(...) NA_character_)
        if (!is.na(ue)) df <- dplyr::filter(df, norm_email_local(Email) == norm_email_local(ue))
      }
      
      # Date range (use Date column coerced to Date)
      dcol <- as_date_any(df$Date)
      if (length(input$dates) == 2) {
        df <- df[!is.na(dcol) & dcol >= as.Date(input$dates[1]) & dcol <= as.Date(input$dates[2]), , drop = FALSE]
      }
      # Pitcher hand
      if (input$hand != "All") df <- dplyr::filter(df, PitcherThrows == input$hand)
      
      # Batter hand (Live only)
      if (!is.null(input$batterSide) && input$batterSide != "All") {
        df <- df %>% dplyr::filter(SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide))
      }
      
      # Zone / in-zone / count (your existing helpers)
      df <- enforce_zone(df, input$zoneLoc)
      df <- enforce_inzone(df, input$inZone)
      df <- filter_qp_locations(df, input$qpLocations)
      df <- apply_count_filter(df, input$countFilter)
      
      # Numeric ranges
      if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed >= input$veloMin)
      if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed <= input$veloMax)
      if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
      if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
      if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak >= input$hbMin)
      if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak <= input$hbMax)
      
      # Pitch types
      ptypes <- input$pitchType; if (is.null(ptypes)) ptypes <- "All"
      if (!("All" %in% ptypes)) df <- dplyr::filter(df, TaggedPitchType %in% ptypes)
      
      # Chronological pitch number → pitch count filter
      df <- df %>% dplyr::arrange(as_date_any(Date)) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
      if (nnz(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
      if (nnz(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
      
      # Compute Stuff+ (harmless if not used)
      df2 <- compute_stuff_simple(df, base_type = "Fastball", level = "College") %>% force_pitch_levels()
      df2
    })
    
    # ======================================================
    # CAMPS SUMMARY PAGE (Exact copy of Pitching Summary)
    # ======================================================
    
    # Summary header
    output$campSummaryHeader <- renderUI({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(div("No data available"))
      
      player_name <- if (!is.null(input$player) && input$player != "All") input$player else "All Players"
      total_pitches <- nrow(df)
      
      div(
        style = "text-align: center; font-size: 18px; font-weight: bold;",
        paste0(player_name, " - ", total_pitches, " pitches")
      )
    })
    
    # Summary Release Plot - Match main Pitching Summary exactly
    output$campSummaryReleasePlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots(); if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      line_col <- if (dark_on) "#ffffff" else "black"
      
      # Get ordered types like main Pitching Summary
      types_chr <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      types_chr <- types_chr[types_chr %in% names(all_colors)]
      
      # Create session label
      sess_lbl <- if (length(unique(df$SessionType)) == 1) unique(df$SessionType)[1] else "All Sessions"
      
      # --- background geometry (same as main Pitching Summary)
      rp_w <- 4; rp_h <- 0.83
      xs <- seq(-rp_w, rp_w, length.out = 100)
      ys <- rp_h * (1 - (xs / rp_w)^2)
      mound <- data.frame(x = c(xs, rev(xs)), y = c(ys, rep(0, length(xs))))
      
      # --- averages for hover+dot (same as main Pitching Summary)
      avg <- df %>%
        dplyr::filter(is.finite(RelSide), is.finite(RelHeight)) %>%
        dplyr::group_by(TaggedPitchType) %>%
        dplyr::summarise(
          avg_RelSide    = mean(RelSide,    na.rm = TRUE),
          avg_RelHeight  = mean(RelHeight,  na.rm = TRUE),
          avg_Extension  = mean(Extension,  na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::filter(TaggedPitchType %in% types_chr) %>%
        dplyr::mutate(
          TaggedPitchType = factor(TaggedPitchType, levels = types_chr),
          tt = paste0(
            "Session: ", sess_lbl,
            "<br>Height: ", sprintf("%.1f ft", avg_RelHeight),
            "<br>Side: ", sprintf("%.1f ft", avg_RelSide),
            "<br>Extension: ", sprintf("%.1f ft", avg_Extension)
          )
        )
      
      # --- ensure y axis goes to at least 6 (same as main Pitching Summary)
      y_max <- max(6, suppressWarnings(max(df$RelHeight, na.rm = TRUE) + 0.2))
      
      p <- ggplot() +
        geom_polygon(data = mound, aes(x, y), fill = "tan", color = "tan") +
        annotate("rect", xmin = -0.5, xmax = 0.5, ymin = rp_h - 0.05, ymax = rp_h + 0.05, fill = "white") +
        geom_vline(xintercept = 0, color = line_col, size = 0.7) +
        geom_hline(yintercept = 0, color = line_col, size = 0.7) +
        ggiraph::geom_point_interactive(
          data = avg,
          aes(x = avg_RelSide, y = avg_RelHeight,
              color = TaggedPitchType, tooltip = tt, data_id = TaggedPitchType),
          size = 8, show.legend = FALSE
        ) +
        scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
        scale_y_continuous(limits = c(0, y_max), breaks = seq(0, ceiling(y_max), by = 1)) +
        theme_minimal() + axis_theme + grid_theme(dark_on) +
        labs(x = NULL, y = NULL) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
          axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
          panel.grid = element_blank(),
          axis.ticks = element_blank()
        )
      
      girafe_transparent(
        ggobj = p,
        width_svg = 8, height_svg = 6.5,
        bg = "transparent",
        options = list(
          ggiraph::opts_sizing(rescale = TRUE),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
          ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
    # Summary Movement Plot - Match main Pitching Summary exactly
    output$campSummaryMovementPlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots(); if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      line_col <- if (dark_on) "#ffffff" else "gray"
      
      types_chr <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      types_chr <- types_chr[types_chr %in% names(all_colors)]
      if (!length(types_chr)) return(NULL)
      
      # Averages per type (respect filters)
      avg_mov <- df %>%
        dplyr::group_by(TaggedPitchType) %>%
        dplyr::summarise(
          avg_HorzBreak        = mean(HorzBreak, na.rm = TRUE),
          avg_InducedVertBreak = mean(InducedVertBreak, na.rm = TRUE),
          .groups = "drop"
        )
      
      # interactive payload (per pitch) — uses make_hover_tt()
      df_i <- df %>%
        dplyr::mutate(
          tt  = make_hover_tt(.),
          rid = dplyr::row_number()
        )
      
      # Note: breakLines input doesn't exist in Camps, so skip the baseline reference lines
      
      p <- ggplot() +
        geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
        geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
        ggiraph::geom_point_interactive(
          data = avg_mov %>% dplyr::filter(TaggedPitchType %in% types_chr),
          aes(x = avg_HorzBreak, y = avg_InducedVertBreak, color = TaggedPitchType,
              tooltip = paste0(TaggedPitchType, "<br>IVB: ", round(avg_InducedVertBreak,1), 
                               " in<br>HB: ", round(avg_HorzBreak,1), " in"),
              data_id = TaggedPitchType),
          size = 8, show.legend = FALSE
        ) +
        scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
        theme_minimal() + axis_theme + grid_theme(dark_on) +
        labs(x = NULL, y = NULL) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
          axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
          panel.grid = element_blank(),
          axis.ticks = element_blank()
        )
      
      girafe_transparent(
        ggobj = p,
        width_svg = 8, height_svg = 6.5,
        bg = "transparent",
        options = list(
          ggiraph::opts_sizing(rescale = TRUE),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
          ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
    # Summary Zone Plot (interactive)
    output$campSummaryZonePlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(NULL)
      df <- df %>% dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
      if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      line_col <- if (dark_on) "#ffffff" else "black"
      
      # Create outcome categories like the main Summary page
      df$Result <- compute_result(df$PitchCall, df$PlayResult)
      df$Result <- factor(df$Result, levels = result_levels)
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      p <- ggplot(df, aes(PlateLocSide, PlateLocHeight)) +
        ggiraph::geom_point_interactive(aes(
          color = TaggedPitchType,
          shape = Result,
          tooltip = make_hover_tt(df)
        ), size = 2.8, alpha = 0.9) +
        scale_color_manual(values = all_colors[types], limits = types, name = NULL) +
        scale_shape_manual(values = shape_map, name = NULL) +
        geom_rect(aes(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP),
                  fill = NA, color = line_col, linewidth = 1) +
        geom_rect(aes(xmin = -1.5, xmax = 1.5, ymin = 2.65-1.5, ymax = 2.65+1.5),
                  fill = NA, color = line_col, linetype = "dashed", linewidth = 0.8) +
        coord_fixed(ratio = 1) +
        labs(x = "Plate Side (ft)", y = "Plate Height (ft)") +
        theme_minimal() + axis_theme + grid_theme(dark_on) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(color = axis_col),
          axis.text.y = element_text(color = axis_col),
          axis.title.x = element_text(color = axis_col),
          axis.title.y = element_text(color = axis_col)
        )
      
      girafe_transparent(ggobj = p, options = list(ggiraph::opts_hover_inv(css = "opacity:0.1;")))
    })
    
    # Summary Heat Zone Plot
    output$campSummaryHeatZonePlot <- renderPlot({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(NULL)
      
      # Use advanced KDE frequency heatmap (matching all other suites)
      grid <- make_kde_grid(df$PlateLocSide, df$PlateLocHeight, n = 200)
      if (!nrow(grid)) return(ggplot() + theme_void())
      
      # Normalize KDE values to 0-100 scale
      grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
      
      # Use the draw_heat function for consistency with all other heatmaps
      draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
                show_scale = TRUE, scale_label = "Pitch Frequency",
                scale_limits = c(0, 80))
    }, bg = "transparent")
    
    # Summary Legend
    output$campSummaryLegend <- renderPlot({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(ggplot() + theme_void())
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#ffffff" else "black"
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      if (!length(types)) return(ggplot() + theme_void())
      pal <- colors_for_mode(dark_on)
      
      # Create a simple legend plot
      legend_df <- data.frame(
        x = seq_along(types),
        y = 1,
        type = factor(types, levels = types)
      )
      
      ggplot(legend_df, aes(x, y, color = type)) +
        geom_point(size = 6) +
        scale_color_manual(values = pal[types], name = "Pitch Type") +
        theme_void() +
        theme(
          legend.position = "bottom",
          legend.direction = "horizontal",
          legend.box = "horizontal",
          legend.text = element_text(size = 12, color = axis_col),
          legend.title = element_text(size = 14, face = "bold", color = axis_col),
          legend.margin = margin(t = 0, b = 0)
        ) +
        guides(color = guide_legend(override.aes = list(size = 4), nrow = 1))
    }, bg = "transparent")
    
    # Summary Table Buttons
    output$campSummaryTableButtons <- renderUI({
      sel <- isolate(input$campSummaryMode); if (is.null(sel)) sel <- "Stuff"
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("campSummaryMode"), label = NULL,
                            choices = c("Stuff","Process","Results","Raw Data","Custom"),
                            selected = sel, width = "120px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("campSummaryColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']=='Custom'", ns("campSummaryMode")),
          selectizeInput(ns("campSummaryCustomCols"), label = NULL,
                         choices = setdiff(all_table_cols, "Pitch"),
                         multiple = TRUE,
                         options = list(placeholder = "Choose columns to show…"))
        )
      )
    })
    
    # Summary Table
    output$campSummaryTablePage <- DT::renderDataTable({
      df <- pitch_df_for_plots()
      if (!nrow(df)) {
        return(DT::datatable(
          data.frame(Message = "No data for selected filters"),
          options = list(dom = 't'), rownames = FALSE
        ))
      }
      
      mode   <- if (!is.null(input$campSummaryMode)) input$campSummaryMode else "Stuff"
      custom <- if (!is.null(input$campSummaryCustomCols)) input$campSummaryCustomCols else character(0)
      
      # Use make_summary and then transform to match main Pitching Summary exactly
      summ <- safe_make_summary(df)
      summ <- dplyr::mutate(summ,
                            ReleaseTilt = as.character(ReleaseTilt),
                            BreakTilt   = as.character(BreakTilt)
      )
      
      # Add Process/Results columns (same as main Pitching Summary)
      extras <- compute_process_results(df, mode) %>%
        dplyr::rename(Pitch = PitchType) %>%
        dplyr::mutate(Pitch = as.character(Pitch))
      
      # Build the exact same table structure as main Pitching Summary
      df_table <- summ %>%
        dplyr::mutate(
          Pitch     = PitchType,
          `#`       = PitchCount,
          Velo      = round(Velo_Avg, 1),
          Max       = round(Velo_Max, 1),
          rTilt     = ReleaseTilt,
          bTilt     = BreakTilt,
          SpinEff   = ifelse(is.na(SpinEff), "", paste0(round(SpinEff * 100, 1), "%")),
          Spin      = round(SpinRate, 0),
          Height    = round(RelHeight, 1),
          Side      = round(RelSide, 1),
          Ext       = round(Extension, 1),
          `InZone%` = InZonePercent,
          `Comp%`   = CompPercent,
          `K%`      = KPercent,
          `BB%`     = BBPercent,
          `FPS%`    = FPSPercent,
          `E+A%`    = EAPercent,
          `QP%`     = QPPercent,
          `Strike%` = StrikePercent,
          `Swing%`  = SwingPercent,
          `Whiff%`  = WhiffPercent,
          VAA       = VertApprAngle,
          HAA       = HorzApprAngle
        ) %>%
        dplyr::mutate(Pitch = as.character(Pitch)) %>%
        dplyr::select(
          Pitch, `#`, Usage,
          dplyr::any_of(c("0-0","Behind","Even","Ahead","<2K","2K")),
          BF, `RV/100`,
          Velo, Max, IVB, HB, rTilt, bTilt, SpinEff, Spin, Height, Side, VAA, HAA, Ext,
          `InZone%`, `Comp%`, `Strike%`, `Swing%`, `FPS%`, `E+A%`, `QP%`, `K%`, `BB%`, `Whiff%`, EV, LA,
          `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
        ) %>%
        dplyr::mutate(
          SpinEff = {
            val <- suppressWarnings(as.numeric(SpinEff))
            ifelse(is.na(val), "", paste0(round(val * 100, 1), "%"))
          },
          EV = ifelse(is.na(as.numeric(EV)), "", round(as.numeric(EV), 1)),
          LA = ifelse(is.na(as.numeric(LA)), "", round(as.numeric(LA), 1))
        )
      
      # Add Process/Results columns and join
      df_table <- df_table %>% dplyr::left_join(extras, by = "Pitch")
      df_table <- fill_all_qp_pct(df_table, df)
      
      # Column reordering (same as main Pitching Summary)
      df_table <- enforce_process_order(df_table)
      df_table <- enforce_stuff_order(df_table)
      
      visible_set <- visible_set_for(mode, custom)
      datatable_with_colvis(
        df_table,
        lock            = "Pitch",
        remember        = FALSE,
        default_visible = intersect(visible_set, names(df_table)),
        mode            = mode
      )
    })
    
    # ======================================================
    # ORIGINAL PITCHING PAGE PLOTS (keep for backward compatibility)
    # ======================================================
    
    output$campPitchButtons <- renderUI({
      sel <- isolate(input$campPitchMode); if (is.null(sel)) sel <- "Stuff"
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("campPitchMode"), label = NULL,
                            choices = c("Stuff","Process","Results","Raw Data","Custom"),
                            selected = sel, width = "120px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("campPitchColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']=='Custom'", ns("campPitchMode")),
          selectizeInput(ns("campPitchCustomCols"), label = NULL,
                         choices = setdiff(all_table_cols, "Pitch"),
                         multiple = TRUE,
                         options = list(placeholder = "Choose columns to show…"))
        )
      )
    })
    
    # ----- Plot data (pitching-only rows; optional player filter) -----
    pitch_df_for_plots <- reactive({
      df <- filtered_base()
      
      # TEMPORARY: Disable filtering to test
      # allowed_campers <- load_allowed_campers()
      # if (length(allowed_campers) > 0) {
      #   df <- dplyr::filter(df, Pitcher %in% allowed_campers)
      # }
      
      # Apply individual player selection
      if (!is.null(input$player) && input$player != "All") {
        df <- dplyr::filter(df, Pitcher == input$player)
      }
      df
    })
    
    # Release Plot: RelSide vs RelHeight
    output$campPitchReleasePlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(NULL)
      df <- df %>% dplyr::filter(is.finite(RelSide), is.finite(RelHeight))
      if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      p <- ggplot(df, aes(RelSide, RelHeight, color = TaggedPitchType)) +
        ggiraph::geom_point_interactive(aes(
          tooltip = paste0("Pitch: ", TaggedPitchType,
                           "\nVelo: ", ifelse(is.finite(RelSpeed), round(RelSpeed,1), NA), " mph",
                           "\nSpin: ", ifelse(is.finite(SpinRate), round(SpinRate,0), NA), " rpm")
        ), size = 2.8, alpha = 0.9) +
        scale_color_manual(values = all_colors[types], limits = types, name = NULL) +
        labs(x = "Release Side (ft)", y = "Release Height (ft)") +
        theme_minimal() + grid_theme(dark_on) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(color = axis_col),
          axis.text.y = element_text(color = axis_col),
          axis.title.x = element_text(color = axis_col),
          axis.title.y = element_text(color = axis_col)
        )
      
      girafe_transparent(ggobj = p)
    })
    
    # Movement Plot: HB vs IVB
    output$campPitchMovePlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(NULL)
      df <- df %>% dplyr::filter(is.finite(HorzBreak), is.finite(InducedVertBreak))
      if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      p <- ggplot(df, aes(HorzBreak, InducedVertBreak, color = TaggedPitchType)) +
        ggiraph::geom_point_interactive(aes(
          tooltip = paste0("Pitch: ", TaggedPitchType,
                           "\nHB: ", round(HorzBreak,1), " in",
                           "\nIVB: ", round(InducedVertBreak,1), " in")
        ), size = 2.8, alpha = 0.9) +
        scale_color_manual(values = all_colors[types], limits = types, name = NULL) +
        labs(x = "Horizontal Break (in)", y = "Induced Vertical Break (in)") +
        theme_minimal() + grid_theme(dark_on) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(color = axis_col),
          axis.text.y = element_text(color = axis_col),
          axis.title.x = element_text(color = axis_col),
          axis.title.y = element_text(color = axis_col)
        )
      
      girafe_transparent(ggobj = p)
    })
    
    # Location Plot: PlateLocSide vs PlateLocHeight + zone
    output$campPitchLocPlot <- ggiraph::renderGirafe({
      df <- pitch_df_for_plots()
      if (!nrow(df)) return(NULL)
      df <- df %>% dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
      if (!nrow(df)) return(NULL)
      dark_on <- isTRUE(input$dark_mode)
      line_col <- if (dark_on) "#ffffff" else "black"
      
      types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      
      home <- data.frame(x=c(-0.75,0.75,0.75,0.00,-0.75),
                         y=c(1.05,1.05,1.15,1.25,1.15)-0.5)
      cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), fill = NA, color = line_col) +
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col, linetype = "dashed") +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  fill = NA, color = line_col) +
        ggiraph::geom_point_interactive(
          data = df,
          aes(PlateLocSide, PlateLocHeight, color = TaggedPitchType,
              tooltip = paste0("Pitch: ", TaggedPitchType,
                               "\nCall: ", coalesce(PitchCall, ""),
                               "\nVelo: ", ifelse(is.finite(RelSpeed), round(RelSpeed,1), NA), " mph")),
          size = 3.0, alpha = 0.95, stroke = 0.7
        ) +
        scale_color_manual(values = all_colors[types], limits = types, name = NULL) +
        coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
        theme_void() + theme(legend.position = "none")
      
      girafe_transparent(ggobj = p)
    })
    
    # ----- Pitching table (same options/defs as your Pitching Summary) -----
    output$campPitchTable <- DT::renderDataTable({
      df_all <- filtered_base()
      # Only filter by Pitcher if the selected player exists in the Pitcher column
      if (!is.null(input$player) && input$player != "All") {
        # Check if player exists in Pitcher column before filtering
        if (input$player %in% df_all$Pitcher) {
          df_all <- dplyr::filter(df_all, Pitcher == input$player)
        }
      }
      validate(need(nrow(df_all) > 0, "No pitching data for current filters / player"))
      
      by_type <- split(df_all, df_all$TaggedPitchType)
      
      build_row <- function(df) {
        safe_pct <- function(num, den) {
          num <- suppressWarnings(as.numeric(num)); den <- suppressWarnings(as.numeric(den))
          ifelse(is.finite(den) & den > 0 & is.finite(num), paste0(round(100*num/den, 1), "%"), "")
        }
        scores <- ifelse(
          df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
            df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
          ifelse(
            df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
              df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5),
            0.73, 0
          )
        )
        has_pc  <- sum(!is.na(df$PitchCall)) > 0
        strikes <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
        sw      <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
        den     <- sum(df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
        
        bf_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
        fps_opp <- bf_live
        k_live  <- sum(df$SessionType == "Live" & df$KorBB == "Strikeout",        na.rm = TRUE)
        bb_live <- sum(df$SessionType == "Live" & df$KorBB == "Walk",             na.rm = TRUE)
        fps_live <- sum(df$SessionType == "Live" &
                          df$Balls == 0 & df$Strikes == 0 &
                          df$PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"),
                        na.rm = TRUE)
        ea_live  <- sum(df$SessionType == "Live" & (
          (df$Balls == 0 & df$Strikes == 0 & df$PitchCall == "InPlay") |
            (df$Balls == 0 & df$Strikes == 1 & df$PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
            )) |
            (df$Balls == 1 & df$Strikes == 0 & df$PitchCall == "InPlay") |
            (df$Balls == 1 & df$Strikes == 1 & df$PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
            ))
        ),
        na.rm = TRUE
        )
        
        vmax   <- suppressWarnings(max(as.numeric(df$RelSpeed), na.rm = TRUE)); vmax <- if (is.finite(vmax)) round(vmax, 1) else NA_real_
        ev_all <- nz_mean(ifelse(df$SessionType=="Live", df$ExitSpeed, NA_real_))
        la_all <- nz_mean(ifelse(df$SessionType=="Live", df$Angle,     NA_real_))
        stuff_all <- round(nz_mean(df$`Stuff+`), 1)
        ctrl_all   <- round(nz_mean(scores) * 100, 1)
        qp_vals   <- compute_qp_points(df)
        qp_all    <- round(nz_mean(qp_vals) * 200, 1)
        qp_pct    <- safe_pct(sum((qp_vals * 200) >= 100, na.rm = TRUE), nrow(df))
        
        tibble::tibble(
          `#`            = nrow(df),
          Usage          = NA_character__,  # filled after bind
          Velo           = round(nz_mean(df$RelSpeed), 1),
          Max            = vmax,
          IVB            = round(nz_mean(df$InducedVertBreak), 1),
          HB             = round(nz_mean(df$HorzBreak), 1),
          ReleaseTilt   = convert_to_clock(nz_mean(df$ReleaseTilt)),
          BreakTilt     = convert_to_clock(nz_mean(df$BreakTilt)),
          SpinEff        = { v <- nz_mean(df$SpinEfficiency); if (is.na(v)) "" else paste0(round(v*100,1), "%") },
          Spin           = round(nz_mean(df$SpinRate), 0),
          Height         = round(nz_mean(df$RelHeight), 1),
          Side           = round(nz_mean(df$RelSide), 1),
          VAA            = round(nz_mean(df$VertApprAngle), 1),
          HAA            = round(nz_mean(df$HorzApprAngle), 1),
          Ext            = round(nz_mean(df$Extension), 1),
          `InZone%`      = { inzone <- (df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
                                          df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP);
          safe_pct(sum(inzone, na.rm = TRUE), sum(!is.na(inzone))) },
          `Comp%`        = { comp <- (df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                                        df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5));
          safe_pct(sum(comp, na.rm = TRUE), sum(!is.na(comp))) },
          `Strike%`      = if (has_pc) safe_pct(strikes, nrow(df)) else "",
          `FPS%`         = safe_pct(fps_live, fps_opp),
          `E+A%`         = safe_pct(ea_live,  fps_opp),
          `QP%`          = qp_pct,
          `K%`           = safe_pct(k_live,   bf_live),
          `BB%`          = safe_pct(bb_live,  bf_live),
          `Whiff%`       = safe_pct(sw, den),
          EV = round(ev_all, 1),
          LA = round(la_all, 1),
          `Stuff+`       = stuff_all,
          `Ctrl+`        = ctrl_all,
          `QP+`          = qp_all,
          `Pitching+`    = round((stuff_all + qp_all)/2, 1)
        )
      }
      
      rows <- lapply(names(by_type), function(p) {
        dfi <- by_type[[p]]
        tibble::tibble(Pitch = as.character(p)) %>% dplyr::bind_cols(build_row(dfi))
      })
      
      out_tbl <- dplyr::bind_rows(rows)
      tot <- sum(out_tbl$`#`, na.rm = TRUE)
      out_tbl$Usage <- ifelse(tot > 0, paste0(round(100*out_tbl$`#`/tot, 1), "%"), "")
      
      all_row <- tibble::tibble(Pitch = "All") %>% dplyr::bind_cols(build_row(df_all))
      all_row$Usage <- "100%"
      out_tbl <- dplyr::bind_rows(out_tbl, all_row)
      
      mode   <- input$campPitchMode
      custom <- input$campPitchCustomCols; if (is.null(custom)) custom <- character(0)
      visible_set <- visible_set_for_lb(mode, custom)
      
      datatable_with_colvis(
        out_tbl,
        lock            = "Pitch",
        remember        = FALSE,
        default_visible = intersect(visible_set, names(out_tbl))
      )
    }, server = FALSE)
    
    # ======================================================
    # HITTING page (Data & Performance — spray + table)
    # ======================================================
    output$campHitButtons <- renderUI({
      sel <- isolate(input$campHitMode); if (is.null(sel)) sel <- "Results"
      tagList(
        radioButtons(
          ns("campHitMode"), NULL,
          choices = c("Results", "Custom"),
          selected = sel, inline = TRUE
        ),
        conditionalPanel(
          sprintf("input['%s']==='Custom'", ns("campHitMode")),
          selectizeInput(
            ns("campHitCustomCols"), NULL,
            choices = c(
              "PA","AB","AVG","SLG","OBP","OPS",
              "xWOBA","xISO","BABIP","GB%","Barrel%",
              "Swing%","Whiff%","K%","BB%","EV","LA"
            ),
            selected = c("PA","AB","AVG","SLG","OBP","OPS"),
            multiple = TRUE, options = list(placeholder = "Pick columns…")
          )
        )
      )
    })
    
    filtered_hit_camps <- reactive({
      df <- filtered_base()
      # Only filter by Batter if the selected player exists in the Batter column
      if (!is.null(input$player) && input$player != "All") {
        # Check if player exists in Batter column before filtering
        if (input$player %in% df$Batter) {
          df <- dplyr::filter(df, Batter == input$player)
        }
      }
      df
    })
    
    # Spray chart
    output$campSprayChart <- ggiraph::renderGirafe({
      df <- filtered_hit_camps(); if (!nrow(df)) return(NULL)
      st <- tolower(trimws(as.character(df$SessionType)))
      live_mask <- grepl("live|game|ab", st)
      
      dist_num <- suppressWarnings(as.numeric(df$Distance))
      dir_num  <- suppressWarnings(as.numeric(df$Direction))
      ok <- which(live_mask & df$PitchCall == "InPlay" & is.finite(dist_num) & is.finite(dir_num))
      
      fence_pts <- data.frame(deg = c(-45,-22.5,0,22.5,45), r = c(330,370,400,370,330))
      deg_seq <- seq(-45, 45, length.out = 301)
      r_seq   <- stats::spline(fence_pts$deg, fence_pts$r, xout = deg_seq)$y
      fence   <- data.frame(x = r_seq * sin(deg_seq*pi/180), y = r_seq * cos(deg_seq*pi/180))
      fl_l <- data.frame(x = c(0, 330*sin(-45*pi/180)), y = c(0, 330*cos(-45*pi/180)))
      fl_r <- data.frame(x = c(0, 330*sin( 45*pi/180)), y = c(0, 330*cos( 45*pi/180)))
      th_in <- seq(-45, 45, length.out = 121)
      infield <- data.frame(x = 95 * sin(th_in*pi/180), y = 95 * cos(th_in*pi/180))
      home <- data.frame(x = c(-0.75, 0.75, 0.75, 0, -0.75),
                         y = c( 1.05, 1.05, 1.15, 1.25, 1.15) - 2.0)
      
      if (!length(ok)) {
        p_empty <- ggplot() +
          geom_polygon(data = home, aes(x, y), fill = NA, color = "grey50") +
          geom_path(data = fence, aes(x, y), color = "grey40", linewidth = 0.8) +
          geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                       fill = "#f3f5f7", color = NA, alpha = 0.6) +
          geom_path(data = fl_l, aes(x, y), color = "grey50") +
          geom_path(data = fl_r, aes(x, y), color = "grey50") +
          geom_path(data = infield, aes(x, y), color = "grey70") +
          annotate("text", x = 0, y = 200, label = "No balls in play for current filters", size = 5) +
          coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
          theme_void()
        return(girafe_transparent(ggobj = p_empty))
      }
      
      bbe <- df[ok, , drop = FALSE]
      bbe$Distance  <- dist_num[ok]
      bbe$Direction <- dir_num[ok]
      
      FOUL_DEG_RAW  <- 90
      FOUL_DEG_GEOM <- 110
      angle_scale   <- FOUL_DEG_GEOM / FOUL_DEG_RAW
      
      th     <- bbe$Direction * angle_scale * pi/180
      bbe$x  <- bbe$Distance * sin(th)
      bbe$y  <- bbe$Distance * cos(th)
      
      hit_levels <- c("Single","Double","Triple","HomeRun")
      outcome <- dplyr::case_when(bbe$PlayResult %in% hit_levels ~ bbe$PlayResult, TRUE ~ "Out")
      bbe$Outcome <- factor(outcome, levels = c("Out", hit_levels))
      outcome_cols <- c("Single"="#1fab54","Double"="#1f77b4","Triple"="#7b1fa2","HomeRun"="#d62728","Out"="#222222")
      
      bbe <- bbe %>%
        dplyr::mutate(
          rid     = dplyr::row_number(),
          tt      = paste0(
            "EV: ", ifelse(is.finite(ExitSpeed), sprintf("%.1f", ExitSpeed), "—"), " mph\n",
            "LA: ", ifelse(is.finite(Angle),     sprintf("%.1f", Angle),     "—"), "°\n",
            "Distance: ", ifelse(is.finite(Distance), paste0(sprintf("%.0f", Distance), " ft"), "—"), "\n",
            "Pitch: ", TaggedPitchType, "\n",
            "Result: ", PlayResult
          ),
          tt_fill = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray80")
        )
      
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), fill = NA, color = "grey50") +
        geom_path(data = fence, aes(x, y), color = "grey40", linewidth = 0.8) +
        geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                     fill = "#f3f5f7", color = NA, alpha = 0.6) +
        geom_path(data = fl_l, aes(x, y), color = "grey50") +
        geom_path(data = fl_r, aes(x, y), color = "grey50") +
        geom_path(data = infield, aes(x, y), color = "grey70") +
        ggiraph::geom_point_interactive(
          data = bbe,
          aes(x, y, color = Outcome, tooltip = tt, data_id = rid),
          size = 2.8, alpha = 0.95
        ) +
        ggiraph::geom_point_interactive(
          data = bbe,
          aes(x, y, tooltip = tt, data_id = rid, fill = I(tt_fill)),
          shape = 21, size = 8, alpha = 0.001, stroke = 0, inherit.aes = FALSE
        ) +
        scale_color_manual(values = outcome_cols, name = "Result") +
        coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
        theme_void() + theme(legend.position = "right")
      
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_sizing(rescale = TRUE),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.35);"),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    })
    
    # Hitting table (same DP logic/formatting)
    output$campHitTable <- DT::renderDataTable({
      df <- filtered_hit_camps()
      if (!nrow(df)) return(DT::datatable(data.frame(message = "No rows after filters"), rownames = FALSE))
      df <- df %>% dplyr::filter(!is.na(Batter) & nzchar(Batter))
      if (!nrow(df)) return(DT::datatable(data.frame(message = "No batters for current filters"), rownames = FALSE))
      
      swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
      by_batter <- split(df, df$Batter)
      
      rows <- lapply(by_batter, function(dfi) {
        is_term_i <- (
          (!is.na(dfi$PlayResult) & dfi$PlayResult != "Undefined") |
            (!is.na(dfi$KorBB) & dfi$KorBB %in% c("Strikeout","Walk"))
        )
        term <- dfi[is_term_i, , drop = FALSE]
        PAt <- nrow(term)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
        H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
        H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
        HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        H_all <- H1 + H2 + H3 + HR
        TB_all <- 1*H1 + 2*H2 + 3*H3 + 4*HR
        Kct_all <- sum(term$KorBB == "Strikeout" |
                         term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
        BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        ABt <- PAt - (BBc_all + HBP_all + Sac_all)
        
        swings_all <- sum(!is.na(dfi$PitchCall) & dfi$PitchCall %in% swing_levels, na.rm = TRUE)
        whiffs_all <- sum(dfi$PitchCall == "StrikeSwinging", na.rm = TRUE)
        
        bbe_i <- dfi %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
        EV_i <- nz_mean(bbe_i$ExitSpeed)
        LA_i <- nz_mean(bbe_i$Angle)
        GB_i <- safe_div(sum(bbe_i$TaggedHitType == "GroundBall", na.rm = TRUE),
                         sum(!is.na(bbe_i$TaggedHitType), na.rm = TRUE))
        
        extras_all <- compute_process_results(dfi) %>%
          dplyr::filter(PitchType == "All") %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::summarise(
            xWOBA = nz_mean(xWOBA), xISO = nz_mean(xISO),
            BABIP = nz_mean(BABIP), BarrelFrac = nz_mean(`Barrel%`)
          )
        barrel_frac <- extras_all$BarrelFrac[1]
        if (is.na(barrel_frac)) {
          candidates <- c("Barrel","Barrels","BarrelFlag","IsBarrel","Barreled","Barrelled")
          nm <- candidates[candidates %in% names(bbe_i)]
          barrel_frac <- if (!length(nm)) NA_real_ else safe_div(sum(as.logical(bbe_i[[nm[1]]]), na.rm = TRUE),
                                                                 sum(!is.na(bbe_i[[nm[1]]])))
        }
        
        tibble::tibble(
          Player = as.character(dfi$Batter[1]),
          PA  = PAt,
          AB  = ABt,
          AVG = safe_div(H_all, ABt),
          SLG = safe_div(TB_all, ABt),
          OBP = safe_div(H_all + BBc_all + HBP_all, PAt),
          OPS = NA_real_,
          xWOBA = extras_all$xWOBA[1],
          xISO  = extras_all$xISO[1],
          BABIP = extras_all$BABIP[1],
          `Swing%` = safe_div(swings_all, nrow(dfi)),
          `Whiff%` = safe_div(whiffs_all, swings_all),
          `GB%`    = GB_i,
          `K%`     = safe_div(Kct_all, PAt),
          `BB%`    = safe_div(BBc_all, PAt),
          `Barrel%`= barrel_frac,
          EV = EV_i,
          LA = LA_i
        ) %>% dplyr::mutate(OPS = SLG + OBP)
      })
      
      out <- dplyr::bind_rows(rows)
      num_cols <- c("PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP",
                    "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
      out <- out %>% dplyr::mutate(dplyr::across(dplyr::all_of(num_cols), ~ suppressWarnings(as.numeric(.))))
      out$EV <- ifelse(is.finite(out$EV), round(out$EV, 1), out$EV)
      out$LA <- ifelse(is.finite(out$LA), round(out$LA, 1), out$LA)
      
      pct_cols  <- c("Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%")
      rate_cols <- c("AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP")
      out[pct_cols]  <- lapply(out[pct_cols],  function(z) ifelse(is.finite(z), paste0(round(z*100,1), "%"), ""))
      out[rate_cols] <- lapply(out[rate_cols], fmt_rate3)
      suppressWarnings(out <- out %>% dplyr::arrange(dplyr::desc(as.numeric(OPS))))
      
      mode   <- input$campHitMode; if (is.null(mode)) mode <- "Results"
      custom <- input$campHitCustomCols; if (is.null(custom)) custom <- character(0)
      default_visible <- if (identical(mode, "Custom")) unique(c("Player", custom)) else {
        c("Player","PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP","GB%","Barrel%","Swing%","Whiff%","K%","BB%","EV","LA")
      }
      
      datatable_with_colvis(
        out,
        lock            = "Player",
        remember        = FALSE,
        default_visible = intersect(default_visible, names(out))
      )
    }, server = FALSE)
    
    # ======================================================
    # CATCHING page (Data & Performance)
    # ======================================================
    output$campCatchButtons <- renderUI({
      sel <- isolate(input$campCatchMode); if (is.null(sel)) sel <- "Data"
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("campCatchMode"), label = NULL,
                            choices = c("Data","Custom"), selected = sel, width = "100px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("campCatchColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']==='Custom'", ns("campCatchMode")),
          selectizeInput(
            ns("campCatchCustomCols"), label = NULL,
            choices = c("#","Velo","ExchangeTime","PopTime","SL+"),
            multiple = TRUE,
            options = list(placeholder = "Choose columns…")
          )
        )
      )
    })
    
    output$campCatchTable <- DT::renderDataTable({
      df_all <- filtered_base()
      if (!is.null(input$player) && input$player != "All") {
        df_all <- dplyr::filter(df_all, Catcher == input$player)
      }
      df_all <- df_all %>% dplyr::filter(!is.na(Catcher) & nzchar(Catcher))
      if (!nrow(df_all)) {
        return(DT::datatable(data.frame(Note = "No rows for current filters / player."), options = list(dom = 't'), rownames = FALSE))
      }
      
      to_num <- function(x) suppressWarnings(as.numeric(x))
      takes_all   <- tryCatch({
        pitch_call_safe <- as.character(df_all$PitchCall)
        (!is.na(pitch_call_safe)) & (pitch_call_safe %in% c("StrikeCalled","BallCalled"))
      }, error = function(e) rep(FALSE, nrow(df_all)))
      buckets_all <- inzone_label(df_all$PlateLocSide, df_all$PlateLocHeight)
      
      by_catcher <- split(seq_len(nrow(df_all)), df_all$Catcher)
      
      rows <- lapply(names(by_catcher), function(name) {
        idx <- by_catcher[[name]]
        dfi <- df_all[idx, , drop = FALSE]
        
        takes   <- takes_all[idx]
        buckets <- buckets_all[idx]
        
        base_tbl <- dplyr::tibble(
          take   = takes,
          bucket = buckets,
          is_cs  = dfi$PitchCall == "StrikeCalled"
        ) |>
          dplyr::filter(take) |>
          dplyr::group_by(bucket) |>
          dplyr::summarise(cs_rate = mean(is_cs, na.rm = TRUE), n = dplyr::n(), .groups = "drop")
        
        overall_rate <- if (nrow(base_tbl) && sum(base_tbl$n) > 0) {
          sum(base_tbl$cs_rate * base_tbl$n) / sum(base_tbl$n)
        } else NA_real_
        
        rate_for_bucket <- function(b) {
          r <- base_tbl$cs_rate[match(b, base_tbl$bucket)]
          ifelse(is.na(r), overall_rate, r)
        }
        
        obs_all <- if (any(takes, na.rm = TRUE)) mean(dfi$PitchCall[takes] == "StrikeCalled", na.rm = TRUE) else NA_real_
        tb      <- table(buckets[takes])
        exp_all <- if (length(tb)) sum(as.numeric(tb) * vapply(names(tb), rate_for_bucket, numeric(1))) / sum(tb) else NA_real_
        sl_all  <- if (is.finite(obs_all) && is.finite(exp_all) && exp_all > 0) round(100 * obs_all / exp_all, 1) else NA_real_
        
        dft <- dfi |>
          dplyr::mutate(
            ThrowSpeed_num   = to_num(ThrowSpeed),
            ExchangeTime_num = to_num(ExchangeTime),
            PopTime_num      = to_num(PopTime)
          ) |>
          dplyr::filter(is.finite(PopTime_num))
        
        tibble::tibble(
          Player       = name,
          `#`          = nrow(dft),
          Velo         = if (nrow(dft)) round(mean(dft$ThrowSpeed_num,   na.rm = TRUE), 1) else NA_real_,
          ExchangeTime = if (nrow(dft)) round(mean(dft$ExchangeTime_num, na.rm = TRUE), 1) else NA_real_,
          PopTime      = if (nrow(dft)) round(mean(dft$PopTime_num,      na.rm = TRUE), 2) else NA_real_,
          `SL+`        = sl_all
        )
      })
      
      final <- dplyr::bind_rows(rows)
      
      mode <- input$campCatchMode; if (is.null(mode)) mode <- "Data"
      default_visible <- if (identical(mode, "Custom")) {
        unique(c("Player", input$campCatchCustomCols))
      } else {
        c("Player","#","Velo","ExchangeTime","PopTime","SL+")
      }
      
      datatable_with_colvis(
        final,
        lock            = "Player",
        remember        = TRUE,
        default_visible = intersect(default_visible, names(final)),
        enable_colors   = FALSE
      )
    }, server = FALSE)
  })
}


# ==========================
# == Leaderboard (new)    ==
# ==========================
mod_leader_ui <- function(id, show_header = FALSE) {
  ns <- NS(id)
  fluidPage(
    if (isTRUE(show_header)) {
      fluidRow(
        class = "suite-header",
        column(2, tags$img(src = "PCUlogo.png", height = "100px")),
        column(
          8,
          div(
            style = "height:100%; display:flex; justify-content:center; align-items:flex-start;",
            tags$h1("Leaderboards", style = "margin-top:25px; font-weight:bold;")
          )
        ),
        column(
          2,
          div(style = "text-align:right; margin-top:10px;",
              tags$img(src = school_logo, height = "80px", alt = school_display_name))
        )
      )
    },
    sidebarLayout(
      sidebarPanel(
        selectInput(ns("domain"), "Leaderboard Domain:", choices = c("Pitching","Hitting","Catching"), selected = "Pitching"),
        selectInput(ns("teamType"), "Team:", choices = TEAM_CHOICES, selected = "All"),
        
        # --- Common filters (apply to all domains) ---
        selectInput(ns("sessionType"), "Session Type:", choices = c("All","Bullpen","Live"), selected = "All"),
        dateRangeInput(ns("dates"), "Date Range:",
                       start = max(pitch_data$Date, na.rm = TRUE),
                       end   = max(pitch_data$Date, na.rm = TRUE),
                       format = "mm/dd/yyyy"),
        selectInput(ns("hand"),       "Pitcher Hand:",  choices = c("All","Left","Right"), selected = "All"),
        selectInput(ns("pitchType"),  "Pitch Type:",    choices = c("All", levels(pitch_data$TaggedPitchType)), selected = "All", multiple = TRUE),
        selectInput(
          ns("zoneLoc"), "Zone Location:",
          choices = c("All",
                      "Upper Half","Bottom Half","Left Half","Right Half",
                      "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
          selected = "All", multiple = TRUE
        ),
        selectInput(ns("inZone"),     "In Zone:",       choices = c("All","Yes","No","Competitive"), selected = "All"),
        selectInput(ns("batterSide"), "Batter Hand:",   choices = c("All","Left","Right"), selected = "All"),
        selectInput(ns("qpLocations"), "QP Locations:", choices = c("All", "Yes", "No"), selected = "All"),
        selectInput(
          ns("countFilter"), "Count:",
          choices  = c("All"="All","Even"="Even","Behind"="Behind","Ahead"="Ahead","2K Not Full"="2KNF",
                       "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
          selected = "All", multiple = TRUE
        ),
        fluidRow(
          column(6, numericInput(ns("veloMin"), "Velocity Min (MPH):", value = NA)),
          column(6, numericInput(ns("veloMax"), "Velocity Max (MPH):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("ivbMin"), "IVB Min (inches):", value = NA)),
          column(6, numericInput(ns("ivbMax"), "IVB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("hbMin"), "HB Min (inches):", value = NA)),
          column(6, numericInput(ns("hbMax"), "HB Max (inches):", value = NA))
        ),
        fluidRow(
          column(6, numericInput(ns("pcMin"), "Pitch Count Min:", value = NA, min = 1)),
          column(6, numericInput(ns("pcMax"), "Pitch Count Max:", value = NA, min = 1))
        ),
        width = 3,
        class = "sidebar"
      ),
      mainPanel(
        # --- Pitching (unchanged UI) ---
        conditionalPanel(
          condition = sprintf("input['%s'] === 'Pitching'", ns("domain")),
          tagList(
            div(style = "margin: 8px 0;", uiOutput(ns("lbButtons"))),
            DT::dataTableOutput(ns("lbTable"))
          )
        ),
        
        # --- Hitting (per-player) ---
        conditionalPanel(
          condition = sprintf("input['%s'] === 'Hitting'", ns("domain")),
          tagList(
            div(style="display:flex; align-items:center; gap:12px; margin-bottom:8px;", uiOutput(ns("lbHitButtons"))),
            DT::dataTableOutput(ns("lbHitTable"))
          )
        ),
        
        # --- Catching (per-player) ---
        conditionalPanel(
          condition = sprintf("input['%s'] === 'Catching'", ns("domain")),
          tagList(
            div(style="display:flex; align-items:center; gap:12px; margin-bottom:8px;", uiOutput(ns("lbCatchButtons"))),
            DT::dataTableOutput(ns("lbCatchTable"))
          )
        )
      )
    )
  )
}

mod_leader_server <- function(id, is_active = shiny::reactive(TRUE), global_date_range = NULL) {
  moduleServer(id, function(input, output, session) {
    
    # Sync local date input with global date range
    if (!is.null(global_date_range)) {
      observe({
        if (!is.null(global_date_range()) && length(global_date_range()) == 2) {
          updateDateRangeInput(session, "dates", 
                               start = global_date_range()[1], 
                               end = global_date_range()[2])
        }
      })
      
      # Update global date range when local input changes
      observeEvent(input$dates, {
        if (!is.null(input$dates) && length(input$dates) == 2) {
          global_date_range(input$dates)
        }
      })
    }
    ns <- session$ns
    
    # ---------- constants ----------
    TEAM_CODE <- "GRA_CAN"
    
    # Map team-code synonyms (extend this list as needed)
    TEAM_SYNONYMS <- list(
      GRA_CAN = c("GRA_CAN")
    )
    
    # ---------- small helpers ----------
    nnz <- function(x) !is.null(x) && !is.na(x)
    safe_div <- function(a,b) {
      a <- suppressWarnings(as.numeric(a)); b <- suppressWarnings(as.numeric(b))
      ifelse(is.finite(den <- b) & den != 0 & is.finite(a), a/den, NA_real_)
    }
    # Parse numbers; treat anything with % as percentage -> fraction
    parse_num <- function(x) {
      if (is.numeric(x)) return(x)
      sx <- trimws(as.character(x))
      sx[sx == ""] <- NA_character_
      is_pct <- grepl("%", sx)
      val <- suppressWarnings(as.numeric(gsub("[^0-9eE.+-]", "", sx)))
      val[is_pct] <- val[is_pct] / 100
      val
    }
    nz_mean <- function(x) {
      x <- suppressWarnings(as.numeric(x))
      m <- mean(x, na.rm = TRUE)
      if (is.finite(m)) m else NA_real_
    }
    # 3-dec rate with NO leading zero for 0.xxx
    fmt_rate3 <- function(x) {
      x <- suppressWarnings(as.numeric(x))
      s <- ifelse(is.finite(x), sprintf("%.3f", x), "")
      sub("^0\\.", ".", s)
    }
    # Barrel% fallback finder (common column names)
    barrel_share_from_flags <- function(df) {
      candidates <- c("Barrel","Barrels","BarrelFlag","IsBarrel","Barreled","Barrelled")
      nm <- candidates[candidates %in% names(df)]
      if (!length(nm)) return(NA_real_)
      col <- df[[nm[1]]]
      safe_div(sum(as.logical(col), na.rm = TRUE), sum(!is.na(col)))
    }
    
    # Keep count filter tidy
    observeEvent(input$countFilter, {
      sel <- input$countFilter
      if (is.null(sel) || !length(sel)) {
        updateSelectInput(session, "countFilter", selected = "All")
      } else if ("All" %in% sel && length(sel) > 1) {
        updateSelectInput(session, "countFilter", selected = setdiff(sel, "All"))
      }
    }, ignoreInit = TRUE)
    
    # ---------- TEAM-SCOPED BASE ----------
    # Returns the base dataset for the selected domain & session type,
    # filtered to team-specific rows based on Team selector.
    team_base <- reactive({
      req(is_active(), input$teamType)
      # Use modified_pitch_data() to match Pitching suite (includes pitch type/pitcher modifications)
      modified_data <- tryCatch(modified_pitch_data(), error = function(e) pitch_data_pitching)
      if (is.null(modified_data)) modified_data <- pitch_data_pitching
      
      base <- switch(
        input$domain,
        "Pitching" = if (input$sessionType == "All") modified_data else dplyr::filter(modified_data, SessionType == input$sessionType),
        "Hitting"  = if (input$sessionType == "All") pitch_data else dplyr::filter(pitch_data, SessionType == input$sessionType),
        "Catching" = if (input$sessionType == "All") pitch_data else dplyr::filter(pitch_data, SessionType == input$sessionType)
      )
      
      # Filter by team selection
      if (input$teamType == "Campers") {
        if (identical(input$domain, "Hitting")) {
          dplyr::filter(base, Batter %in% ALLOWED_CAMPERS)
        } else {
          dplyr::filter(base, Pitcher %in% ALLOWED_CAMPERS)
        }
      } else if (input$teamType == TEAM_CODE) {
        if (identical(input$domain, "Hitting")) {
          dplyr::filter(base, Batter %in% ALLOWED_HITTERS)
        } else {
          dplyr::filter(base, Pitcher %in% ALLOWED_PITCHERS)
        }
      } else {
        base
      }
    })
    
    
    # Default the date range to the most recent date with data for the chosen domain/sessionType
    observe({
      req(is_active())
      base <- team_base()
      last_date <- suppressWarnings(max(base$Date, na.rm = TRUE))
      if (is.finite(last_date)) {
        updateDateRangeInput(session, "dates", start = last_date, end = last_date)
      }
    })
    
    # Domain-aware filtered data BEFORE pitch-type filtering (used for usage denominators)
    filtered_lb_before_pitch_type <- reactive({
      req(is_active(), input$dates, input$hand, input$zoneLoc, input$inZone, input$qpLocations)
      
      df <- team_base()
      
      # ⛔️ Drop warmups & blank pitch types (match Pitching suite filtering)
      if ("TaggedPitchType" %in% names(df)) {
        df <- df %>%
          dplyr::mutate(.tpt = trimws(as.character(TaggedPitchType))) %>%
          dplyr::filter(!is.na(.tpt) & nzchar(.tpt)) %>%
          dplyr::select(-.tpt)
      }
      if ("PitchSession" %in% names(df)) {
        df <- dplyr::filter(df, is.na(PitchSession) | PitchSession != "Warmup")
      }
      
      # Date range
      df <- dplyr::filter(df, Date >= input$dates[1], Date <= input$dates[2])
      
      # Pitcher hand
      if (input$hand != "All") df <- dplyr::filter(df, PitcherThrows == input$hand)
      
      # Batter hand (Live only)
      if (!is.null(input$batterSide) && input$batterSide != "All") {
        df <- df %>% dplyr::filter(
          SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide)
        )
      }
      
      # Zone / in-zone / count filters
      df <- enforce_zone(df, input$zoneLoc)
      df <- enforce_inzone(df, input$inZone)
      df <- filter_qp_locations(df, input$qpLocations)
      df <- apply_count_filter(df, input$countFilter)
      
      # Numeric ranges
      if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed >= input$veloMin)
      if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed <= input$veloMax)
      if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
      if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
      if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak >= input$hbMin)
      if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak <= input$hbMax)
      
      # Chronological pitch number bounds
      df <- df %>% dplyr::arrange(Date) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
      if (nnz(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
      if (nnz(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
      
      # Per-user visibility: Coaches see all, Players see only their own data
      is_coach_val <- tryCatch({
        exists("is_coach", inherits = TRUE) && isTRUE(get("is_coach", inherits = TRUE)())
      }, error = function(...) FALSE)
      admin_val <- tryCatch({
        exists("is_admin", inherits = TRUE) && isTRUE(get("is_admin", inherits = TRUE)())
      }, error = function(...) FALSE)
      
      if (!admin_val && !is_coach_val && "Email" %in% names(df)) {
        norm_email_local <- function(x) tolower(trimws(x))
        ue <- tryCatch({
          if (exists("user_email", inherits = TRUE)) get("user_email", inherits = TRUE)() else NA_character_
        }, error = function(...) NA_character_)
        if (!is.na(ue)) df <- dplyr::filter(df, norm_email_local(Email) == norm_email_local(ue))
      }
      
      compute_stuff_simple(df, base_type = "Fastball", level = "College") %>%
        force_pitch_levels()
    })
    
    # Domain-aware filtered data (LSU-only)
    filtered_lb <- reactive({
      df <- filtered_lb_before_pitch_type()
      
      # Pitch types
      ptypes <- input$pitchType
      if (is.null(ptypes)) ptypes <- "All"
      if (!("All" %in% ptypes)) df <- dplyr::filter(df, TaggedPitchType %in% ptypes)
      
      df
    })
    
    # =========================
    # Pitching (unchanged)
    # =========================
    output$lbButtons <- renderUI({
      sel <- isolate(input$lbMode); if (is.null(sel)) sel <- "Stuff"
      ct_names <- names(custom_tables())
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("lbMode"), label = NULL,
                            choices = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data", ct_names, "Custom"),
                            selected = sel, width = "120px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("lbColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']=='Custom'", ns("lbMode")),
          selectizeInput(ns("lbCustomCols"), label = NULL,
                         choices = setdiff(all_table_cols, "Pitch"),
                         multiple = TRUE,
                         options = list(placeholder = "Choose columns to show…"))
        )
      )
    })
    
    # Build leaderboard table by player for the selected domain (Pitching path you already had)
    output$lbTable <- DT::renderDataTable({
      df <- filtered_lb()
      validate(need(nrow(df) > 0, "No data for selected filters"))
      
      player_col <- switch(input$domain,
                           "Pitching" = "Pitcher",
                           "Hitting"  = "Batter",
                           "Catching" = "Catcher")
      if (!player_col %in% names(df)) {
        return(DT::datatable(data.frame(Message = "Player column not found"), options = list(dom = 't')))
      }
      
      df <- df %>% dplyr::filter(!is.na(.data[[player_col]]) & nzchar(.data[[player_col]]))
      by_player <- split(df, df[[player_col]])
      
      res_mode <- resolve_table_mode_global(input$lbMode, input$lbCustomCols)
      mode <- res_mode$mode
      custom <- res_mode$cols
      # Check for Raw Data mode first
      if (identical(mode, "Raw Data")) {
        # Helper function for innings pitched calculation
        ip_calculation <- function(pitches_data) {
          outs <- sum(pitches_data$KorBB == "Strikeout", na.rm = TRUE) + 
            sum(pitches_data$PlayResult %in% c("Out", "FieldersChoice", "Error"), na.rm = TRUE)
          innings <- outs / 3
          whole_innings <- floor(innings)
          remaining_outs <- outs %% 3
          if (remaining_outs == 0) {
            return(paste0(whole_innings, ".0"))
          } else {
            return(paste0(whole_innings, ".", remaining_outs))
          }
        }
        
        rows <- lapply(by_player, function(dfi) {
          all_ip <- ip_calculation(dfi)
          all_p <- nrow(dfi)
          # Completed BF calculation (shared)
          all_bf <- calculate_bf(dfi)
          all_h <- sum(dfi$PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
          all_xbh <- sum(dfi$PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE)
          all_barrels <- sum(dfi$ExitSpeed >= 95 & dfi$Angle >= 10 & dfi$Angle <= 35, na.rm = TRUE)
          all_bb <- sum(dfi$KorBB == "Walk", na.rm = TRUE)
          all_hbp <- sum(dfi$PlayResult == "HitByPitch", na.rm = TRUE)
          all_k <- sum(dfi$KorBB == "Strikeout", na.rm = TRUE)
          all_whiffs <- sum(dfi$PitchCall == "StrikeSwinging", na.rm = TRUE)
          
          # Calculate P/IP and P/BF for the player
          # Convert IP from "X.Y" format to decimal (X + Y/3)
          ip_decimal <- if (all_ip != "0.0") {
            parts <- strsplit(all_ip, "\\.")[[1]]
            as.numeric(parts[1]) + as.numeric(parts[2])/3
          } else 0
          
          p_per_ip <- if (ip_decimal > 0) as.character(round(all_p / ip_decimal, 1)) else ""
          p_per_bf <- if (all_bf > 0) as.character(round(all_p / all_bf, 1)) else ""
          
          tibble::tibble(
            Player = as.character(dfi[[player_col]][1]),
            IP = all_ip,
            P = all_p,
            BF = all_bf,
            `P/IP` = p_per_ip,
            `P/BF` = p_per_bf,
            H = all_h,
            XBH = all_xbh,
            Barrels = all_barrels,
            BB = all_bb,
            HBP = all_hbp,
            K = all_k,
            Whiffs = all_whiffs
          )
        })
        
        out_tbl <- dplyr::bind_rows(rows)
        visible_set <- c("Player", "IP", "P", "BF", "P/IP", "P/BF", "H", "XBH", "Barrels", "BB", "HBP", "K", "Whiffs")
        
        tryCatch({
          # Only enable colors for Pitching domain, disable for Hitting and Catching
          use_colors <- isTRUE(input$lbColors) && input$domain == "Pitching"
          datatable_with_colvis(
            out_tbl,
            lock            = "Player",
            remember        = FALSE,
            default_visible = visible_set,
            mode            = "Raw Data",
            enable_colors   = use_colors
          )
        }, error = function(e) {
          message("lbTable Raw Data error: ", conditionMessage(e))
          DT::datatable(
            data.frame(Message = "Error creating table"),
            options = list(dom = 't'), rownames = FALSE
          )
        })
      } else {
        # Normal mode processing
        
        build_all_row <- function(df) {
          scalar_chr <- function(x) {
            if (length(x) < 1) return("")
            as.character(x[[1]])
          }
          scalar_num <- function(x) {
            x <- suppressWarnings(as.numeric(x))
            if (length(x) < 1) return(NA_real_)
            v <- x[[1]]
            if (is.finite(v)) v else NA_real_
          }
          safe_pct <- function(num, den) {
            num <- suppressWarnings(as.numeric(num)); den <- suppressWarnings(as.numeric(den))
            out <- ifelse(is.finite(den) & den > 0 & is.finite(num), paste0(round(100*num/den, 1), "%"), "")
            scalar_chr(out)
          }
          nz_mean_local <- function(x) {
            x <- suppressWarnings(as.numeric(x))
            m <- mean(x, na.rm = TRUE)
            if (is.finite(m)) m else NA_real_
          }
          
          scores <- ifelse(
            df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
              df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
            ifelse(
              df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5),
              0.73, 0
            )
          )
          has_pc  <- sum(!is.na(df$PitchCall)) > 0
          strikes <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
          sw      <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
          den     <- sum(df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
          csw_all  <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE)
          
          df_live <- dplyr::filter(df, SessionType == "Live")
          bf_live <- calculate_bf(df_live)
          fps_opp <- sum(df_live$Balls == 0 & df_live$Strikes == 0, na.rm = TRUE)
          # Use completed BF (shared calculation)
          bf_use <- calculate_bf(df)
          
          # For Live-specific metrics, always filter to Live regardless of sessionType
          k_live  <- sum(df_live$KorBB == "Strikeout", na.rm = TRUE)
          bb_live <- sum(df_live$KorBB == "Walk",      na.rm = TRUE)
          fps_live <- sum(df_live$Balls == 0 & df_live$Strikes == 0 &
                            df_live$PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"),
                          na.rm = TRUE)
          ea_live  <- sum(
            (df_live$Balls == 0 & df_live$Strikes == 0 & df_live$PitchCall == "InPlay") |
              (df_live$Balls == 0 & df_live$Strikes == 1 & df_live$PitchCall %in% c(
                "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
              )) |
              (df_live$Balls == 1 & df_live$Strikes == 0 & df_live$PitchCall == "InPlay") |
              (df_live$Balls == 1 & df_live$Strikes == 1 & df_live$PitchCall %in% c(
                "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
              )),
            na.rm = TRUE
          )
          
          vmax   <- suppressWarnings(max(as.numeric(df$RelSpeed), na.rm = TRUE)); vmax <- if (is.finite(vmax)) round(vmax, 1) else NA_real_
          ev_all <- nz_mean_local(ifelse(df$SessionType=="Live", df$ExitSpeed, NA_real_))
          la_all <- nz_mean_local(ifelse(df$SessionType=="Live", df$Angle,     NA_real_))
          stuff_all <- round(nz_mean_local(df$`Stuff+`), 1)
          ctrl_all   <- round(nz_mean_local(scores) * 100, 1)
          qp_vals   <- compute_qp_points(df)
          qp_all    <- round(nz_mean_local(qp_vals) * 200, 1)
          qp_pct    <- safe_pct(sum((qp_vals * 200) >= 100, na.rm = TRUE), nrow(df))
          
          tibble::tibble(
            `#`            = nrow(df),
            Usage          = "100%",
            BF             = scalar_num(bf_use),
            Velo           = scalar_num(round(nz_mean_local(df$RelSpeed), 1)),
            Max            = scalar_num(vmax),
            IVB            = scalar_num(round(nz_mean_local(df$InducedVertBreak), 1)),
            HB             = scalar_num(round(nz_mean_local(df$HorzBreak), 1)),
            rTilt          = scalar_chr(convert_to_clock(nz_mean_local(df$ReleaseTilt))),
            bTilt          = scalar_chr(convert_to_clock(nz_mean_local(df$BreakTilt))),
            SpinEff        = { v <- nz_mean_local(df$SpinEfficiency); scalar_chr(if (is.na(v)) "" else paste0(round(v*100,1), "%")) },
            Spin           = scalar_num(round(nz_mean_local(df$SpinRate), 0)),
            Height         = scalar_num(round(nz_mean_local(df$RelHeight), 1)),
            Side           = scalar_num(round(nz_mean_local(df$RelSide), 1)),
            VAA            = scalar_num(round(nz_mean_local(df$VertApprAngle), 1)),
            HAA            = scalar_num(round(nz_mean_local(df$HorzApprAngle), 1)),
            Ext            = scalar_num(round(nz_mean_local(df$Extension), 1)),
            `InZone%`      = { inzone <- (df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
                                            df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP);
            safe_pct(sum(inzone, na.rm = TRUE), sum(!is.na(inzone))) },
            `Comp%`        = { comp <- (df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                                          df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5));
            safe_pct(sum(comp, na.rm = TRUE), sum(!is.na(comp))) },
            `Strike%`      = if (has_pc) safe_pct(strikes, nrow(df)) else "",
            `FPS%`         = safe_pct(fps_live, fps_opp),
            `E+A%`         = safe_pct(ea_live,  fps_opp),
            `QP%`          = qp_pct,
            `K%`           = safe_pct(k_live,   bf_live),
            `BB%`          = safe_pct(bb_live,  bf_live),
            `Whiff%`       = safe_pct(sw, den),
            `CSW%`         = if (has_pc) safe_pct(csw_all, nrow(df)) else "",
            EV             = scalar_num(round(ev_all, 1)),
            LA             = scalar_num(round(la_all, 1)),
            `Stuff+`       = scalar_num(stuff_all),
            `Ctrl+`        = scalar_num(ctrl_all),
            `QP+`          = scalar_num(qp_all),
            `Pitching+`    = scalar_num(round((stuff_all + qp_all)/2, 1))
          )
        }
        
        original_data <- if (identical(mode, "Usage")) filtered_lb_before_pitch_type() else NULL
        
        rows <- lapply(by_player, function(dfi) {
          # Flatten any list-cols that break downstream summaries
          dfi <- dfi %>% dplyr::mutate(dplyr::across(where(is.list), ~unlist(.x)))
          base_row <- build_all_row(dfi)
          coerce_extras_types <- function(df_ex) {
            if (!"IP" %in% names(df_ex)) df_ex$IP <- NA_character_
            df_ex$IP <- as.character(df_ex$IP)
            pct_cols <- intersect(c("GB%","Barrel%"), names(df_ex))
            if (length(pct_cols)) {
              df_ex[pct_cols] <- lapply(df_ex[pct_cols], function(z) {
                z_chr <- as.character(z)
                z_chr[z_chr == ""] <- NA_character_
                z_chr
              })
            }
            num_cols <- intersect(c("BABIP","AVG","SLG","xWOBA","xISO","FIP","WHIP","RV/100"), names(df_ex))
            for (nm in num_cols) df_ex[[nm]] <- suppressWarnings(as.numeric(df_ex[[nm]]))
            df_ex
          }
          extras_all <- compute_process_results(dfi) %>%
            dplyr::filter(PitchType == "All") %>%
            dplyr::select(IP, BABIP, `GB%`, `Barrel%`, AVG, SLG, xWOBA, xISO, FIP, WHIP, `RV/100`) %>%
            coerce_extras_types()
          if (!nrow(extras_all)) {
            extras_all <- tibble::tibble(
              IP = NA_character_, BABIP = NA_real_, `GB%` = NA_real_, `Barrel%` = NA_real_,
              AVG = NA_real_, SLG = NA_real_, xWOBA = NA_real_, xISO = NA_real_,
              FIP = NA_real_, WHIP = NA_real_, `RV/100` = NA_real_
            )
          }
          # normalize GB%/Barrel% to character to avoid type clashes across players
          for (nm in c("GB%","Barrel%")) {
            if (nm %in% names(extras_all)) {
              extras_all[[nm]] <- as.character(extras_all[[nm]])
            }
          }
          out_row <- dplyr::bind_cols(
            tibble::tibble(Player = as.character(dfi[[player_col]][1])),
            base_row,
            extras_all
          )
          if (identical(mode, "Usage")) {
            player_val <- as.character(dfi[[player_col]][1])
            original_player <- if (!is.null(original_data)) {
              original_data[original_data[[player_col]] == player_val, , drop = FALSE]
            } else NULL
            usage_cols <- compute_usage_by_count(dfi, original_player) %>%
              dplyr::filter(tolower(PitchType) == "all") %>%
              dplyr::select(`0-0`,`Behind`,`Even`,`Ahead`,`<2K`,`2K`)
            if (!nrow(usage_cols)) {
              usage_cols <- tibble::tibble(`0-0` = "", Behind = "", Even = "", Ahead = "", `<2K` = "", `2K` = "")
            }
            out_row <- dplyr::bind_cols(out_row, usage_cols)
          }
          out_row
        })
        
        out_tbl <- dplyr::bind_rows(rows) %>% dplyr::relocate(Player)
        if ("IP" %in% names(out_tbl)) {
          out_tbl$IP <- as.character(out_tbl$IP)
        }
        # Reorder columns for custom
        if (identical(mode, "Custom")) {
          order_cols <- unique(c("Player", custom))
          extras <- setdiff(names(out_tbl), order_cols)
          out_tbl <- out_tbl[, c(order_cols, extras), drop = FALSE]
        }
        
        if (identical(mode, "Process")) {
          out_tbl <- tryCatch(
            enforce_process_order(out_tbl),
            error = function(e) {
              message("leaderboard enforce_process_order error: ", conditionMessage(e))
              out_tbl
            }
          )
          out_tbl <- tryCatch(
            fill_all_qp_pct(out_tbl, df),
            error = function(e) {
              message("leaderboard fill_all_qp_pct error: ", conditionMessage(e))
              out_tbl
            }
          )
        }
        if (identical(mode, "Stuff")) {
          out_tbl <- tryCatch(
            enforce_stuff_order(out_tbl),
            error = function(e) {
              message("leaderboard enforce_stuff_order error: ", conditionMessage(e))
              out_tbl
            }
          )
        }
        
        visible_set <- visible_set_for_lb(mode, custom)
        
        if ("Pitching+" %in% names(out_tbl)) {
          suppressWarnings(out_tbl <- out_tbl %>% dplyr::arrange(dplyr::desc(as.numeric(`Pitching+`))))
        }
        
        # Add error handling wrapper for leaderboard table
        build_lb_dt <- function(data, ...) {
          tryCatch(
            datatable_with_colvis(data, ...),
            error = function(e) {
              message("lbTable datatable error [mode=", mode, "]: ", conditionMessage(e))
              message("Columns: ", paste(names(data), collapse = ", "))
              # Return a fallback datatable with error message
              DT::datatable(
                data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
                options = list(dom = 't'), rownames = FALSE
              )
            }
          )
        }
        
        build_lb_dt(
          out_tbl,
          lock            = "Player",
          remember        = FALSE,
          default_visible = intersect(visible_set, names(out_tbl)),
          mode            = mode
        )
      } # End of else block for normal modes
    }, server = FALSE)
    
    # ==========================
    # Leaderboard: Hitting (PLAYER)
    # ==========================
    output$lbHitButtons <- renderUI({
      req(input$domain == "Hitting")
      ct_names <- names(custom_tables())
      tagList(
        div(style = "display:flex; align-items:center; gap:12px;",
            selectInput(
              ns("lbHitMode"), label = NULL,
              choices = c("Results", "Swing Decisions", ct_names, "Custom"),
              selected = "Results", width = "170px"
            )
        ),
        conditionalPanel(
          sprintf("input['%s']==='Custom'", ns("lbHitMode")),
          selectizeInput(
            ns("lbHitCustomCols"), NULL,
            choices = c(
              "PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
              "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA",
              "FPS%","Called%","Chase%","GoZoneSw%","IZswing%","EdgeSwing%","PosSD%"
            ),
            selected = c("PA","AB","AVG","SLG","OBP","OPS"),
            multiple = TRUE, options = list(placeholder = "Pick columns…")
          )
        )
      )
    })
    
    output$lbHitTable <- DT::renderDataTable({
      req(input$domain == "Hitting")
      
      df <- filtered_lb()
      if (!nrow(df)) {
        return(DT::datatable(data.frame(message = "No rows after filters"), rownames = FALSE))
      }
      
      # keep only rows with a Batter name
      df <- df %>% dplyr::filter(!is.na(Batter) & nzchar(Batter))
      if (!nrow(df)) {
        return(DT::datatable(data.frame(message = "No batters for current filters"), rownames = FALSE))
      }
      
      swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
      by_batter <- split(df, df$Batter)
      
      results_rows <- lapply(by_batter, function(dfi) {
        # Terminal rows = completed PA for THIS batter
        is_term_i <- (
          (!is.na(dfi$PlayResult) & dfi$PlayResult != "Undefined") |
            (!is.na(dfi$KorBB) & dfi$KorBB %in% c("Strikeout","Walk"))
        )
        term <- dfi[is_term_i, , drop = FALSE]
        
        # Tallies
        PAt     <- nrow(term)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        SF_all  <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        IBB_all <- sum(term$PlayResult == "IntentionalWalk", na.rm = TRUE)
        H1      <- sum(term$PlayResult == "Single",  na.rm = TRUE)
        H2      <- sum(term$PlayResult == "Double",  na.rm = TRUE)
        H3      <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
        HR      <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        H_all   <- H1 + H2 + H3 + HR
        TB_all  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
        Kct_all <- sum(term$KorBB == "Strikeout" |
                         term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
        BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        ABt     <- PAt - (BBc_all + HBP_all + Sac_all)
        ISO_all <- safe_div(TB_all, ABt) - safe_div(H_all, ABt)
        uBB_all <- BBc_all - IBB_all
        wOBA_all <- {
          num <- 0.690*uBB_all + 0.722*HBP_all + 0.888*H1 + 1.271*H2 + 1.616*H3 + 2.101*HR
          den <- ABt + BBc_all - IBB_all + SF_all + HBP_all
          safe_div(num, den)
        }
        
        swings_all <- sum(!is.na(dfi$PitchCall) & dfi$PitchCall %in% swing_levels, na.rm = TRUE)
        whiffs_all <- sum(dfi$PitchCall == "StrikeSwinging", na.rm = TRUE)
        
        bbe_i <- dfi %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)),
                                       PitchCall == "InPlay")
        EV_i <- nz_mean(bbe_i$ExitSpeed)
        LA_i <- nz_mean(bbe_i$Angle)
        GB_i <- safe_div(sum(bbe_i$TaggedHitType == "GroundBall", na.rm = TRUE),
                         sum(!is.na(bbe_i$TaggedHitType), na.rm = TRUE))
        
        # extras from processor for this batter (prefer "All" row)
        extras_all <- compute_process_results(dfi) %>%
          dplyr::filter(PitchType == "All") %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::summarise(
            xWOBA = nz_mean(xWOBA), xISO = nz_mean(xISO),
            BABIP = nz_mean(BABIP), BarrelFrac = nz_mean(`Barrel%`)
          )
        
        # Barrel% value: from processor OR fallback to flags on batted balls
        barrel_frac <- extras_all$BarrelFrac[1]
        if (is.na(barrel_frac)) {
          barrel_frac <- barrel_share_from_flags(bbe_i)
        }
        
        tibble::tibble(
          Player = as.character(dfi$Batter[1]),
          PA  = PAt,
          AB  = ABt,
          AVG = safe_div(H_all, ABt),
          SLG = safe_div(TB_all, ABt),
          OBP = safe_div(H_all + BBc_all + HBP_all, PAt),
          OPS = NA_real_,
          wOBA = wOBA_all,
          xWOBA = extras_all$xWOBA[1],
          ISO   = ISO_all,
          xISO  = extras_all$xISO[1],
          BABIP = extras_all$BABIP[1],
          `Swing%` = safe_div(swings_all, nrow(dfi)),
          `Whiff%` = safe_div(whiffs_all, swings_all),
          `GB%`    = GB_i,
          `K%`     = safe_div(Kct_all, PAt),
          `BB%`    = safe_div(BBc_all, PAt),
          `Barrel%`= barrel_frac,
          EV = EV_i,
          LA = LA_i
        ) %>% dplyr::mutate(OPS = SLG + OBP)
      })
      
      # Swing Decisions rows per batter
      sd_rows <- lapply(by_batter, function(dfi) {
        inner_half <- 7 / 12
        mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
        mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
        green_xmin <- mid_x - inner_half
        green_xmax <- mid_x + inner_half
        green_ymin <- mid_y - inner_half
        green_ymax <- mid_y + inner_half
        
        df_sd <- dfi %>%
          dplyr::mutate(
            is_swing = !is.na(PitchCall) & PitchCall %in% c("StrikeSwinging","FoulBall","FoulBallFieldable","FoulBallNotFieldable","InPlay"),
            in_green = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
              PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
              PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
            in_zone = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
              PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
              PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
            possd_point = dplyr::case_when(
              in_green & is_swing ~ 2,
              in_green & !is_swing ~ -1,
              in_zone & !in_green & is_swing ~ 1,
              in_zone & !in_green & !is_swing ~ 0,
              !in_zone & is_swing ~ -1,
              !in_zone & !is_swing ~ 1,
              TRUE ~ 0
            )
          )
        
        summarize_sd <- function(dat) {
          total_pitches <- nrow(dat)
          swings <- sum(dat$is_swing, na.rm = TRUE)
          fps_num <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0 &
                           !is.na(dat$PitchCall) & dat$PitchCall %in% c("StrikeSwinging","InPlay","FoulBall","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
          fps_den <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0, na.rm = TRUE)
          called <- sum(!is.na(dat$PitchCall) & dat$PitchCall == "StrikeCalled", na.rm = TRUE)
          chase_num <- sum(dat$is_swing & !dat$in_zone, na.rm = TRUE)
          chase_den <- sum(!dat$in_zone, na.rm = TRUE)
          gozone_sw_num <- sum(dat$is_swing & dat$in_green, na.rm = TRUE)
          gozone_sw_den <- sum(dat$in_green, na.rm = TRUE)
          iz_sw_num <- sum(dat$is_swing & dat$in_zone, na.rm = TRUE)
          iz_sw_den <- sum(dat$in_zone, na.rm = TRUE)
          edge_sw_num <- sum(dat$is_swing & dat$in_zone & !dat$in_green, na.rm = TRUE)
          edge_sw_den <- sum(dat$in_zone & !dat$in_green, na.rm = TRUE)
          possd_points <- sum(dat$possd_point, na.rm = TRUE)
          
          tibble::tibble(
            `Swing%` = safe_div(swings, total_pitches) * 100,
            `FPS%` = safe_div(fps_num, fps_den) * 100,
            `Called%` = safe_div(called, total_pitches) * 100,
            `Chase%` = safe_div(chase_num, chase_den) * 100,
            `GoZoneSw%` = safe_div(gozone_sw_num, gozone_sw_den) * 100,
            `IZswing%` = safe_div(iz_sw_num, iz_sw_den) * 100,
            `EdgeSwing%` = safe_div(edge_sw_num, edge_sw_den) * 100,
            `PosSD%` = safe_div(possd_points, total_pitches) * 100
          )
        }
        
        sd_vals <- summarize_sd(df_sd)
        sd_vals <- sd_vals %>%
          dplyr::mutate(dplyr::across(dplyr::everything(), ~ ifelse(is.finite(.), round(.,1), NA_real_)))
        
        tibble::tibble(
          Player = as.character(dfi$Batter[1])
        ) %>% dplyr::bind_cols(sd_vals)
      })
      
      res_tbl <- dplyr::bind_rows(results_rows)
      sd_tbl  <- dplyr::bind_rows(sd_rows)
      
      res_mode <- resolve_table_mode_global(input$lbHitMode, input$lbHitCustomCols)
      mode   <- res_mode$mode
      custom <- res_mode$cols
      if (mode %in% names(custom_tables())) {
        mode <- "Custom"
        custom <- custom_tables()[[res_mode$mode]]$cols %||% character(0)
      }
      
      if (identical(mode, "Swing Decisions")) {
        out <- sd_tbl
        pct_cols <- c("Swing%","FPS%","Called%","Chase%","GoZoneSw%","IZswing%","EdgeSwing%","PosSD%")
        out[pct_cols] <- lapply(out[pct_cols], function(z) ifelse(is.finite(z), paste0(round(z,1), "%"), ""))
        default_visible <- c("Player", pct_cols)
        if (identical(mode, "Custom")) {
          default_visible <- unique(c("Player", custom))
        }
        return(datatable_with_colvis(
          out,
          lock = "Player",
          remember = FALSE,
          default_visible = intersect(default_visible, names(out)),
          enable_colors = FALSE
        ))
      }
      
      out <- res_tbl
      # coerce numerics (avoid backtick headaches with tidyselect)
      num_cols <- c("PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
                    "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
      out <- out %>%
        dplyr::mutate(
          dplyr::across(dplyr::all_of(num_cols), ~ suppressWarnings(as.numeric(.)))
        )
      
      # EV / LA -> 1 decimal
      out$EV <- ifelse(is.finite(out$EV), round(out$EV, 1), out$EV)
      out$LA <- ifelse(is.finite(out$LA), round(out$LA, 1), out$LA)
      
      # 3-dec rates (no leading 0); percents to 0–100%
      pct_cols  <- c("Swing%","Whiff%","GB%","K%","BB%","Barrel%")
      rate_cols <- c("AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP")
      out[pct_cols]  <- lapply(out[pct_cols],  function(z) ifelse(is.finite(z), paste0(round(z*100,1), "%"), ""))
      out[rate_cols] <- lapply(out[rate_cols], fmt_rate3)
      
      # Default visible columns per mode / custom
      default_visible <- if (identical(mode, "Custom")) {
        unique(c("Player", custom))
      } else {
        c("Player","PA","AB","AVG","SLG","OBP","OPS",
          "wOBA","xWOBA","ISO","xISO","BABIP","GB%","Barrel%",
          "Swing%","Whiff%","K%","BB%","EV","LA")
      }
      
      # Sort by OPS desc by default
      suppressWarnings(out <- out %>% dplyr::arrange(dplyr::desc(as.numeric(OPS))))
      
      # Add error handling wrapper for hitting leaderboard table
      build_lbhit_dt <- function(data, ...) {
        tryCatch(
          datatable_with_colvis(data, ...),
          error = function(e) {
            message("lbHitTable datatable error [mode=", mode, "]: ", conditionMessage(e))
            message("Columns: ", paste(names(data), collapse = ", "))
            # Return a fallback datatable with error message
            DT::datatable(
              data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
              options = list(dom = 't'), rownames = FALSE
            )
          }
        )
      }
      
      if (identical(mode, "Custom")) {
        order_cols <- unique(c("Player", custom))
        extras <- setdiff(names(out), order_cols)
        out <- out[, c(order_cols, extras), drop = FALSE]
      }
      
      pct_cols  <- intersect(c("Swing%","Whiff%","GB%","K%","BB%","Barrel%"), names(out))
      rate_cols <- intersect(c("AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP"), names(out))
      build_lbhit_dt(
        out,
        lock            = "Player",
        remember        = FALSE,
        default_visible = intersect(default_visible, names(out)),
        enable_colors   = FALSE
      )
    }, server = FALSE)
    
    # ==========================
    # Leaderboard: Catching (PLAYER)
    # ==========================
    output$lbCatchButtons <- renderUI({
      ct_names <- names(custom_tables())
      tagList(
        div(style = "display: flex; align-items: center; gap: 15px;",
            div(style = "flex: 0 0 auto;",
                selectInput(ns("lbCatchMode"), label = NULL,
                            choices = c("Data", ct_names, "Custom"), selected = "Data", width = "140px")
            ),
            div(style = "flex: 0 0 auto;",
                checkboxInput(ns("lbCatchColors"), 
                              label = "Color-Code", 
                              value = TRUE,
                              width = "80px")
            )
        ),
        conditionalPanel(
          sprintf("input['%s']==='Custom'", ns("lbCatchMode")),
          selectizeInput(
            ns("lbCatchCustomCols"), label = NULL,
            choices = c("#","Velo","ExchangeTime","PopTime","SL+"),
            multiple = TRUE,
            options = list(placeholder = "Choose columns…")
          )
        )
      )
    })
    
    output$lbCatchTable <- DT::renderDataTable({
      req(is_active(), input$domain == "Catching")
      
      df_all <- filtered_lb()
      df_all <- df_all %>% dplyr::filter(!is.na(Catcher) & nzchar(Catcher))
      if (!nrow(df_all)) {
        return(DT::datatable(data.frame(Note = "No rows for current filters."), options = list(dom = 't'), rownames = FALSE))
      }
      
      to_num <- function(x) suppressWarnings(as.numeric(x))
      
      # pre-compute take buckets
      takes_all   <- tryCatch({
        pitch_call_safe <- as.character(df_all$PitchCall)
        (!is.na(pitch_call_safe)) & (pitch_call_safe %in% c("StrikeCalled","BallCalled"))
      }, error = function(e) rep(FALSE, nrow(df_all)))
      buckets_all <- inzone_label(df_all$PlateLocSide, df_all$PlateLocHeight)
      
      by_catcher <- split(seq_len(nrow(df_all)), df_all$Catcher)  # split by index for reuse
      
      rows <- lapply(names(by_catcher), function(name) {
        idx <- by_catcher[[name]]
        dfi <- df_all[idx, , drop = FALSE]
        
        # SL+ for this catcher across all takes
        takes   <- takes_all[idx]
        buckets <- buckets_all[idx]
        
        base_tbl <- dplyr::tibble(
          take   = takes,
          bucket = buckets,
          is_cs  = dfi$PitchCall == "StrikeCalled"
        ) |>
          dplyr::filter(take) |>
          dplyr::group_by(bucket) |>
          dplyr::summarise(cs_rate = mean(is_cs, na.rm = TRUE), n = dplyr::n(), .groups = "drop")
        
        overall_rate <- if (nrow(base_tbl) && sum(base_tbl$n) > 0) {
          sum(base_tbl$cs_rate * base_tbl$n) / sum(base_tbl$n)
        } else NA_real_
        
        rate_for_bucket <- function(b) {
          r <- base_tbl$cs_rate[match(b, base_tbl$bucket)]
          ifelse(is.na(r), overall_rate, r)
        }
        
        obs_all <- if (any(takes, na.rm = TRUE)) mean(dfi$PitchCall[takes] == "StrikeCalled", na.rm = TRUE) else NA_real_
        tb      <- table(buckets[takes])
        exp_all <- if (length(tb)) sum(as.numeric(tb) * vapply(names(tb), rate_for_bucket, numeric(1))) / sum(tb) else NA_real_
        sl_all  <- if (is.finite(obs_all) && is.finite(exp_all) && exp_all > 0) round(100 * obs_all / exp_all, 1) else NA_real_
        
        # Throws: PopTime-present
        dft <- dfi |>
          dplyr::mutate(
            ThrowSpeed_num   = to_num(ThrowSpeed),
            ExchangeTime_num = to_num(ExchangeTime),
            PopTime_num      = to_num(PopTime)
          ) |>
          dplyr::filter(is.finite(PopTime_num))
        
        tibble::tibble(
          Player       = name,
          `#`          = nrow(dft),
          Velo         = if (nrow(dft)) round(mean(dft$ThrowSpeed_num,   na.rm = TRUE), 1) else NA_real_,
          ExchangeTime = if (nrow(dft)) round(mean(dft$ExchangeTime_num, na.rm = TRUE), 1) else NA_real_,
          PopTime      = if (nrow(dft)) round(mean(dft$PopTime_num,      na.rm = TRUE), 2) else NA_real_,
          `SL+`        = sl_all
        )
      })
      
      final <- dplyr::bind_rows(rows)
      
      res_mode <- resolve_table_mode_global(input$lbCatchMode, input$lbCatchCustomCols)
      mode <- res_mode$mode
      custom <- res_mode$cols
      default_visible <- if (identical(mode, "Custom")) {
        unique(c("Player", custom))
      } else {
        c("Player","#","Velo","ExchangeTime","PopTime","SL+")
      }
      if (identical(mode, "Custom")) {
        order_cols <- unique(c("Player", custom))
        extras <- setdiff(names(final), order_cols)
        final <- final[, c(order_cols, extras), drop = FALSE]
      }
      
      # Add error handling wrapper for catching leaderboard table
      build_lbcatch_dt <- function(data, ...) {
        tryCatch(
          datatable_with_colvis(data, ...),
          error = function(e) {
            message("lbCatchTable datatable error [mode=", mode, "]: ", conditionMessage(e))
            message("Columns: ", paste(names(data), collapse = ", "))
            # Return a fallback datatable with error message
            DT::datatable(
              data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
              options = list(dom = 't'), rownames = FALSE
            )
          }
        )
      }
      
      build_lbcatch_dt(
        final,
        lock            = "Player",
        remember        = TRUE,
        default_visible = intersect(default_visible, names(final)),
        enable_colors   = FALSE
      )
    }, server = FALSE)
    
  })  # closes moduleServer
}     # closes mod_leader_server

# ==================================
# == Comparison Suite (new module) ==
# ==================================
mod_comp_ui <- function(id, show_header = FALSE) {
  ns <- NS(id)
  fluidPage(
    if (isTRUE(show_header)) {
      fluidRow(
        class = "suite-header",
        column(2, tags$img(src = "PCUlogo.png", height = "100px")),
        column(
          8,
          div(
            style = "height:100%; display:flex; justify-content:center; align-items:flex-start;",
            tags$h1("UNM Comparison Suite", style = "margin-top:25px; font-weight:bold;")
          )
        ),
        column(2, div(style = "text-align:right; margin-top:10px;",
                      tags$img(src = school_logo, height = "80px", alt = school_display_name)))
      )
    },
    sidebarLayout(
      sidebarPanel(
        selectInput(ns("domain"), "Player Type:", choices = c("Pitcher","Hitter","Catcher"), selected = "Pitcher"),
        selectInput(ns("teamType"), "Team:", choices = TEAM_CHOICES, selected = "All"),
        width = 2
      ),
      mainPanel(
        # ---- TWO-PANEL COMPARISON (same layout as Pitching > Comparison Tool) ----
        fluidRow(
          # -------- LEFT PANEL (A) --------
          column(
            6,
            div(style="font-weight:700; text-align:center; margin-bottom:6px;", "Comparison #1"),
            wellPanel(
              selectInput(
                ns("cmpA_sessionType"), "Session Type:",
                choices  = c("All","Bullpen","Live"),
                selected = "Live"
              ),
              dateRangeInput(
                ns("cmpA_dates"), "Date Range:",
                start = max(pitch_data$Date, na.rm = TRUE),
                end   = max(pitch_data$Date, na.rm = TRUE),
                format = "mm/dd/yyyy"
              ),
              selectInput(
                ns("cmpA_chart"), "Select Chart:",
                choices = c("Movement Plot","Release Plot","HeatMap","Location Chart"),
                selected = "HeatMap"
              ),
              conditionalPanel(
                sprintf("input['%s']=='HeatMap'", ns("cmpA_chart")),
                selectInput(
                  ns("cmpA_hmStat"), "Select HeatMap:",
                  choices = c("Frequency","Whiff Rate","Exit Velocity","GB Rate","Contact Rate","Swing Rate","Run Values"),
                  selected = "Frequency"
                )
              ),
              conditionalPanel(
                sprintf("input['%s']=='Location Chart'", ns("cmpA_chart")),
                selectInput(
                  ns("cmpA_result"), "Pitch Results:",
                  choices  = c("All", result_levels),
                  selected = "All",
                  multiple = TRUE
                )
              ),
              # dynamic player select (label & choices depend on Player Type)
              uiOutput(ns("cmpA_player_ui")),
              selectInput(ns("cmpA_hand"),   "Pitcher Hand:", choices = c("All","Left","Right"), selected = "All"),
              selectInput(ns("cmpA_batter"), "Batter Hand:",  choices = c("All","Left","Right"), selected = "All"),
              selectInput(ns("cmpA_qpLocations"), "QP Locations:", choices = c("All", "Yes", "No"), selected = "All"),
              selectInput(
                ns("cmpA_pitchType"),"Pitch Type:",
                choices  = c("All", levels(pitch_data$TaggedPitchType)),
                selected = "All", multiple = TRUE
              ),
              selectInput(
                ns("cmpA_pitchResults"), "Pitch Results:",
                choices  = c("All", result_levels),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpA_countFilter"), "Count:",
                choices = c(
                  "All" = "All",
                  "Even"   = "Even",
                  "Behind" = "Behind",
                  "Ahead"      = "Ahead",
                  "2K Not Full"= "2KNF",
                  "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
                ),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpA_afterCountFilter"), "After Count:",
                choices = c(
                  "All" = "All",
                  "Even"   = "Even",
                  "Behind" = "Behind",
                  "Ahead"      = "Ahead",
                  "2K Not Full"= "2KNF",
                  "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
                ),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpA_zone"),"Zone Location:",
                choices = c("All",
                            "Upper Half","Bottom Half","Left Half","Right Half",
                            "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
                selected = "All",
                multiple = TRUE
              ),
              fluidRow(
                column(6, numericInput(ns("cmpA_veloMin"), "Velocity Min (MPH):", value = NA)),
                column(6, numericInput(ns("cmpA_veloMax"), "Velocity Max (MPH):", value = NA))
              ),
              fluidRow(
                column(6, numericInput(ns("cmpA_ivbMin"), "IVB Min (inches):", value = NA)),
                column(6, numericInput(ns("cmpA_ivbMax"), "IVB Max (inches):", value = NA))
              ),
              fluidRow(
                column(6, numericInput(ns("cmpA_hbMin"), "HB Min (inches):", value = NA)),
                column(6, numericInput(ns("cmpA_hbMax"), "HB Max (inches):", value = NA))
              )
            ),
            # Single switchable plot container (prevents double-render)
            uiOutput(ns("cmpA_plot_ui"))
          ),
          
          # -------- RIGHT PANEL (B) --------
          column(
            6,
            div(style="font-weight:700; text-align:center; margin-bottom:6px;", "Comparison #2"),
            wellPanel(
              selectInput(
                ns("cmpB_sessionType"), "Session Type:",
                choices  = c("All","Bullpen","Live"),
                selected = "Live"
              ),
              dateRangeInput(
                ns("cmpB_dates"), "Date Range:",
                start = max(pitch_data$Date, na.rm = TRUE),
                end   = max(pitch_data$Date, na.rm = TRUE),
                format = "mm/dd/yyyy"
              ),
              selectInput(
                ns("cmpB_chart"), "Select Chart:",
                choices = c("Movement Plot","Release Plot","HeatMap","Location Chart"),
                selected = "HeatMap"
              ),
              conditionalPanel(
                sprintf("input['%s']=='HeatMap'", ns("cmpB_chart")),
                selectInput(
                  ns("cmpB_hmStat"), "Select HeatMap:",
                  choices = c("Frequency","Whiff Rate","Exit Velocity","GB Rate","Contact Rate","Swing Rate","Run Values"),
                  selected = "Frequency"
                )
              ),
              conditionalPanel(
                sprintf("input['%s']=='Location Chart'", ns("cmpB_chart")),
                selectInput(
                  ns("cmpB_result"), "Pitch Results:",
                  choices  = c("All", result_levels),
                  selected = "All",
                  multiple = TRUE
                )
              ),
              uiOutput(ns("cmpB_player_ui")),
              selectInput(ns("cmpB_hand"),   "Pitcher Hand:", choices = c("All","Left","Right"), selected = "All"),
              selectInput(ns("cmpB_batter"), "Batter Hand:",  choices = c("All","Left","Right"), selected = "All"),
              selectInput(ns("cmpB_qpLocations"), "QP Locations:", choices = c("All", "Yes", "No"), selected = "All"),
              selectInput(
                ns("cmpB_pitchType"),"Pitch Type:",
                choices  = c("All", levels(pitch_data$TaggedPitchType)),
                selected = "All", multiple = TRUE
              ),
              selectInput(
                ns("cmpB_pitchResults"), "Pitch Results:",
                choices  = c("All", result_levels),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpB_countFilter"), "Count:",
                choices = c(
                  "All" = "All",
                  "Even"   = "Even",
                  "Behind" = "Behind",
                  "Ahead"      = "Ahead",
                  "2K Not Full"= "2KNF",
                  "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
                ),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpB_afterCountFilter"), "After Count:",
                choices = c(
                  "All" = "All",
                  "Even"   = "Even",
                  "Behind" = "Behind",
                  "Ahead"      = "Ahead",
                  "2K Not Full"= "2KNF",
                  "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"
                ),
                selected = "All",
                multiple = TRUE
              ),
              selectInput(
                ns("cmpB_zone"),"Zone Location:",
                choices = c("All",
                            "Upper Half","Bottom Half","Left Half","Right Half",
                            "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
                selected = "All",
                multiple = TRUE
              ),
              fluidRow(
                column(6, numericInput(ns("cmpB_veloMin"), "Velocity Min (MPH):", value = NA)),
                column(6, numericInput(ns("cmpB_veloMax"), "Velocity Max (MPH):", value = NA))
              ),
              fluidRow(
                column(6, numericInput(ns("cmpB_ivbMin"), "IVB Min (inches):", value = NA)),
                column(6, numericInput(ns("cmpB_ivbMax"), "IVB Max (inches):", value = NA))
              ),
              fluidRow(
                column(6, numericInput(ns("cmpB_hbMin"), "HB Min (inches):", value = NA)),
                column(6, numericInput(ns("cmpB_hbMax"), "HB Max (inches):", value = NA))
              )
            ),
            # Single switchable plot container (prevents double-render)
            uiOutput(ns("cmpB_plot_ui"))
          )
        ),
        
        tags$hr(),
        # ---------- STACKED TABLES ----------
        fluidRow(
          column(
            12,
            div(style="font-weight:700; text-align:center; margin-bottom:6px;", "Comparison #1 Table"),
            div(
              style = "margin: 8px 0;",
              tagList(
                div(style = "display: flex; align-items: center; gap: 15px;",
                    div(style = "flex: 0 0 auto;",
                        selectInput(
                          ns("cmpA_tableMode"), label = NULL,
                          choices = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data","Custom"),
                          selected = "Stuff",
                          width = "120px"
                        )
                    ),
                    div(style = "flex: 0 0 auto;",
                        checkboxInput(
                          ns("cmpA_tableColors"), 
                          label = "Color-Code", 
                          value = TRUE,
                          width = "80px"
                        )
                    ),
                    div(style = "flex: 0 0 auto;",
                        div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Split By:"),
                        selectInput(
                          ns("cmpA_splitBy"), label = NULL,
                          choices = c("Pitch Types", "Batter Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Batter"),
                          selected = "Pitch Types",
                          width = "140px"
                        )
                    )
                ),
                conditionalPanel(
                  sprintf("input['%s']=='Custom'", ns("cmpA_tableMode")),
                  selectInput(ns("cmpA_customSaved"), "Saved Table:", choices = c(""), selected = ""),
                  textInput(ns("cmpA_customName"), "Name:", value = ""),
                  selectizeInput(
                    ns("cmpA_customCols"), label = "Columns (drag to order):",
                    choices  = setdiff(all_table_cols, "Pitch"),
                    multiple = TRUE,
                    options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
                  ),
                  actionButton(ns("cmpA_saveCustom"), "Save / Update", class = "btn-primary btn-sm"),
                  actionButton(ns("cmpA_deleteCustom"), "Delete", class = "btn-danger btn-sm")
                )
              )
            ),
            DT::dataTableOutput(ns("cmpA_table"))
          )
        ),
        br(),
        fluidRow(
          column(
            12,
            div(style="font-weight:700; text-align:center; margin-bottom:6px;", "Comparison #2 Table"),
            div(
              style = "margin: 8px 0;",
              tagList(
                div(style = "display: flex; align-items: center; gap: 15px;",
                    div(style = "flex: 0 0 auto;",
                        selectInput(
                          ns("cmpB_tableMode"), label = NULL,
                          choices = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data","Custom"),
                          selected = "Stuff",
                          width = "120px"
                        )
                    ),
                    div(style = "flex: 0 0 auto;",
                        checkboxInput(
                          ns("cmpB_tableColors"), 
                          label = "Color-Code", 
                          value = TRUE,
                          width = "80px"
                        )
                    ),
                    div(style = "flex: 0 0 auto;",
                        div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Split By:"),
                        selectInput(
                          ns("cmpB_splitBy"), label = NULL,
                          choices = c("Pitch Types", "Batter Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Batter"),
                          selected = "Pitch Types",
                          width = "140px"
                        )
                    )
                ),
                conditionalPanel(
                  sprintf("input['%s']=='Custom'", ns("cmpB_tableMode")),
                  selectInput(ns("cmpB_customSaved"), "Saved Table:", choices = c(""), selected = ""),
                  textInput(ns("cmpB_customName"), "Name:", value = ""),
                  selectizeInput(
                    ns("cmpB_customCols"), label = "Columns (drag to order):",
                    choices  = setdiff(all_table_cols, "Pitch"),
                    multiple = TRUE,
                    options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
                  ),
                  actionButton(ns("cmpB_saveCustom"), "Save / Update", class = "btn-primary btn-sm"),
                  actionButton(ns("cmpB_deleteCustom"), "Delete", class = "btn-danger btn-sm")
                )
              )
            ),
            DT::dataTableOutput(ns("cmpB_table"))
          )
        )
      )
    )
  )
} 

mod_comp_server <- function(id, is_active = shiny::reactive(TRUE), global_date_range = NULL) {
  moduleServer(id, function(input, output, session) {
    # Dark-mode flag that respects root-scope toggle
    is_dark_mode <- reactive({
      dm <- tryCatch({
        rs <- session$rootScope()
        if (!is.null(rs) && !is.null(rs$input$dark_mode)) rs$input$dark_mode else NULL
      }, error = function(...) NULL)
      if (is.null(dm) && !is.null(input$dark_mode)) dm <- input$dark_mode
      isTRUE(dm)
    })
    
    # Sync custom table lists into comparison (namespaced) controls
    observe({
      nms <- names(custom_tables())
      base_modes <- c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data")
      currentA <- isolate(input$cmpA_tableMode)
      currentB <- isolate(input$cmpB_tableMode)
      updateSelectInput(session, "cmpA_tableMode", choices = c(base_modes, nms, "Custom"),
                        selected = currentA)
      updateSelectInput(session, "cmpB_tableMode", choices = c(base_modes, nms, "Custom"),
                        selected = currentB)
      updateSelectInput(session, "cmpA_customSaved", choices = c("", nms),
                        selected = isolate(input$cmpA_customSaved))
      updateSelectInput(session, "cmpB_customSaved", choices = c("", nms),
                        selected = isolate(input$cmpB_customSaved))
    })
    
    # Switch table/split choices to match domain (Pitcher vs Hitter)
    observeEvent(input$domain, {
      dom <- input$domain %||% "Pitcher"
      nms <- names(custom_tables())
      if (dom %in% c("Hitter","Catcher","Pitcher","Pitching","Hitting","Catching")) {
        if (dom %in% c("Hitter","Hitting")) {
          tbl_choices <- c("Results","Swing Decisions", nms, "Custom")
          split_choices <- c("Pitch Types", "Pitcher Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Pitcher")
        } else {
          tbl_choices <- c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data", nms, "Custom")
          split_choices <- c("Pitch Types", "Batter Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Batter")
        }
        updateSelectInput(session, "cmpA_tableMode", choices = tbl_choices,
                          selected = tbl_choices[[1]])
        updateSelectInput(session, "cmpB_tableMode", choices = tbl_choices,
                          selected = tbl_choices[[1]])
        updateSelectInput(session, "cmpA_splitBy", choices = split_choices,
                          selected = split_choices[[1]])
        updateSelectInput(session, "cmpB_splitBy", choices = split_choices,
                          selected = split_choices[[1]])
      }
    }, ignoreInit = TRUE)
    
    # Sync local date input with global date range if available
    if (!is.null(global_date_range)) {
      # Comp module has different date input names (cmpA_dates, cmpB_dates)
      observe({
        if (!is.null(global_date_range()) && length(global_date_range()) == 2) {
          updateDateRangeInput(session, "cmpA_dates", 
                               start = global_date_range()[1], 
                               end = global_date_range()[2])
          updateDateRangeInput(session, "cmpB_dates", 
                               start = global_date_range()[1], 
                               end = global_date_range()[2])
        }
      })
    }
    ns <- session$ns
    tooltip_css <- "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
    
    # ---------- Dynamic player pickers ----------
    .player_label <- function(dom) switch(dom,
                                          Pitcher = "Select Pitcher:",
                                          Hitter  = "Select Hitter:",
                                          Catcher = "Select Catcher:"
    )
    .player_choices <- function(dom) {
      switch(
        dom,
        Pitcher = c("All" = "All", name_map_pitching),
        Hitter  = c("All" = "All", batter_map),
        Catcher = c("All" = "All", catcher_map)
      )
    }
    
    # ---------- Helpers ----------
    collapse_list_cols <- function(dat) {
      if (!nrow(dat)) return(dat)
      dat %>%
        dplyr::mutate(dplyr::across(
          dplyr::where(is.list),
          ~ vapply(., function(x) {
            if (is.null(x)) "" else if (length(x) == 1 && !is.list(x)) as.character(x)
            else paste0(unlist(x), collapse = ", ")
          }, character(1))
        ))
    }
    
    # ---------- Player UIs ----------
    output$cmpA_player_ui <- renderUI({
      lab <- .player_label(input$domain)
      selectInput(ns("cmpA_player"), lab, choices = .player_choices(input$domain), selected = "All")
    })
    output$cmpB_player_ui <- renderUI({
      lab <- .player_label(input$domain)
      selectInput(ns("cmpB_player"), lab, choices = .player_choices(input$domain), selected = "All")
    })
    
    .last_date_for <- function(dom, player, st) {
      df <- pitch_data
      # normalize once
      if (!"SessionType_std" %in% names(df)) {
        df$SessionType_std <- {
          x0 <- tolower(trimws(as.character(df$SessionType)))
          dplyr::case_when(
            grepl("bull", x0)         ~ "Bullpen",
            grepl("live|game|ab", x0) ~ "Live",
            TRUE                      ~ "Other"
          )
        }
      }
      if (!is.null(st) && st != "All") {
        df <- df[df$SessionType_std == st, , drop = FALSE]
      }
      if (isTRUE(player == "All") || is.null(player) || !nzchar(player)) {
        return(suppressWarnings(max(df$Date, na.rm = TRUE)))
      }
      col <- switch(dom, "Pitcher" = "Pitcher", "Hitter" = "Batter", "Catcher" = "Catcher", "Pitcher")
      suppressWarnings(max(df$Date[df[[col]] == player], na.rm = TRUE))
    }
    
    observeEvent(list(input$domain, input$cmpA_player, input$cmpA_sessionType), {
      req(is_active())
      last_date <- .last_date_for(input$domain, input$cmpA_player, input$cmpA_sessionType)
      if (is.finite(last_date)) updateDateRangeInput(session, "cmpA_dates", start = last_date, end = last_date)
    }, ignoreInit = TRUE)
    observeEvent(list(input$domain, input$cmpB_player, input$cmpB_sessionType), {
      req(is_active())
      last_date <- .last_date_for(input$domain, input$cmpB_player, input$cmpB_sessionType)
      if (is.finite(last_date)) updateDateRangeInput(session, "cmpB_dates", start = last_date, end = last_date)
    }, ignoreInit = TRUE)
    
    # ---------- Common filtering helper ----------
    normalize_session_type <- function(x) {
      x0 <- tolower(trimws(as.character(x)))
      dplyr::case_when(
        grepl("bull|prac", x0)         ~ "Bullpen",
        grepl("live|game|ab", x0)      ~ "Live",
        TRUE                           ~ "Other"
      )
    }
    
    .filtered_panel <- function(which = c("A","B")) {
      which <- match.arg(which)
      
      dom_in <- (input[[paste0("cmp", which, "_domain")]] %||% input$domain %||% "Pitcher")
      dom <- if (dom_in %in% c("Pitching","Pitcher")) "Pitcher"
      else if (dom_in %in% c("Hitting","Hitter")) "Hitter"
      else if (dom_in %in% c("Catching","Catcher")) "Catcher"
      else "Pitcher"
      
      dates  <- input[[paste0("cmp", which, "_dates")]]
      hand   <- input[[paste0("cmp", which, "_hand")]]
      bats   <- input[[paste0("cmp", which, "_batter")]]
      zone   <- input[[paste0("cmp", which, "_zone")]]
      ptypes <- input[[paste0("cmp", which, "_pitchType")]]
      qpLoc  <- input[[paste0("cmp", which, "_qpLocations")]]
      pr_res <- input[[paste0("cmp", which, "_pitchResults")]]
      cntSel <- input[[paste0("cmp", which, "_countFilter")]]
      afterSel <- input[[paste0("cmp", which, "_afterCountFilter")]]
      vmin   <- input[[paste0("cmp", which, "_veloMin")]]
      vmax   <- input[[paste0("cmp", which, "_veloMax")]]
      ivbmin <- input[[paste0("cmp", which, "_ivbMin")]]
      ivbmax <- input[[paste0("cmp", which, "_ivbMax")]]
      hbmin  <- input[[paste0("cmp", which, "_hbMin")]]
      hbmax  <- input[[paste0("cmp", which, "_hbMax")]]
      player <- input[[paste0("cmp", which, "_player")]]
      stype  <- input[[paste0("cmp", which, "_sessionType")]]
      
      req(dates)
      if (is.null(ptypes)) ptypes <- "All"
      if (is.null(stype)  || !nzchar(stype)) stype <- "Live"
      
      df <- if (identical(dom, "Pitcher") && exists("pitch_data_pitching")) pitch_data_pitching else pitch_data
      if (!nrow(df)) return(df[0, , drop = FALSE])
      
      # Privacy scoping: Coaches see all, Players see only their own data
      if (exists("user_email") && is.function(user_email) &&
          exists("is_admin")   && is.function(is_admin)   &&
          exists("is_coach")   && is.function(is_coach)   &&
          !is_admin() && !is_coach()) {
        ne <- function(x) tolower(trimws(x))
        ue <- user_email()
        if (!is.na(ue) && "Email" %in% names(df)) {
          df <- dplyr::filter(df, ne(Email) == ne(ue))
        }
      }
      if (!nrow(df)) return(df)
      
      if (!("SessionType_std" %in% names(df))) {
        df$SessionType_std <- normalize_session_type(df$SessionType)
      }
      
      df <- dplyr::filter(df, as.Date(Date) >= as.Date(dates[1]),
                          as.Date(Date) <= as.Date(dates[2]))
      if (!nrow(df)) return(df)
      
      if (!is.null(player) && player != "All") {
        df <- switch(
          dom,
          "Pitcher" = dplyr::filter(df, Pitcher == player),
          "Hitter"  = dplyr::filter(df, Batter  == player),
          "Catcher" = dplyr::filter(df, Catcher == player),
          df
        )
      }
      if (!nrow(df)) return(df)
      
      # Add team filtering
      team_type <- input$teamType %||% "All"
      if (team_type == "Campers") {
        df <- switch(
          dom,
          "Pitcher" = dplyr::filter(df, Pitcher %in% ALLOWED_CAMPERS),
          "Hitter"  = dplyr::filter(df, Batter %in% ALLOWED_CAMPERS),
          "Catcher" = dplyr::filter(df, Catcher %in% ALLOWED_CAMPERS),
          df
        )
      } else if (team_type == TEAM_CODE) {
        # GCU team only
        df <- switch(
          dom,
          "Pitcher" = dplyr::filter(df, Pitcher %in% ALLOWED_PITCHERS),
          "Hitter"  = dplyr::filter(df, Batter %in% ALLOWED_HITTERS),
          "Catcher" = dplyr::filter(df, Catcher %in% ALLOWED_PITCHERS),
          df
        )
      }
      # If team_type == "All", no team filtering is applied
      if (!nrow(df)) return(df)
      
      if (stype != "All") df <- df[df$SessionType_std == stype, , drop = FALSE]
      if (!nrow(df)) return(df)
      
      if (!is.null(hand) && hand != "All") df <- dplyr::filter(df, PitcherThrows == hand)
      if (!is.null(bats) && bats != "All") {
        st_std <- df$SessionType_std
        df <- df %>% dplyr::filter(st_std != "Live" | (st_std == "Live" & BatterSide == bats))
      }
      if (!nrow(df)) return(df)
      
      if (!is.null(zone) && !identical(zone, "All")) {
        df <- enforce_zone(df, zone)
        if (!nrow(df)) return(df)
      }
      
      # Count filters
      if (!is.null(cntSel) && !("All" %in% cntSel)) {
        df <- apply_count_filter(df, cntSel)
        if (!nrow(df)) return(df)
      }
      if (!is.null(afterSel) && !("All" %in% afterSel)) {
        df <- apply_after_count_filter(df, afterSel)
        if (!nrow(df)) return(df)
      }
      
      # Apply QP Locations filter
      if (!is.null(qpLoc) && qpLoc != "All") {
        df <- filter_qp_locations(df, qpLoc)
        if (!nrow(df)) return(df)
      }
      
      nnz <- function(x) !is.null(x) && !is.na(x)
      if (nnz(vmin))   df <- dplyr::filter(df, RelSpeed         >= vmin)
      if (nnz(vmax))   df <- dplyr::filter(df, RelSpeed         <= vmax)
      if (nnz(ivbmin)) df <- dplyr::filter(df, InducedVertBreak >= ivbmin)
      if (nnz(ivbmax)) df <- dplyr::filter(df, InducedVertBreak <= ivbmax)
      if (nnz(hbmin))  df <- dplyr::filter(df, HorzBreak        >= hbmin)
      if (nnz(hbmax))  df <- dplyr::filter(df, HorzBreak        <= hbmax)
      if (!nrow(df)) return(df)
      
      if (!("All" %in% ptypes)) df <- dplyr::filter(df, TaggedPitchType %in% ptypes)
      if (!nrow(df)) return(df)
      
      # Pitch Results filter
      df <- apply_pitch_results_filter(df, pr_res)
      if (!nrow(df)) return(df)
      
      df2 <- compute_stuff_simple(df, base_type = "Fastball", level = "College") %>%
        force_pitch_levels() %>%
        dplyr::mutate(Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels))
      attr(df2, "domain") <- dom
      df2
    }
    
    # ---------- PLOTS ----------
    .movement_girafe <- function(df) {
      if (!nrow(df)) return(NULL)
      dark_on <- is_dark_mode()
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      line_col <- if (dark_on) "#ffffff" else "black"
      cols <- if (exists("colors_for_mode")) colors_for_mode(dark_on) else all_colors
      grid_col <- adjustcolor(if (dark_on) "white" else "black",
                              alpha.f = if (dark_on) 0.18 else 0.12)
      df_i <- df %>% dplyr::mutate(tt = make_hover_tt(.), rid = dplyr::row_number())
      types_chr <- as.character(intersect(names(all_colors), unique(df_i$TaggedPitchType)))
      avg_mov <- df %>%
        dplyr::filter(is.finite(HorzBreak), is.finite(InducedVertBreak)) %>%
        dplyr::group_by(TaggedPitchType) %>%
        dplyr::summarise(
          avg_HorzBreak        = mean(HorzBreak, na.rm = TRUE),
          avg_InducedVertBreak = mean(InducedVertBreak, na.rm = TRUE),
          .groups = "drop"
        )
      p <- ggplot() +
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(HorzBreak, InducedVertBreak,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          alpha = 0.25, size = 4.0, shape = 21, stroke = 0.25
        ) +
        geom_point(
          data = avg_mov,
          aes(avg_HorzBreak, avg_InducedVertBreak, color = TaggedPitchType),
          size = 8
        ) +
        geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
        geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
        coord_cartesian(xlim = c(-25, 25), ylim = c(-25, 25)) +
        scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
        scale_fill_manual(values  = cols[types_chr], limits = types_chr, name = NULL) +
        labs(x = "Horizontal Break (in)", y = "Induced Vertical Break (in)") +
        theme_minimal(base_size = 12) + grid_theme(dark_on) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(color = axis_col),
          axis.text.y = element_text(color = axis_col),
          axis.title.x = element_text(color = axis_col),
          axis.title.y = element_text(color = axis_col),
          axis.ticks = element_blank(),
          panel.grid.major = element_line(color = grid_col),
          panel.grid.minor = element_blank()
        )
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_sizing(rescale = TRUE),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
          ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    }
    output$cmpA_movement <- ggiraph::renderGirafe({ .movement_girafe(.filtered_panel("A")) })
    output$cmpB_movement <- ggiraph::renderGirafe({ .movement_girafe(.filtered_panel("B")) })
    
    .release_plot <- function(df) {
      if (!nrow(df)) return(ggplot() + theme_void())
      axis_th <- get0("axis_theme", ifnotfound = theme())
      dark_on <- is_dark_mode()
      axis_col <- if (dark_on) "#e5e7eb" else "black"
      line_col <- if (dark_on) "#ffffff" else "black"
      grid_col <- adjustcolor(if (dark_on) "white" else "black",
                              alpha.f = if (dark_on) 0.18 else 0.12)
      cols <- if (exists("colors_for_mode")) colors_for_mode(dark_on) else all_colors
      types <- if (exists("ordered_types") && is.function(ordered_types)) {
        ot <- as.character(ordered_types()); ot[ot %in% unique(df$TaggedPitchType)]
      } else as.character(intersect(names(all_colors), unique(df$TaggedPitchType)))
      rp_w <- 4; rp_h <- 0.83
      xs <- seq(-rp_w, rp_w, length.out = 100); ys <- rp_h * (1 - (xs / rp_w)^2)
      mound <- data.frame(x = c(xs, rev(xs)), y = c(ys, rep(0, length(xs))))
      avg <- df %>%
        dplyr::group_by(TaggedPitchType) %>%
        dplyr::summarise(
          avg_RelSide   = mean(RelSide,   na.rm = TRUE),
          avg_RelHeight = mean(RelHeight, na.rm = TRUE),
          .groups = "drop"
        ) %>% dplyr::filter(TaggedPitchType %in% types)
      if (!nrow(avg)) return(ggplot() + theme_void())
      ggplot() +
        geom_polygon(data = mound, aes(x, y), fill = "tan", color = "tan") +
        annotate("rect", xmin = -0.5, xmax = 0.5, ymin = rp_h - 0.05, ymax = rp_h + 0.05, fill = "white") +
        geom_vline(xintercept = 0, color = line_col, size = 0.7) +
        geom_hline(yintercept = 0, color = line_col, size = 0.7) +
        geom_point(data = avg, aes(avg_RelSide, avg_RelHeight, color = TaggedPitchType), size = 4) +
        scale_color_manual(values = cols[types], limits = types, name = NULL) +
        theme_minimal() + axis_th + grid_theme(dark_on) +
        theme(
          legend.position = "none",
          axis.text.x = element_text(color = axis_col),
          axis.text.y = element_text(color = axis_col),
          axis.ticks = element_blank(),
          panel.grid.major = element_line(color = grid_col),
          panel.grid.minor = element_blank(),
          panel.background = element_rect(fill = "transparent", color = NA),
          plot.background = element_rect(fill = "transparent", color = NA)
        ) +
        labs(x = NULL, y = NULL)
    }
    output$cmpA_release <- renderPlot({ .release_plot(.filtered_panel("A")) }, bg = "transparent")
    output$cmpB_release <- renderPlot({ .release_plot(.filtered_panel("B")) }, bg = "transparent")
    
    .kde_grid <- function(x, y, lims = c(-2.5, 2.5, 0, 4.5), n = 200, h = NULL) {
      ok <- is.finite(x) & is.finite(y)
      x <- x[ok]; y <- y[ok]
      if (length(x) < 2 || length(unique(x)) < 2 || length(unique(y)) < 2) {
        return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
      }
      
      # Use adaptive bandwidth based on sample size and spread
      if (is.null(h)) {
        n_pts <- length(x)
        x_sd <- sd(x)
        y_sd <- sd(y)
        h_x <- x_sd * (n_pts^(-1/6)) * 1.2
        h_y <- y_sd * (n_pts^(-1/6)) * 1.2
        h <- c(h_x, h_y)
      }
      
      d <- MASS::kde2d(x, y, n = n, lims = lims, h = h)
      expand.grid(x = d$x, y = d$y) |> transform(z = as.vector(d$z))
    }
    
    .heat_plot <- function(df, stat) {
      render_heatmap_stat(df, stat)
    }
    output$cmpA_heat <- renderPlot({ .heat_plot(.filtered_panel("A"), input$cmpA_hmStat) }, bg = "transparent")
    output$cmpB_heat <- renderPlot({ .heat_plot(.filtered_panel("B"), input$cmpB_hmStat) }, bg = "transparent")
    
    .pitch_girafe <- function(df, sel_results) {
      if (!nrow(df)) return(NULL)
      if (!is.null(sel_results) && length(sel_results) && !("All" %in% sel_results)) {
        keep <- as.character(compute_result(df$PitchCall, df$PlayResult)) %in% sel_results
        df <- df[keep, , drop = FALSE]
      }
      if (!nrow(df)) return(NULL)
      dark_on <- is_dark_mode()
      dom <- attr(df, "domain") %||% "Pitcher"
      if (identical(dom, "Hitter")) {
        # Local copy of hitting location plot (with green box)
        return({
          df_subset <- df
          if (!"Result" %in% names(df_subset)) {
            df_subset$Result <- compute_result(df_subset$PitchCall, df_subset$PlayResult)
          }
          line_col <- if (dark_on) "#ffffff" else "black"
          grid_col <- if (dark_on) "#d1d5db" else "black"
          cols <- colors_for_mode(dark_on)
          hit_result_levels <- names(hit_shape_map)
          df_subset <- df_subset %>%
            dplyr::mutate(
              ResultDisplay = dplyr::case_when(
                Result %in% c("In Play (Out)", "In Play (Hit)") ~ "In Play",
                TRUE ~ as.character(Result)
              )
            )
          df_plot <- df_subset %>%
            dplyr::filter(is.finite(as.numeric(PlateLocSide)), is.finite(as.numeric(PlateLocHeight))) %>%
            dplyr::mutate(
              PlateLocSide = as.numeric(PlateLocSide),
              PlateLocHeight = as.numeric(PlateLocHeight),
              TaggedPitchType = as.character(TaggedPitchType),
              ResultDisplay = dplyr::case_when(
                ResultDisplay %in% hit_result_levels ~ ResultDisplay,
                TRUE ~ NA_character_
              ),
              ResultDisplay = factor(ResultDisplay, levels = hit_result_levels),
              tooltip = paste0(
                "<b>", TaggedPitchType, "</b><br>",
                "PitchCall: ", ifelse(is.na(PitchCall), "—", as.character(PitchCall)), "<br>",
                "Result: ", ifelse(is.na(ResultDisplay), "—", as.character(ResultDisplay)), "<br>",
                "Velo: ", ifelse(is.finite(as.numeric(RelSpeed)), sprintf("%.1f mph", as.numeric(RelSpeed)), "—"), "<br>",
                "EV: ", ifelse(is.finite(as.numeric(ExitSpeed)), sprintf("%.1f mph", as.numeric(ExitSpeed)), "—"), "<br>",
                "LA: ", ifelse(is.finite(as.numeric(Angle)), sprintf("%.1f°", as.numeric(Angle)), "—")
              ),
              rid = dplyr::row_number()
            )
          if (!nrow(df_plot)) {
            p_empty <- ggplot() +
              annotate("text", x = 0, y = 2.5, label = "No pitches", size = 5) +
              theme_void()
            return(girafe_transparent(ggobj = p_empty))
          }
          types_chr <- intersect(names(cols), unique(df_plot$TaggedPitchType))
          if (!length(types_chr)) types_chr <- unique(df_plot$TaggedPitchType)
          col_vals <- cols[types_chr]; col_vals[is.na(col_vals)] <- "gray70"
          home <- data.frame(
            x = c(-0.75, 0.75, 0.75, 0, -0.75),
            y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
          )
          sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
          mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
          mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
          dx <- (ZONE_RIGHT - ZONE_LEFT) / 3
          dy <- (ZONE_TOP - ZONE_BOTTOM) / 3
          grid_vertical <- data.frame(
            x = c(ZONE_LEFT + dx, ZONE_LEFT + 2 * dx),
            ymin = ZONE_BOTTOM,
            ymax = ZONE_TOP
          )
          grid_horizontal <- data.frame(
            y = c(ZONE_BOTTOM + dy, ZONE_BOTTOM + 2 * dy),
            xmin = ZONE_LEFT,
            xmax = ZONE_RIGHT
          )
          inner_half <- 7 / 12
          green_box <- data.frame(
            xmin = mid_x - inner_half,
            xmax = mid_x + inner_half,
            ymin = mid_y - inner_half,
            ymax = mid_y + inner_half
          )
          df_known <- dplyr::filter(df_plot, !is.na(ResultDisplay))
          df_other <- dplyr::filter(df_plot, is.na(ResultDisplay))
          tooltip_css <- "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
          p <- ggplot() +
            geom_polygon(data = home, aes(x, y), inherit.aes = FALSE, fill = NA, color = line_col) +
            geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                      inherit.aes = FALSE, fill = NA, color = line_col) +
            geom_rect(data = green_box,
                      aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                      inherit.aes = FALSE,
                      fill = "#66c87a", alpha = 0.18, color = NA) +
            geom_segment(data = grid_vertical,
                         aes(x = x, xend = x, y = ymin, yend = ymax),
                         inherit.aes = FALSE, color = grid_col, linewidth = 0.4) +
            geom_segment(data = grid_horizontal,
                         aes(x = xmin, xend = xmax, y = y, yend = y),
                         inherit.aes = FALSE, color = grid_col, linewidth = 0.4) +
            ggiraph::geom_point_interactive(
              data = df_other,
              aes(PlateLocSide, PlateLocHeight,
                  color = TaggedPitchType, fill = TaggedPitchType,
                  tooltip = tooltip, data_id = rid),
              size = 4.5, alpha = 0.9, shape = 21, stroke = 0.4
            ) +
            ggiraph::geom_point_interactive(
              data = df_known,
              aes(PlateLocSide, PlateLocHeight,
                  color = TaggedPitchType, fill = TaggedPitchType, shape = ResultDisplay,
                  tooltip = tooltip, data_id = rid),
              size = 5, alpha = 0.95, stroke = 0.8
            ) +
            scale_color_manual(values = col_vals, limits = types_chr, drop = FALSE, name = NULL) +
            scale_fill_manual(values = col_vals, limits = types_chr, drop = FALSE, name = NULL) +
            scale_shape_manual(values = hit_shape_map, drop = TRUE) +
            coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
            theme_void() +
            theme(legend.position = "none")
          
          girafe_transparent(
            ggobj = p,
            options = list(
              ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
              ggiraph::opts_hover(css = "stroke-width:1.5px;"),
              ggiraph::opts_hover_inv(css = "opacity:0.15;")
            )
          )
        })
      }
      types <- if (exists("ordered_types") && is.function(ordered_types)) ordered_types() else
        intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
      types_chr <- as.character(types)
      df_i <- df %>%
        dplyr::mutate(
          Result  = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
          tt      = make_hover_tt(.),
          rid     = dplyr::row_number(),
          tt_fill = dplyr::coalesce(colors_for_mode(dark_on)[as.character(TaggedPitchType)], "gray")
        )
      home <- data.frame(x = c(-0.75,0.75,0.75,0.00,-0.75),
                         y = c(1.05,1.05,1.15,1.25,1.15) - 0.5)
      cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
      sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
      line_col <- if (dark_on) "#ffffff" else "black"
      df_known <- dplyr::filter(df_i, !is.na(Result))
      df_other <- dplyr::filter(df_i,  is.na(Result))
      p <- ggplot() +
        geom_polygon(data = home, aes(x, y), inherit.aes = FALSE, fill = NA, color = line_col) +
        geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  inherit.aes = FALSE, fill = NA, color = line_col, linetype = "dashed") +
        geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                  inherit.aes = FALSE, fill = NA, color = line_col) +
        ggiraph::geom_point_interactive(
          data = df_other,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          position = "identity",
          size = 3.2, alpha = 0.9, shape = 16, stroke = 0.3
        ) +
        ggiraph::geom_point_interactive(
          data = df_known,
          aes(PlateLocSide, PlateLocHeight,
              color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
              tooltip = tt, data_id = rid),
          position = "identity",
          size = 3.8, alpha = 0.95, stroke = 0.8
        ) +
        scale_color_manual(values = colors_for_mode(dark_on)[types_chr], limits = types_chr, name = NULL) +
        scale_fill_manual(values  = colors_for_mode(dark_on)[types_chr], limits = types_chr, name = NULL) +
        scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
        coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
        theme_void() + theme(legend.position = "none") +
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
          inherit.aes = FALSE, shape = 21, size = 6, alpha = 0.001, stroke = 0
        )
      girafe_transparent(
        ggobj = p,
        options = list(
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
          ggiraph::opts_hover(css = "stroke-width:1.5px;"),
          ggiraph::opts_hover_inv(css = "opacity:0.15;")
        )
      )
    }
    output$cmpA_pitch <- ggiraph::renderGirafe({ .pitch_girafe(.filtered_panel("A"), input$cmpA_result) })
    output$cmpB_pitch <- ggiraph::renderGirafe({ .pitch_girafe(.filtered_panel("B"), input$cmpB_result) })
    
    # Switchable plot container (ensures only ONE chart visible per side)
    output$cmpA_plot_ui <- renderUI({
      switch(input$cmpA_chart,
             "Movement Plot" = ggiraph::girafeOutput(ns("cmpA_movement"), height = "480px"),
             "Release Plot"  = plotOutput(ns("cmpA_release"), height = "480px"),
             "HeatMap"       = plotOutput(ns("cmpA_heat"), height = "480px"),
             "Location Chart"= ggiraph::girafeOutput(ns("cmpA_pitch"), height = "480px")
      )
    })
    output$cmpB_plot_ui <- renderUI({
      switch(input$cmpB_chart,
             "Movement Plot" = ggiraph::girafeOutput(ns("cmpB_movement"), height = "480px"),
             "Release Plot"  = plotOutput(ns("cmpB_release"), height = "480px"),
             "HeatMap"       = plotOutput(ns("cmpB_heat"), height = "480px"),
             "Location Chart"= ggiraph::girafeOutput(ns("cmpB_pitch"), height = "480px")
      )
    })
    
    # ---------- TABLES (IDENTICAL to DP / Summary page logic) ----------
    # fallback visible set helper if not global
    if (!exists("visible_set_for")) {
      visible_set_for <- function(mode, custom) {
        base <- c(
          "Pitch","#","Usage","BF","IP","FIP","WHIP","Velo","Max","IVB","HB","rTilt","bTilt","SpinEff","Spin",
          "Height","Side","VAA","HAA","Ext","InZone%","Comp%","Strike%","FPS%","E+A%",
          "K%","BB%","Whiff%","EV","LA","Stuff+","Ctrl+","QP+","Pitching+",
          # Results-specific
          "PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP","GB%","Barrel%","Swing%","Whiff%","K%","BB%","EV","LA"
        )
        if (identical(mode, "Custom") && length(custom)) unique(c("Pitch", custom)) else base
      }
    }
    
    .dp_like_table <<- function(df, mode, custom_cols, enable_colors = TRUE) {
      if (!nrow(df)) {
        return(DT::datatable(
          data.frame(Message = "No data for selected filters"),
          options = list(dom = 't'), rownames = FALSE
        ))
      }
      dom <- attr(df, "domain") %||% "Pitcher"
      split_choice <- attr(df, "split_choice") %||% "Pitch Types"
      split_col_name <- switch(
        split_choice,
        "Pitch Types" = "Pitch",
        "Batter Hand" = if (dom == "Hitter") "Pitcher Hand" else "Batter Hand",
        "Pitcher Hand" = "Pitcher Hand",
        "Count" = "Count",
        "After Count" = "After Count",
        "Velocity" = "Velocity",
        "IVB" = "IVB",
        "HB" = "HB",
        "Batter" = if (dom == "Hitter") "Pitcher" else "Batter",
        "Pitch"
      )
      pitch_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
      df$TaggedPitchType <- df[[pitch_col]]
      df$PitchType <- df$TaggedPitchType
      if (!"SplitColumn" %in% names(df)) {
        df$SplitColumn <- df[[pitch_col]]
      }
      if (!"TaggedPitchType" %in% names(df)) {
        df$TaggedPitchType <- df$PitchType %||% df$Pitch %||% df$SplitColumn
      }
      
      # Hitting-mode tables (Results + Swing Decisions + Custom)
      if (identical(dom, "Hitter")) {
        safe_div_local <- function(num, den) {
          num <- suppressWarnings(as.numeric(num))
          den <- suppressWarnings(as.numeric(den))
          ifelse(is.finite(den) & den > 0 & is.finite(num), num/den, NA_real_)
        }
        nz_mean_local <- function(x) {
          x <- suppressWarnings(as.numeric(x))
          m <- mean(x, na.rm = TRUE)
          if (is.finite(m)) m else NA_real_
        }
        fmt_avg_local <- function(x) {
          z <- ifelse(is.finite(x), sprintf("%.3f", x), NA_character_)
          sub("^0", "", z)
        }
        
        build_results_table_hit <- function(df_src) {
          if (!nrow(df_src)) return(data.frame())
          if (!"SplitColumn" %in% names(df_src)) {
            df_src$SplitColumn <- if ("TaggedPitchType" %in% names(df_src)) {
              as.character(df_src$TaggedPitchType)
            } else {
              "Unknown"
            }
          }
          if (!"TaggedPitchType" %in% names(df_src)) {
            df_src$TaggedPitchType <- df_src$PitchType %||% df_src$Pitch %||% df_src$SplitColumn
          }
          df_src <- df_src %>%
            dplyr::mutate(SplitColumn = dplyr::coalesce(as.character(SplitColumn), "Unknown"))
          
          swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
          is_term <- (
            (!is.na(df_src$PlayResult) & df_src$PlayResult != "Undefined") |
              (!is.na(df_src$KorBB) & df_src$KorBB %in% c("Strikeout","Walk"))
          )
          term <- df_src[is_term, , drop = FALSE]
          
          per_split <- term %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              PA   = dplyr::n(),
              HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
              Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
              SFct = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
              IBBct= sum(PlayResult == "IntentionalWalk", na.rm = TRUE),
              `1B` = sum(PlayResult == "Single",  na.rm = TRUE),
              `2B` = sum(PlayResult == "Double",  na.rm = TRUE),
              `3B` = sum(PlayResult == "Triple",  na.rm = TRUE),
              HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
              Kct  = sum(KorBB == "Strikeout" |
                           PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
              BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
              .groups = "drop"
            ) %>%
            dplyr::mutate(
              AB  = PA - (BBct + HBP + Sac),
              H   = `1B` + `2B` + `3B` + HR,
              TB  = 1*`1B` + 2*`2B` + 3*`3B` + 4*HR,
              AVG = safe_div_local(H, AB),
              SLG = safe_div_local(TB, AB),
              OBP = safe_div_local(H + BBct + HBP, PA),
              OPS = SLG + OBP,
              ISO = SLG - AVG,
              uBB = BBct - IBBct,
              wOBA_num = 0.690*uBB + 0.722*HBP + 0.888*`1B` + 1.271*`2B` + 1.616*`3B` + 2.101*HR,
              wOBA_den = AB + BBct - IBBct + SFct + HBP,
              wOBA = safe_div_local(wOBA_num, wOBA_den)
            )
          
          pitch_totals <- df_src %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              Pitches = dplyr::n(),
              Swings  = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
              Whiffs  = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
              .groups = "drop"
            )
          total_pitches <- sum(pitch_totals$Pitches, na.rm = TRUE)
          
          bbe <- df_src %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
          evla <- bbe %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(EV = nz_mean_local(ExitSpeed), LA = nz_mean_local(Angle), .groups = "drop")
          gb <- bbe %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              `GB%` = safe_div_local(sum(TaggedHitType == "GroundBall", na.rm = TRUE),
                                     sum(!is.na(TaggedHitType),        na.rm = TRUE)),
              .groups = "drop"
            )
          
          parse_pct_prop <- function(x) {
            x_num <- suppressWarnings(as.numeric(sub("%$", "", as.character(x))))
            ifelse(is.finite(x_num), x_num / 100, NA_real_)
          }
          
          extras_raw <- compute_process_results(df_src)
          extras <- extras_raw %>%
            {
              df_proc <- .
              if (!"SplitColumn" %in% names(df_proc) && "PitchType" %in% names(df_proc)) {
                df_proc <- dplyr::rename(df_proc, SplitColumn = PitchType)
              }
              df_proc
            } %>%
            dplyr::mutate(
              xWOBA     = suppressWarnings(as.numeric(xWOBA)),
              xISO      = suppressWarnings(as.numeric(xISO)),
              BABIP     = suppressWarnings(as.numeric(BABIP)),
              `Barrel%` = parse_pct_prop(`Barrel%`)
            ) %>%
            dplyr::select(SplitColumn, xWOBA, xISO, BABIP, `Barrel%`)
          
          res_pt <- per_split %>%
            dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
            dplyr::left_join(evla,         by = "SplitColumn") %>%
            dplyr::left_join(gb,           by = "SplitColumn") %>%
            dplyr::mutate(
              `Swing%` = safe_div_local(Swings, Pitches),
              `Whiff%` = safe_div_local(Whiffs, Swings)
            ) %>%
            dplyr::left_join(extras, by = "SplitColumn") %>%
            dplyr::transmute(
              !!split_col_name := as.character(SplitColumn),
              PA, AB, AVG, SLG, OBP, OPS,
              wOBA, xWOBA,
              ISO, xISO, BABIP,
              `Swing%`, `Whiff%`, `GB%`,
              `K%` = safe_div_local(Kct, PA),
              `BB%` = safe_div_local(BBct, PA),
              `Barrel%`,
              EV, LA
            )
          
          # All-row
          PAt <- nrow(term)
          HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
          Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
          H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
          H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
          H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
          HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
          H   <- H1 + H2 + H3 + HR
          IBB_all <- sum(term$PlayResult == "IntentionalWalk", na.rm = TRUE)
          TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
          Kct_all <- sum(term$KorBB == "Strikeout" |
                           term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
          BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
          ABt <- PAt - (BBc_all + HBP_all + Sac_all)
          swings  <- sum(!is.na(df_src$PitchCall) & df_src$PitchCall %in% swing_levels, na.rm = TRUE)
          whiffs  <- sum(df_src$PitchCall == "StrikeSwinging",                      na.rm = TRUE)
          gbpct_all <- {
            d <- df_src %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
            safe_div_local(sum(d$TaggedHitType == "GroundBall", na.rm = TRUE),
                           sum(!is.na(d$TaggedHitType),         na.rm = TRUE))
          }
          bbe_all <- df_src %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
          
          all_row <- tibble::tibble(
            !!split_col_name := "All",
            PA = PAt,
            AB = ABt,
            AVG = safe_div_local(H, ABt),
            SLG = safe_div_local(TB, ABt),
            OBP = safe_div_local(H + BBc_all + HBP_all, PAt),
            OPS = NA_real_,
            xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
            `Swing%` = safe_div_local(swings, total_pitches),
            `Whiff%` = safe_div_local(whiffs, swings),
            `GB%`    = gbpct_all,
            `K%`     = safe_div_local(Kct_all, PAt),
            `BB%`    = safe_div_local(BBc_all, PAt),
            `Barrel%`= NA_real_,
            EV = nz_mean_local(bbe_all$ExitSpeed),
            LA = nz_mean_local(bbe_all$Angle),
            ISO = SLG - AVG,
            wOBA = {
              uBB_all <- BBc_all - IBB_all
              num <- 0.690*uBB_all + 0.722*HBP_all + 0.888*H1 + 1.271*H2 + 1.616*H3 + 2.101*HR
              den <- ABt + BBc_all - IBB_all + Sac_all + HBP_all
              safe_div_local(num, den)
            }
          ) %>%
            dplyr::mutate(OPS = SLG + OBP)
          
          # Fill All-row process metrics using a single-group compute (avoids unweighted averaging across splits)
          extras_all <- {
            df_all <- df_src
            df_all$SplitColumn <- "All"
            compute_process_results(df_all) %>%
              dplyr::mutate(
                xWOBA     = suppressWarnings(as.numeric(xWOBA)),
                xISO      = suppressWarnings(as.numeric(xISO)),
                BABIP     = suppressWarnings(as.numeric(BABIP)),
                `Barrel%` = parse_pct_prop(`Barrel%`)
              ) %>%
              dplyr::summarise(
                xWOBA = nz_mean_local(xWOBA),
                xISO  = nz_mean_local(xISO),
                BABIP = nz_mean_local(BABIP),
                `Barrel%` = nz_mean_local(`Barrel%`),
                .groups = "drop"
              )
          }
          if (nrow(extras_all)) {
            all_row$xWOBA     <- extras_all$xWOBA[1]
            all_row$xISO      <- extras_all$xISO[1]
            all_row$BABIP     <- extras_all$BABIP[1]
            all_row$`Barrel%` <- extras_all$`Barrel%`[1]
          }
          
          res <- dplyr::bind_rows(res_pt, all_row)
          if (identical(split_choice, "Pitch Types") && split_col_name == "Pitch") {
            ord <- names(all_colors)
            res[[split_col_name]] <- factor(res[[split_col_name]], levels = c(ord, setdiff(res[[split_col_name]], ord)))
            res <- res %>% dplyr::arrange(res[[split_col_name]])
            res[[split_col_name]] <- as.character(res[[split_col_name]])
          }
          res
        }
        
        build_swing_decisions_hit <- function(df_src) {
          if (!nrow(df_src)) {
            return(DT::datatable(
              data.frame(Message = "No data for Swing Decisions"),
              options = list(dom = 't', autoWidth = FALSE), rownames = FALSE
            ))
          }
          if (!"SplitColumn" %in% names(df_src)) {
            df_src$SplitColumn <- if ("TaggedPitchType" %in% names(df_src)) {
              as.character(df_src$TaggedPitchType)
            } else {
              "Unknown"
            }
          }
          df_src <- df_src %>%
            dplyr::mutate(SplitColumn = dplyr::coalesce(as.character(SplitColumn), "Unknown"))
          
          inner_half <- 7 / 12
          mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
          mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
          green_xmin <- mid_x - inner_half
          green_xmax <- mid_x + inner_half
          green_ymin <- mid_y - inner_half
          green_ymax <- mid_y + inner_half
          
          df_sd <- df_src %>%
            dplyr::mutate(
              is_swing = !is.na(PitchCall) & PitchCall %in% c("StrikeSwinging","FoulBall","FoulBallFieldable","FoulBallNotFieldable","InPlay"),
              in_green = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
              in_zone = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
              possd_point = dplyr::case_when(
                in_green & is_swing ~ 2,
                in_green & !is_swing ~ -1,
                in_zone & !in_green & is_swing ~ 1,
                in_zone & !in_green & !is_swing ~ 0,
                !in_zone & is_swing ~ -1,
                !in_zone & !is_swing ~ 1,
                TRUE ~ 0
              )
            )
          
          summarize_sd <- function(dat) {
            total_pitches <- nrow(dat)
            swings <- sum(dat$is_swing, na.rm = TRUE)
            fps_num <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0 &
                             !is.na(dat$PitchCall) & dat$PitchCall %in% c("StrikeSwinging","InPlay","FoulBall","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
            fps_den <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0, na.rm = TRUE)
            called <- sum(!is.na(dat$PitchCall) & dat$PitchCall == "StrikeCalled", na.rm = TRUE)
            chase_num <- sum(dat$is_swing & !dat$in_zone, na.rm = TRUE)
            chase_den <- sum(!dat$in_zone, na.rm = TRUE)
            gozone_sw_num <- sum(dat$is_swing & dat$in_green, na.rm = TRUE)
            gozone_sw_den <- sum(dat$in_green, na.rm = TRUE)
            iz_sw_num <- sum(dat$is_swing & dat$in_zone, na.rm = TRUE)
            iz_sw_den <- sum(dat$in_zone, na.rm = TRUE)
            edge_sw_num <- sum(dat$is_swing & dat$in_zone & !dat$in_green, na.rm = TRUE)
            edge_sw_den <- sum(dat$in_zone & !dat$in_green, na.rm = TRUE)
            possd_points <- sum(dat$possd_point, na.rm = TRUE)
            
            tibble::tibble(
              `Swing%` = safe_div_local(swings, total_pitches) * 100,
              `FPS%` = safe_div_local(fps_num, fps_den) * 100,
              `Called%` = safe_div_local(called, total_pitches) * 100,
              `Chase%` = safe_div_local(chase_num, chase_den) * 100,
              `GoZoneSw%` = safe_div_local(gozone_sw_num, gozone_sw_den) * 100,
              `IZswing%` = safe_div_local(iz_sw_num, iz_sw_den) * 100,
              `EdgeSwing%` = safe_div_local(edge_sw_num, edge_sw_den) * 100,
              `PosSD%` = safe_div_local(possd_points, total_pitches) * 100
            )
          }
          
          swing_decision_by_type <- df_sd %>%
            dplyr::group_by(SplitColumn, .drop = FALSE) %>%
            dplyr::group_modify(~ summarize_sd(.x)) %>%
            dplyr::ungroup() %>%
            dplyr::rename(!!split_col_name := SplitColumn)
          
          all_row <- summarize_sd(df_sd) %>%
            dplyr::mutate(!!split_col_name := "All")
          
          df_swing_decision <- dplyr::bind_rows(swing_decision_by_type, all_row)
          
          if (split_choice == "Pitch Types" && split_col_name %in% names(df_swing_decision)) {
            ord_all <- if (exists("ordered_types") && is.function(ordered_types)) ordered_types() else names(all_colors)
            ord <- ord_all[ord_all %in% as.character(df_swing_decision[[split_col_name]])]
            uniq_vals <- as.character(df_swing_decision[[split_col_name]])
            other <- setdiff(uniq_vals, c(ord, "All"))
            df_swing_decision[[split_col_name]] <- factor(
              df_swing_decision[[split_col_name]],
              levels = c(ord, other, "All")
            )
            df_swing_decision <- df_swing_decision %>%
              dplyr::arrange(.data[[split_col_name]]) %>%
              dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
            all_rows_sd <- df_swing_decision[df_swing_decision[[split_col_name]] == "All", , drop = FALSE]
            other_rows_sd <- df_swing_decision[df_swing_decision[[split_col_name]] != "All", , drop = FALSE]
            df_swing_decision <- dplyr::bind_rows(other_rows_sd, all_rows_sd)
          }
          
          pct_cols_sd <- c("Swing%", "FPS%", "Called%", "Chase%", "GoZoneSw%", "IZswing%", "EdgeSwing%", "PosSD%")
          for (col in pct_cols_sd) if (col %in% names(df_swing_decision)) {
            v <- suppressWarnings(as.numeric(df_swing_decision[[col]]))
            df_swing_decision[[col]] <- ifelse(is.finite(v), paste0(round(v, 1), "%"), "")
          }
          if (identical(split_choice, "Pitch Types") && split_col_name == "Pitch") {
            ord <- names(all_colors)
            df_swing_decision[[split_col_name]] <- factor(df_swing_decision[[split_col_name]], levels = c(ord, setdiff(df_swing_decision[[split_col_name]], ord)))
            df_swing_decision <- df_swing_decision %>% dplyr::arrange(.data[[split_col_name]])
            df_swing_decision[[split_col_name]] <- as.character(df_swing_decision[[split_col_name]])
          }
          
          datatable_with_colvis(
            df_swing_decision,
            lock            = split_col_name,
            remember        = FALSE,
            default_visible = c(split_col_name, pct_cols_sd),
            mode            = NULL,
            enable_colors   = FALSE
          )
        }
        
        # Render hitting table based on mode
        if (identical(mode, "Swing Decisions")) {
          return(build_swing_decisions_hit(df))
        }
        
        results_df <- build_results_table_hit(df)
        if (!nrow(results_df)) {
          return(DT::datatable(
            data.frame(Message = "No data for selected filters"),
            options = list(dom = 't'), rownames = FALSE
          ))
        }
        num_cols <- c("PA","AB","AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP",
                      "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
        results_df <- results_df %>%
          dplyr::mutate(dplyr::across(dplyr::all_of(num_cols), ~ suppressWarnings(as.numeric(.)))) %>%
          {
            df_tmp <- .
            pct_cols  <- c("Swing%","Whiff%","GB%","K%","BB%","Barrel%")
            rate_cols <- c("AVG","SLG","OBP","OPS","wOBA","xWOBA","ISO","xISO","BABIP")
            for (nm in pct_cols) if (nm %in% names(df_tmp)) df_tmp[[nm]] <- ifelse(is.finite(df_tmp[[nm]]), paste0(round(df_tmp[[nm]]*100,1), "%"), "")
            for (nm in rate_cols) if (nm %in% names(df_tmp)) df_tmp[[nm]] <- ifelse(is.finite(df_tmp[[nm]]), fmt_avg_local(df_tmp[[nm]]), "")
            if ("EV" %in% names(df_tmp)) df_tmp$EV <- ifelse(is.finite(df_tmp$EV), round(df_tmp$EV,1), "")
            if ("LA" %in% names(df_tmp)) df_tmp$LA <- ifelse(is.finite(df_tmp$LA), round(df_tmp$LA,1), "")
            df_tmp
          }
        
        visible_cols_base <- c(split_col_name, "PA", "AB", "AVG", "SLG", "OBP", "OPS", "xWOBA", "xISO", "BABIP",
                               "wOBA", "ISO",
                               "Swing%", "Whiff%", "GB%", "K%", "BB%", "Barrel%", "EV", "LA")
        if (identical(mode, "Custom")) {
          custom_cols <- custom_cols[custom_cols %in% visible_cols_base]
          visible_cols <- unique(c(split_col_name, custom_cols))
          if (length(visible_cols) == 1) visible_cols <- visible_cols_base
        } else {
          visible_cols <- visible_cols_base
        }
        
        return(datatable_with_colvis(
          results_df,
          lock = split_col_name,
          remember = FALSE,
          default_visible = intersect(visible_cols, names(results_df)),
          mode = NULL,
          enable_colors = FALSE
        ))
      }
      
      # --- helpers (copied from your DP page) ---
      nz_mean <- function(x) { x <- suppressWarnings(as.numeric(x)); m <- mean(x, na.rm = TRUE); if (is.finite(m)) m else NA_real_ }
      fmt_avg <- function(x) { z <- ifelse(is.finite(x), sprintf("%.3f", x), NA_character_); sub("^0", "", z) }
      safe_div <- function(num, den) ifelse(den > 0, num/den, NA_real_)
      parse_num <- function(x) {
        if (is.numeric(x)) return(x)
        x1 <- trimws(as.character(x)); x1[x1 == ""] <- NA_character_
        ifelse(grepl("%$", x1), suppressWarnings(as.numeric(sub("%$","",x1)))/100,
               suppressWarnings(as.numeric(x1)))
      }
      ip_fmt <- function(ip_raw) {
        out <- rep("", length(ip_raw))
        ok  <- is.finite(ip_raw) & ip_raw > 0
        outs <- floor(ip_raw[ok]*3 + 1e-8)
        inn  <- outs %/% 3
        rem  <- outs %% 3
        out[ok] <- paste0(inn, ".", rem)
        out
      }
      FIP_C <- if (exists("FIP_CONST")) get("FIP_CONST") else 3.20
      
      if (identical(mode, "Results")) {
        # Ensure SplitColumn exists (should have been created by apply_split_by)
        if (!"SplitColumn" %in% names(df)) {
          df$SplitColumn <- if ("TaggedPitchType" %in% names(df)) {
            as.character(df$TaggedPitchType)
          } else {
            "Unknown"
          }
        }
        
        swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
        is_term <- (
          (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
            (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk"))
        )
        term <- df[is_term, , drop = FALSE]
        
        per_type <- term %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            PA   = dplyr::n(),
            HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
            `1B` = sum(PlayResult == "Single",  na.rm = TRUE),
            `2B` = sum(PlayResult == "Double",  na.rm = TRUE),
            `3B` = sum(PlayResult == "Triple",  na.rm = TRUE),
            HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
            Kct  = sum(KorBB == "Strikeout" |
                         PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
            BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
            .groups = "drop"
          ) %>%
          dplyr::mutate(
            AB  = PA - (BBct + HBP + Sac),
            H   = `1B` + `2B` + `3B` + HR,
            TB  = 1*`1B` + 2*`2B` + 3*`3B` + 4*HR,
            AVG = safe_div(H, AB),
            SLG = safe_div(TB, AB),
            OBP = safe_div(H + BBct + HBP, PA),
            OPS = SLG + OBP
          )
        
        pitch_totals <- df %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            Pitches       = dplyr::n(),
            Swings        = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
            Whiffs        = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
            CalledStrikes = sum(PitchCall == "StrikeCalled",    na.rm = TRUE),
            .groups = "drop"
          )
        total_pitches <- sum(pitch_totals$Pitches, na.rm = TRUE)
        
        scores <- ifelse(
          df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
            df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
          ifelse(
            df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
              df$PlateLocHeight >= (2.65 - 1.5) & df$PlateLocHeight <= (2.65 + 1.5),
            0.73, 0
          )
        )
        sc_by_type <- df %>%
          dplyr::mutate(.scores = scores) %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            StuffP   = round(nz_mean(`Stuff+`), 1),
            CommandP = round(nz_mean(.scores) * 100, 1),
            .groups = "drop"
          ) %>%
          dplyr::mutate(PitchingP = round((StuffP + CommandP)/2, 1))
        
        bbe <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
        evla <- bbe %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(EV = nz_mean(ExitSpeed), LA = nz_mean(Angle), .groups = "drop")
        gb <- bbe %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            `GB%` = safe_div(sum(TaggedHitType == "GroundBall", na.rm = TRUE),
                             sum(!is.na(TaggedHitType),        na.rm = TRUE)),
            .groups = "drop"
          )
        
        extras <- compute_process_results(df) %>%
          dplyr::rename(Pitch = PitchType) %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::select(Pitch, xWOBA, xISO, BABIP, `Barrel%`, `RV/100`)
        
        res_pt <- per_type %>%
          dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
          dplyr::left_join(evla,         by = "SplitColumn") %>%
          dplyr::left_join(gb,           by = "SplitColumn") %>%
          dplyr::mutate(
            `Swing%` = safe_div(Swings, Pitches),
            `Whiff%` = safe_div(Whiffs, Swings),
            `CSW%`   = safe_div(Whiffs + CalledStrikes, Pitches),
            Outs     = (AB - H) + Sac,
            IP_raw   = safe_div(Outs, 3),
            BF       = PA,
            `#`      = Pitches,
            Usage    = ifelse(total_pitches > 0, paste0(round(100*Pitches/total_pitches,1), "%"), ""),
            FIP_tmp  = safe_div(13*HR + 3*(BBct + HBP) - 2*Kct, IP_raw),
            FIP      = ifelse(is.finite(FIP_tmp), round(FIP_tmp + FIP_C, 2), NA_real_),
            WHIP_tmp = safe_div(H + BBct, IP_raw),
            WHIP     = ifelse(is.finite(WHIP_tmp), round(WHIP_tmp, 2), NA_real_)
          ) %>%
          dplyr::left_join(sc_by_type, by = "SplitColumn") %>%
          dplyr::left_join(extras, by = c("SplitColumn" = "Pitch")) %>%
          dplyr::transmute(
            Pitch = as.character(SplitColumn),
            `#`, Usage, BF, `RV/100`, IP = ip_fmt(IP_raw), FIP, WHIP,
            PA, AB, AVG, SLG, OBP, OPS,
            xWOBA, xISO, BABIP,
            `Swing%`, `Whiff%`, `CSW%`, `GB%`,
            `K%` = safe_div(Kct, PA), `BB%` = safe_div(BBct, PA),
            `Barrel%`, EV, LA,
            `Pitching+` = PitchingP
          )
        
        PAt <- nrow(term)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
        H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
        H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
        HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        H   <- H1 + H2 + H3 + HR
        TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
        Kct_all <- sum(term$KorBB == "Strikeout" |
                         term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
        BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        ABt <- PAt - (BBc_all + HBP_all + Sac_all)
        swings  <- sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE)
        whiffs  <- sum(df$PitchCall == "StrikeSwinging",                      na.rm = TRUE)
        gbpct_all <- {
          d <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
          safe_div(sum(d$TaggedHitType == "GroundBall", na.rm = TRUE),
                   sum(!is.na(d$TaggedHitType),         na.rm = TRUE))
        }
        Outs_all <- (ABt - H) + Sac_all
        IP_all   <- safe_div(Outs_all, 3)
        FIP_all  <- {
          tmp <- safe_div(13*HR + 3*(BBc_all + HBP_all) - 2*Kct_all, IP_all)
          ifelse(is.finite(tmp), round(tmp + FIP_C, 2), NA_real_)
        }
        WHIP_all <- {
          tmp <- safe_div(H + BBc_all, IP_all)
          ifelse(is.finite(tmp), round(tmp, 2), NA_real_)
        }
        stuff_all <- round(nz_mean(df$`Stuff+`), 1)
        qp_all    <- round(nz_mean(compute_qp_points(df)) * 200, 1)
        pitc_all  <- round((stuff_all + qp_all) / 2, 1)
        
        all_row <- tibble::tibble(
          Pitch = "All",
          `#`   = nrow(df),
          Usage = "100%",
          BF = PAt,
          IP = ip_fmt(IP_all),
          FIP = FIP_all,
          WHIP = WHIP_all,
          PA = PAt, AB = ABt,
          AVG = safe_div(H, ABt),
          SLG = safe_div(TB, ABt),
          OBP = safe_div(H + BBc_all + HBP_all, PAt),
          OPS = NA_real_,
          xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
          `Swing%` = safe_div(swings, total_pitches),
          `Whiff%` = safe_div(whiffs, swings),
          `GB%`    = gbpct_all,
          `K%`     = safe_div(Kct_all, PAt),
          `BB%`    = safe_div(BBc_all, PAt),
          `Barrel%`= NA_real_,
          EV = nz_mean(bbe$ExitSpeed),
          LA = nz_mean(bbe$Angle),
          `Pitching+` = pitc_all
        )
        all_row$OPS <- all_row$SLG + all_row$OBP
        
        extras_all <- compute_process_results(df) %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::summarise(
            xWOBA     = nz_mean(xWOBA),
            xISO      = nz_mean(xISO),
            BABIP     = nz_mean(BABIP),
            `Barrel%` = nz_mean(`Barrel%`),
            .groups = "drop"
          )
        if (nrow(extras_all)) {
          all_row$xWOBA     <- extras_all$xWOBA[1]
          all_row$xISO      <- extras_all$xISO[1]
          all_row$BABIP     <- extras_all$BABIP[1]
          all_row$`Barrel%` <- extras_all$`Barrel%`[1]
        }
        
        df_out <- dplyr::bind_rows(res_pt, all_row) %>%
          dplyr::mutate(
            dplyr::across(c(PA, AB, AVG, SLG, OBP, OPS, xWOBA, xISO, BABIP,
                            `Swing%`, `Whiff%`, `CSW%`, `GB%`, `K%`, `BB%`, `Barrel%`,
                            EV, LA, FIP, WHIP),
                          ~ suppressWarnings(as.numeric(.)))
          )
        pct_cols  <- c("Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%")
        rate_cols <- c("AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP")
        df_out[pct_cols]  <- lapply(df_out[pct_cols],  function(z) ifelse(is.finite(z), paste0(round(z*100,1), "%"), ""))
        df_out[rate_cols] <- lapply(df_out[rate_cols], function(z) ifelse(is.finite(z), fmt_avg(z), ""))
        df_out$EV   <- ifelse(is.finite(df_out$EV),   round(df_out$EV, 1), "")
        df_out$LA   <- ifelse(is.finite(df_out$LA),   round(df_out$LA, 1), "")
        df_out$FIP  <- ifelse(is.finite(df_out$FIP),  sprintf("%.2f", df_out$FIP), "")
        df_out$WHIP <- ifelse(is.finite(df_out$WHIP), sprintf("%.2f", df_out$WHIP), "")
        
        df_dt <- if (exists("safe_for_dt")) safe_for_dt(df_out) else df_out
        names(df_dt)[names(df_dt) == "Pitch"] <- split_col_name
        is_all <- df_dt[[split_col_name]] == "All"
        for (nm in c("Swing%","Whiff%","CSW%","GB%","K%","BB%")) {
          z <- df_dt[[nm]]
          z[is_all & (is.na(z) | trimws(z) == "")] <- "0.0%"
          df_dt[[nm]] <- z
        }
        
        visible_set <- visible_set_for(mode, custom_cols)
        if (identical(mode, "Custom")) {
          order_cols <- unique(c("Pitch", custom_cols))
          extras <- setdiff(names(df_dt), order_cols)
          df_dt <- df_dt[, c(order_cols, extras), drop = FALSE]
        }
        return(datatable_with_colvis(
          df_dt,
          lock            = split_col_name,
          remember        = FALSE,
          default_visible = intersect(visible_set, names(df_dt)),
          mode            = mode,
          enable_colors   = enable_colors
        ))
      }
      
      # ---- RAW DATA TABLE ----
      if (identical(mode, "Raw Data")) {
        # Helper function for innings pitched calculation
        ip_calculation <- function(pitches_data) {
          outs <- sum(pitches_data$KorBB == "Strikeout", na.rm = TRUE) + 
            sum(pitches_data$PlayResult %in% c("Out", "FieldersChoice", "Error"), na.rm = TRUE)
          innings <- outs / 3
          whole_innings <- floor(innings)
          remaining_outs <- outs %% 3
          if (remaining_outs == 0) {
            return(paste0(whole_innings, ".0"))
          } else {
            return(paste0(whole_innings, ".", remaining_outs))
          }
        }
        
        # Use SplitColumn if available (from split_by), otherwise TaggedPitchType
        group_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
        
        raw_per_type <- df %>%
          dplyr::group_by(!!rlang::sym(group_col)) %>%
          dplyr::summarise(
            IP = ip_calculation(dplyr::cur_data_all()),
            P = dplyr::n(),
            BF = calculate_bf(dplyr::cur_data_all()),
            H = sum(PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE),
            XBH = sum(PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE),
            Barrels = sum(ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, na.rm = TRUE),
            BB = sum(KorBB == "Walk", na.rm = TRUE),
            HBP = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            K = sum(KorBB == "Strikeout", na.rm = TRUE),
            Whiffs = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
            .groups = "drop"
          )
        
        # Rename the grouping column to split_col_name
        names(raw_per_type)[names(raw_per_type) == group_col] <- split_col_name
        
        # If split by Pitch Types, order them properly
        if (split_choice == "Pitch Types" && split_col_name == "Pitch") {
          # Define standard pitch order
          pitch_order <- c("Fastball", "Sinker", "Cutter", "Slider", "Sweeper", 
                           "Curveball", "ChangeUp", "Splitter", "Knuckleball", "Other")
          raw_per_type <- raw_per_type %>%
            dplyr::mutate(!!rlang::sym(split_col_name) := factor(
              !!rlang::sym(split_col_name), 
              levels = c(pitch_order, setdiff(unique(!!rlang::sym(split_col_name)), pitch_order))
            )) %>%
            dplyr::arrange(!!rlang::sym(split_col_name)) %>%
            dplyr::mutate(!!rlang::sym(split_col_name) := as.character(!!rlang::sym(split_col_name)))
        }
        
        # All row calculations
        all_ip <- ip_calculation(df)
        all_p <- nrow(df)
        all_bf <- calculate_bf(df)
        all_h <- sum(df$PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
        all_xbh <- sum(df$PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE)
        all_barrels <- sum(df$ExitSpeed >= 95 & df$Angle >= 10 & df$Angle <= 35, na.rm = TRUE)
        all_bb <- sum(df$KorBB == "Walk", na.rm = TRUE)
        all_hbp <- sum(df$PlayResult == "HitByPitch", na.rm = TRUE)
        all_k <- sum(df$KorBB == "Strikeout", na.rm = TRUE)
        all_whiffs <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
        
        # Calculate P/IP and P/BF for All row only
        # Convert IP from "X.Y" format to decimal (X + Y/3)
        ip_decimal <- if (all_ip != "0.0") {
          parts <- strsplit(all_ip, "\\.")[[1]]
          as.numeric(parts[1]) + as.numeric(parts[2])/3
        } else 0
        
        p_per_ip <- if (ip_decimal > 0) as.character(round(all_p / ip_decimal, 1)) else ""
        p_per_bf <- if (all_bf > 0) as.character(round(all_p / all_bf, 1)) else ""
        
        # Create all_row dynamically with split column name
        all_row_data <- list(
          IP = all_ip,
          P = all_p,
          BF = all_bf,
          `P/IP` = p_per_ip,
          `P/BF` = p_per_bf,
          H = all_h,
          XBH = all_xbh,
          Barrels = all_barrels,
          BB = all_bb,
          HBP = all_hbp,
          K = all_k,
          Whiffs = all_whiffs
        )
        all_row_data[[split_col_name]] <- "All"
        all_row <- tibble::as_tibble(all_row_data)
        
        # Add empty P/IP and P/BF columns to per-type data
        raw_per_type$`P/IP` <- ""
        raw_per_type$`P/BF` <- ""
        
        # Reorder columns to match desired layout with dynamic split column name
        col_order <- c(split_col_name, "IP", "P", "BF", "P/IP", "P/BF", "H", "XBH", "Barrels", "BB", "HBP", "K", "Whiffs")
        raw_per_type <- raw_per_type[, col_order]
        
        df_raw <- dplyr::bind_rows(raw_per_type, all_row)
        
        # Column already renamed above, no need to rename again
        visible_set <- names(df_raw)
        table_cache <- df_raw
        return(datatable_with_colvis(
          df_raw,
          lock            = split_col_name,
          remember        = FALSE,
          default_visible = visible_set,
          mode            = mode,
          enable_colors   = FALSE
        ))
      }
      
      # ---- NON-Results modes (match DP page) ----
      # QP+ per pitch type
      qp_by_type <- df %>%
        dplyr::group_by(TaggedPitchType) %>%
        dplyr::summarise(
          `QP+` = {
            vals <- compute_qp_points(dplyr::cur_data_all())
            vals <- suppressWarnings(as.numeric(vals))
            round(mean(vals, na.rm = TRUE) * 200, 1)
          },
          .groups = "drop"
        )
      
      summ <- safe_make_summary(df)
      summ <- dplyr::mutate(summ,
                            ReleaseTilt = as.character(ReleaseTilt),
                            BreakTilt   = as.character(BreakTilt)
      )
      if (!("QP+" %in% names(summ))) {
        summ <- summ %>% dplyr::left_join(qp_by_type, by = c("PitchType" = "TaggedPitchType"))
      }
      
      
      
      # Percent-ish columns: if they already end with "%", keep; else format smartly
      pct_cols <- c("SpinEff","InZonePercent","CompPercent","KPercent","BBPercent",
                    "FPSPercent","EAPercent","QPPercent","StrikePercent","SwingPercent","WhiffPercent")
      for (nm in pct_cols) if (nm %in% names(summ)) {
        x <- summ[[nm]]
        if (is.numeric(x)) {
          # scale: treat <=1.5 as proportions (0–1), otherwise already percent-like
          scale100 <- if (all(!is.na(x)) && max(x, na.rm = TRUE) <= 1.5) 100 else 1
          summ[[nm]] <- ifelse(is.finite(x), paste0(round(x * scale100, 1), "%"), "")
        } else {
          x <- as.character(x)
          has_pct <- grepl("%$", x)
          if (!all(has_pct | is.na(x) | x == "")) {
            v <- suppressWarnings(as.numeric(x))
            scale100 <- if (all(!is.na(v)) && max(v, na.rm = TRUE) <= 1.5) 100 else 1
            fmt <- ifelse(is.finite(v), paste0(round(v * scale100, 1), "%"), x)
            x[!has_pct] <- fmt[!has_pct]
          }
          summ[[nm]] <- x
        }
      }
      
      
      # Percent-like columns (DP page expects strings with %)
      for (nm in c("SpinEff","InZonePercent","CompPercent","KPercent","BBPercent",
                   "FPSPercent","EAPercent","QPPercent","StrikePercent","SwingPercent","WhiffPercent")) {
        if (nm %in% names(summ) && !is.character(summ[[nm]])) {
          # SpinEff is stored as a rate (0–1) in many builds, same pctify works
          summ[[nm]] <- pctify(summ[[nm]])
        }
      }
      
      scores <- ifelse(
        df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
          df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
        ifelse(
          df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
            df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5),
          0.73, 0
        )
      )
      has_pc  <- sum(!is.na(df$PitchCall)) > 0
      strikes <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
      sw      <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
      den     <- sum(df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
      csw_all <- sum(df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
      bf_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
      fps_opp <- bf_live
      k_live  <- sum(df$SessionType == "Live" & df$KorBB == "Strikeout",        na.rm = TRUE)
      bb_live <- sum(df$SessionType == "Live" & df$KorBB == "Walk",             na.rm = TRUE)
      fps_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0 &
                        df$PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
      ea_live  <- sum(df$SessionType == "Live" & (
        (df$Balls == 0 & df$Strikes == 0 & df$PitchCall == "InPlay") |
          (df$Balls == 0 & df$Strikes == 1 & df$PitchCall %in% c(
            "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
          )) |
          (df$Balls == 1 & df$Strikes == 0 & df$PitchCall == "InPlay") |
          (df$Balls == 1 & df$Strikes == 1 & df$PitchCall %in% c(
            "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
          ))
      ),
      na.rm = TRUE
      )
      
      vmax   <- suppressWarnings(max(as.numeric(df$RelSpeed), na.rm = TRUE)); vmax <- if (is.finite(vmax)) round(vmax, 1) else NA_real_
      ev_all <- nz_mean(ifelse(df$SessionType=="Live", df$ExitSpeed, NA_real_))
      la_all <- nz_mean(ifelse(df$SessionType=="Live", df$Angle,     NA_real_))
      stuff_all <- round(nz_mean(df$`Stuff+`), 1)
      ctrl_all   <- round(nz_mean(scores) * 100, 1)
      qp_all    <- round(nz_mean(compute_qp_points(df)) * 200, 1)
      
      df_table <- dplyr::bind_rows(
        summ,
        tibble::tibble(
          PitchType     = "All",
          PitchCount    = nrow(df),
          Usage         = "100%",
          Overall       = "100%",
          BF            = bf_live,
          Velo_Avg      = round(nz_mean(df$RelSpeed), 1),
          Velo_Max      = vmax,
          IVB           = round(nz_mean(df$InducedVertBreak), 1),
          HB            = round(nz_mean(df$HorzBreak), 1),
          ReleaseTilt   = convert_to_clock(nz_mean(df$ReleaseTilt)),
          BreakTilt     = convert_to_clock(nz_mean(df$BreakTilt)),
          SpinEff       = {
            spineff_val <- nz_mean(df$SpinEfficiency)
            if (is.finite(spineff_val)) paste0(round(spineff_val * 100, 1), "%") else ""
          },
          SpinRate      = round(nz_mean(df$SpinRate), 0),
          RelHeight     = round(nz_mean(df$RelHeight), 1),
          RelSide       = round(nz_mean(df$RelSide), 1),
          VertApprAngle = round(nz_mean(df$VertApprAngle), 1),
          HorzApprAngle = round(nz_mean(df$HorzApprAngle), 1),
          Extension     = round(nz_mean(df$Extension), 1),
          InZonePercent = { inzone <- (df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
                                         df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP)
          safe_pct(sum(inzone, na.rm=TRUE), sum(!is.na(inzone))) },
          CompPercent   = { comp <- (df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                                       df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5))
          safe_pct(sum(comp, na.rm=TRUE), sum(!is.na(comp))) },
          KPercent      = safe_pct(k_live, bf_live),
          BBPercent     = safe_pct(bb_live, bf_live),
          FPSPercent    = safe_pct(fps_live, fps_opp),
          EAPercent     = safe_pct(ea_live, fps_opp),
          StrikePercent = if (has_pc) safe_pct(strikes, nrow(df)) else "",
          SwingPercent  = safe_pct(sum(!is.na(df$PitchCall) & df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","FoulBall","InPlay"), na.rm = TRUE), nrow(df)),
          WhiffPercent  = safe_pct(sw, den),
          EV = ev_all, LA = la_all,
          `Stuff+` = stuff_all, `Ctrl+` = ctrl_all, `QP+` = qp_all
        ) %>% dplyr::mutate(`Pitching+` = round((`Stuff+` + `QP+`)/2, 1))
      ) %>%
        dplyr::rename(
          Pitch  = PitchType,
          `#`    = PitchCount,
          Velo   = Velo_Avg,
          Max    = Velo_Max,
          rTilt  = ReleaseTilt,
          bTilt  = BreakTilt,
          Spin   = SpinRate,
          Height = RelHeight,
          Side   = RelSide,
          Ext    = Extension,
          `InZone%` = InZonePercent,
          `Comp%`   = CompPercent,
          `K%`      = KPercent,
          `BB%`     = BBPercent,
          `FPS%`    = FPSPercent,
          `E+A%`    = EAPercent,
          `QP%`     = QPPercent,
          `Strike%` = StrikePercent,
          `Swing%`  = SwingPercent,
          `Whiff%`  = WhiffPercent,
          VAA       = VertApprAngle,
          HAA       = HorzApprAngle
        ) %>%
        dplyr::mutate(Pitch = as.character(Pitch)) %>%
        dplyr::select(
          Pitch, `#`, Usage, BF,
          Velo, Max, IVB, HB, rTilt, bTilt, SpinEff, Spin, Height, Side, VAA, HAA, Ext,
          `InZone%`, `Comp%`, `Strike%`, `Swing%`, `FPS%`, `E+A%`, `QP%`, `K%`, `BB%`, `Whiff%`, EV, LA,
          `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
        ) %>%
        dplyr::mutate(
          SpinEff = {
            val <- suppressWarnings(as.numeric(SpinEff))
            ifelse(is.na(val), "", paste0(round(val * 100, 1), "%"))
          },
          EV = ifelse(is.na(as.numeric(EV)), "", round(as.numeric(EV), 1)),
          LA = ifelse(is.na(as.numeric(LA)), "", round(as.numeric(LA), 1))
        )
      # --- Standardize decimals like DP: 1 decimal for most, 0 for Spin (RPM) ---
      round1 <- intersect(c("Velo","Max","IVB","HB","Height","Side","VAA","HAA","Ext"), names(df_table))
      for (nm in round1) {
        z <- suppressWarnings(as.numeric(df_table[[nm]]))
        df_table[[nm]] <- ifelse(is.finite(z), round(z, 1), df_table[[nm]])
      }
      
      if ("Spin" %in% names(df_table)) {
        z <- suppressWarnings(as.numeric(df_table$Spin))
        df_table$Spin <- ifelse(is.finite(z), round(z, 0), df_table$Spin)
      }
      
      extras <- compute_process_results(df, mode) %>%
        dplyr::rename(Pitch = PitchType) %>%
        dplyr::mutate(Pitch = as.character(Pitch))
      df_table <- df_table %>% dplyr::left_join(extras, by = "Pitch")
      if (all(c("BF","RV/100") %in% names(df_table))) {
        df_table <- df_table %>% dplyr::relocate(`RV/100`, .after = BF)
      }
      if (identical(mode, "Usage")) {
        usage_extras <- compute_usage_by_count(df) %>%
          dplyr::rename(Pitch = PitchType) %>%
          dplyr::mutate(Pitch = as.character(Pitch)) %>%
          dplyr::select(Pitch, `0-0`,`Behind`,`Even`,`Ahead`,`<2K`,`2K`)
        df_table <- df_table %>% dplyr::left_join(usage_extras, by = "Pitch")
      }
      
      df_table <- collapse_list_cols(df_table)
      is_date_like <- function(x) inherits(x, c("Date","POSIXct","POSIXt","difftime"))
      date_like <- vapply(df_table, is_date_like, logical(1))
      if (any(date_like)) df_table[date_like] <- lapply(df_table[date_like], as.character)
      df_table <- as.data.frame(df_table, stringsAsFactors = FALSE, check.names = FALSE)
      df_table <- fill_all_qp_pct(df_table, df)
      
      if (all(c("Whiff%","CSW%") %in% names(df_table))) {
        df_table <- df_table %>% dplyr::relocate(`CSW%`, .after = `Whiff%`)
      }
      if ("Pitching+" %in% names(df_table)) {
        df_table <- df_table %>% dplyr::relocate(`Pitching+`, .after = dplyr::last_col())
      }
      
      df_table <- enforce_process_order(df_table)
      df_table <- enforce_stuff_order(df_table)
      
      # Before renaming "Pitch" to split_col_name, check if split_col_name already exists
      # If it does (e.g., "IVB" or "HB"), remove the original column to avoid duplicates
      if (split_col_name %in% names(df_table) && split_col_name != "Pitch") {
        # Remove the pre-existing column (the measurement column like IVB or HB)
        df_table <- df_table %>% dplyr::select(-dplyr::all_of(split_col_name))
      }
      
      names(df_table)[names(df_table) == "Pitch"] <- split_col_name
      if (identical(mode, "Custom")) {
        order_cols <- unique(c(split_col_name, custom_cols))
        extras <- setdiff(names(df_table), order_cols)
        df_table <- df_table[, c(order_cols, extras), drop = FALSE]
      }
      visible_set <- visible_set_for(mode, custom_cols)
      # ALWAYS replace "Pitch" with split_col_name in visible_set, not just for Custom mode
      if (split_col_name != "Pitch") {
        visible_set <- gsub("^Pitch$", split_col_name, visible_set)
      }
      datatable_with_colvis(
        df_table,
        lock            = split_col_name,
        remember        = FALSE,
        default_visible = intersect(visible_set, names(df_table)),
        mode            = mode,
        enable_colors   = enable_colors
      )
    }
    
    # Custom table save/load within module
    observeEvent(input$cmpA_customSaved, {
      nm <- input$cmpA_customSaved
      if (!nzchar(nm)) return()
      ct <- custom_tables()
      if (!nm %in% names(ct)) return()
      cols <- ct[[nm]]$cols %||% character(0)
      updateTextInput(session, "cmpA_customName", value = nm)
      updateSelectizeInput(session, "cmpA_customCols", selected = cols)
    }, ignoreInit = TRUE)
    observeEvent(input$cmpA_saveCustom, {
      nm <- trimws(input$cmpA_customName %||% "")
      cols <- input$cmpA_customCols %||% character(0)
      if (!nzchar(nm) || !length(cols)) {
        showNotification("Please enter a name and choose at least one column.", type = "warning")
        return()
      }
      ct <- custom_tables()
      ct[[nm]] <- list(cols = cols)
      custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
      updateSelectInput(session, "cmpA_customSaved", choices = c("", names(ct)), selected = nm)
      showNotification(paste("Saved custom table", nm), type = "message")
    }, ignoreInit = TRUE)
    observeEvent(input$cmpA_deleteCustom, {
      nm <- input$cmpA_customSaved
      if (!nzchar(nm)) return()
      ct <- custom_tables()
      if (nm %in% names(ct)) {
        ct[[nm]] <- NULL
        custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
        updateSelectInput(session, "cmpA_customSaved", choices = c("", names(ct)), selected = "")
        showNotification(paste("Deleted custom table", nm), type = "message")
      }
    }, ignoreInit = TRUE)
    
    observeEvent(input$cmpB_customSaved, {
      nm <- input$cmpB_customSaved
      if (!nzchar(nm)) return()
      ct <- custom_tables()
      if (!nm %in% names(ct)) return()
      cols <- ct[[nm]]$cols %||% character(0)
      updateTextInput(session, "cmpB_customName", value = nm)
      updateSelectizeInput(session, "cmpB_customCols", selected = cols)
    }, ignoreInit = TRUE)
    observeEvent(input$cmpB_saveCustom, {
      nm <- trimws(input$cmpB_customName %||% "")
      cols <- input$cmpB_customCols %||% character(0)
      if (!nzchar(nm) || !length(cols)) {
        showNotification("Please enter a name and choose at least one column.", type = "warning")
        return()
      }
      ct <- custom_tables()
      ct[[nm]] <- list(cols = cols)
      custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
      updateSelectInput(session, "cmpB_customSaved", choices = c("", names(ct)), selected = nm)
      showNotification(paste("Saved custom table", nm), type = "message")
    }, ignoreInit = TRUE)
    observeEvent(input$cmpB_deleteCustom, {
      nm <- input$cmpB_customSaved
      if (!nzchar(nm)) return()
      ct <- custom_tables()
      if (nm %in% names(ct)) {
        ct[[nm]] <- NULL
        custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
        updateSelectInput(session, "cmpB_customSaved", choices = c("", names(ct)), selected = "")
        showNotification(paste("Deleted custom table", nm), type = "message")
      }
    }, ignoreInit = TRUE)
    
    output$cmpA_table <- DT::renderDataTable({
      res <- resolve_table_mode_global(input$cmpA_tableMode, input$cmpA_customCols)
      df_panel <- .filtered_panel("A")
      dom_attr <- attr(df_panel, "domain")
      df_tbl <- apply_split_by(df_panel, input$cmpA_splitBy %||% "Pitch Types")
      attr(df_tbl, "domain") <- dom_attr
      tryCatch(
        .dp_like_table(df_tbl, res$mode, res$cols,
                       enable_colors = isTRUE(input$cmpA_tableColors)),
        error = function(e) {
          message("cmpA_table datatable error: ", conditionMessage(e))
          DT::datatable(
            data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
            options = list(dom = 't'), rownames = FALSE
          )
        }
      )
    })
    output$cmpB_table <- DT::renderDataTable({
      res <- resolve_table_mode_global(input$cmpB_tableMode, input$cmpB_customCols)
      df_panel <- .filtered_panel("B")
      dom_attr <- attr(df_panel, "domain")
      df_tbl <- apply_split_by(df_panel, input$cmpB_splitBy %||% "Pitch Types")
      attr(df_tbl, "domain") <- dom_attr
      tryCatch(
        .dp_like_table(df_tbl, res$mode, res$cols,
                       enable_colors = isTRUE(input$cmpB_tableColors)),
        error = function(e) {
          message("cmpB_table datatable error: ", conditionMessage(e))
          DT::datatable(
            data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
            options = list(dom = 't'), rownames = FALSE
          )
        }
      )
    })
  })
}

# ==================================
# == Correlations Suite ==
# ==================================

# Correlations UI
correlations_ui <- function() {
  fluidPage(
    tags$head(
      tags$style(HTML("
        .correlation-sidebar {
          background-color: #f8f9fa;
          border-right: 1px solid #dee2e6;
          padding: 20px;
          min-height: 100vh;
        }
        .correlation-main {
          padding: 20px;
        }
        .correlation-chart {
          border: 1px solid #dee2e6;
          border-radius: 5px;
          padding: 15px;
          background-color: transparent;
        }
        .correlation-controls {
          margin-bottom: 20px;
        }
        /* Dark mode overrides */
        body.theme-dark .correlation-sidebar {
          background-color: transparent !important;
          border-color: rgba(255,255,255,0.08) !important;
          color: #e5e7eb !important;
        }
        body.theme-dark .correlation-main {
          background: transparent !important;
          color: #e5e7eb !important;
        }
        body.theme-dark .correlation-chart {
          background: transparent !important;
          border-color: rgba(255,255,255,0.12) !important;
          box-shadow: 0 2px 14px rgba(0,0,0,0.35);
        }
        body.theme-dark #corr_summary,
        body.theme-dark #corr_data_table,
        body.theme-dark .correlation-controls label {
          color: #e5e7eb !important;
        }
        body.theme-dark .correlation-controls .form-control,
        body.theme-dark .correlation-controls .selectize-input {
          background: #0f172a !important;
          color: #e5e7eb !important;
          border-color: #1f2937 !important;
        }
      "))
    ),
    fluidRow(
      # Sidebar with controls
      column(3, class = "correlation-sidebar",
             h4("Correlation Analysis Settings"),
             
             # Domain selection
             div(class = "correlation-controls",
                 selectInput("corr_domain", "Domain:",
                             choices = c("Pitching", "Hitting", "Catching"),
                             selected = "Pitching")
             ),
             
             # Team selection
             div(class = "correlation-controls",
                 selectInput("corr_teamType", "Team:",
                             choices = TEAM_CHOICES,
                             selected = "All")
             ),
             
             # Date range
             div(class = "correlation-controls",
                 dateRangeInput("corr_date_range", "Date Range:",
                                start = max(pitch_data$Date, na.rm = TRUE),
                                end = max(pitch_data$Date, na.rm = TRUE),
                                format = "yyyy-mm-dd")
             ),
             
             # Player selection
             div(class = "correlation-controls",
                 selectInput("corr_player", "Select Player:",
                             choices = NULL,
                             multiple = TRUE)
             ),
             
             # Pitch type selection
             div(class = "correlation-controls",
                 selectInput("corr_pitch_type", "Pitch Type:",
                             choices = c("All" = "all"),
                             selected = "all",
                             multiple = TRUE)
             ),
             
             # Stuff+ Base Pitch option
             div(class = "correlation-controls",
                 selectInput("corr_stuff_base", "Stuff+ Base Pitch:",
                             choices = NULL)
             ),
             
             # Variable selection
             div(class = "correlation-controls",
                 selectInput("corr_var_x", "X Variable:",
                             choices = NULL)
             ),
             
             div(class = "correlation-controls",
                 selectInput("corr_var_y", "Y Variable:",
                             choices = NULL)
             ),
             
             # Aggregation level
             div(class = "correlation-controls",
                 radioButtons("corr_aggregation", "Data Level:",
                              choices = c("Player Averages" = "averages",
                                          "Individual Pitches" = "pitches"),
                              selected = "averages")
             ),
             
             # Analysis button
             div(class = "correlation-controls",
                 actionButton("corr_analyze", "Run Correlation Analysis",
                              class = "btn-primary btn-block")
             )
      ),
      
      # Main panel with results
      column(9, class = "correlation-main",
             div(id = "correlations-content",
                 h3("Correlation Analysis Results"),
                 
                 # Results summary
                 div(id = "corr_summary",
                     uiOutput("corr_summary_ui")
                 ),
                 
                 # Correlation chart
                 div(class = "correlation-chart",
                     plotOutput("corr_plot", height = "500px")
                 ),
                 
                 br(),
                 
                 # Data table
                 div(
                   h4("Data Used in Analysis"),
                   DT::dataTableOutput("corr_data_table")
                 )
             ) # Close correlations-content div
      )
    )
  )
}

# ----------------------------------------
# Custom Reports UI / Server (new suite)
# ----------------------------------------
custom_reports_ui <- function(id) {
  ns <- NS(id)
  fluidPage(
    shinyjs::useShinyjs(),  # Enable shinyjs
    div(
      class = "creports-root",
      # Floating show sidebar button (only visible when sidebar is hidden)
      div(id = ns("show_sidebar_btn"), style = "display:none; position:fixed; top:10px; left:10px; z-index:2000;",
          actionButton(ns("show_sidebar"), "Show Sidebar", class = "btn-primary btn-sm")
      ),
      fluidRow(
        # Sidebar with toggle button
        column(3, id = ns("sidebar_column"),
               div(style = "position:relative;",
                   actionButton(ns("toggle_sidebar"), "Hide Sidebar", 
                                class = "btn-sm btn-secondary", 
                                style = "position:absolute; right:5px; top:5px; z-index:1000;"),
                   h4("Report Setup"),
                   textInput(ns("report_title"), "Report Title", ""),
                   selectInput(ns("report_type"), "Report Type:", choices = c("Pitching","Hitting"), selected = "Pitching"),
                   selectInput(ns("report_scope"), "Scope:", choices = c("Single Player","Multi-Player"), selected = "Single Player"),
                   # Single Player mode - show player selector
                   conditionalPanel(
                     sprintf("input['%s'] == 'Single Player'", ns("report_scope")),
                     selectizeInput(ns("report_players"), "Players:", choices = NULL, multiple = TRUE)
                   ),
                   # Multi-Player mode - note about row assignments
                   conditionalPanel(
                     sprintf("input['%s'] == 'Multi-Player'", ns("report_scope")),
                     div(style = "background-color:#f0f0f0; padding:10px; border-radius:5px; margin-bottom:10px;",
                         tags$strong("Multi-Player Mode:"),
                         tags$br(),
                         "Each row = 1 player"
                     ),
                     # Player dropdowns for each possible row (only show up to current row count)
                     uiOutput(ns("multi_player_selectors"))
                   ),
                   selectInput(ns("report_rows"), "Rows:", choices = 1:15, selected = 1),
                   selectInput(ns("report_cols"), "Columns:", choices = 1:5, selected = 1),
                   selectInput(ns("saved_report"), "Saved Reports:", choices = c(""), selected = ""),
                   uiOutput(ns("report_global_toggle")),
                   div(style = "display: flex; gap: 5px;",
                       actionButton(ns("new_report"), "New Report", class = "btn-success btn-sm"),
                       actionButton(ns("save_report"), "Save Report", class = "btn-primary btn-sm"),
                       actionButton(ns("delete_report"), "Delete Report", class = "btn-danger btn-sm")
                   )
               )
        ),
        column(9, id = ns("main_column"),
               uiOutput(ns("report_header")),
               uiOutput(ns("report_canvas"))
        )
      )
    )
  )
}

custom_reports_server <- function(id) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    is_admin_fun <- get0("is_admin", mode = "function", inherits = TRUE)
    is_admin_local <- reactive({
      if (is.null(is_admin_fun)) return(FALSE)
      val <- try(is_admin_fun(), silent = TRUE)
      if (inherits(val, "try-error")) FALSE else isTRUE(val)
    })
    
    output$report_global_toggle <- renderUI({
      if (!isTRUE(is_admin_local())) return(NULL)
      checkboxInput(ns("report_global"), "Share with all schools (admin)", value = FALSE)
    })
    
    # Sidebar toggle
    sidebar_visible <- reactiveVal(TRUE)
    observeEvent(input$toggle_sidebar, {
      sidebar_visible(!sidebar_visible())
      if (sidebar_visible()) {
        shinyjs::show("sidebar_column")
        shinyjs::hide("show_sidebar_btn")
        shinyjs::removeClass(selector = paste0("#", ns("main_column")), class = "col-sm-12")
        shinyjs::addClass(selector = paste0("#", ns("main_column")), class = "col-sm-9")
        updateActionButton(session, "toggle_sidebar", label = "Hide Sidebar")
      } else {
        shinyjs::hide("sidebar_column")
        shinyjs::show("show_sidebar_btn")
        shinyjs::removeClass(selector = paste0("#", ns("main_column")), class = "col-sm-9")
        shinyjs::addClass(selector = paste0("#", ns("main_column")), class = "col-sm-12")
      }
    })
    
    # Show sidebar button click
    observeEvent(input$show_sidebar, {
      sidebar_visible(TRUE)
      shinyjs::show("sidebar_column")
      shinyjs::hide("show_sidebar_btn")
      shinyjs::removeClass(selector = paste0("#", ns("main_column")), class = "col-sm-12")
      shinyjs::addClass(selector = paste0("#", ns("main_column")), class = "col-sm-9")
      updateActionButton(session, "toggle_sidebar", label = "Hide Sidebar")
    })
    
    observe({
      updateSelectInput(session, "saved_report", choices = c("", names(custom_reports_store())))
    })
    
    # Populate players based on type (for Single Player mode)
    observeEvent(input$report_type, {
      if (input$report_type == "Pitching") {
        players <- sort(unique(stats::na.omit(c(pitch_data_pitching$Pitcher, pitch_data$Pitcher))))
      } else {
        # For hitting, get batters from pitch_data
        batters <- unique(stats::na.omit(as.character(pitch_data$Batter)))
        batters <- batters[nzchar(batters)]  # Remove empty strings
        players <- sort(batters)
      }
      
      # Update the main player selector (Single Player mode) - add "All" option
      updateSelectizeInput(session, "report_players",
                           choices = c("All", players),
                           selected = "All",  # Default to All
                           server = TRUE)
      
      # Update all row player selectors (Multi-Player mode) - add "All" option
      for (r in 1:15) {
        selector_id <- paste0("row_player_", r)
        updateSelectizeInput(session, selector_id,
                             choices = c("", "All", players),
                             server = TRUE)
      }
    }, ignoreInit = FALSE)
    
    # Load saved report
    observeEvent(input$saved_report, {
      nm <- input$saved_report
      if (!nzchar(nm)) return()
      cr <- custom_reports_store()
      if (!nm %in% names(cr)) return()
      rep <- cr[[nm]]
      if (isTRUE(is_admin_local())) {
        updateCheckboxInput(session, "report_global", value = identical(rep$school_code, GLOBAL_SCOPE))
      }
      
      # Set loading flag to prevent observe block from overwriting
      loading_report(TRUE)
      
      # FIRST: Update current_cells with saved data (before UI changes)
      update_reports_grid(rep$cells %||% list())
      
      # THEN: Update all UI elements (this will trigger renderUI which reads from current_cells)
      updateTextInput(session, "report_title", value = rep$title %||% "")
      updateSelectInput(session, "report_type", selected = rep$type %||% "Pitching")
      updateSelectInput(session, "report_scope", selected = rep$scope %||% "Single Player")
      updateSelectizeInput(session, "report_players", selected = rep$players %||% character(0))
      updateSelectInput(session, "report_rows", selected = rep$rows %||% 1)
      updateSelectInput(session, "report_cols", selected = rep$cols %||% 1)
      
      # After a delay, explicitly update filter inputs and player selectors
      # This ensures they get the saved values even if the UI already exists
      later::later(function() {
        cells <- rep$cells %||% list()
        rows <- rep$rows %||% 1
        cols <- rep$cols %||% 1
        scope <- rep$scope %||% "Single Player"
        
        # FIRST: Always show controls when loading a report
        # This ensures filter controls are visible so we can update them
        for (r in seq_len(rows)) {
          for (c in seq_len(cols)) {
            cell_id <- paste0("r", r, "c", c)
            updateCheckboxInput(session, paste0("cell_show_controls_", cell_id), value = TRUE)
          }
        }
        
        # THEN: Wait a bit for controls to render, then update filter values
        later::later(function() {
          # Update row player inputs in Multi-Player mode
          if (scope == "Multi-Player") {
            for (r in seq_len(rows)) {
              player_val <- cells[[paste0("row_", r, "_player")]]
              if (!is.null(player_val) && length(player_val) == 1 && !is.na(player_val) && player_val != "") {
                updateSelectizeInput(session, paste0("row_player_", r), selected = player_val)
              }
            }
          }
          
          # Update filter inputs for each cell
          for (r in seq_len(rows)) {
            for (c in seq_len(cols)) {
              cell_id <- paste0("r", r, "c", c)
              saved_cell <- cells[[cell_id]]
              if (!is.null(saved_cell)) {
                # Update filter inputs if they have saved values
                if (!is.null(saved_cell$dates) && length(saved_cell$dates) == 2) {
                  updateDateRangeInput(session, paste0("cell_dates_", cell_id), 
                                       start = saved_cell$dates[1], end = saved_cell$dates[2])
                }
                if (!is.null(saved_cell$session) && length(saved_cell$session) == 1 && !is.na(saved_cell$session) && saved_cell$session != "") {
                  updateSelectInput(session, paste0("cell_session_", cell_id), selected = saved_cell$session)
                }
                if (!is.null(saved_cell$pitch_types) && length(saved_cell$pitch_types) > 0) {
                  updateSelectizeInput(session, paste0("cell_pitch_types_", cell_id), selected = saved_cell$pitch_types)
                }
                if (!is.null(saved_cell$batter_side) && length(saved_cell$batter_side) == 1 && !is.na(saved_cell$batter_side) && saved_cell$batter_side != "") {
                  updateSelectInput(session, paste0("cell_batter_side_", cell_id), selected = saved_cell$batter_side)
                }
                if (!is.null(saved_cell$pitcher_hand) && length(saved_cell$pitcher_hand) == 1 && !is.na(saved_cell$pitcher_hand) && saved_cell$pitcher_hand != "") {
                  updateSelectInput(session, paste0("cell_pitcher_hand_", cell_id), selected = saved_cell$pitcher_hand)
                }
                if (!is.null(saved_cell$results) && length(saved_cell$results) > 0) {
                  updateSelectInput(session, paste0("cell_results_", cell_id), selected = saved_cell$results)
                }
                if (!is.null(saved_cell$qp) && length(saved_cell$qp) == 1 && !is.na(saved_cell$qp) && saved_cell$qp != "") {
                  updateSelectInput(session, paste0("cell_qp_", cell_id), selected = saved_cell$qp)
                }
                if (!is.null(saved_cell$count) && length(saved_cell$count) > 0) {
                  updateSelectInput(session, paste0("cell_count_", cell_id), selected = saved_cell$count)
                }
                if (!is.null(saved_cell$after_count) && length(saved_cell$after_count) > 0) {
                  updateSelectInput(session, paste0("cell_after_count_", cell_id), selected = saved_cell$after_count)
                }
                if (!is.null(saved_cell$zone) && length(saved_cell$zone) > 0) {
                  updateSelectInput(session, paste0("cell_zone_", cell_id), selected = saved_cell$zone)
                }
                if (!is.null(saved_cell$velo_min) && length(saved_cell$velo_min) == 1 && !is.na(saved_cell$velo_min)) {
                  updateNumericInput(session, paste0("cell_velo_min_", cell_id), value = saved_cell$velo_min)
                }
                if (!is.null(saved_cell$velo_max) && length(saved_cell$velo_max) == 1 && !is.na(saved_cell$velo_max)) {
                  updateNumericInput(session, paste0("cell_velo_max_", cell_id), value = saved_cell$velo_max)
                }
                if (!is.null(saved_cell$ivb_min) && length(saved_cell$ivb_min) == 1 && !is.na(saved_cell$ivb_min)) {
                  updateNumericInput(session, paste0("cell_ivb_min_", cell_id), value = saved_cell$ivb_min)
                }
                if (!is.null(saved_cell$ivb_max) && length(saved_cell$ivb_max) == 1 && !is.na(saved_cell$ivb_max)) {
                  updateNumericInput(session, paste0("cell_ivb_max_", cell_id), value = saved_cell$ivb_max)
                }
                if (!is.null(saved_cell$hb_min) && length(saved_cell$hb_min) == 1 && !is.na(saved_cell$hb_min)) {
                  updateNumericInput(session, paste0("cell_hb_min_", cell_id), value = saved_cell$hb_min)
                }
                if (!is.null(saved_cell$hb_max) && length(saved_cell$hb_max) == 1 && !is.na(saved_cell$hb_max)) {
                  updateNumericInput(session, paste0("cell_hb_max_", cell_id), value = saved_cell$hb_max)
                }
              }
            }
          }          # Clear the loading flag after all updates are done
          loading_report(FALSE)
        }, delay = 0.5)  # 0.5 second delay for controls to render
      }, delay = 1.5)  # 1.5 second initial delay
    }, ignoreInit = TRUE)
    
    # Render player selectors in sidebar for Multi-Player mode
    output$multi_player_selectors <- renderUI({
      req(input$report_scope == "Multi-Player")
      rows <- as.integer(input$report_rows)
      if (is.na(rows) || rows < 1) return(NULL)
      
      players <- if (input$report_type == "Pitching") {
        sort(unique(stats::na.omit(c(pitch_data_pitching$Pitcher, pitch_data$Pitcher))))
      } else {
        sort(unique(stats::na.omit(c(pitch_data$Batter, pitch_data_pitching$Batter))))
      }
      
      cells <- current_cells()
      
      lapply(1:rows, function(r) {
        selectizeInput(
          ns(paste0("row_player_", r)),
          paste0("Row ", r, " Player:"),
          choices = c("", "All", players),
          selected = cells[[paste0("row_", r, "_player")]] %||% "",
          width = "100%"
        )
      })
    })
    
    # Header showing report title + players
    output$report_header <- renderUI({
      title_txt <- trimws(input$report_title)
      
      # Helper function to format player names from "Last, First" to "First Last"
      format_player_name <- function(p) {
        if (grepl(",", p)) {
          parts <- strsplit(p, ",\\s*")[[1]]
          if (length(parts) == 2) {
            paste(parts[2], parts[1])  # First Last
          } else {
            p
          }
        } else {
          p
        }
      }
      
      # Build player label based on mode - DON'T show player names in Multi-Player
      player_lbl <- if (input$report_scope == "Multi-Player") {
        NULL  # Don't show player names in Multi-Player mode
      } else {
        # Single Player mode
        players <- input$report_players %||% character(0)
        if (length(players) > 0) {
          formatted_players <- sapply(players, format_player_name)
          paste(formatted_players, collapse = " | ")
        } else {
          "No players selected"
        }
      }
      
      tagList(
        h3(style = "margin-top:0; margin-bottom:4px; text-align:center;", 
           if (nzchar(title_txt)) title_txt else "Custom Report"),
        if (!is.null(player_lbl)) {
          div(style = "font-weight:600; margin-bottom:10px; text-align:center;", player_lbl)
        }
      )
    })
    
    # Save report
    observeEvent(input$save_report, {
      nm <- trimws(input$report_title)
      if (!nzchar(nm)) {
        showNotification("Please enter a report title.", type = "warning")
        return()
      }
      cells <- isolate(current_cells())
      scope <- if (isTRUE(is_admin_local()) && isTRUE(input$report_global)) GLOBAL_SCOPE else current_school()
      rep <- list(
        title = nm,
        type = input$report_type,
        scope = input$report_scope,
        players = input$report_players,
        rows = as.integer(input$report_rows),
        cols = as.integer(input$report_cols),
        cells = cells,
        school_code = scope
      )
      cr <- custom_reports_store()
      cr[[nm]] <- rep
      custom_reports_store(cr); save_custom_reports(cr)
      updateSelectInput(session, "saved_report", choices = c("", names(cr)), selected = nm)
      showNotification("Report saved.", type = "message")
    }, ignoreInit = TRUE)
    
    # Delete
    observeEvent(input$delete_report, {
      nm <- input$saved_report
      if (!nzchar(nm)) return()
      cr <- custom_reports_store()
      if (nm %in% names(cr)) {
        cr[[nm]] <- NULL
        custom_reports_store(cr); save_custom_reports(cr)
        updateSelectInput(session, "saved_report", choices = c("", names(cr)), selected = "")
        showNotification("Report deleted.", type = "message")
      }
    }, ignoreInit = TRUE)
    
    # New Report - clear everything for fresh start
    observeEvent(input$new_report, {
      # Clear all cells
      current_cells(list())
      
      # Reset to defaults
      updateTextInput(session, "report_title", value = "")
      updateSelectInput(session, "report_type", selected = "Pitching")
      updateSelectInput(session, "report_scope", selected = "Single Player")
      updateSelectizeInput(session, "report_players", selected = character(0))
      updateSelectInput(session, "report_rows", selected = 1)
      updateSelectInput(session, "report_cols", selected = 1)
      updateSelectInput(session, "saved_report", selected = "")
      if (isTRUE(is_admin_local())) updateCheckboxInput(session, "report_global", value = FALSE)
      
      showNotification("New report created. Start building!", type = "message")
    }, ignoreInit = TRUE)
    
    # Grid state
    current_cells <- reactiveVal(list())
    loading_report <- reactiveVal(FALSE)  # Flag to prevent observe from overwriting during load
    update_reports_grid <- function(cells_list) {
      current_cells(cells_list)
    }
    
    # Build per-cell filter UI based on "Filters to show"
    output_filters_for_cell <- function(cell_id) {
      renderUI({
        # Get saved values from current_cells if available
        cells <- current_cells()
        saved_cell <- cells[[cell_id]] %||% list()
        
        # Check input first, then saved cell data for filter_select
        sel <- input[[paste0("cell_filter_select_", cell_id)]] %||% saved_cell$filter_select %||% character(0)
        
        out <- list()
        if ("Dates" %in% sel) {
          all_dates <- c(pitch_data_pitching$Date, pitch_data$Date)
          d_min <- suppressWarnings(min(all_dates, na.rm = TRUE))
          d_max <- suppressWarnings(max(all_dates, na.rm = TRUE))
          if (!is.finite(d_min)) d_min <- Sys.Date() - 30
          if (!is.finite(d_max)) d_max <- Sys.Date()
          
          # Preserve existing date range - check input first, then saved cell data
          existing_dates <- input[[paste0("cell_dates_", cell_id)]] %||% saved_cell$dates %||% NULL
          start_date <- if (!is.null(existing_dates) && length(existing_dates) >= 1) existing_dates[1] else d_max - 30
          end_date <- if (!is.null(existing_dates) && length(existing_dates) >= 2) existing_dates[2] else d_max
          
          out <- c(out, list(
            dateRangeInput(ns(paste0("cell_dates_", cell_id)), "Dates:",
                           start = start_date, end = end_date, min = d_min, max = d_max,
                           format = "mm/dd/yyyy")
          ))
        }
        if ("Session Type" %in% sel) {
          existing_session <- input[[paste0("cell_session_", cell_id)]] %||% saved_cell$session %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_session_", cell_id)), "Session Type:",
                        choices = c("All","Bullpen","Live"), 
                        selected = if (!is.null(existing_session)) existing_session else "All")
          ))
        }
        if ("Pitch Types" %in% sel) {
          pts <- if (input$report_type == "Pitching") {
            sort(unique(as.character(pitch_data_pitching$TaggedPitchType)))
          } else {
            sort(unique(as.character(pitch_data$TaggedPitchType)))
          }
          existing_types <- input[[paste0("cell_pitch_types_", cell_id)]] %||% saved_cell$pitch_types %||% NULL
          out <- c(out, list(
            selectizeInput(ns(paste0("cell_pitch_types_", cell_id)), "Pitch Types:",
                           choices = c("All", pts), multiple = TRUE, 
                           selected = if (!is.null(existing_types)) existing_types else "All")
          ))
        }
        if ("Batter Hand" %in% sel) {
          existing_batter <- input[[paste0("cell_batter_side_", cell_id)]] %||% saved_cell$batter_side %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_batter_side_", cell_id)), "Batter Hand:",
                        choices = c("All","Left","Right"), 
                        selected = if (!is.null(existing_batter)) existing_batter else "All")
          ))
        }
        if ("Pitcher Hand" %in% sel) {
          existing_pitcher <- input[[paste0("cell_pitcher_hand_", cell_id)]] %||% saved_cell$pitcher_hand %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_pitcher_hand_", cell_id)), "Pitcher Hand:",
                        choices = c("All","Left","Right"), 
                        selected = if (!is.null(existing_pitcher)) existing_pitcher else "All")
          ))
        }
        if ("Pitch Results" %in% sel) {
          existing_results <- input[[paste0("cell_results_", cell_id)]] %||% saved_cell$results %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_results_", cell_id)), "Pitch Results:",
                        choices = c("All", result_levels), 
                        selected = if (!is.null(existing_results)) existing_results else "All", 
                        multiple = TRUE)
          ))
        }
        if ("QP Locations" %in% sel) {
          existing_qp <- input[[paste0("cell_qp_", cell_id)]] %||% saved_cell$qp %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_qp_", cell_id)), "QP Locations:",
                        choices = c("All","Yes","No"), 
                        selected = if (!is.null(existing_qp)) existing_qp else "All")
          ))
        }
        if ("Count" %in% sel) {
          existing_count <- input[[paste0("cell_count_", cell_id)]] %||% saved_cell$count %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_count_", cell_id)), "Count:",
                        choices = c("All","Even","Behind","Ahead","2KNF",
                                    "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
                        selected = if (!is.null(existing_count)) existing_count else "All", 
                        multiple = TRUE)
          ))
        }
        if ("After Count" %in% sel) {
          existing_after <- input[[paste0("cell_after_count_", cell_id)]] %||% saved_cell$after_count %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_after_count_", cell_id)), "After Count:",
                        choices = c("All","Even","Behind","Ahead","2KNF",
                                    "0-0","0-1","1-0","1-1","2-0","2-1","0-2","1-2","2-2","3-0","3-1","3-2"),
                        selected = if (!is.null(existing_after)) existing_after else "All", 
                        multiple = TRUE)
          ))
        }
        if ("Zone Location" %in% sel) {
          existing_zone <- input[[paste0("cell_zone_", cell_id)]] %||% saved_cell$zone %||% NULL
          out <- c(out, list(
            selectInput(ns(paste0("cell_zone_", cell_id)), "Zone Location:",
                        choices = c("All",
                                    "Upper Half","Bottom Half","Left Half","Right Half",
                                    "Upper 3rd","Bottom 3rd","Left 3rd","Right 3rd"),
                        selected = if (!is.null(existing_zone)) existing_zone else "All", 
                        multiple = TRUE)
          ))
        }
        if ("Velo Min/Max" %in% sel) {
          existing_vmin <- input[[paste0("cell_velo_min_", cell_id)]] %||% saved_cell$velo_min %||% NULL
          existing_vmax <- input[[paste0("cell_velo_max_", cell_id)]] %||% saved_cell$velo_max %||% NULL
          out <- c(out, list(
            numericInput(ns(paste0("cell_velo_min_", cell_id)), "Velo Min", 
                         value = if (!is.null(existing_vmin)) existing_vmin else NA),
            numericInput(ns(paste0("cell_velo_max_", cell_id)), "Velo Max", 
                         value = if (!is.null(existing_vmax)) existing_vmax else NA)
          ))
        }
        if ("IVB Min/Max" %in% sel) {
          existing_ivbmin <- input[[paste0("cell_ivb_min_", cell_id)]] %||% saved_cell$ivb_min %||% NULL
          existing_ivbmax <- input[[paste0("cell_ivb_max_", cell_id)]] %||% saved_cell$ivb_max %||% NULL
          out <- c(out, list(
            numericInput(ns(paste0("cell_ivb_min_", cell_id)), "IVB Min", 
                         value = if (!is.null(existing_ivbmin)) existing_ivbmin else NA),
            numericInput(ns(paste0("cell_ivb_max_", cell_id)), "IVB Max", 
                         value = if (!is.null(existing_ivbmax)) existing_ivbmax else NA)
          ))
        }
        if ("HB Min/Max" %in% sel) {
          existing_hbmin <- input[[paste0("cell_hb_min_", cell_id)]] %||% saved_cell$hb_min %||% NULL
          existing_hbmax <- input[[paste0("cell_hb_max_", cell_id)]] %||% saved_cell$hb_max %||% NULL
          out <- c(out, list(
            numericInput(ns(paste0("cell_hb_min_", cell_id)), "HB Min", 
                         value = if (!is.null(existing_hbmin)) existing_hbmin else NA),
            numericInput(ns(paste0("cell_hb_max_", cell_id)), "HB Max", 
                         value = if (!is.null(existing_hbmax)) existing_hbmax else NA)
          ))
        }
        if (length(out)) {
          div(style = "display: flex; flex-wrap: wrap; gap: 10px;",
              lapply(out, function(item) {
                div(style = "flex: 0 1 auto; min-width: 150px;", item)
              })
          )
        } else {
          div("No filters selected")
        }
      })
    }
    
    # When grid size changes, preserve existing cell data
    observeEvent(list(input$report_rows, input$report_cols), {
      rows <- suppressWarnings(as.integer(input$report_rows))
      cols <- suppressWarnings(as.integer(input$report_cols))
      if (is.null(rows) || length(rows)==0 || is.na(rows) || rows < 1) return()
      if (is.null(cols) || length(cols)==0 || is.na(cols) || cols < 1) return()
      # Don't clear current_cells - just keep existing data
      # This allows cells to persist when adding more rows/cols
    })
    
    # Render filter controls for each cell (only when grid size changes)
    observeEvent(list(input$report_rows, input$report_cols), {
      rows <- suppressWarnings(as.integer(input$report_rows))
      cols <- suppressWarnings(as.integer(input$report_cols))
      if (is.null(rows) || length(rows)==0 || is.na(rows) || rows < 1) return()
      if (is.null(cols) || length(cols)==0 || is.na(cols) || cols < 1) return()
      for (r in seq_len(rows)) for (c in seq_len(cols)) {
        local({
          rid <- r; cid <- c
          cell_id <- paste0("r", rid, "c", cid)
          output[[paste0("cell_filters_", cell_id)]] <- output_filters_for_cell(cell_id)
        })
      }
    }, ignoreInit = FALSE)
    
    # UI for grid
    output$report_canvas <- renderUI({
      rows <- as.integer(input$report_rows); cols <- as.integer(input$report_cols)
      cells <- isolate(current_cells())  # Use isolate to prevent re-rendering on cell changes
      is_multi_player <- input$report_scope == "Multi-Player"
      
      # Helper function to format player names from "Last, First" to "First Last"
      format_player_name <- function(player_name) {
        if (is.null(player_name) || !nzchar(player_name)) return("")
        if (grepl(",", player_name)) {
          parts <- strsplit(player_name, ",\\s*")[[1]]
          if (length(parts) == 2) {
            return(paste(parts[2], parts[1]))  # First Last
          }
        }
        player_name
      }
      
      grid <- lapply(seq_len(rows), function(r) {
        # For Multi-Player mode, add player name before the row of charts
        player_name_row <- NULL
        if (is_multi_player) {
          row_player <- input[[paste0("row_player_", r)]]
          if (!is.null(row_player) && nzchar(row_player)) {
            formatted_name <- format_player_name(row_player)
            player_name_row <- div(
              style = "font-size:18px; font-weight:bold; margin-bottom:10px; margin-top:15px; padding-left:15px;",
              formatted_name
            )
          }
        }
        
        # Build cells for this row
        row_cells <- lapply(seq_len(cols), function(cn) {
          cell_id <- paste0("r", r, "c", cn)
          sel <- cells[[cell_id]] %||% list(
            type = "", 
            filter = "Pitch Types", 
            title = "",
            show_controls = TRUE,
            table_mode = "Stuff",
            table_custom_cols = character(0),
            color = TRUE,
            heat_stat = "Frequency",
            filter_select = c("Dates","Session Type","Pitch Types")
          )
          width <- if (cols == 1) 8 else if (cols == 2) 6 else if (cols == 3) 4 else if (cols == 4) 3 else 2
          offset <- if (cols == 1 && cn == 1) 2 else 0
          
          # In Multi-Player mode, rows 2+ use row 1's settings
          is_controlled_row <- is_multi_player && r > 1
          
          column(
            width = width, offset = offset,
            div(class = "creport-cell",
                # Always create controls to preserve state, but hide them for rows 2+ in Multi-Player mode
                # Title and show controls toggle
                div(style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;",
                    if (!is_controlled_row) {
                      # Row 1 or Single-Player mode: show checkbox
                      checkboxInput(ns(paste0("cell_show_controls_", cell_id)), "Show controls", 
                                    value = sel$show_controls %||% TRUE, width = "120px")
                    }
                ),
                # Controls container - always render but hide with CSS for rows 2+
                div(
                  id = ns(paste0("cell_controls_container_", cell_id)),
                  style = if (is_controlled_row) "display:none;" else "",  # Hide for rows 2+ using CSS
                  conditionalPanel(
                    condition = if (is_controlled_row) "false" else sprintf("input['%s']", ns(paste0("cell_show_controls_", cell_id))),
                    div(
                      # Title input - only visible when controls are shown
                      textInput(ns(paste0("cell_title_", cell_id)), "Chart Title:", 
                                value = sel$title %||% "", placeholder = "Enter chart title..."),
                      selectInput(ns(paste0("cell_type_", cell_id)), "Content:", 
                                  choices = c("", "Movement Plot", "Release Plot", "Location Plot", "Heatmap", "Summary Table", "Spray Chart"),
                                  selected = sel$type),
                      conditionalPanel(
                        sprintf("input['%s'] == 'Summary Table'", ns(paste0("cell_type_", cell_id))),
                        tagList(
                          selectInput(ns(paste0("cell_table_mode_", cell_id)), "Table:", 
                                      choices = if (input$report_type == "Hitting") c("Results","Swing Decisions","Custom") else c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data",
                                                                                                                                   names(custom_tables()), "Custom"),
                                      selected = {
                                        ch <- if (input$report_type == "Hitting") c("Results","Swing Decisions","Custom") else c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data",
                                                                                                                                names(custom_tables()), "Custom")
                                        if (!is.null(sel$table_mode) && sel$table_mode %in% ch) sel$table_mode else ch[[1]]
                                      }),
                          selectInput(ns(paste0("cell_filter_", cell_id)), "Split By:", 
                                      choices = c("Pitch Types","Batter Hand","Pitcher Hand","Count","After Count","Velocity","IVB","HB","Batter"),
                                      selected = sel$filter),
                          checkboxInput(ns(paste0("cell_color_", cell_id)), "Color-Code", value = sel$color %||% TRUE),
                          conditionalPanel(
                            condition = sprintf("input['%s']=='Custom' && input['%s']=='Hitting'", 
                                                ns(paste0("cell_table_mode_", cell_id)), ns("report_type")),
                            selectizeInput(
                              ns(paste0("cell_table_custom_cols_", cell_id)),
                              "Columns (drag to order):",
                              choices = c("PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP",
                                          "Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%","EV","LA"),
                              selected = sel$table_custom_cols %||% c("PA","AB","AVG","SLG","OBP","OPS","Swing%","Whiff%"),
                              multiple = TRUE,
                              options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
                            )
                          )
                        )
                      ),
                      conditionalPanel(
                        sprintf("input['%s'] == 'Heatmap'", ns(paste0("cell_type_", cell_id))),
                        selectInput(ns(paste0("cell_heat_stat_", cell_id)), "Heatmap Type:",
                                    choices = c("Frequency","Whiff Rate","Exit Velocity","GB Rate","Contact Rate","Swing Rate","Run Values"),
                                    selected = sel$heat_stat %||% "Frequency")
                      ),
                      # Per-cell filters (collapsed set)
                      selectizeInput(
                        ns(paste0("cell_filter_select_", cell_id)),
                        "Filters to show:",
                        choices = c("Dates","Session Type","Pitch Types","Batter Hand","Pitcher Hand","Pitch Results","QP Locations",
                                    "Count","After Count","Zone Location","Velo Min/Max","IVB Min/Max","HB Min/Max"),
                        selected = sel$filter_select %||% c("Dates","Session Type","Pitch Types"),
                        multiple = TRUE,
                        options = list(plugins = list("remove_button"))
                      ),
                      uiOutput(ns(paste0("cell_filters_", cell_id)))
                    )
                  )
                ),
                # Title display - non-reactive div updated via JavaScript
                div(
                  id = ns(paste0("cell_title_display_", cell_id)),
                  style = "text-align:center; margin-bottom:10px; font-weight:bold;",
                  ""  # Empty initially, updated via JS
                ),
                # Cell output - always rendered
                uiOutput(ns(paste0("cell_output_", cell_id)))
            )
          )
        })
        
        # Return player name (if Multi-Player) followed by the row of charts
        tagList(player_name_row, fluidRow(row_cells))
      })
      
      tagList(grid)
    })
    
    # Observe cell selections and update stored state (throttle to prevent excessive updates)
    observe({
      # Don't update if we're currently loading a saved report
      if (loading_report()) return()
      
      rows <- as.integer(input$report_rows); cols <- as.integer(input$report_cols)
      
      # Validate that rows and cols are valid integers
      if (length(rows) == 0 || length(cols) == 0) return()
      if (is.na(rows) || is.na(cols)) return()
      if (rows < 1 || cols < 1) return()
      
      cells <- isolate(current_cells())  # Use isolate to prevent dependency loops
      
      # Save row players in Multi-Player mode
      if (input$report_scope == "Multi-Player") {
        for (r in seq_len(rows)) {
          player_input <- input[[paste0("row_player_", r)]]
          # Only update if input exists, otherwise preserve existing value
          if (!is.null(player_input)) {
            cells[[paste0("row_", r, "_player")]] <- player_input
          }
        }
      }
      
      for (r in seq_len(rows)) {
        for (c in seq_len(cols)) {
          id <- paste0("r", r, "c", c)
          
          # Get existing cell data or create new
          existing_cell <- cells[[id]] %||% list()
          
          # Helper function to update value only if input exists, otherwise keep existing
          update_if_exists <- function(input_val, existing_val, default_val = NULL) {
            if (!is.null(input_val)) input_val
            else if (!is.null(existing_val)) existing_val
            else default_val
          }
          
          # Save ALL cell settings, preserving existing values if inputs don't exist yet
          cells[[id]] <- list(
            type = update_if_exists(input[[paste0("cell_type_", id)]], existing_cell$type, ""),
            filter = update_if_exists(input[[paste0("cell_filter_", id)]], existing_cell$filter, "Pitch Types"),
            title = update_if_exists(input[[paste0("cell_title_", id)]], existing_cell$title, ""),
            show_controls = update_if_exists(input[[paste0("cell_show_controls_", id)]], existing_cell$show_controls, TRUE),
            table_mode = update_if_exists(input[[paste0("cell_table_mode_", id)]], existing_cell$table_mode, "Stuff"),
            table_custom_cols = update_if_exists(input[[paste0("cell_table_custom_cols_", id)]], existing_cell$table_custom_cols, character(0)),
            color = update_if_exists(input[[paste0("cell_color_", id)]], existing_cell$color, TRUE),
            heat_stat = update_if_exists(input[[paste0("cell_heat_stat_", id)]], existing_cell$heat_stat, "Frequency"),
            filter_select = update_if_exists(input[[paste0("cell_filter_select_", id)]], existing_cell$filter_select, c("Dates","Session Type","Pitch Types")),
            # Save all filter values - preserve existing if input doesn't exist
            dates = update_if_exists(input[[paste0("cell_dates_", id)]], existing_cell$dates),
            session = update_if_exists(input[[paste0("cell_session_", id)]], existing_cell$session),
            pitch_types = update_if_exists(input[[paste0("cell_pitch_types_", id)]], existing_cell$pitch_types),
            batter_side = update_if_exists(input[[paste0("cell_batter_side_", id)]], existing_cell$batter_side),
            pitcher_hand = update_if_exists(input[[paste0("cell_pitcher_hand_", id)]], existing_cell$pitcher_hand),
            results = update_if_exists(input[[paste0("cell_results_", id)]], existing_cell$results),
            qp = update_if_exists(input[[paste0("cell_qp_", id)]], existing_cell$qp),
            count = update_if_exists(input[[paste0("cell_count_", id)]], existing_cell$count),
            after_count = update_if_exists(input[[paste0("cell_after_count_", id)]], existing_cell$after_count),
            zone = update_if_exists(input[[paste0("cell_zone_", id)]], existing_cell$zone),
            velo_min = update_if_exists(input[[paste0("cell_velo_min_", id)]], existing_cell$velo_min),
            velo_max = update_if_exists(input[[paste0("cell_velo_max_", id)]], existing_cell$velo_max),
            ivb_min = update_if_exists(input[[paste0("cell_ivb_min_", id)]], existing_cell$ivb_min),
            ivb_max = update_if_exists(input[[paste0("cell_ivb_max_", id)]], existing_cell$ivb_max),
            hb_min = update_if_exists(input[[paste0("cell_hb_min_", id)]], existing_cell$hb_min),
            hb_max = update_if_exists(input[[paste0("cell_hb_max_", id)]], existing_cell$hb_max)
          )
          # Keep UI in sync with stored state
        }
      }
      current_cells(cells)
    }) %>% throttle(500)  # Reduced throttle for better responsiveness
    
    # Helper: get filtered dataset for player(s) for a given cell
    # This is now a pure function that will be cached via bindCache in the reactive
    get_cell_data <- function(cell_id, players, report_type, dates, session, pitch_types, 
                              batter_side, pitcher_hand, results, qp, count, after_count, 
                              zone, velo_min, velo_max, ivb_min, ivb_max, hb_min, hb_max) {
      if (is.null(players) || length(players) == 0) return(data.frame())
      
      # Handle "All" selection - get all data for that report type
      if (report_type == "Pitching") {
        if ("All" %in% players || identical(players, "All")) {
          df <- pitch_data_pitching  # All pitchers
        } else {
          df <- pitch_data_pitching %>% dplyr::filter(Pitcher %in% players)
        }
        
        # Apply three-tier filtering for players (admins and coaches see all)
        tryCatch({
          if (!is_admin() && !is_coach()) {
            ue <- user_email()
            if (!is.na(ue)) {
              df <- df %>% dplyr::filter(norm_email(Email) == norm_email(ue))
            }
          }
        }, error = function(e) {
          # Silently handle if is_admin/is_coach not available
        })
      } else {
        # For Hitting: filter by Batter, ensure Batter column exists and has data
        if (!"Batter" %in% names(pitch_data)) {
          message("Batter column not found in pitch_data")
          return(data.frame())
        }
        if ("All" %in% players || identical(players, "All")) {
          df <- pitch_data %>% dplyr::filter(!is.na(Batter), nzchar(as.character(Batter)))  # All batters
        } else {
          df <- pitch_data %>% 
            dplyr::filter(!is.na(Batter), nzchar(as.character(Batter)), Batter %in% players)
        }
        
        # Apply three-tier filtering for players (admins and coaches see all)
        tryCatch({
          if (!is_admin() && !is_coach()) {
            ue <- user_email()
            if (!is.na(ue)) {
              df <- df %>% dplyr::filter(norm_email(Email) == norm_email(ue))
            }
          }
        }, error = function(e) {
          # Silently handle if is_admin/is_coach not available
        })
      }
      
      # Apply all filters efficiently
      if (!is.null(dates) && length(dates) == 2) {
        df <- df %>% dplyr::filter(Date >= dates[1], Date <= dates[2])
      }
      if (!is.null(session) && session != "All") df <- df %>% dplyr::filter(SessionType %in% session)
      if (!is.null(pitch_types) && length(pitch_types) && !("All" %in% pitch_types)) df <- df %>% dplyr::filter(TaggedPitchType %in% pitch_types)
      if (!is.null(batter_side) && batter_side != "All") df <- df %>% dplyr::filter(BatterSide == batter_side)
      if (!is.null(pitcher_hand) && pitcher_hand != "All") df <- df %>% dplyr::filter(PitcherThrows == pitcher_hand)
      df <- apply_pitch_results_filter(df, results)
      if (!is.null(qp) && qp != "All") df <- filter_qp_locations(df, qp)
      df <- apply_count_filter(df, count)
      df <- apply_after_count_filter(df, after_count)
      df <- enforce_zone(df, zone)
      nnz <- function(x) !is.null(x) && suppressWarnings(is.finite(as.numeric(x)))
      if (nnz(velo_min))   df <- df %>% dplyr::filter(RelSpeed >= as.numeric(velo_min))
      if (nnz(velo_max))   df <- df %>% dplyr::filter(RelSpeed <= as.numeric(velo_max))
      if (nnz(ivb_min)) df <- df %>% dplyr::filter(InducedVertBreak >= as.numeric(ivb_min))
      if (nnz(ivb_max)) df <- df %>% dplyr::filter(InducedVertBreak <= as.numeric(ivb_max))
      if (nnz(hb_min))  df <- df %>% dplyr::filter(HorzBreak >= as.numeric(hb_min))
      if (nnz(hb_max))  df <- df %>% dplyr::filter(HorzBreak <= as.numeric(hb_max))
      
      # Calculate Stuff+ if not present (using same method as other pages)
      if (!"Stuff+" %in% names(df) || all(is.na(df$`Stuff+`))) {
        df <- tryCatch({
          compute_stuff_simple(df, base_type = "Fastball", level = "College")
        }, error = function(e) {
          message("Could not compute Stuff+ in custom reports: ", e$message)
          df$`Stuff+` <- NA_real_
          df
        })
      }
      
      df
    }
    
    # Wrapper that extracts inputs and calls cached function
    get_cell_data_wrapper <- function(cell_id) {
      # Determine which player(s) to use
      players <- if (input$report_scope == "Multi-Player") {
        # Extract row number from cell_id (e.g., "r1c2" -> row 1)
        row_num <- as.integer(sub("r(\\d+)c.*", "\\1", cell_id))
        row_player <- input[[paste0("row_player_", row_num)]]
        if (is.null(row_player) || !nzchar(row_player)) {
          return(data.frame())  # No player selected for this row
        }
        row_player
      } else {
        # Single Player mode - use main player selector
        input$report_players
      }
      
      # Allow "All" or empty to pass through, but require something
      if (is.null(players) || (length(players) == 1 && !nzchar(players))) {
        return(data.frame())
      }
      
      # In Multi-Player mode, use Row 1's filters for all rows (but keep each row's own player)
      # Extract row and column from cell_id
      row_num <- as.integer(sub("r(\\d+)c.*", "\\1", cell_id))
      col_num <- as.integer(sub("r\\d+c(\\d+)", "\\1", cell_id))
      
      # Determine which cell's filters to use
      filter_cell_id <- if (input$report_scope == "Multi-Player" && row_num > 1) {
        # Use row 1, same column for filters
        paste0("r1c", col_num)
      } else {
        # Use this cell's own filters
        cell_id
      }
      
      get_cell_data(
        cell_id = cell_id,
        players = players,
        report_type = input$report_type,
        dates = input[[paste0("cell_dates_", filter_cell_id)]],
        session = input[[paste0("cell_session_", filter_cell_id)]] %||% "All",
        pitch_types = input[[paste0("cell_pitch_types_", filter_cell_id)]],
        batter_side = input[[paste0("cell_batter_side_", filter_cell_id)]],
        pitcher_hand = input[[paste0("cell_pitcher_hand_", filter_cell_id)]],
        results = input[[paste0("cell_results_", filter_cell_id)]],
        qp = input[[paste0("cell_qp_", filter_cell_id)]],
        count = input[[paste0("cell_count_", filter_cell_id)]],
        after_count = input[[paste0("cell_after_count_", filter_cell_id)]],
        zone = input[[paste0("cell_zone_", filter_cell_id)]],
        velo_min = input[[paste0("cell_velo_min_", filter_cell_id)]],
        velo_max = input[[paste0("cell_velo_max_", filter_cell_id)]],
        ivb_min = input[[paste0("cell_ivb_min_", filter_cell_id)]],
        ivb_max = input[[paste0("cell_ivb_max_", filter_cell_id)]],
        hb_min = input[[paste0("cell_hb_min_", filter_cell_id)]],
        hb_max = input[[paste0("cell_hb_max_", filter_cell_id)]]
      )
    }
    
    # Simple visuals
    render_cell <- function(cell_id) {
      # In Multi-Player mode, use Row 1's chart type and settings for all rows
      # Extract row and column from cell_id
      row_num <- as.integer(sub("r(\\d+)c.*", "\\1", cell_id))
      col_num <- as.integer(sub("r\\d+c(\\d+)", "\\1", cell_id))
      
      # Determine which cell's settings to use
      settings_cell_id <- if (input$report_scope == "Multi-Player" && row_num > 1) {
        # Use row 1, same column for settings
        paste0("r1c", col_num)
      } else {
        # Use this cell's own settings
        cell_id
      }
      
      tsel <- input[[paste0("cell_type_", settings_cell_id)]] %||% ""
      fsel <- input[[paste0("cell_filter_", settings_cell_id)]] %||% "Pitch Types"
      out_id <- paste0("cell_render_", cell_id)
      tooltip_css_local <- if (exists("tooltip_css", inherits = TRUE)) tooltip_css else
        "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
      # Dark-mode helper
      is_dark_mode_local <- function() {
        dm <- NULL
        # prefer root scope to pick up global toggle
        dm <- tryCatch({
          rs <- session$rootScope()
          if (!is.null(rs) && !is.null(rs$input$dark_mode)) rs$input$dark_mode else NULL
        }, error = function(...) NULL)
        if (is.null(dm) && !is.null(input$dark_mode)) dm <- input$dark_mode
        isTRUE(dm)
      }
      # clear previous output so switching types always re-renders
      output[[out_id]] <- renderUI({ NULL })
      if (!nzchar(tsel)) {
        output[[out_id]] <- renderUI({ NULL })
        return(NULL)
      }
      df <- get_cell_data_wrapper(cell_id)
      if (!nrow(df)) {
        output[[out_id]] <- renderUI({ div("No data") })
        return(uiOutput(ns(out_id)))
      }
      if (tsel == "Summary Table") {
        df <- apply_split_by(df, fsel)
        split_col <- if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"
        df$SplitColumn <- df[[split_col]]
      }
      
      if (tsel == "Movement Plot") {
        df_mv <- df %>% dplyr::filter(is.finite(HorzBreak), is.finite(InducedVertBreak))
        if (!"Stuff+" %in% names(df_mv) && "StuffPlus" %in% names(df_mv)) df_mv$`Stuff+` <- df_mv$StuffPlus
        output[[out_id]] <- ggiraph::renderGirafe({
          if (!nrow(df_mv)) return(NULL)
          dark_on <- is_dark_mode_local()
          axis_col <- if (dark_on) "#e5e7eb" else "black"
          line_col <- if (dark_on) "#ffffff" else "black"
          grid_col <- adjustcolor(if (dark_on) "white" else "black",
                                  alpha.f = if (dark_on) 0.18 else 0.12)
          cols <- colors_for_mode(dark_on)
          df_mv <- df_mv %>%
            dplyr::mutate(
              SplitColumn = .data[[if ("SplitColumn" %in% names(df_mv)) "SplitColumn" else "TaggedPitchType"]],
              tt = make_hover_tt(.),
              rid = dplyr::row_number()
            )
          types_chr <- as.character(intersect(names(cols), unique(df_mv$SplitColumn)))
          avg <- df_mv %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              avg_HB   = mean(HorzBreak, na.rm = TRUE),
              avg_IVB  = mean(InducedVertBreak, na.rm = TRUE),
              avg_velo = mean(RelSpeed, na.rm = TRUE),
              avg_stuff= if ("Stuff+" %in% names(df_mv)) mean(`Stuff+`, na.rm = TRUE) else NA_real_,
              n_obs    = dplyr::n(),
              .groups = "drop"
            ) %>%
            dplyr::mutate(
              tt = paste0(SplitColumn,
                          "<br>Velo: ", round(avg_velo,1), " mph",
                          "<br>IVB: ", round(avg_IVB,1), " in",
                          "<br>HB: ", round(avg_HB,1), " in",
                          ifelse(is.finite(avg_stuff), paste0("<br>Stuff+: ", round(avg_stuff,1)), ""),
                          "<br>Pitches: ", n_obs),
              data_id = SplitColumn
            )
          p <- ggplot() +
            ggiraph::geom_point_interactive(
              data = df_mv,
              aes(HorzBreak, InducedVertBreak, color = SplitColumn, fill = SplitColumn, tooltip = tt, data_id = rid),
              alpha = 0.25, size = 4, shape = 21, stroke = 0.25
            ) +
            ggiraph::geom_point_interactive(
              data = avg,
              aes(avg_HB, avg_IVB, color = SplitColumn, tooltip = tt, data_id = data_id),
              size = 8, show.legend = FALSE
            ) +
            geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
            geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
            coord_cartesian(xlim = c(-25,25), ylim = c(-25,25)) +
            scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
            scale_fill_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
            theme_minimal() + axis_theme + grid_theme(dark_on) +
            theme(legend.position = "none",
                  axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
                  axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
                  axis.ticks = element_blank(),
                  panel.grid.major = element_line(color = grid_col),
                  panel.grid.minor = element_blank())
          girafe_transparent(
            ggobj = p,
            width_svg = 8, height_svg = 6.5,
            options = list(
              ggiraph::opts_sizing(rescale = TRUE),
              ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css_local),
              ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
              ggiraph::opts_hover_inv(css = "opacity:0.15;")
            )
          )
        })
        return(ggiraph::girafeOutput(ns(out_id), height = "280px"))
      } else if (tsel == "Release Plot") {
        output[[out_id]] <- ggiraph::renderGirafe({
          df$SplitColumn <- df[[if ("SplitColumn" %in% names(df)) "SplitColumn" else "TaggedPitchType"]]
          df <- df %>% dplyr::filter(is.finite(RelSide), is.finite(RelHeight))
          if (!nrow(df)) return(NULL)
          dark_on <- is_dark_mode_local()
          axis_col <- if (dark_on) "#e5e7eb" else "black"
          line_col <- if (dark_on) "#ffffff" else "black"
          grid_col <- adjustcolor(if (dark_on) "white" else "black",
                                  alpha.f = if (dark_on) 0.18 else 0.12)
          cols <- colors_for_mode(dark_on)
          
          types_chr <- intersect(names(cols), as.character(unique(df$SplitColumn)))
          types_chr <- types_chr[types_chr %in% names(cols)]
          
          sess_lbl <- {
            ss <- unique(df$SessionType)
            if (length(ss) == 1) ss else "All Sessions"
          }
          
          rp_w <- 4; rp_h <- 0.83
          xs <- seq(-rp_w, rp_w, length.out = 100)
          ys <- rp_h * (1 - (xs / rp_w)^2)
          mound <- data.frame(x = c(xs, rev(xs)), y = c(ys, rep(0, length(xs))))
          
          avg <- df %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              avg_RelSide    = mean(RelSide,    na.rm = TRUE),
              avg_RelHeight  = mean(RelHeight,  na.rm = TRUE),
              avg_Extension  = mean(Extension,  na.rm = TRUE),
              .groups = "drop"
            ) %>%
            dplyr::filter(SplitColumn %in% types_chr) %>%
            dplyr::mutate(
              SplitColumn = factor(SplitColumn, levels = types_chr),
              tt = paste0(
                "Session: ", sess_lbl,
                "<br>Height: ", sprintf("%.1f ft", avg_RelHeight),
                "<br>Side: ", sprintf("%.1f ft", avg_RelSide),
                "<br>Extension: ", sprintf("%.1f ft", avg_Extension)
              )
            )
          
          y_max <- max(6, suppressWarnings(max(df$RelHeight, na.rm = TRUE) + 0.2))
          
          p <- ggplot() +
            geom_polygon(data = mound, aes(x, y), fill = if (dark_on) "transparent" else "tan", color = "tan") +
            annotate("rect", xmin = -0.5, xmax = 0.5, ymin = rp_h - 0.05, ymax = rp_h + 0.05, fill = "white") +
            geom_vline(xintercept = 0, color = line_col, size = 0.7) +
            geom_hline(yintercept = 0, color = line_col, size = 0.7) +
            ggiraph::geom_point_interactive(
              data = avg,
              aes(x = avg_RelSide, y = avg_RelHeight,
                  color = SplitColumn, tooltip = tt, data_id = SplitColumn),
              size = 8, show.legend = FALSE
            ) +
            scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
            scale_y_continuous(limits = c(0, y_max), breaks = seq(0, ceiling(y_max), by = 1)) +
            theme_minimal() + axis_theme + grid_theme(dark_on) +
            labs(x = NULL, y = NULL) +
            theme(
              legend.position = "none",
              axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
              axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
              axis.ticks = element_blank(),
              panel.grid.major = element_line(color = grid_col),
              panel.grid.minor = element_blank(),
              panel.background = element_rect(fill = "transparent", color = NA),
              plot.background = element_rect(fill = "transparent", color = NA)
            )
          
          girafe_transparent(
            ggobj = p,
            width_svg = 8, height_svg = 6.5,
            options = list(
              ggiraph::opts_sizing(rescale = TRUE),
              ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css_local),
              ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
              ggiraph::opts_hover_inv(css = "opacity:0.15;")
            )
          )
        })
        return(ggiraph::girafeOutput(ns(out_id), height = "280px"))
      } else if (tsel == "Location Plot") {
        output[[out_id]] <- ggiraph::renderGirafe({
          df_loc <- df %>% dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
          if (!nrow(df_loc)) return(NULL)
          dark_on <- is_dark_mode_local()
          line_col <- if (dark_on) "#ffffff" else "black"
          grid_col <- if (dark_on) "#d1d5db" else "black"
          cols <- colors_for_mode(dark_on)
          
          # Use different location plots based on report type
          if (input$report_type == "Hitting") {
            # Use Hitting suite location plot with green box
            if (!"Result" %in% names(df_loc)) {
              df_loc$Result <- compute_result(df_loc$PitchCall, df_loc$PlayResult)
            }
            
            # Use hit_shape_map levels for the hitting suite
            hit_result_levels <- names(hit_shape_map)
            
            df_loc <- df_loc %>%
              dplyr::mutate(
                ResultDisplay = dplyr::case_when(
                  Result %in% c("In Play (Out)", "In Play (Hit)") ~ "In Play",
                  TRUE ~ as.character(Result)
                )
              )
            
            df_plot <- df_loc %>%
              dplyr::mutate(
                TaggedPitchType = as.character(TaggedPitchType),
                ResultDisplay = dplyr::case_when(
                  ResultDisplay %in% hit_result_levels ~ ResultDisplay,
                  TRUE ~ NA_character_
                ),
                ResultDisplay = factor(ResultDisplay, levels = hit_result_levels),
                tooltip = paste0(
                  "<b>", TaggedPitchType, "</b><br>",
                  "PitchCall: ", ifelse(is.na(PitchCall), "—", as.character(PitchCall)), "<br>",
                  "Result: ", ifelse(is.na(ResultDisplay), "—", as.character(ResultDisplay)), "<br>",
                  "Velo: ", ifelse(is.finite(as.numeric(RelSpeed)), sprintf("%.1f mph", as.numeric(RelSpeed)), "—"), "<br>",
                  "EV: ", ifelse(is.finite(as.numeric(ExitSpeed)), sprintf("%.1f mph", as.numeric(ExitSpeed)), "—"), "<br>",
                  "LA: ", ifelse(is.finite(as.numeric(Angle)), sprintf("%.1f°", as.numeric(Angle)), "—")
                ),
                rid = dplyr::row_number()
              )
            
            types_chr <- intersect(names(cols), unique(df_plot$TaggedPitchType))
            if (!length(types_chr)) types_chr <- unique(df_plot$TaggedPitchType)
            col_vals <- cols[types_chr]; col_vals[is.na(col_vals)] <- "gray70"
            
            home <- data.frame(
              x = c(-0.75, 0.75, 0.75, 0, -0.75),
              y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
            )
            sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
            mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
            mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
            dx <- (ZONE_RIGHT - ZONE_LEFT) / 3
            dy <- (ZONE_TOP - ZONE_BOTTOM) / 3
            grid_vertical <- data.frame(
              x = c(ZONE_LEFT + dx, ZONE_LEFT + 2 * dx),
              ymin = ZONE_BOTTOM,
              ymax = ZONE_TOP
            )
            grid_horizontal <- data.frame(
              y = c(ZONE_BOTTOM + dy, ZONE_BOTTOM + 2 * dy),
              xmin = ZONE_LEFT,
              xmax = ZONE_RIGHT
            )
            inner_half <- 7 / 12  # 7 inches converted to feet
            green_box <- data.frame(
              xmin = mid_x - inner_half,
              xmax = mid_x + inner_half,
              ymin = mid_y - inner_half,
              ymax = mid_y + inner_half
            )
            
            df_known <- dplyr::filter(df_plot, !is.na(ResultDisplay))
            df_other <- dplyr::filter(df_plot, is.na(ResultDisplay))
            
            p <- ggplot() +
              geom_polygon(data = home, aes(x, y), inherit.aes = FALSE, fill = NA, color = line_col) +
              geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                        inherit.aes = FALSE, fill = NA, color = line_col) +
              geom_rect(data = green_box,
                        aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                        inherit.aes = FALSE,
                        fill = "#4CAF50", alpha = 0.15, color = "#4CAF50", linetype = "dashed", linewidth = 0.75) +
              geom_segment(data = grid_vertical,
                           aes(x = x, xend = x, y = ymin, yend = ymax),
                           inherit.aes = FALSE, color = grid_col, linetype = "solid") +
              geom_segment(data = grid_horizontal,
                           aes(y = y, yend = y, x = xmin, xend = xmax),
                           inherit.aes = FALSE, color = grid_col, linetype = "solid") +
              ggiraph::geom_point_interactive(
                data = df_other,
                aes(PlateLocSide, PlateLocHeight,
                    color = TaggedPitchType, fill = TaggedPitchType,
                    tooltip = tooltip, data_id = rid),
                size = 4.0, alpha = 0.85, shape = 16, stroke = 0.6
              ) +
              ggiraph::geom_point_interactive(
                data = df_known,
                aes(PlateLocSide, PlateLocHeight,
                    color = TaggedPitchType, fill = TaggedPitchType, shape = ResultDisplay,
                    tooltip = tooltip, data_id = rid),
                size = 4.0, alpha = 0.85, stroke = 0.8
              ) +
              scale_color_manual(values = col_vals, limits = types_chr, name = NULL) +
              scale_fill_manual(values = col_vals, limits = types_chr, name = NULL) +
              scale_shape_manual(values = hit_shape_map, drop = TRUE, name = NULL) +
              coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
              theme_void() + theme(legend.position = "none")
            
            girafe_transparent(
              ggobj = p,
              options = list(
                ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css_local),
                ggiraph::opts_hover(css = "stroke-width:1.5px;"),
                ggiraph::opts_hover_inv(css = "opacity:0.15;")
              )
            )
          } else {
            # Use Pitching suite location plot (original)
            df_loc <- df_loc %>%
              dplyr::mutate(
                SplitColumn = .data[[if ("SplitColumn" %in% names(df_loc)) "SplitColumn" else "TaggedPitchType"]],
                Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
                tt = make_hover_tt(.),
                rid = dplyr::row_number(),
                tt_fill = dplyr::coalesce(cols[as.character(SplitColumn)], "gray")
              )
            df_known <- df_loc %>% dplyr::filter(!is.na(Result))
            df_other <- df_loc %>% dplyr::filter(is.na(Result))
            types_chr <- as.character(intersect(names(cols), unique(df_loc$SplitColumn)))
            home <- data.frame(x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
                               y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5)
            cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
            sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
            p <- ggplot() +
              geom_polygon(data = home, aes(x, y), fill = NA, color = "black", inherit.aes = FALSE) +
              geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                        fill = NA, color = "black", linetype = "dashed", inherit.aes = FALSE) +
              geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                        fill = NA, color = "black", inherit.aes = FALSE) +
              ggiraph::geom_point_interactive(
                data = df_other,
                aes(PlateLocSide, PlateLocHeight,
                    color = SplitColumn, fill = SplitColumn,
                    tooltip = tt, data_id = rid),
                position = "identity",
                size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
              ) +
              ggiraph::geom_point_interactive(
                data = df_known,
                aes(PlateLocSide, PlateLocHeight,
                    color = SplitColumn, fill = SplitColumn, shape = Result,
                    tooltip = tt, data_id = rid),
                position = "identity",
                size = 4.0, alpha = 0.95, stroke = 0.8
              ) +
              scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
              scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
              scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
              coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
              theme_void() + theme(legend.position = "none") +
              ggiraph::geom_point_interactive(
                data = df_loc,
                aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
                shape = 21, size = 6, alpha = 0.001, stroke = 0, inherit.aes = FALSE
              )
            girafe_transparent(
              ggobj = p,
              options = list(
                ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css_local),
                ggiraph::opts_hover(css = "stroke-width:1.5px;"),
                ggiraph::opts_hover_inv(css = "opacity:0.15;")
              )
            )
          }
        })
        return(ggiraph::girafeOutput(ns(out_id), height = "280px"))
      } else if (tsel == "Heatmap") {
        output[[out_id]] <- renderPlot({
          df_loc <- df
          if (!nrow(df_loc)) {
            plot.new(); title("No data"); return(invisible())
          }
          
          # Apply Pitch Results filter for heatmap too (use settings_cell_id for filter)
          df_loc <- apply_pitch_results_filter(df_loc, input[[paste0("cell_results_", settings_cell_id)]])
          
          if (!nrow(df_loc)) {
            plot.new(); title("No data after filters"); return(invisible())
          }
          
          # Heatmap type selection
          hm_stat <- input[[paste0("cell_heat_stat_", settings_cell_id)]] %||% "Frequency"
          plot_obj <- render_heatmap_stat(df_loc, hm_stat)
          print(plot_obj)
          return(invisible())
          
          # Use advanced Pitching Suite heatmap implementation
          if (hm_stat == "Frequency") {
            grid <- make_kde_grid(df_loc$PlateLocSide, df_loc$PlateLocHeight, n = 200)
            
            if (!nrow(grid)) return(ggplot() + theme_void())
            
            # Normalize KDE values to 0-100 scale
            grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "Pitch Frequency",
                             scale_limits = c(0, 80)))
          }
          
          # Filter to valid location data for non-Frequency stats
          df_loc <- df_loc %>% dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
          if (!nrow(df_loc)) {
            plot.new(); title("No location data"); return(invisible())
          }
          
          if (hm_stat == "Whiff Rate") {
            swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                              "FoulBallNotFieldable", "InPlay")
            swing_mask  <- df_loc$PitchCall %in% swing_events
            val <- ifelse(swing_mask, ifelse(df_loc$PitchCall == "StrikeSwinging", 1, 0), NA_real_)
            grid <- make_kde_mean_grid(df_loc$PlateLocSide, df_loc$PlateLocHeight, val)
            if (!nrow(grid)) return(ggplot() + theme_void())
            breaks <- c(seq(0, 50, length.out = HEAT_BINS + 1), Inf)
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                             breaks = breaks, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "Whiff Rate %",
                             scale_limits = c(0, 50)))
          }
          
          if (hm_stat == "GB Rate") {
            df_bip <- df_loc %>%
              filter(SessionType == "Live", 
                     PitchCall == "InPlay",
                     !is.na(TaggedHitType))
            
            if (nrow(df_bip) < 3) {
              plot.new(); title("Insufficient Live BIP data"); return(invisible())
            }
            
            val <- ifelse(df_bip$TaggedHitType == "GroundBall", 1, 0)
            grid <- make_kde_mean_grid(df_bip$PlateLocSide, df_bip$PlateLocHeight, val)
            if (!nrow(grid)) return(ggplot() + theme_void())
            
            breaks <- c(-Inf, seq(0, 70, length.out = HEAT_BINS + 1), Inf)
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                             breaks = breaks, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "GB Rate %",
                             scale_limits = c(0, 70)))
          }
          
          if (hm_stat == "Contact Rate") {
            # Contact Rate = 100% - Whiff Rate (guaranteed perfect opposite colors)
            swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                              "FoulBallNotFieldable", "InPlay")
            swing_mask  <- df_loc$PitchCall %in% swing_events
            val <- ifelse(swing_mask, ifelse(df_loc$PitchCall == "StrikeSwinging", 0, 1), NA_real_)
            grid <- make_kde_mean_grid(df_loc$PlateLocSide, df_loc$PlateLocHeight, val)
            if (!nrow(grid)) return(ggplot() + theme_void())
            grid$z <- pmin(pmax(grid$z * 100, 50), 100)
            breaks <- seq(50, 100, length.out = HEAT_BINS + 1)
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                             breaks = breaks, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "Contact Rate %",
                             scale_limits = c(50, 100)))
          }
          
          if (hm_stat == "Swing Rate") {
            swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                              "FoulBallNotFieldable", "InPlay")
            
            val <- ifelse(df_loc$PitchCall %in% swing_events, 1, 0)
            grid <- make_kde_mean_grid(df_loc$PlateLocSide, df_loc$PlateLocHeight, val)
            if (!nrow(grid)) return(ggplot() + theme_void())
            breaks <- seq(20, 80, length.out = HEAT_BINS + 1)
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                             breaks = breaks, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "Swing Rate %",
                             scale_limits = c(20, 80)))
          }
          
          if (hm_stat == "Exit Velocity") {
            df_bip <- dplyr::filter(
              df_loc, 
              SessionType == "Live",
              PitchCall == "InPlay",
              is.finite(PlateLocSide), 
              is.finite(PlateLocHeight),
              is.finite(ExitSpeed)
            )
            
            if (!nrow(df_bip)) return(ggplot() + theme_void())
            
            grid <- make_kde_mean_grid(df_bip$PlateLocSide, df_bip$PlateLocHeight, df_bip$ExitSpeed)
            if (!nrow(grid)) return(ggplot() + theme_void())
            breaks <- seq(60, 110, length.out = HEAT_BINS + 1)
            
            return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                             breaks = breaks, mark_max = FALSE,
                             show_scale = TRUE, scale_label = "Exit Velocity (mph)",
                             scale_limits = c(60, 110)))
          }
          
          # Default fallback
          ggplot() + theme_void()
        }, bg = "transparent")
        return(plotOutput(ns(out_id), height = "280px"))
      } else if (tsel == "Summary Table") {
        output[[out_id]] <- DT::renderDataTable({
          # Add tryCatch wrapper for entire table rendering to handle filter transitions
          tryCatch({
            df_tbl <- df
            
            is_hitting_mode <- !is.null(input$report_type) && input$report_type == "Hitting"
            
            if (is_hitting_mode) {
              mode_choice <- input[[paste0("cell_table_mode_", settings_cell_id)]] %||% "Results"
              fmt_avg_local <- function(x) {
                x <- suppressWarnings(as.numeric(x))
                s <- ifelse(is.finite(x), sprintf("%.3f", x), "")
                sub("^0\\.", ".", s)
              }
              if (!"SplitColumn" %in% names(df_tbl)) df_tbl$SplitColumn <- df_tbl$TaggedPitchType
              split_choice <- fsel
              df_tbl <- apply_split_by(df_tbl, split_choice)
              if (!"SplitColumn" %in% names(df_tbl) && split_col_name %in% names(df_tbl)) {
                df_tbl$SplitColumn <- df_tbl[[split_col_name]]
              }
              
              split_col_name <- switch(
                split_choice,
                "Pitch Types" = "Pitch",
                "Pitcher Hand" = "Pitcher Hand",
                "Count" = "Count",
                "After Count" = "After Count",
                "Velocity" = "Velocity",
                "IVB" = "InducedVert",
                "HB" = "HorzBreak",
                "Pitcher" = "Pitcher",
                "Pitch"  # default
              )
              
              if (!nrow(df_tbl)) return(data.frame(Message = "No data"))
              
              swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
              safe_terminal_check <- function(play_result, korbb) {
                play_ok <- !is.na(play_result) & play_result != "Undefined"
                korbb_ok <- !is.na(korbb) & korbb %in% c("Strikeout","Walk")
                return(play_ok | korbb_ok)
              }
              
              is_terminal <- safe_terminal_check(df_tbl$PlayResult, df_tbl$KorBB)
              term <- df_tbl[is_terminal, , drop = FALSE]
              
              if (nrow(term) == 0) {
                return(DT::datatable(
                  data.frame(Message = "No completed plate appearances in selected data"),
                  options = list(dom = 't', autoWidth = FALSE), rownames = FALSE
                ))
              }
              
              # Helper: Results table (same as hitting suite)
              # Local helper for safe division (match hitting suite)
              safe_div_local <- function(num, den) {
                num <- suppressWarnings(as.numeric(num))
                den <- suppressWarnings(as.numeric(den))
                ifelse(is.finite(den) & den != 0 & is.finite(num), num/den, NA_real_)
              }
              
              build_results_table <- function(df_src) {
                per_type <- term %>%
                  dplyr::group_by(SplitColumn) %>%
                  dplyr::summarise(
                    PA   = dplyr::n(),
                    HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
                    Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
                    H1 = sum(PlayResult == "Single",  na.rm = TRUE),
                    H2 = sum(PlayResult == "Double",  na.rm = TRUE),
                    H3 = sum(PlayResult == "Triple",  na.rm = TRUE),
                    HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
                    Kct  = sum(KorBB == "Strikeout" |
                                 PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
                    BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
                    .groups = "drop"
                  ) %>%
                  dplyr::mutate(
                    AB  = PA - (BBct + HBP + Sac),
                    H   = H1 + H2 + H3 + HR,
                    TB  = 1*H1 + 2*H2 + 3*H3 + 4*HR,
                    AVG = dplyr::if_else(AB > 0, H / AB, 0),
                    SLG = dplyr::if_else(AB > 0, TB / AB, 0),
                    OBP = dplyr::if_else(PA > 0, (H + BBct + HBP) / PA, 0),
                    OPS = SLG + OBP
                  )
                
                pitch_totals <- df_src %>%
                  dplyr::group_by(SplitColumn) %>%
                  dplyr::summarise(
                    Pitches = dplyr::n(),
                    Swings  = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
                    Whiffs  = sum(!is.na(PitchCall) & PitchCall == "StrikeSwinging", na.rm = TRUE),
                    .groups = "drop"
                  )
                
                bbe <- df_src %>%
                  dplyr::filter(
                    !is.na(SessionType),
                    grepl("live|game|ab", tolower(SessionType)), 
                    !is.na(PitchCall),
                    PitchCall == "InPlay"
                  )
                
                evla <- if (nrow(bbe) > 0) {
                  bbe %>%
                    dplyr::group_by(SplitColumn) %>%
                    dplyr::summarise(
                      EV = mean(ExitSpeed, na.rm = TRUE), 
                      LA = mean(Angle, na.rm = TRUE),
                      GBpct = sum(!is.na(TaggedHitType) & TaggedHitType == "GroundBall", na.rm = TRUE) / sum(!is.na(TaggedHitType), na.rm = TRUE),
                      .groups = "drop"
                    )
                } else {
                  data.frame(SplitColumn = character(0), EV = numeric(0), LA = numeric(0), GBpct = numeric(0))
                }
                
                out <- per_type %>%
                  dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
                  dplyr::left_join(evla, by = "SplitColumn") %>%
                  dplyr::mutate(
                    `Swing%` = dplyr::if_else(Pitches > 0, Swings / Pitches, 0),
                    `Whiff%` = dplyr::if_else(Swings > 0, Whiffs / Swings, 0),
                    `GB%` = dplyr::coalesce(GBpct, 0),
                    `K%` = dplyr::if_else(PA > 0, Kct / PA, 0),
                    `BB%` = dplyr::if_else(PA > 0, BBct / PA, 0)
                  ) %>%
                  dplyr::transmute(
                    !!split_col_name := as.character(SplitColumn),
                    PA, AB, AVG, SLG, OBP, OPS,
                    xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
                    `Swing%`, `Whiff%`, `GB%`, `K%`, `BB%`, `Barrel%` = NA_real_, EV, LA
                  )
                
                # Process extras (xWOBA/xISO/BABIP/Barrel%) from compute_process_results
                extras_raw <- compute_process_results(df_src)
                if ("PitchType" %in% names(extras_raw)) {
                  extras <- extras_raw %>%
                    dplyr::rename(!!split_col_name := PitchType) %>%
                    dplyr::mutate(
                      xWOBA     = suppressWarnings(as.numeric(xWOBA)),
                      xISO      = suppressWarnings(as.numeric(xISO)),
                      BABIP     = suppressWarnings(as.numeric(BABIP)),
                      `Barrel%` = suppressWarnings(as.numeric(`Barrel%`))
                    ) %>%
                    dplyr::select(.data[[split_col_name]], xWOBA, xISO, BABIP, `Barrel%`)
                } else {
                  extras <- tibble::tibble(
                    !!split_col_name := character(0),
                    xWOBA = numeric(0), xISO = numeric(0), BABIP = numeric(0), `Barrel%` = numeric(0)
                  )
                }
                
                # Barrel% per split (fallback to ensure non-blank)
                barrels_df <- df_src %>%
                  dplyr::group_by(SplitColumn) %>%
                  dplyr::summarise(
                    BarrelPct = safe_div_local(
                      sum(SessionType == "Live" & PitchCall == "InPlay" &
                            is.finite(ExitSpeed) & is.finite(Angle) &
                            ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, na.rm = TRUE),
                      sum(SessionType == "Live" & PitchCall == "InPlay", na.rm = TRUE)
                    ),
                    .groups = "drop"
                  ) %>%
                  dplyr::rename(!!split_col_name := SplitColumn)
                
                # ALL row
                PAt <- nrow(term)
                HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
                Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
                H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
                H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
                H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
                HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
                H   <- H1 + H2 + H3 + HR
                TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
                Kct_all <- sum(term$KorBB == "Strikeout" |
                                 term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
                BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
                ABt <- PAt - (BBc_all + HBP_all + Sac_all)
                
                swings_all  <- sum(!is.na(df_src$PitchCall) & df_src$PitchCall %in% swing_levels, na.rm = TRUE)
                whiffs_all  <- sum(df_src$PitchCall == "StrikeSwinging", na.rm = TRUE)
                total_pitches <- nrow(df_src)
                
                bbe_all <- df_src %>% dplyr::filter(
                  !is.na(SessionType),
                  grepl("live|game|ab", tolower(SessionType)), 
                  !is.na(PitchCall),
                  PitchCall == "InPlay"
                )
                
                gbpct_all <- safe_div_local(sum(bbe_all$TaggedHitType == "GroundBall", na.rm = TRUE),
                                            sum(!is.na(bbe_all$TaggedHitType), na.rm = TRUE))
                
                all_row <- tibble::tibble(
                  !!split_col_name := "All",
                  PA = PAt,
                  AB = ABt,
                  AVG = safe_div_local(H, ABt),
                  SLG = safe_div_local(TB, ABt),
                  OBP = safe_div_local(H + BBc_all + HBP_all, PAt),
                  OPS = NA_real_,
                  xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
                  `Swing%` = safe_div_local(swings_all, total_pitches),
                  `Whiff%` = safe_div_local(whiffs_all, swings_all),
                  `GB%` = gbpct_all,
                  `K%` = safe_div_local(Kct_all, PAt),
                  `BB%` = safe_div_local(BBc_all, PAt),
                  `Barrel%` = NA_real_,
                  EV = nz_mean(bbe_all$ExitSpeed),
                  LA = nz_mean(bbe_all$Angle)
                ) %>%
                  dplyr::mutate(OPS = SLG + OBP)
                
                # All-row extras
                extras_all <- compute_process_results(df_src) %>%
                  dplyr::summarise(
                    xWOBA     = nz_mean(suppressWarnings(as.numeric(xWOBA))),
                    xISO      = nz_mean(suppressWarnings(as.numeric(xISO))),
                    BABIP     = nz_mean(suppressWarnings(as.numeric(BABIP))),
                    `Barrel%` = nz_mean(suppressWarnings(as.numeric(`Barrel%`))),
                    .groups = "drop"
                  )
                if (nrow(extras_all)) {
                  all_row$xWOBA     <- extras_all$xWOBA[1]
                  all_row$xISO      <- extras_all$xISO[1]
                  all_row$BABIP     <- extras_all$BABIP[1]
                  all_row$`Barrel%` <- extras_all$`Barrel%`[1]
                }
                # All-row Barrel% fallback
                all_barrel_frac <- safe_div_local(
                  sum(df_src$SessionType == "Live" & df_src$PitchCall == "InPlay" &
                        is.finite(df_src$ExitSpeed) & is.finite(df_src$Angle) &
                        df_src$ExitSpeed >= 95 & df_src$Angle >= 10 & df_src$Angle <= 35, na.rm = TRUE),
                  sum(df_src$SessionType == "Live" & df_src$PitchCall == "InPlay", na.rm = TRUE)
                )
                if (is.finite(all_barrel_frac)) {
                  all_row$`Barrel%` <- all_barrel_frac
                }
                
                res <- dplyr::bind_rows(out, all_row)
                # Join per-type extras and barrel fallback
                if (nrow(extras)) {
                  res <- res %>% dplyr::left_join(extras, by = split_col_name, suffix = c("", ".ext"))
                }
                if (nrow(barrels_df)) {
                  res <- res %>% dplyr::left_join(barrels_df, by = split_col_name)
                  res$`Barrel%` <- dplyr::coalesce(res$BarrelPct, res$`Barrel%`)
                  res$BarrelPct <- NULL
                }
                if ("xWOBA.ext" %in% names(res)) {
                  res <- res %>%
                    dplyr::mutate(
                      xWOBA     = dplyr::coalesce(xWOBA.ext, xWOBA),
                      xISO      = dplyr::coalesce(xISO.ext,  xISO),
                      BABIP     = dplyr::coalesce(BABIP.ext, BABIP),
                      `Barrel%` = dplyr::coalesce(`Barrel%.ext`, `Barrel%`)
                    ) %>%
                    dplyr::select(-dplyr::ends_with(".ext"))
                }
                
                # Enforce pitch order if splitting by Pitch Types
                if (identical(split_choice, "Pitch Types") && split_col_name == "Pitch") {
                  ord <- names(all_colors)
                  res[[split_col_name]] <- factor(res[[split_col_name]], levels = c(ord, setdiff(res[[split_col_name]], ord)))
                  res <- res %>% dplyr::arrange(res[[split_col_name]])
                  res[[split_col_name]] <- as.character(res[[split_col_name]])
                }
                
                res
              }
              
              # Helper: Swing Decision table (same as hitting suite)
              build_swing_decisions <- function(df_src) {
                if (!nrow(df_src)) {
                  return(DT::datatable(
                    data.frame(Message = "No data for Swing Decisions"),
                    options = list(dom = 't', autoWidth = FALSE), rownames = FALSE
                  ))
                }
                df_src <- df_src %>%
                  dplyr::mutate(SplitColumn = dplyr::coalesce(as.character(SplitColumn), "Unknown"))
                
                inner_half <- 7 / 12
                mid_x <- (ZONE_LEFT + ZONE_RIGHT) / 2
                mid_y <- (ZONE_BOTTOM + ZONE_TOP) / 2
                green_xmin <- mid_x - inner_half
                green_xmax <- mid_x + inner_half
                green_ymin <- mid_y - inner_half
                green_ymax <- mid_y + inner_half
                
                df_sd <- df_src %>%
                  dplyr::mutate(
                    is_swing = !is.na(PitchCall) & PitchCall %in% swing_levels,
                    in_green = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                      PlateLocSide >= green_xmin & PlateLocSide <= green_xmax &
                      PlateLocHeight >= green_ymin & PlateLocHeight <= green_ymax,
                    in_zone = !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                      PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                      PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
                    possd_point = dplyr::case_when(
                      in_green & is_swing ~ 2,
                      in_green & !is_swing ~ -1,
                      in_zone & !in_green & is_swing ~ 1,
                      in_zone & !in_green & !is_swing ~ 0,
                      !in_zone & is_swing ~ -1,
                      !in_zone & !is_swing ~ 1,
                      TRUE ~ 0
                    )
                  )
                
                summarize_sd <- function(dat) {
                  total_pitches <- nrow(dat)
                  swings <- sum(dat$is_swing, na.rm = TRUE)
                  fps_num <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0 &
                                   !is.na(dat$PitchCall) & dat$PitchCall %in% c("StrikeSwinging","InPlay","FoulBall","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
                  fps_den <- sum(!is.na(dat$Balls) & !is.na(dat$Strikes) & dat$Balls == 0 & dat$Strikes == 0, na.rm = TRUE)
                  called <- sum(!is.na(dat$PitchCall) & dat$PitchCall == "StrikeCalled", na.rm = TRUE)
                  chase_num <- sum(dat$is_swing & !dat$in_zone, na.rm = TRUE)
                  chase_den <- sum(!dat$in_zone, na.rm = TRUE)
                  gozone_sw_num <- sum(dat$is_swing & dat$in_green, na.rm = TRUE)
                  gozone_sw_den <- sum(dat$in_green, na.rm = TRUE)
                  iz_sw_num <- sum(dat$is_swing & dat$in_zone, na.rm = TRUE)
                  iz_sw_den <- sum(dat$in_zone, na.rm = TRUE)
                  edge_sw_num <- sum(dat$is_swing & dat$in_zone & !dat$in_green, na.rm = TRUE)
                  edge_sw_den <- sum(dat$in_zone & !dat$in_green, na.rm = TRUE)
                  possd_points <- sum(dat$possd_point, na.rm = TRUE)
                  
                  tibble::tibble(
                    `Swing%` = safe_div_local(swings, total_pitches) * 100,
                    `FPS%` = safe_div_local(fps_num, fps_den) * 100,
                    `Called%` = safe_div_local(called, total_pitches) * 100,
                    `Chase%` = safe_div_local(chase_num, chase_den) * 100,
                    `GoZoneSw%` = safe_div_local(gozone_sw_num, gozone_sw_den) * 100,
                    `IZswing%` = safe_div_local(iz_sw_num, iz_sw_den) * 100,
                    `EdgeSwing%` = safe_div_local(edge_sw_num, edge_sw_den) * 100,
                    `PosSD%` = safe_div_local(possd_points, total_pitches) * 100
                  )
                }
                
                swing_decision_by_type <- df_sd %>%
                  dplyr::group_by(SplitColumn, .drop = FALSE) %>%
                  dplyr::group_modify(~ summarize_sd(.x)) %>%
                  dplyr::ungroup() %>%
                  dplyr::rename(!!split_col_name := SplitColumn)
                
                all_row <- summarize_sd(df_sd) %>%
                  dplyr::mutate(!!split_col_name := "All")
                
                df_swing_decision <- dplyr::bind_rows(swing_decision_by_type, all_row)
                
                pct_cols_sd <- c("Swing%", "FPS%", "Called%", "Chase%", "GoZoneSw%", "IZswing%", "EdgeSwing%", "PosSD%")
                for (col in pct_cols_sd) if (col %in% names(df_swing_decision)) {
                  v <- suppressWarnings(as.numeric(df_swing_decision[[col]]))
                  df_swing_decision[[col]] <- ifelse(is.finite(v), paste0(round(v, 1), "%"), "")
                }
                if (identical(split_choice, "Pitch Types") && split_col_name == "Pitch") {
                  ord <- names(all_colors)
                  df_swing_decision[[split_col_name]] <- factor(df_swing_decision[[split_col_name]], levels = c(ord, setdiff(df_swing_decision[[split_col_name]], ord)))
                  df_swing_decision <- df_swing_decision %>% dplyr::arrange(.data[[split_col_name]])
                  df_swing_decision[[split_col_name]] <- as.character(df_swing_decision[[split_col_name]])
                }
                
                datatable_with_colvis(
                  df_swing_decision,
                  lock            = split_col_name,
                  remember        = FALSE,
                  default_visible = c(split_col_name, pct_cols_sd),
                  mode            = NULL,
                  enable_colors   = FALSE
                )
              }
              
              if (identical(mode_choice, "Swing Decisions")) {
                return(build_swing_decisions(df_tbl))
              }
              
              results_df <- build_results_table(df_tbl)
              num_cols <- c("PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP",
                            "Swing%","Whiff%","GB%","K%","BB%","Barrel%","EV","LA")
              results_df <- results_df %>%
                dplyr::mutate(dplyr::across(dplyr::all_of(num_cols), ~ suppressWarnings(as.numeric(.)))) %>%
                {
                  df_tmp <- .
                  pct_cols  <- c("Swing%","Whiff%","GB%","K%","BB%","Barrel%")
                  rate_cols <- c("AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP")
                  for (nm in pct_cols) if (nm %in% names(df_tmp)) df_tmp[[nm]] <- ifelse(is.finite(df_tmp[[nm]]), paste0(round(df_tmp[[nm]]*100,1), "%"), "")
                  for (nm in rate_cols) if (nm %in% names(df_tmp)) df_tmp[[nm]] <- ifelse(is.finite(df_tmp[[nm]]), fmt_avg_local(df_tmp[[nm]]), "")
                  if ("EV" %in% names(df_tmp)) df_tmp$EV <- ifelse(is.finite(df_tmp$EV), round(df_tmp$EV,1), "")
                  if ("LA" %in% names(df_tmp)) df_tmp$LA <- ifelse(is.finite(df_tmp$LA), round(df_tmp$LA,1), "")
                  df_tmp
                }
              
              visible_cols_base <- c(split_col_name, "PA", "AB", "AVG", "SLG", "OBP", "OPS", "xWOBA", "xISO", "BABIP",
                                     "Swing%", "Whiff%", "GB%", "K%", "BB%", "Barrel%", "EV", "LA")
              if (identical(mode_choice, "Custom")) {
                custom_cols <- input[[paste0("cell_table_custom_cols_", settings_cell_id)]] %||% visible_cols_base[-1]
                custom_cols <- custom_cols[custom_cols %in% visible_cols_base]
                visible_cols <- unique(c(split_col_name, custom_cols))
              } else {
                visible_cols <- visible_cols_base
              }
              
              datatable_with_colvis(
                results_df,
                lock = split_col_name,
                remember = FALSE,
                default_visible = intersect(visible_cols, names(results_df)),
                mode = NULL,
                enable_colors = FALSE
              )
            } else {
              # PITCHING MODE: Use existing logic
              if (!"Strike" %in% names(df_tbl)) df_tbl$Strike <- 0
              if (!"Whiff" %in% names(df_tbl))  df_tbl$Whiff  <- 0
              if (!"SplitColumn" %in% names(df_tbl)) df_tbl$SplitColumn <- df_tbl$TaggedPitchType
              split_choice <- fsel
              df_tbl <- apply_split_by(df_tbl, split_choice)
              if (identical(split_choice, "Pitch Types")) {
                ord <- names(all_colors)
                df_tbl$SplitColumn <- as.character(df_tbl$SplitColumn)
                extra <- setdiff(unique(df_tbl$SplitColumn), ord)
                df_tbl$SplitColumn <- factor(df_tbl$SplitColumn, levels = c(ord, extra))
                df_tbl$SplitColumn <- as.character(df_tbl$SplitColumn)
              }
              attr(df_tbl, "split_choice") <- split_choice
              if (!"SplitColumn" %in% names(df_tbl)) df_tbl$SplitColumn <- df_tbl$TaggedPitchType
              if (!nrow(df_tbl)) return(data.frame(Message = "No data"))
              
              # resolve table mode, including saved customs
              mode_choice <- input[[paste0("cell_table_mode_", settings_cell_id)]] %||% "Stuff"
              res_mode <- resolve_table_mode_global(mode_choice, NULL)
              mode <- res_mode$mode
              custom_cols <- res_mode$cols
              enable_colors <- isTRUE(input[[paste0("cell_color_", settings_cell_id)]])
              
              # Use the global .dp_like_table function (defined in main server, populated by comparison suite)
              if (exists(".dp_like_table", inherits = TRUE) && is.function(.dp_like_table)) {
                .dp_like_table(df_tbl, mode, custom_cols, enable_colors = enable_colors)
              } else {
                # Fallback: show message
                DT::datatable(
                  data.frame(Message = "Table builder loading. Please refresh if this persists."),
                  options = list(dom = 't', autoWidth = FALSE), rownames = FALSE
                )
              }
            }
          }, error = function(e) {
            # If any error during rendering, show a helpful message
            message("Error rendering custom reports table: ", e$message)
            DT::datatable(
              data.frame(Message = paste("Error rendering table:", e$message)),
              options = list(dom = 't', autoWidth = FALSE), rownames = FALSE
            )
          })
        })
        return(DT::dataTableOutput(ns(out_id)))
      } else if (tsel == "Spray Chart") {
        output[[out_id]] <- ggiraph::renderGirafe({
          # Different data filtering based on report type
          if (input$report_type == "Pitching") {
            # For pitching: show where batters hit off this pitcher
            df_spray <- df %>% dplyr::filter(!is.na(Batter))
          } else {
            # For hitting: show where this batter hit the ball
            df_spray <- df
          }
          
          if (!nrow(df_spray)) return(NULL)
          dark_on <- is_dark_mode_local()
          cols <- colors_for_mode(dark_on)
          field_fill  <- if (dark_on) "transparent" else "#f3f5f7"
          field_alpha <- if (dark_on) 0 else 0.6
          foul_line_col <- if (dark_on) "#e5e7eb" else "grey50"
          fence_col  <- if (dark_on) "#9ca3af" else "grey40"
          infield_col <- if (dark_on) "#cbd5e1" else "grey70"
          text_col   <- if (dark_on) "#e5e7eb" else "black"
          
          # Accept any live-like session text
          st <- tolower(trimws(as.character(df_spray$SessionType)))
          live_mask <- grepl("live|game|ab", st)
          
          # Require in-play with numeric distance/direction
          dist_num <- suppressWarnings(as.numeric(df_spray$Distance))
          dir_num  <- suppressWarnings(as.numeric(df_spray$Direction))
          ok <- which(live_mask & df_spray$PitchCall == "InPlay" &
                        is.finite(dist_num) & is.finite(dir_num))
          
          # --- Field geometry (±45°, 330/370/400/370/330) ---
          fence_pts <- data.frame(deg = c(-45,-22.5,0,22.5,45),
                                  r   = c(330,370,400,370,330))
          deg_seq <- seq(-45, 45, length.out = 301)
          r_seq   <- stats::spline(fence_pts$deg, fence_pts$r, xout = deg_seq)$y
          fence   <- data.frame(x = r_seq * sin(deg_seq*pi/180),
                                y = r_seq * cos(deg_seq*pi/180))
          fl_l <- data.frame(x = c(0, 330*sin(-45*pi/180)),
                             y = c(0, 330*cos(-45*pi/180)))
          fl_r <- data.frame(x = c(0, 330*sin( 45*pi/180)),
                             y = c(0, 330*cos( 45*pi/180)))
          th_in <- seq(-45, 45, length.out = 121)
          infield <- data.frame(x = 95 * sin(th_in*pi/180),
                                y = 95 * cos(th_in*pi/180))
          # home plate (simple)
          home <- data.frame(
            x = c(-0.75, 0.75, 0.75, 0, -0.75),
            y = c( 1.05, 1.05, 1.15, 1.25, 1.15) - 2.0
          )
          
          # If nothing to plot, show field + message
          if (!length(ok)) {
            p_empty <- ggplot() +
              geom_polygon(data = home, aes(x, y), fill = NA, color = foul_line_col) +
              geom_path(data = fence, aes(x, y), color = fence_col, linewidth = 0.8) +
              geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                           fill = field_fill, color = NA, alpha = field_alpha) +
              geom_path(data = fl_l, aes(x, y), color = foul_line_col) +
              geom_path(data = fl_r, aes(x, y), color = foul_line_col) +
              geom_path(data = infield, aes(x, y), color = infield_col) +
              annotate("text", x = 0, y = 200, label = "No balls in play for current filters", size = 5, color = text_col) +
              coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
              theme_void()
            return(girafe_transparent(ggobj = p_empty))
          }
          
          # --- Points to plot ---
          bbe <- df_spray[ok, , drop = FALSE]
          bbe$Distance  <- dist_num[ok]
          bbe$Direction <- dir_num[ok]
          
          # Fixed mapping: raw Direction ±75 -> on-field ±45 (foul lines)
          FOUL_DEG_RAW  <- 90    # raw "down the line"
          FOUL_DEG_GEOM <- 110    # field drawing foul line angle
          angle_scale   <- FOUL_DEG_GEOM / FOUL_DEG_RAW
          
          # Polar (0° = CF, +RF, −LF) → cartesian
          th     <- bbe$Direction * angle_scale * pi/180
          bbe$x  <- bbe$Distance * sin(th)
          bbe$y  <- bbe$Distance * cos(th)
          
          # Outcome colors
          outcome <- dplyr::case_when(bbe$PlayResult %in% hit_levels ~ bbe$PlayResult, TRUE ~ "Out")
          bbe$Outcome <- factor(outcome, levels = c("Out", hit_levels))
          outcome_cols <- if (dark_on) {
            c("Single"="#34d399","Double"="#60a5fa","Triple"="#c084fc","HomeRun"="#f87171","Out"="#e5e7eb")
          } else {
            c("Single"="#1fab54","Double"="#1f77b4","Triple"="#7b1fa2","HomeRun"="#d62728","Out"="#222222")
          }
          
          # Tooltip + tooltip fill by pitch type color
          bbe <- bbe %>%
            dplyr::mutate(
              rid     = dplyr::row_number(),
              tt      = paste0(
                "EV: ", ifelse(is.finite(ExitSpeed), sprintf("%.1f", ExitSpeed), "—"), " mph\n",
                "LA: ", ifelse(is.finite(Angle),     sprintf("%.1f", Angle),     "—"), "°\n",
                "Distance: ", ifelse(is.finite(Distance), paste0(sprintf("%.0f", Distance), " ft"), "—"), "\n",
                "Pitch: ", TaggedPitchType, "\n",
                "Result: ", PlayResult
              ),
              tt_fill = dplyr::coalesce(cols[as.character(TaggedPitchType)], "gray80")
            )
          
          p <- ggplot() +
            geom_polygon(data = home, aes(x, y), fill = NA, color = foul_line_col) +
            geom_path(data = fence, aes(x, y), color = fence_col, linewidth = 0.8) +
            geom_polygon(data = rbind(fence, fence[1,]), aes(x, y),
                         fill = field_fill, color = NA, alpha = field_alpha) +
            geom_path(data = fl_l, aes(x, y), color = foul_line_col) +
            geom_path(data = fl_r, aes(x, y), color = foul_line_col) +
            geom_path(data = infield, aes(x, y), color = infield_col) +
            
            ggiraph::geom_point_interactive(
              data = bbe,
              aes(x, y, color = Outcome, tooltip = tt, data_id = rid),
              size = 2.8, alpha = 0.95
            ) +
            ggiraph::geom_point_interactive( # invisible hover pad to color tooltip bg by pitch type
              data = bbe,
              aes(x, y, tooltip = tt, data_id = rid, fill = I(tt_fill)),
              shape = 21, size = 8, alpha = 0.001, stroke = 0, inherit.aes = FALSE
            ) +
            scale_color_manual(values = outcome_cols, name = "Result") +
            coord_fixed(xlim = c(-380, 380), ylim = c(-30, 420)) +
            theme_void() + theme(
              legend.position = "bottom",
              legend.direction = "horizontal",
              legend.box = "horizontal",
              legend.margin = margin(t = -4, r = 0, b = -12, l = 0),
              legend.box.margin = margin(t = -6, r = 0, b = -14, l = 0),
              plot.margin = margin(t = 0, r = 0, b = -16, l = 0),
              legend.text = element_text(size = 11, face = "bold", color = text_col),
              legend.title = element_text(color = text_col),
              legend.background = element_rect(fill = "transparent", color = NA),
              legend.box.background = element_rect(fill = "transparent", color = NA),
              legend.key = element_rect(fill = "transparent", color = NA)
            )
          
          girafe_transparent(
            ggobj = p,
            options = list(
              ggiraph::opts_sizing(rescale = TRUE),
              ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css_local),
              ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
              ggiraph::opts_hover_inv(css = "opacity:0.15;")
            )
          )
        })
        return(ggiraph::girafeOutput(ns(out_id), height = "280px"))
      }
      output[[out_id]] <- renderUI({ div("Unsupported selection") })
      uiOutput(ns(out_id))
    }
    
    # Outputs for each cell (optimized to only create observers once per cell)
    cells_with_render_observers <- reactiveVal(character(0))
    
    observeEvent(list(input$report_rows, input$report_cols), {
      rows <- as.integer(input$report_rows); cols <- as.integer(input$report_cols)
      
      # Validate that rows and cols are valid integers
      if (length(rows) == 0 || length(cols) == 0) return()
      if (is.na(rows) || is.na(cols)) return()
      if (rows < 1 || cols < 1) return()
      
      existing_render <- cells_with_render_observers()
      
      for (r in seq_len(rows)) {
        for (c in seq_len(cols)) {
          cell_id <- paste0("r", r, "c", c)
          
          # Only create observer if we haven't already
          if (!cell_id %in% existing_render) {
            local({
              id <- cell_id
              
              # Use reactive to cache expensive computations
              cell_data <- reactive({
                # Only re-compute when these specific inputs change
                # NOTE: Do NOT include cell_title here - it causes re-render on every keystroke
                input[[paste0("cell_type_", id)]]
                input[[paste0("cell_filter_", id)]]
                input[[paste0("cell_table_mode_", id)]]
                
                # Isolate to prevent reactive dependencies on filters
                list(
                  type = input[[paste0("cell_type_", id)]],
                  filter = input[[paste0("cell_filter_", id)]],
                  mode = input[[paste0("cell_table_mode_", id)]]
                )
              }) %>% debounce(300)  # Slightly increased for stability
              
              # Update title display using delayed shinyjs::html (throttled to prevent focus loss)
              # In Multi-Player mode, rows 2+ use Row 1's title
              observe({
                # Determine which title to use
                is_multi_player <- input$report_scope == "Multi-Player"
                
                # Extract row and column from cell_id (format: "r1c2")
                row_num <- as.integer(sub("r(\\d+)c\\d+", "\\1", id))
                col_num <- as.integer(sub("r\\d+c(\\d+)", "\\1", id))
                
                # For rows 2+ in Multi-Player mode, use Row 1's title
                if (is_multi_player && row_num > 1) {
                  title_cell_id <- paste0("r1c", col_num)
                  title_val <- input[[paste0("cell_title_", title_cell_id)]]
                } else {
                  title_val <- input[[paste0("cell_title_", id)]]
                }
                
                shinyjs::delay(50, {
                  shinyjs::html(
                    id = paste0("cell_title_display_", id),
                    html = title_val %||% ""
                  )
                })
              })
              
              output[[paste0("cell_output_", id)]] <- renderUI({
                # Get cell data (triggers on chart type/filter/mode changes only)
                cd <- cell_data()
                
                # Render the chart (title is separate, updated via shinyjs)
                render_cell(id)
              })
            })
            existing_render <- c(existing_render, cell_id)
          }
        }
      }
      cells_with_render_observers(existing_render)
    }, ignoreInit = FALSE)
  })
}

# ==================================
# == Player Plans Suite ==
# ==================================

# Player Plans UI
player_plans_ui <- function() {
  fluidPage(
    tags$head(
      tags$style(HTML("
        .goal-container {
          border: 1px solid #ddd;
          border-radius: 5px;
          padding: 15px;
          margin: 10px 0;
          background-color: #f9f9f9;
          position: relative;
        }
        .goal-description {
          min-height: 80px;
          padding: 10px;
          background-color: white;
          border: 1px solid #e0e0e0;
          border-radius: 3px;
          margin-bottom: 15px;
        }
        /* Fixed checkbox positioning */
        .goal-checkbox {
          position: absolute !important;
          top: 8px !important;
          right: 8px !important;
          z-index: 999 !important;
          margin: 0 !important;
          padding: 0 !important;
        }
        .goal-checkbox .checkbox {
          margin: 0 !important;
          min-height: auto !important;
        }
        .goal-checkbox .checkbox input[type='checkbox'] {
          margin: 0 !important;
        }
      "))
    ),
    
    div(
      class = "pp-root",
      sidebarLayout(
        sidebarPanel(
          width = 3,
          h4("Player Plans"),
          selectInput("pp_player_select", "Select Player:",
                      choices = NULL,
                      selected = NULL),
          
          selectInput("pp_session_type", "Session Type:",
                      choices = c("All", "Bullpen", "Live"),
                      selected = "All"),
          
          dateRangeInput("pp_date_range", "Date Range:",
                         start = Sys.Date() - 30,
                         end = Sys.Date(),
                         format = "mm/dd/yyyy"),
          
          hr(),
          
          # Goal 1
          h5("Goal #1"),
          selectInput("pp_goal1_type", "Goal Type:",
                      choices = c("", "Stuff", "Execution"),
                      selected = ""),
          
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Stuff'",
            selectInput("pp_goal1_stuff_category", "Category:",
                        choices = c("", "Velocity", "Movement"),
                        selected = "")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Stuff' && input.pp_goal1_stuff_category == 'Velocity'",
            selectInput("pp_goal1_velocity_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal1_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Stuff' && input.pp_goal1_stuff_category == 'Movement'",
            selectInput("pp_goal1_movement_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal1_movement_type", "Movement Type:",
                        choices = c("IVB", "HB"),
                        selected = NULL,
                        multiple = TRUE),
            selectInput("pp_goal1_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Stuff'",
            selectInput("pp_goal1_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Movement Plot", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Stuff' && input.pp_goal1_chart_view == 'Movement Plot'",
            selectInput("pp_goal1_movement_display", "Movement Plot View:",
                        choices = c("Averages Only", "Averages and Pitches",
                                    "Target Shapes Only", "Target Shapes and Pitches"),
                        selected = c("Averages and Pitches"),
                        multiple = TRUE),
            actionButton("pp_goal1_target_settings", "Target Shapes Settings",
                         class = "btn-default btn-sm")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal1_type == 'Execution'",
            selectInput("pp_goal1_execution_stat", "Stat:",
                        choices = c("", "FPS%", "E+A%", "InZone%", "Strike%", 
                                    "Comp%", "Ctrl+", "QP+", "QP%", "Whiff%", "CSW%"),
                        selected = ""),
            selectInput("pp_goal1_execution_pitch", "Pitch Type:",
                        choices = c("All"),
                        selected = "All",
                        multiple = TRUE),
            selectInput("pp_goal1_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All"),
            selectInput("pp_goal1_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Heatmap", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          
          # Target section for Goal 1
          conditionalPanel(
            condition = "input.pp_goal1_type != ''",
            hr(),
            h6("Target:"),
            fluidRow(
              column(4,
                     selectInput("pp_goal1_target_direction", NULL,
                                 choices = c("", ">", "<"),
                                 selected = "")
              ),
              column(8,
                     textInput("pp_goal1_target_value", NULL,
                               placeholder = "Enter target value",
                               value = "")
              )
            )
          ),
          
          hr(),
          
          # Goal 2
          h5("Goal #2"),
          selectInput("pp_goal2_type", "Goal Type:",
                      choices = c("", "Stuff", "Execution"),
                      selected = ""),
          
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Stuff'",
            selectInput("pp_goal2_stuff_category", "Category:",
                        choices = c("", "Velocity", "Movement"),
                        selected = "")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Stuff' && input.pp_goal2_stuff_category == 'Velocity'",
            selectInput("pp_goal2_velocity_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal2_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Stuff' && input.pp_goal2_stuff_category == 'Movement'",
            selectInput("pp_goal2_movement_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal2_movement_type", "Movement Type:",
                        choices = c("IVB", "HB"),
                        selected = NULL,
                        multiple = TRUE),
            selectInput("pp_goal2_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Stuff'",
            selectInput("pp_goal2_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Movement Plot", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Stuff' && input.pp_goal2_chart_view == 'Movement Plot'",
            selectInput("pp_goal2_movement_display", "Movement Plot View:",
                        choices = c("Averages Only", "Averages and Pitches",
                                    "Target Shapes Only", "Target Shapes and Pitches"),
                        selected = c("Averages and Pitches"),
                        multiple = TRUE),
            actionButton("pp_goal2_target_settings", "Target Shapes Settings",
                         class = "btn-default btn-sm")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal2_type == 'Execution'",
            selectInput("pp_goal2_execution_stat", "Stat:",
                        choices = c("", "FPS%", "E+A%", "InZone%", "Strike%", 
                                    "Comp%", "Ctrl+", "QP+", "QP%", "Whiff%", "CSW%"),
                        selected = ""),
            selectInput("pp_goal2_execution_pitch", "Pitch Type:",
                        choices = c("All"),
                        selected = "All",
                        multiple = TRUE),
            selectInput("pp_goal2_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All"),
            selectInput("pp_goal2_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Heatmap", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          
          # Target section for Goal 2
          conditionalPanel(
            condition = "input.pp_goal2_type != ''",
            hr(),
            h6("Target:"),
            fluidRow(
              column(4,
                     selectInput("pp_goal2_target_direction", NULL,
                                 choices = c("", ">", "<"),
                                 selected = "")
              ),
              column(8,
                     textInput("pp_goal2_target_value", NULL,
                               placeholder = "Enter target value",
                               value = "")
              )
            )
          ),
          
          hr(),
          
          # Goal 3
          h5("Goal #3"),
          selectInput("pp_goal3_type", "Goal Type:",
                      choices = c("", "Stuff", "Execution"),
                      selected = ""),
          
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Stuff'",
            selectInput("pp_goal3_stuff_category", "Category:",
                        choices = c("", "Velocity", "Movement"),
                        selected = "")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Stuff' && input.pp_goal3_stuff_category == 'Velocity'",
            selectInput("pp_goal3_velocity_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal3_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Stuff' && input.pp_goal3_stuff_category == 'Movement'",
            selectInput("pp_goal3_movement_pitch", "Pitch Type:",
                        choices = NULL,
                        selected = NULL),
            selectInput("pp_goal3_movement_type", "Movement Type:",
                        choices = c("IVB", "HB"),
                        selected = NULL,
                        multiple = TRUE),
            selectInput("pp_goal3_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All")
          ),
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Stuff'",
            selectInput("pp_goal3_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Movement Plot", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Stuff' && input.pp_goal3_chart_view == 'Movement Plot'",
            selectInput("pp_goal3_movement_display", "Movement Plot View:",
                        choices = c("Averages Only", "Averages and Pitches",
                                    "Target Shapes Only", "Target Shapes and Pitches"),
                        selected = c("Averages and Pitches"),
                        multiple = TRUE),
            actionButton("pp_goal3_target_settings", "Target Shapes Settings",
                         class = "btn-default btn-sm")
          ),
          
          conditionalPanel(
            condition = "input.pp_goal3_type == 'Execution'",
            selectInput("pp_goal3_execution_stat", "Stat:",
                        choices = c("", "FPS%", "E+A%", "InZone%", "Strike%", 
                                    "Comp%", "Ctrl+", "QP+", "QP%", "Whiff%", "CSW%"),
                        selected = ""),
            selectInput("pp_goal3_execution_pitch", "Pitch Type:",
                        choices = c("All"),
                        selected = "All",
                        multiple = TRUE),
            selectInput("pp_goal3_batter_hand", "Batter Hand:",
                        choices = c("All", "Left", "Right"),
                        selected = "All"),
            selectInput("pp_goal3_chart_view", "Chart View:",
                        choices = c("Trend Chart", "Heatmap", "Pitch Map"),
                        selected = "Trend Chart")
          ),
          
          # Target section for Goal 3
          conditionalPanel(
            condition = "input.pp_goal3_type != ''",
            hr(),
            h6("Target:"),
            fluidRow(
              column(4,
                     selectInput("pp_goal3_target_direction", NULL,
                                 choices = c("", ">", "<"),
                                 selected = "")
              ),
              column(8,
                     textInput("pp_goal3_target_value", NULL,
                               placeholder = "Enter target value",
                               value = "")
              )
            )
          )
        ),
        
        mainPanel(
          width = 9,
          div(id = "player-plans-content",
              # PDF Download Button
              # Content goes here
              
              # Header section with logos and title
              fluidRow(
                column(2,
                       div(style = "text-align: left; padding-top: 20px;",
                           tags$img(src = "PCUlogo.png", style = "height: 80px; max-width: 100%;")
                       )
                ),
                column(8,
                       div(style = "text-align: center; padding: 20px 0;",
                           h2(strong("Player Development Plan"), style = "margin-bottom: 10px;"),
                           h3(strong(textOutput("pp_player_name", inline = TRUE)), style = "margin-bottom: 5px;"),
                           h5(em(textOutput("pp_date_range_display", inline = TRUE)), style = "margin: 0;")
                       )
                ),
                column(2,
                       div(style = "text-align: right; padding-top: 30px;",
                           tags$img(src = school_logo, style = "height: 40px; max-width: 100%;", alt = school_display_name)
                       )
                )
              ),
              hr(),
              uiOutput("pp_dynamic_goals"),
              br(),
              # View Completed Goals button
              fluidRow(
                column(12,
                       div(style = "text-align: center; margin: 20px 0;",
                           actionButton("pp_view_completed", "View Completed Goals", 
                                        class = "btn-info", style = "margin-right: 10px;"),
                           span(textOutput("pp_completed_count", inline = TRUE), 
                                style = "font-size: 14px; color: #666;")
                       )
                )
              ),
              br(),
              fluidRow(
                column(12,
                       div(style = "text-align: center;",
                           h4(strong("Notes"))
                       ),
                       textAreaInput("pp_general_notes", label = NULL,
                                     placeholder = "Enter general notes for this player plan...",
                                     rows = 4, width = "100%")
                )
              )
          ) # Close player-plans-content div
        )
      ),
      
      # JavaScript for localStorage persistence
      tags$script(HTML("
      // Save player plans to localStorage
      Shiny.addCustomMessageHandler('savePlayerPlans', function(plans) {
        try {
          localStorage.setItem('playerPlans', JSON.stringify(plans));
          console.log('Saved player plans to localStorage');
        } catch(e) {
          console.error('Error saving to localStorage:', e);
        }
      });
      
      // Load player plans from localStorage
      Shiny.addCustomMessageHandler('loadPlayerPlans', function(message) {
        try {
          var savedPlans = localStorage.getItem('playerPlans');
          if (savedPlans) {
            var plans = JSON.parse(savedPlans);
            Shiny.setInputValue('loadedPlayerPlans', plans);
            console.log('Loaded player plans from localStorage');
          } else {
            console.log('No saved plans found in localStorage');
          }
        } catch(e) {
          console.error('Error loading from localStorage:', e);
        }
      });
      
      // Save completed goals to localStorage
      Shiny.addCustomMessageHandler('saveCompletedGoals', function(goals) {
        try {
          localStorage.setItem('completedGoals', JSON.stringify(goals));
          console.log('Saved completed goals to localStorage');
        } catch(e) {
          console.error('Error saving completed goals to localStorage:', e);
        }
      });
      
      // Load completed goals from localStorage
      Shiny.addCustomMessageHandler('loadCompletedGoals', function(message) {
        try {
          var savedGoals = localStorage.getItem('completedGoals');
          if (savedGoals) {
            var goals = JSON.parse(savedGoals);
            Shiny.setInputValue('loadedCompletedGoals', goals);
            console.log('Loaded completed goals from localStorage');
          } else {
            console.log('No saved completed goals found in localStorage');
          }
        } catch(e) {
          console.error('Error loading completed goals from localStorage:', e);
        }
      });
    ")),
      
      # Add custom CSS for the modal
      tags$style(HTML("
      .modal-dialog {
        max-width: 800px;
      }
      .goal-completion-checkbox {
        margin-top: 5px;
      }
      "))
    )
  )
}
# ==================================
# == AUTHENTICATION SETUP ==
# ==================================

# Using shinyapps.io native authentication instead of shinymanager
# Three-tier access system:
# 1. Admins - see all data + admin features
# 2. Coaches - see all data, no admin features  
# 3. Players - see only their own data (matched via lookup_table.csv)

admin_emails <- c(
  "jgaynor@pitchingcoachu.com",
  "ahalverson@pitchingcoachu.com"
)

# Coach emails - defined per-school via `config/school_config.R`
# Players are identified by their email being in the lookup_table.csv Email column
# They will only see data where Email matches their login email


ui <- tagList(
  # --- Custom navbar colors & styling ---
  tags$head(
    # Apple iOS home screen icon
    tags$link(rel = "apple-touch-icon", href = "PCUlogo.png"),
    tags$link(rel = "apple-touch-icon", sizes = "152x152", href = "PCUlogo.png"),
    tags$link(rel = "apple-touch-icon", sizes = "180x180", href = "PCUlogo.png"),
    tags$link(rel = "apple-touch-icon", sizes = "167x167", href = "PCUlogo.png"),
    # Standard favicon
    tags$link(rel = "icon", type = "image/png", href = "PCUlogo.png"),
    # Apple mobile web app settings
    tags$meta(name = "apple-mobile-web-app-capable", content = "yes"),
    tags$meta(name = "apple-mobile-web-app-status-bar-style", content = "black-translucent"),
    tags$meta(name = "apple-mobile-web-app-title", content = "PCU Dashboard"),
    
    tags$script(HTML("
      document.addEventListener('DOMContentLoaded', function() {
        var checkbox = document.querySelector('.dark-toggle input#dark_mode');
        if (!checkbox) return;
        var sync = function() {
          var state = !!checkbox.checked;
          if (window.Shiny && Shiny.setInputValue) {
            Shiny.setInputValue('dark_mode', state, {priority: 'event'});
          }
        };
        checkbox.addEventListener('change', sync);
        sync();
      });
    ")),
    tags$script(HTML("
      // Add a simple dropdown mirror for the top navbar tabs (mobile only)
      document.addEventListener('DOMContentLoaded', function() {
        var buildSelect = function() {
          var nav = document.querySelector('#top .navbar-nav');
          if (!nav) return;
          var links = Array.prototype.slice.call(nav.querySelectorAll('a'));
          if (!links.length || document.getElementById('topNavSelect')) return;
          var select = document.createElement('select');
          select.id = 'topNavSelect';
          select.className = 'form-control nav-dropdown';
          links.forEach(function(link) {
            var opt = document.createElement('option');
            var val = (link.getAttribute('data-value') || link.textContent || '').trim();
            opt.value = val;
            opt.textContent = (link.textContent || '').trim();
            if (link.parentElement && link.parentElement.classList.contains('active')) opt.selected = true;
            select.appendChild(opt);
          });
          select.addEventListener('change', function() {
            var target = links.find(function(l) {
              var val = (l.getAttribute('data-value') || l.textContent || '').trim();
              return val === select.value;
            });
            if (target) target.click();
          });
          var container = document.querySelector('#top .navbar-header') || nav.parentNode;
          if (container) {
            container.parentNode.insertBefore(select, container.nextSibling);
          } else {
            nav.parentNode.insertBefore(select, nav);
          }
          $(document).on('shown.bs.tab', '#top .navbar-nav a', function(e) {
            var val = ($(e.target).data('value') || $(e.target).text() || '').trim();
            $('#topNavSelect').val(val);
          });
        };
        buildSelect();
        // fallback for late nav rendering
        setTimeout(buildSelect, 300);
      });
    ")),
    tags$script(HTML("
      // Add dropdown mirrors for inner tabsets (suite pages) - mobile-friendly
      document.addEventListener('DOMContentLoaded', function() {
        var ensureSidebarDock = function() {
          // Prefer the accordion body under Filters
          var body = document.querySelector('.sidebar .sidebar-accordion-body');
          if (body) return body;
          // If accordion exists but body not yet created (unlikely), build one
          var accordion = document.querySelector('.sidebar .sidebar-accordion');
          if (accordion && !accordion.querySelector('.sidebar-accordion-body')) {
            var b = document.createElement('div');
            b.className = 'sidebar-accordion-body';
            accordion.appendChild(b);
            return b;
          }
          return null;
        };
        var placeWrapper = function(nav, wrapper) {
          if (!nav || !wrapper) return;
          var target = null;
          var mobile = window.innerWidth <= 768;
          if (mobile) {
            var row = nav.closest('.row');
            target = row ? row.querySelector('.sidebar-accordion-body') : null;
            if (!target) target = ensureSidebarDock();
            if (!target) target = document.querySelector('.sidebar .sidebar-accordion-body');
          }
          if (target) {
            wrapper.classList.add('inner-nav-in-sidebar');
            if (wrapper.parentNode !== target) {
              target.insertBefore(wrapper, target.firstChild);
            } else if (wrapper !== target.firstChild) {
              target.insertBefore(wrapper, target.firstChild);
            }
          } else if (nav.parentNode) {
            wrapper.classList.remove('inner-nav-in-sidebar');
            if (wrapper.parentNode !== nav.parentNode) {
              nav.parentNode.insertBefore(wrapper, nav);
            } else if (wrapper.nextSibling !== nav) {
              nav.parentNode.insertBefore(wrapper, nav);
            }
          }
        };
        var enhance = function(nav) {
          if (window.innerWidth <= 768) return; // show native tabs on mobile; no dropdown mirror
          if (!nav || nav.dataset.hasSelect) return;
          var links = Array.prototype.slice.call(nav.querySelectorAll('a'));
          if (!links.length) return;
          var sel = document.createElement('select');
          sel.className = 'form-control inner-nav-dropdown';
          links.forEach(function(link) {
            var opt = document.createElement('option');
            var href = (link.getAttribute('href') || '').replace('#','');
            opt.value = href;
            opt.textContent = (link.textContent || '').trim();
            if (link.parentElement && link.parentElement.classList.contains('active')) opt.selected = true;
            sel.appendChild(opt);
          });
          sel.addEventListener('change', function() {
            var target = links.find(function(l) {
              var href = (l.getAttribute('href') || '').replace('#','');
              return href === sel.value;
            });
            if (target) target.click();
          });
          var wrapper = document.createElement('div');
          wrapper.className = 'inner-nav-wrap';
          wrapper.appendChild(sel);
          nav._innerSelectWrapper = wrapper;
          placeWrapper(nav, wrapper);
          // Re-check placement after other mobile transforms run
          setTimeout(function() { placeWrapper(nav, wrapper); }, 150);
          window.addEventListener('resize', function() { placeWrapper(nav, wrapper); });
          $(nav).on('shown.bs.tab', 'a', function(e) {
            var href = ($(e.target).attr('href') || '').replace('#','');
            sel.value = href;
          });
          nav.dataset.hasSelect = '1';
        };
        var init = function() {
          // standard tabsets
          document.querySelectorAll('.tabbable > .nav.nav-tabs').forEach(function(nav){
            if (!nav.dataset.hasSelect) enhance(nav);
            else if (nav._innerSelectWrapper) placeWrapper(nav, nav._innerSelectWrapper);
          });
          // fallback: any nav-tabs missing a select
          document.querySelectorAll('.nav.nav-tabs').forEach(function(nav){
            if (!nav.dataset.hasSelect) enhance(nav);
            else if (nav._innerSelectWrapper) placeWrapper(nav, nav._innerSelectWrapper);
          });
        };
        init();
        // Re-run when DOM mutates (late-rendered tabsets)
        var mo = new MutationObserver(function() {
          clearTimeout(mo._debounce);
          mo._debounce = setTimeout(init, 120);
        });
        mo.observe(document.body, {childList: true, subtree: true});
        document.addEventListener('shiny:recalculating', function() { setTimeout(init, 200); });
      });
    ")),
    tags$script(HTML("
      // Mobile sidebar: replace full panel with a single dropdown accordion
      document.addEventListener('DOMContentLoaded', function() {
        var transform = function(sidebar) {
          if (!sidebar || sidebar.dataset.mobileAccordion) return;
          if (window.innerWidth > 768) return;
          var details = document.createElement('details');
          details.className = 'sidebar-accordion';
          var summary = document.createElement('summary');
          summary.textContent = 'Filters';
          summary.className = 'sidebar-accordion-summary';
          var body = document.createElement('div');
          body.className = 'sidebar-accordion-body';
          while (sidebar.firstChild) {
            body.appendChild(sidebar.firstChild);
          }
          details.appendChild(summary);
          details.appendChild(body);
          sidebar.appendChild(details);
          sidebar.dataset.mobileAccordion = '1';
        };
        var init = function() {
          document.querySelectorAll('.sidebar').forEach(transform);
        };
        init();
        window.addEventListener('resize', function() {
          // Do not rebuild; only apply on first mobile render to avoid moving nodes back and forth
        });
        document.addEventListener('shiny:recalculating', function() { setTimeout(init, 200); });
      });
    ")),
    # Custom authentication disabled - no need for token persistence
    tags$style(HTML(colorize_css("
      /* ===== MODERN PROFESSIONAL DESIGN ===== */
      
      /* Global Styles */
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
      
      body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%);
        color: #1a202c;
        font-size: 14px;
      }
      
      /* ===== NAVBAR DESIGN ===== */
      .navbar-inverse { 
        background: linear-gradient(135deg, #000000 0%, #1a1a1a 50%, #2d2d2d 100%);
        border: none;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        min-height: 70px;
      }
      .navbar { 
        position: relative; 
        border-radius: 0;
        margin-bottom: 0;
      }

      /* Brand area with two logos side-by-side */
      .navbar-inverse .navbar-brand {
        color: #ffffff !important;
        font-weight: 800;
        font-size: 24px;
        letter-spacing: -0.5px;
        display: flex;
        align-items: center;
        gap: 12px;
        padding-top: 15px;
        padding-bottom: 15px;
        transition: all 0.3s ease;
      }
      .navbar-inverse .navbar-brand:hover {
        transform: translateY(-2px);
      }
      .navbar-inverse .navbar-brand .brand-logo {
        height: 40px;
        display: inline-block;
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
      }
      .navbar-inverse .navbar-brand .brand-title {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      /* PCU logo on the far right */
      .navbar .pcu-right {
        position: absolute;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        height: 50px;
        display: block;
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
      }
      @media (max-width: 768px) {
        .navbar .pcu-right { display: none; }
        .navbar-inverse .navbar-brand { font-size: 18px; }
      .navbar-inverse .navbar-brand .brand-logo { height: 32px; }
      /* Mobile nav: show original tabs (scrollable) plus dropdown */
      .navbar-inverse .navbar-nav { display: flex; overflow-x: auto; white-space: nowrap; }
      .navbar-inverse .navbar-nav > li { float: none; display: inline-block; }
      #topNavSelect, .nav-dropdown { display: block; width: 100%; max-width: none; }
      /* Sidebar: show accordion dropdown only on mobile */
      .sidebar-dropdown-wrap { display: none; }
        .sidebar { display: block !important; }
        .sidebar details.sidebar-accordion { display: block; }
        .sidebar .well { padding: 0; border: none; box-shadow: none; background: transparent; }
        .sidebar .sidebar-accordion-body .well { padding: 16px; }
        /* Prevent thin charts/tables: allow horizontal scroll when needed */
        .plotly { overflow-x: auto !important; }
        .plotly .main-svg { overflow: visible !important; }
        .plotly .legend, .plotly .infolayer { overflow: visible !important; }
        .plot-container { overflow: auto !important; padding-bottom: 12px; }
        .girafe_container_std, .ggiraph-container { overflow: auto !important; }
        .dataTables_wrapper { overflow-x: auto !important; width: 100% !important; }
        /* Hide desktop sidebar toggle button on mobile */
        #pitchingSidebarToggle { display: none !important; }
        /* Allow Plotly legends to scroll on small screens */
        .plotly .legend {
          max-height: 65vh;
          overflow-y: auto !important;
          white-space: normal !important;
          max-width: 100% !important;
          position: relative !important;
        }
      .plotly .legend .scrollbox { overflow: visible !important; }
      /* Let static legend plots breathe on mobile */
      .legend-plot-wrap { width: 100%; overflow-x: auto; }
      #summary_legend, #summary_result_legend { min-height: 140px !important; }
    }

      /* Tab Navigation - Modern pill style */
      .navbar-inverse .navbar-nav {
        margin-top: 8px;
      }
      .navbar-inverse .navbar-nav > li > a { 
        color: rgba(255, 255, 255, 0.85) !important;
        font-weight: 600;
        font-size: 15px;
        padding: 10px 20px;
        margin: 0 4px;
        border-radius: 12px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }
      .navbar-inverse .navbar-nav > li > a::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(227,82,5,0.18) 0%, rgba(255,140,26,0.12) 100%);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .navbar-inverse .navbar-nav > li > a:hover::before {
        opacity: 1;
      }
      .navbar-inverse .navbar-nav > li > a:hover,
      .navbar-inverse .navbar-nav > li > a:focus { 
        color: #ffffff !important;
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      }

      /* Active tab - vibrant gradient */
      .navbar-inverse .navbar-nav > .active > a,
      .navbar-inverse .navbar-nav > .active > a:hover,
      .navbar-inverse .navbar-nav > .active > a:focus {
        color: #ffffff !important;
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        box-shadow: 0 4px 15px rgba(227, 82, 5, 0.4);
        transform: translateY(-2px);
      }
      /* Charts/graphs: keep backgrounds transparent globally */
      .plot-container, .plotly, .plotly .main-svg, .plotly .svg-container { background: transparent !important; }
      .plotly .cartesianlayer .bg, .plotly .draglayer, .plotly .bglayer rect { fill: transparent !important; }
      .plotly .polar > g, .plotly .ternary > g { fill: transparent !important; }
      .girafe_container svg, .ggiraph-container svg, canvas { background: transparent !important; }
      /* Nuke ggiraph’s white rect background in light mode */
      body:not(.theme-dark) .girafe_container svg rect.bg,
      body:not(.theme-dark) .ggiraph-container svg rect.bg {
        fill: transparent !important;
      }
      /* Remove default white panel rects in girafe outputs */
      body:not(.theme-dark) .girafe_container svg rect[fill='#FFFFFF'],
      body:not(.theme-dark) .girafe_container svg rect[fill='#ffffff'],
      body:not(.theme-dark) .girafe_container svg rect[fill='#fff'],
      body:not(.theme-dark) .girafe_container svg rect[fill='white'],
      body:not(.theme-dark) .ggiraph-container svg rect[fill='#FFFFFF'],
      body:not(.theme-dark) .ggiraph-container svg rect[fill='#ffffff'],
      body:not(.theme-dark) .ggiraph-container svg rect[fill='#fff'],
      body:not(.theme-dark) .ggiraph-container svg rect[fill='white'] {
        fill: transparent !important;
        stroke: none !important;
      }
      /* Force plot images and canvases transparent */
      .shiny-plot-output img,
      .shiny-plot-output canvas,
      .shiny-image-output img {
        background: transparent !important;
        background-color: transparent !important;
      }
      /* Light mode: transparent plot surfaces + no shadows */
      body:not(.theme-dark) .shiny-plot-output,
      body:not(.theme-dark) .plotly,
      body:not(.theme-dark) .html-widget,
      body:not(.theme-dark) .ggiraph-container,
      body:not(.theme-dark) .girafe_container {
        background: transparent !important;
        box-shadow: none !important;
        border: none !important;
      }
      /* Light mode: remove white panels behind plots/graphs (everywhere except sidebar) */
      body:not(.theme-dark) .well,
      body:not(.theme-dark) .panel {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      /* Light mode: ensure main content areas are transparent */
      body:not(.theme-dark) .col-sm-9,
      body:not(.theme-dark) .main-panel,
      body:not(.theme-dark) .tab-content,
      body:not(.theme-dark) .tab-pane {
        background: transparent !important;
      }
      /* Light mode: force sidebarLayout panels transparent */
      body:not(.theme-dark) .sidebarLayout,
      body:not(.theme-dark) .sidebarPanel,
      body:not(.theme-dark) .mainPanel,
      body:not(.theme-dark) .container-fluid,
      body:not(.theme-dark) .row {
        background: transparent !important;
      }
      /* Light mode: all divs inside main content transparent */
      body:not(.theme-dark) .col-sm-9 > div,
      body:not(.theme-dark) .main-panel > div,
      body:not(.theme-dark) .tab-pane > div {
        background: transparent !important;
      }
      /* Light mode: specific plot IDs (matching dark mode approach) */
      body:not(.theme-dark) #heatPlot,
      body:not(.theme-dark) #heatPlot canvas,
      body:not(.theme-dark) #heatPlot img,
      body:not(.theme-dark) #pitchPlot,
      body:not(.theme-dark) #pitchPlot canvas,
      body:not(.theme-dark) #pitchPlot img,
      body:not(.theme-dark) #heatmapPlot,
      body:not(.theme-dark) #heatmapPlot canvas,
      body:not(.theme-dark) #heatmapPlot img,
      body:not(.theme-dark) #veloTrendPlot,
      body:not(.theme-dark) #veloTrendPlot canvas,
      body:not(.theme-dark) #veloTrendPlot img,
      body:not(.theme-dark) #summary_heatZonePlot,
      body:not(.theme-dark) #summary_heatZonePlot canvas,
      body:not(.theme-dark) #summary_heatZonePlot img,
      body:not(.theme-dark) #summary_legend,
      body:not(.theme-dark) #summary_legend canvas,
      body:not(.theme-dark) #summary_legend img,
      body:not(.theme-dark) #heatmapsHeatPlot,
      body:not(.theme-dark) #heatmapsHeatPlot canvas,
      body:not(.theme-dark) #heatmapsHeatPlot img,
      body:not(.theme-dark) #cmpA_heat,
      body:not(.theme-dark) #cmpA_heat canvas,
      body:not(.theme-dark) #cmpA_heat img,
      body:not(.theme-dark) #cmpB_heat,
      body:not(.theme-dark) #cmpB_heat canvas,
      body:not(.theme-dark) #cmpB_heat img,
      body:not(.theme-dark) #corr_plot,
      body:not(.theme-dark) #corr_plot canvas,
      body:not(.theme-dark) #corr_plot img,
      body:not(.theme-dark) #campSummaryHeatZonePlot,
      body:not(.theme-dark) #campSummaryHeatZonePlot canvas,
      body:not(.theme-dark) #campSummaryHeatZonePlot img,
      body:not(.theme-dark) #campSummaryLegend,
      body:not(.theme-dark) #campSummaryLegend canvas,
      body:not(.theme-dark) #campSummaryLegend img,
      body:not(.theme-dark) #summary_result_legend,
      body:not(.theme-dark) #summary_result_legend canvas,
      body:not(.theme-dark) #summary_result_legend img,
      body:not(.theme-dark) #result_key,
      body:not(.theme-dark) #result_key canvas,
      body:not(.theme-dark) #result_key img,
      body:not(.theme-dark) #pitch_type_key,
      body:not(.theme-dark) #pitch_type_key canvas,
      body:not(.theme-dark) #pitch_type_key img {
        background: transparent !important;
      }
      /* Keep sidebar styling intact in light mode */
      body:not(.theme-dark) .sidebar .well,
      body:not(.theme-dark) .col-sm-3 .well,
      body:not(.theme-dark) .col-sm-4 .well,
      body:not(.theme-dark) .sidebar .panel {
        background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%) !important;
        border: none !important;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08) !important;
        border-left: 4px solid #e35205 !important;
      }
      /* Tables: allow full width */
      .dataTables_wrapper { width: 100% !important; }
      /* Optional navbar dropdown mirror */
      .nav-dropdown {
        margin: 6px 0 10px 0;
        max-width: 360px;
        font-weight: 700;
        font-size: 17px;
        padding: 12px 14px;
        min-height: 48px;
        line-height: 1.4;
      }
      /* Inner tabset dropdown mirror */
      .inner-nav-wrap { margin: 8px 0 12px 0; display: none; }
      .inner-nav-dropdown { width: 100%; font-weight: 800; font-size: 17px; padding: 22px 18px; min-height: 76px; line-height: 1.45; letter-spacing: 0.2px; }
      /* Sidebar dropdown */
      .sidebar-dropdown-wrap { margin: 8px 0 8px 0; display: none; }
      .sidebar-dropdown { width: 100%; font-weight: 700; font-size: 17px; padding: 12px 14px; min-height: 48px; line-height: 1.4; }
      .sidebar-accordion { border: 1px solid #e2e8f0; border-radius: 12px; background: #fff; box-shadow: 0 4px 12px rgba(0,0,0,0.06); }
      .sidebar-accordion-summary { padding: 14px; font-weight: 800; font-size: 16px; cursor: pointer; }
      .sidebar-accordion-body { padding: 12px; }
      
      /* ===== SIDEBAR DESIGN ===== */
      .well {
        background: #ffffff;
        border: none;
        border-radius: 16px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        padding: 24px;
        margin-bottom: 20px;
      }
      
      .sidebar .well, .col-sm-3 .well, .col-sm-4 .well {
        background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
        border-left: 4px solid #e35205;
      }
      
      /* Form Controls - Modern inputs */
      .form-control, .selectize-input {
        border: 2px solid #e2e8f0;
        border-radius: 10px;
        padding: 10px 14px;
        font-size: 14px;
        transition: all 0.3s ease;
        background: #ffffff;
      }
      .form-control:focus, .selectize-input.focus {
        border-color: #e35205;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        outline: none;
      }
      
      .form-group label {
        font-weight: 600;
        color: #2d3748;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
      }
      
      /* Select dropdowns */
      .selectize-dropdown {
        border: 2px solid #e2e8f0;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        margin-top: 4px;
      }
      .selectize-dropdown-content .option {
        padding: 10px 14px;
        transition: all 0.2s ease;
      }
      .selectize-dropdown-content .option:hover,
      .selectize-dropdown-content .option.active {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        color: white;
      }
      
      /* Date inputs */
      .shiny-date-range-input .input-daterange input {
        border-radius: 10px;
        border: 2px solid #e2e8f0;
      }
      
      /* ===== TAB PANELS (Secondary navigation) ===== */
      .nav-tabs {
        border-bottom: 2px solid #e2e8f0;
        margin-bottom: 20px;
      }
      .nav-tabs > li > a {
        border: none;
        border-radius: 12px 12px 0 0;
        color: #4a5568;
        font-weight: 600;
        padding: 12px 24px;
        margin-right: 4px;
        transition: all 0.3s ease;
        position: relative;
      }
      .nav-tabs > li > a:hover {
        background: linear-gradient(135deg, rgba(227,82,5,0.12) 0%, rgba(255,140,26,0.08) 100%);
        color: #e35205;
        border: none;
      }
      .nav-tabs > li.active > a,
      .nav-tabs > li.active > a:hover,
      .nav-tabs > li.active > a:focus {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        color: white;
        border: none;
        box-shadow: 0 -2px 10px rgba(227, 82, 5, 0.3);
      }
      /* Dark mode tabs (page-level) */
      body.theme-dark .nav-tabs {
        border-color: rgba(255,255,255,0.18);
      }
      body.theme-dark .nav-tabs > li > a {
        color: rgba(229, 231, 235, 0.88);
        background: rgba(255,255,255,0.04);
        border: 1px solid rgba(255,255,255,0.08);
      }
      body.theme-dark .nav-tabs > li > a:hover {
        background: rgba(255,255,255,0.10);
        color: #ffffff;
        border-color: rgba(255,255,255,0.14);
      }
      body.theme-dark .nav-tabs > li.active > a,
      body.theme-dark .nav-tabs > li.active > a:hover,
      body.theme-dark .nav-tabs > li.active > a:focus {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        color: #ffffff;
        border: none;
        box-shadow: 0 -2px 12px rgba(227,82,5,0.35);
      }
      
      /* ===== BUTTONS ===== */
      .btn {
        border-radius: 10px;
        font-weight: 600;
        padding: 10px 20px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }
      .btn:active {
        transform: translateY(0);
      }
      
      .btn-primary {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        color: white;
      }
      .btn-primary:hover, .btn-primary:focus {
        background: linear-gradient(135deg, #ff8c1a 0%, #e35205 100%);
        color: white;
      }
      
      .btn-default {
        background: white;
        color: #4a5568;
        border: 2px solid #e2e8f0;
      }
      .btn-default:hover {
        background: #f7fafc;
        border-color: #e35205;
        color: #e35205;
      }
      
      /* Add Note button */
      #openNote {
        border-radius: 50%;
        padding: 12px 14px;
        font-size: 18px;
        box-shadow: 0 4px 20px rgba(85, 43, 154, 0.4);
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
      }
      #openNote:hover {
        box-shadow: 0 6px 25px rgba(85, 43, 154, 0.6);
        transform: translateY(-3px) scale(1.05);
      }
      
      /* ===== TABLES ===== */
      .dataTables_wrapper {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
      }
      .dataTable thead th {
        background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #404040 100%);
        color: white;
        font-weight: 600;
        padding: 14px 10px;
        border: none;
        text-transform: uppercase;
        font-size: 12px;
        letter-spacing: 0.5px;
      }
      .dataTable tbody tr {
        transition: all 0.2s ease;
      }
      .dataTable tbody tr:hover {
        background: rgba(102, 126, 234, 0.05);
        transform: scale(1.01);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      }
      .dataTable tbody td {
        padding: 12px 10px;
        border-bottom: 1px solid #f0f0f0;
      }
      
      /* ===== PANELS & CARDS ===== */
      .panel {
        border: none;
        border-radius: 12px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
        overflow: hidden;
      }
      .panel-default > .panel-heading {
        background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
        border: none;
        color: #2d3748;
        font-weight: 700;
        padding: 16px 20px;
        border-bottom: 2px solid #e2e8f0;
      }
      .panel-body {
        padding: 20px;
      }
      
      /* ===== PLOTS & CHARTS ===== */
      .shiny-plot-output, .plotly, .html-widget {
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
        background: transparent;
      }
      
      /* ===== PAGE CONTAINER ===== */
      .container-fluid {
        padding: 20px 30px;
      }
      
      /* ===== LOADING ANIMATION ===== */
      .shiny-output-error { color: #e53e3e; }
      .shiny-output-error:before { content: '⚠ '; }
      
      /* Custom scrollbar */
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      ::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #ff8c1a 0%, #e35205 100%);
      }

      /* ===== DARK MODE OVERRIDES ===== */
      body.theme-dark {
        background: radial-gradient(circle at 20% 20%, #0d1224 0%, #0a0f1d 45%, #060910 100%);
        color: #e5e7eb;
      }
      body.theme-dark .navbar-inverse {
        background: linear-gradient(135deg, #0b0f19 0%, #0f172a 100%);
        box-shadow: 0 6px 24px rgba(0,0,0,0.5);
      }
      body.theme-dark .navbar-inverse .navbar-brand .brand-title {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      body.theme-dark .navbar-inverse .navbar-nav > li > a {
        color: rgba(229, 231, 235, 0.9) !important;
      }
      body.theme-dark .navbar-inverse .navbar-nav > li > a:hover,
      body.theme-dark .navbar-inverse .navbar-nav > li > a:focus {
        color: #ffffff !important;
        background: rgba(255,255,255,0.08);
        box-shadow: 0 4px 12px rgba(0,0,0,0.35);
      }
      /* Dark mode: keep sidebars transparent (mobile + desktop) */
      body.theme-dark .sidebar,
      body.theme-dark .sidebar .well,
      body.theme-dark .col-sm-3 .well,
      body.theme-dark .col-sm-4 .well,
      body.theme-dark .sidebar .panel,
      body.theme-dark .sidebar-accordion,
      body.theme-dark .sidebar-accordion-body {
        background: transparent !important;
        box-shadow: none !important;
        border: none !important;
      }
      body.theme-dark .sidebar .well .form-control,
      body.theme-dark .sidebar .well .selectize-input {
        background: rgba(255,255,255,0.06) !important;
      }
      body.theme-dark .navbar-inverse .navbar-nav > .active > a,
      body.theme-dark .navbar-inverse .navbar-nav > .active > a:hover,
      body.theme-dark .navbar-inverse .navbar-nav > .active > a:focus {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
        box-shadow: 0 6px 18px rgba(102,126,234,0.45);
      }
      body.theme-dark .container-fluid {
        background: transparent !important;
      }
      body.theme-dark .well,
      body.theme-dark .panel {
        background: rgba(15,23,42,0.9) !important;
        border: 1px solid #1f2937 !important;
        box-shadow: 0 6px 24px rgba(0,0,0,0.45);
        color: #e5e7eb !important;
      }
      body.theme-dark .panel-default > .panel-heading {
        background: linear-gradient(135deg, #111827 0%, #0b1220 100%) !important;
        color: #e5e7eb !important;
        border: none !important;
      }
      body.theme-dark .form-control,
      body.theme-dark .selectize-input {
        background: #0f172a !important;
        color: #e5e7eb !important;
        border: 1px solid #1f2937 !important;
        box-shadow: none !important;
      }
      body.theme-dark .form-control:focus,
      body.theme-dark .selectize-input.focus {
        border-color: #ff8c1a !important;
        box-shadow: 0 0 0 3px rgba(118, 75, 162, 0.25) !important;
      }
      body.theme-dark .form-group label {
        color: #e5e7eb !important;
      }
      body.theme-dark .btn-default {
        background: #0f172a !important;
        color: #e5e7eb !important;
        border: 1px solid #1f2937 !important;
      }
      body.theme-dark .btn-primary {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%) !important;
        color: #fff !important;
        box-shadow: 0 4px 14px rgba(102,126,234,0.35);
      }
      body.theme-dark .dataTables_wrapper {
        background: rgba(15,23,42,0.9) !important;
        color: #e5e7eb !important;
      }
      body.theme-dark .dataTable tbody tr:hover {
        background: rgba(102,126,234,0.08) !important;
        box-shadow: 0 2px 10px rgba(0,0,0,0.35) !important;
      }
      body.theme-dark .shiny-plot-output,
      body.theme-dark .plotly,
      body.theme-dark .html-widget {
        background: transparent !important;
        box-shadow: 0 2px 16px rgba(0,0,0,0.35);
      }
      /* Wipe embedded white rects in svg/png */
      body.theme-dark svg rect[fill='#FFFFFF'],
      body.theme-dark svg rect[fill='#ffffff'],
      body.theme-dark svg rect[fill='#fff'] {
        fill: transparent !important;
        stroke: none !important;
      }
      body.theme-dark #summary_heatZonePlot,
      body.theme-dark #summary_heatZonePlot canvas,
      body.theme-dark #summary_heatZonePlot img,
      body.theme-dark #summary_legend,
      body.theme-dark #summary_legend canvas,
      body.theme-dark #summary_legend img {
        background: transparent !important;
      }
      body.theme-dark #heatmapsHeatPlot,
      body.theme-dark #heatmapsHeatPlot canvas,
      body.theme-dark #heatmapsHeatPlot img,
      body.theme-dark #cmpA_heat,
      body.theme-dark #cmpA_heat canvas,
      body.theme-dark #cmpA_heat img,
      body.theme-dark #cmpB_heat,
      body.theme-dark #cmpB_heat canvas,
      body.theme-dark #cmpB_heat img {
        background: transparent !important;
      }
      /* Toggle switch styling */
      .dark-toggle { display:flex; align-items:center; gap:10px; }
      .dark-toggle .switch-label { display:flex; align-items:center; gap:10px; margin:0; cursor:pointer; }
      .dark-toggle input#dark_mode { display:none; }
      .dark-toggle .switch-track {
        position: relative; width: 50px; height: 26px;
        background: #4b5563; border-radius: 13px; transition: background 0.2s ease;
        box-shadow: inset 0 0 4px rgba(0,0,0,0.35);
      }
      .dark-toggle .switch-thumb {
        position: absolute; top: 3px; left: 3px; width: 20px; height: 20px;
        background: #fff; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        transition: transform 0.2s ease;
      }
      .dark-toggle input#dark_mode:checked + .switch-track { background: #ff8c1a; }
      .dark-toggle input#dark_mode:checked + .switch-track .switch-thumb { transform: translateX(24px); }
      .dark-toggle .switch-text { font-weight:600; color:#e5e7eb; }
      
      /* Dropdowns (selectize + native) – scoped to dark mode; purple highlight for selected item */
      body.theme-dark .selectize-input,
      body.theme-dark .selectize-control.single .selectize-input,
      body.theme-dark select.form-control {
        background: #0f172a !important;
        color: #e5e7eb !important;
        border: 1px solid #1f2937 !important;
        box-shadow: none !important;
      }
      body.theme-dark .selectize-input input { color: #e5e7eb !important; }
      body.theme-dark .selectize-input > .item {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%) !important;
        color: #fff !important;
        border-radius: 6px;
        padding: 2px 6px;
      }
      body.theme-dark .selectize-dropdown {
        background: #0f172a !important;
        color: #e5e7eb !important;
        border-color: #1f2937 !important;
      }
      body.theme-dark .selectize-dropdown .option { color: #e5e7eb !important; }
      body.theme-dark .selectize-dropdown .option:hover,
      body.theme-dark .selectize-dropdown .option.active {
        background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%) !important;
        color: #fff !important;
      }
      
      /* Custom Reports cell container */
      .creport-cell {
        background: #ffffff;
        border: 2px solid #000;
        padding: 15px;
        margin-bottom: 15px;
        border-radius: 6px;
      }
      body.theme-dark .creport-cell {
        background: rgba(15,23,42,0.9) !important;
        border: 1px solid #1f2937 !important;
        box-shadow: 0 4px 18px rgba(0,0,0,0.35);
        color: #e5e7eb;
      }
      body.theme-dark .creport-cell h4,
      body.theme-dark .creport-cell h5,
      body.theme-dark .creport-cell label,
      body.theme-dark .creport-cell input,
      body.theme-dark .creport-cell select,
      body.theme-dark .creport-cell .form-control {
        color: #e5e7eb !important;
        background-color: #0f172a !important;
        border-color: #1f2937 !important;
      }
      
      /* Player Plans & Custom Reports root containers */
      .pp-root, .creports-root { background: transparent !important; }
      .pp-root .container-fluid,
      .creports-root .container-fluid {
        background: transparent !important;
      }
      /* Dark-mode forcing for Custom Reports layout */
      body.theme-dark .creports-root .panel,
      body.theme-dark .creports-root .well,
      body.theme-dark .creports-root .form-group,
      body.theme-dark .creports-root .tab-content,
      body.theme-dark .creports-root .tab-pane,
      body.theme-dark .creports-root .row,
      body.theme-dark .creports-root .col-sm-3,
      body.theme-dark .creports-root .col-sm-9 {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      body.theme-dark .creports-root .form-control {
        background: #0f172a !important;
        color: #e5e7eb !important;
        border: 1px solid #1f2937 !important;
      }
      body.theme-dark .creports-root .girafe_container svg,
      body.theme-dark .creports-root canvas {
        background: transparent !important;
      }
      body.theme-dark #creports-sidebar_column .well,
      body.theme-dark #creports-main_column .well {
        background: radial-gradient(circle at top left, #1f2937 0%, #0f172a 60%, #0b0f19 100%) !important;
        border-left: 4px solid #ff8c1a !important;
        color: #e5e7eb !important;
      }
      body.theme-dark #creports-main_column .panel,
      body.theme-dark #creports-sidebar_column .panel {
        background: #0f172a !important;
        color: #e5e7eb !important;
        box-shadow: 0 2px 12px rgba(0,0,0,0.35);
      }
      
      /* Player Plans container dark mode */
      body.theme-dark .pp-root {
        background: transparent !important;
      }
      body.theme-dark .pp-root .goal-container {
        background: rgba(15,23,42,0.85) !important;
        border: 1px solid #1f2937 !important;
        box-shadow: 0 4px 20px rgba(0,0,0,0.35);
        color: #e5e7eb;
      }
      body.theme-dark .pp-root .goal-description {
        background: rgba(17,24,39,0.9) !important;
        border-color: #1f2937 !important;
        color: #e5e7eb !important;
      }
      body.theme-dark .pp-root .panel,
      body.theme-dark .pp-root .well {
        background: rgba(15,23,42,0.9) !important;
        color: #e5e7eb !important;
        box-shadow: 0 2px 12px rgba(0,0,0,0.35);
      }
      body.theme-dark .pp-root .girafe_container svg,
      body.theme-dark .pp-root canvas {
        background: transparent !important;
      }
      /* Make black strokes/lines white in dark mode (axes/strike zones) */
      body.theme-dark svg rect[stroke='black'],
      body.theme-dark svg line[stroke='black'],
      body.theme-dark svg path[stroke='black'] {
        stroke: #ffffff !important;
      }
      /* Also flip pure-black fills to white in dark mode (fastball dots/legend) */
      body.theme-dark svg [fill='black'],
      body.theme-dark svg [fill='#000'],
      body.theme-dark svg [fill='#000000'] {
        fill: #ffffff !important;
      }
      /* Subtle gridlines in dark mode */
      body.theme-dark .panel.grid.major,
      body.theme-dark line.panel.grid.major,
      body.theme-dark polyline.panel.grid.major,
      body.theme-dark path.panel.grid.major {
        stroke: rgba(255,255,255,0.18) !important;
      }
      body.theme-dark .panel.grid.minor,
      body.theme-dark line.panel.grid.minor,
      body.theme-dark polyline.panel.grid.minor,
      body.theme-dark path.panel.grid.minor {
        stroke: rgba(255,255,255,0.08) !important;
      }
      /* Catch default ggplot grid strokes */
      body.theme-dark svg line[stroke='#ebebeb'],
      body.theme-dark svg line[stroke='#E5E5E5'],
      body.theme-dark svg line[stroke='#d9d9d9'],
      body.theme-dark svg path[stroke='#ebebeb'],
      body.theme-dark svg path[stroke='#E5E5E5'],
      body.theme-dark svg path[stroke='#d9d9d9'] {
        stroke: rgba(255,255,255,0.18) !important;
      }
      /* Axis text/ticks in dark mode */
      body.theme-dark .axis text,
      body.theme-dark g.tick text,
      body.theme-dark text {
        fill: #e5e7eb !important;
      }
      body.theme-dark .axis line,
      body.theme-dark g.tick line {
        stroke: rgba(255,255,255,0.4) !important;
      }
      /* Legend readability in dark mode */
      body.theme-dark g.legend text,
      body.theme-dark [aria-label='legend'] text,
      body.theme-dark g[class*='legend'] text {
        fill: #ffffff !important;
      }
      body.theme-dark g.legend rect,
      body.theme-dark [aria-label='legend'] rect {
        fill: transparent !important;
        stroke: transparent !important;
      }
      /* Inline toggle styling */
      .inline-toggle {
        background: rgba(0,0,0,0.35);
        border-radius: 12px;
        padding: 8px 12px;
        width: fit-content;
      }
      /* Modal text readable on light modal backgrounds */
      body.theme-dark .modal-content,
      body.theme-dark .modal-body,
      body.theme-dark .modal-title {
        color: #000000 !important;
      }
    ", accent_color, accent_secondary_color, background_color, background_secondary_color)))
  ),
  
  # --- Global click handler for Notes → jump back to saved view ---
  tags$script(HTML("
    document.addEventListener('click', function(e){
      var a = e.target.closest('a.note-jump'); if(!a) return;
      e.preventDefault();
      Shiny.setInputValue('noteJump', {
        suite: a.dataset.suite || '', page: a.dataset.page || '',
        pitcher: a.dataset.pitcher || '', sess: a.dataset.sess || '',
        ds: a.dataset.ds || '', de: a.dataset.de || '', nonce: Math.random()
      }, {priority:'event'});
    }, true);
  ")),
  
  tags$script(HTML("
  // Avoid double-binding by namespacing and unbinding first
  $(document).off('click.pcuOpenMedia', 'a.open-media')
    .on('click.pcuOpenMedia', 'a.open-media', function(e){
      e.preventDefault();
      var url = $(this).data('url') || $(this).attr('href') || '';
      var typ = (($(this).data('type') || 'auto') + '').toLowerCase();
      if(!url) return;
      Shiny.setInputValue('open_media', {url: url, type: typ, nonce: Math.random()}, {priority:'event'});
    });
  ")),
  
  shinyjs::useShinyjs(),
  
  tags$style(HTML(colorize_css("
    /* Custom note button - already styled in main CSS */
    #openNote.btn-note {
      background: linear-gradient(135deg, #e35205 0%, #ff8c1a 100%);
      border: none;
      color: #fff;
    }
    #openNote.btn-note:hover,
    #openNote.btn-note:focus,
    #openNote.btn-note:active,
    #openNote.btn-note:active:focus {
      background: linear-gradient(135deg, #ff8c1a 0%, #e35205 100%);
      border: none;
      color: #fff;
      outline: none;
    }
    /* Make the # column look like a link */
    td.clickable-cell, td.clickable-cell a, .pitch-count-link {
      color: #0d6efd !important;
      text-decoration: underline;
      cursor: pointer;
    }
    td.clickable-cell:hover, td.clickable-cell a:hover, .pitch-count-link:hover {
      color: #0a58ca !important;
    }
  ", accent_color, accent_secondary_color, background_color, background_secondary_color))),
  # --- Floating "Add Note" button (top-right, all pages) ---
  absolutePanel(
    style = "background:transparent; border:none; box-shadow:none; z-index:2000;",
    actionButton("openNote", label = NULL, icon = icon("sticky-note"),
                 class = "btn btn-note", title = "Add Note"),
    top = 60, right = 12, width = 50, fixed = TRUE, draggable = FALSE
  ),
  navbarPage(
    title = tagList(
      tags$img(src = school_logo, class = "brand-logo", alt = school_display_name),
      tags$span("Dashboard", class = "brand-title"),
      tags$img(src = "PCUlogo.png", class = "pcu-right", alt = "PCU")
    ),
    id = "top",
    inverse = TRUE,
    tabPanel("Pitching",   value = "Pitching",   pitch_ui()),
    tabPanel("Hitting",    value = "Hitting",    mod_hit_ui("hit")),
    tabPanel("Catching",   value = "Catching",   mod_catch_ui("catch")),
    tabPanel("Leaderboard", value = "Leaderboard", mod_leader_ui("leader")),
    tabPanel("Comparison Tool", value = "Comparison Suite", mod_comp_ui("comp")),
    tabPanel("Correlations", value = "Correlations", correlations_ui()),
    tabPanel("Custom Reports", value = "Custom Reports", custom_reports_ui("creports")),
    tabPanel("Player Plans", value = "Player Plans", player_plans_ui()),
    tabPanel("Notes", value = "Notes",
             fluidPage(
               br(),
               DT::dataTableOutput("notesTable")
             )
    )
  )
)

# Custom authentication disabled - using shinyapps.io native authentication


# Server logic
server <- function(input, output, session) {
  
  # Get user email from shinyapps.io authentication
  # In shinyapps.io, session$user contains the authenticated user's email
  user_email <- reactive({
    # Try to get email from session
    email <- session$user
    
    # If no session user (running locally), return NA
    if (is.null(email) || !nzchar(email)) {
      return(NA_character_)
    }
    
    as.character(email)
  })
  
  # Check if current user is admin (only jgaynor@pitchingcoachu.com)
  is_admin <- reactive({
    u <- user_email()
    !is.na(u) && u %in% admin_emails
  })
  
  # Check if current user is a coach (can see all data)
  is_coach <- reactive({
    u <- user_email()
    !is.na(u) && tolower(trimws(u)) %in% tolower(trimws(coach_emails))
  })
  
  # Helper to normalize email for comparison
  norm_email <- function(x) tolower(trimws(as.character(x)))
  
  # Initialize database on startup
  init_modifications_db()
  # keep custom table choices in sync
  observe({
    custom_tables()
    update_custom_table_choices(session)
  })
  
  # Theme toggle (light/dark)
  observeEvent(input$dark_mode, {
    if (isTRUE(input$dark_mode)) {
      shinyjs::addClass(selector = "body", class = "theme-dark")
    } else {
      shinyjs::removeClass(selector = "body", class = "theme-dark")
    }
  }, ignoreInit = TRUE)
  
  # Helper to resolve table mode (supports saved custom tables)
  resolve_table_mode <- function(mode_in, custom_cols_in) {
    ct <- custom_tables()
    if (!is.null(mode_in) && mode_in %in% names(ct)) {
      cols <- ct[[mode_in]]$cols %||% character(0)
      return(list(mode = "Custom", cols = cols))
    }
    list(mode = mode_in %||% "Stuff", cols = custom_cols_in %||% character(0))
  }
  
  # Shared table builder function for Summary/DP/Comparison/Custom Reports
  # This ensures consistent table formatting across all suites
  .dp_like_table <<- function(df, mode, custom_cols, enable_colors = TRUE) {
    # Note: The full implementation is in mod_comp_server
    # This is a placeholder that will be overwritten when comparison suite loads
    # But ensures the function exists globally
    if (!nrow(df)) {
      return(DT::datatable(
        data.frame(Message = "No data for selected filters"),
        options = list(dom = 't'), rownames = FALSE
      ))
    }
    # If this gets called before comparison suite initializes, show message
    DT::datatable(
      data.frame(Message = "Loading table builder..."),
      options = list(dom = 't'), rownames = FALSE
    )
  }

  # ---- Video helpers (PCU-style modal with metrics/compare/multi-angle) ----
  guess_video_type <- function(name_or_url) {
    nm <- tolower(as.character(name_or_url %||% ""))
    if (grepl("\\.mp4(\\?.*)?$", nm)) "video/mp4"
    else if (grepl("\\.mov(\\?.*)?$", nm)) "video/quicktime"
    else "video"
  }

  # Map a clip name to a served URL, respecting subfolders by source (Edger/Behind/Side)
  # Robust to extension case (.MOV/.MP4) and container swaps.
  video_url_for <- function(clip, source = NULL) {
    # Normalize input
    if (is.null(clip) || length(clip) == 0) return("")
    clip_chr <- trimws(as.character(clip)[1])
    if (!nzchar(clip_chr)) return("")
    
    # If a full URL was stored, use it as-is (Cloudinary, S3, etc.)
    if (grepl("^https?://", clip_chr)) return(clip_chr)
    
    # Base directory configured by addResourcePath(...) at startup
    vdir <- getOption("PCU_VIDEOS_DIR", NA_character_)
    if (is.na(vdir) || !nzchar(vdir)) return("")
    
    # Build candidate filenames with case and container variants
    make_candidates <- function(fname) {
      # Split name and extension (case-insensitive)
      ext0  <- tools::file_ext(fname)              # may be "" or "MOV" etc.
      base0 <- if (nzchar(ext0)) sub(sprintf("\\.%s$", ext0), "", fname, ignore.case = TRUE) else fname
      
      # Try both containers if none or if it's mov/mp4
      if (!nzchar(ext0) || grepl("^(?i)(mov|mp4)$", ext0)) {
        exts <- c("mov", "mp4")                    # try MOV & MP4
      } else {
        exts <- ext0                               # unknown ext -> just use given
      }
      
      # Case variants for base and ext
      bases <- unique(c(base0, tolower(base0), toupper(base0)))
      extsL <- unique(c(exts, tolower(exts), toupper(exts)))
      
      # If original had an extension, include the original string as-is first
      cand <- character(0)
      if (nzchar(ext0)) cand <- c(cand, fname)
      
      # Then all base×ext combinations (both lower/upper ext)
      for (b in bases) for (e in extsL) cand <- c(cand, paste0(b, ".", e))
      
      # If there was no extension at all, also include bare bases (some users store raw names)
      if (!nzchar(ext0)) cand <- c(cand, bases)
      
      unique(cand)
    }
    
    # Helper: construct served URL under /videos/... and ensure the file exists on disk
    make_url_if_exists <- function(path_parts, fname) {
      abs_path <- do.call(file.path, c(list(vdir), as.list(path_parts), list(fname)))
      if (file.exists(abs_path)) {
        prefix <- paste(c("videos", path_parts), collapse = "/")
        return(paste0(prefix, "/", utils::URLencode(fname)))
      }
      ""
    }
    
    # Optional source → subfolder mapping
    src_map <- c(Edger = "Edger", Behind = "Behind", Side = "Side")
    
    # 1) If a source was given (Edger/Behind/Side), try videos/<Source>/<file>
    if (!is.null(source) && nzchar(source)) {
      subdir <- src_map[[as.character(source)]]
      if (!is.null(subdir)) {
        for (nm in make_candidates(clip_chr)) {
          url <- make_url_if_exists(subdir, nm)
          if (nzchar(url)) return(url)
        }
      }
    }
    
    # 2) Backward compatibility: try root videos/<file> (no subfolder)
    for (nm in make_candidates(clip_chr)) {
      url <- make_url_if_exists(character(0), nm)
      if (nzchar(url)) return(url)
    }
    
    ""
  }

  fmt_num <- function(digits = 1, unit = "") {
    function(x) {
      x_num <- suppressWarnings(as.numeric(x))
      if (length(x_num) == 0 || all(is.na(x_num))) return("\u2014")
      v <- x_num[1]; if (is.na(v)) return("\u2014")
      out <- format(round(v, digits), nsmall = digits, trim = TRUE)
      if (nzchar(unit)) paste0(out, unit) else out
    }
  }
  
  fmt_pct <- function(digits = 1) {
    function(x) {
      x_num <- suppressWarnings(as.numeric(x))
      if (length(x_num) == 0 || all(is.na(x_num))) return("\u2014")
      v <- x_num[1]; if (is.na(v)) return("\u2014")
      if (v <= 1) v <- v * 100
      paste0(format(round(v, digits), nsmall = digits), "%")
    }
  }
  
  metric_val <- function(row, col, fmt = NULL) {
    v <- tryCatch(row[[col]], error = function(e) NULL)
    if (is.null(v) || length(v) == 0) return(tags$span(style="opacity:.6;", "\u2014"))
    v1 <- v[1]
    
    if (is.null(fmt)) {
      txt <- as.character(v1)
      if (!nzchar(txt)) tags$span(style="opacity:.6;", "\u2014") else txt
    } else {
      out <- tryCatch(fmt(v1), error = function(e) "\u2014")
      if (!nzchar(as.character(out))) tags$span(style="opacity:.6;", "\u2014") else out
    }
  }
  
  # 180° = 12:00, 270° = 3:00, 0° = 6:00, 90° = 9:00
  # If already "H:MM", pass through unchanged.
  deg_to_clock <- function(x) {
    if (is.character(x) && length(x) && grepl("^\\s*\\d{1,2}:\\d{2}\\s*$", x[1])) {
      return(trimws(x[1]))
    }
    d <- suppressWarnings(as.numeric(x))
    if (length(d) == 0 || is.na(d)) return("\u2014")
    a <- (d + 180) %% 360
    hour   <- floor(a / 30)
    minute <- round((a %% 30) / 30 * 60)
    if (minute == 60) { minute <- 0; hour <- hour + 1 }
    hour <- hour %% 12; if (hour == 0) hour <- 12
    sprintf("%d:%02d", hour, minute)
  }

  # --- helpers ---
  format_name_first_last <- function(x) {
    s <- as.character(x %||% "")
    if (!nzchar(s)) return("\u2014")
    # If "Last, First", flip it
    if (grepl(",", s, fixed = TRUE)) {
      parts <- trimws(strsplit(s, ",", fixed = TRUE)[[1]])
      if (length(parts) >= 2) return(paste(parts[2], parts[1]))
    }
    s
  }

  # Helpers (keep these near your other helpers)
  get_first_col <- function(row, candidates) {
    for (nm in candidates) if (!is.null(row[[nm]])) return(row[[nm]])
    NULL
  }

  metric_row <- function(label, value_html) {
    # Bold ONLY the label, value regular. Center the whole line.
    tags$div(
      style = "margin:6px 0; text-align:center;",
      tags$span(style="font-weight:800;", paste0(label, ": ")),
      tags$span(style="font-weight:600;", value_html)
    )
  }

  metric_value_only <- function(value_html) {
    # No label; show value bold & centered (for Velocity/Spin)
    tags$div(style = "margin:6px 0; text-align:center; font-weight:800;", value_html)
  }

  # --- panel ---
  build_metrics_panel <- function(row) {
    # Name (First Last) and Date
    name_text <- format_name_first_last(
      row[["Pitcher"]] %||% row[["pitcher_name"]] %||% row[["PlayerName"]] %||% "\u2014"
    )
    raw_date <- row[["GameDate"]] %||% row[["Date"]] %||% row[["datetime"]] %||% NA
    date_text <- (function(x) {
      d <- suppressWarnings(as.Date(x))
      if (!is.na(d)) return(format(d, "%-m/%-d/%y"))
      px <- suppressWarnings(as.POSIXct(x, tz = "UTC"))
      if (!is.na(px)) return(format(as.Date(px), "%-m/%-d/%y"))
      "\u2014"
    })(raw_date)
    
    # Metrics (ordered as requested)
    pitch_type <- as.character(row[["TaggedPitchType"]] %||% "\u2014")
    
    velo_val <- metric_val(row, "RelSpeed", fmt_num(1, " mph"))              # value only
    ivb_val  <- metric_val(row, "InducedVertBreak", fmt_num(1, "\""))
    hb_val   <- metric_val(row, "HorzBreak",        fmt_num(1, "\""))
    spin_val <- metric_val(row, "SpinRate",         fmt_num(0, " rpm"))       # value only
    
    se_col   <- get_first_col(row, c("SpinEfficiency", "SpinEff", "SpinEffPct"))
    spin_eff <- {
      if (is.null(se_col)) tags$span("\u2014") else {
        val <- tryCatch(se_col, error = function(e) NA)
        if (is.null(val)) tags$span("\u2014") else tags$span(fmt_pct(1)(val))
      }
    }
    
    tilt_src <- get_first_col(row, c("BreakTilt", "bTilt", "ReleaseTilt", "rTilt"))
    btilt    <- tags$span(deg_to_clock(tilt_src))
    
    # Use RelHeight / RelSide (1 decimal)
    height_v <- metric_val(row, "RelHeight", fmt_num(1, ""))
    side_v   <- metric_val(row, "RelSide",   fmt_num(1, ""))
    
    tags$div(
      # Header: name & date centered and bold
      tags$div(style = "font-weight:900; font-size:1.15rem; text-align:center;", name_text),
      tags$div(style = "font-weight:800; opacity:.9; text-align:center; margin-bottom:6px;", date_text),
      tags$hr(),
      # Metrics (stacked)
      tags$div(
        style = "text-align:center;",
        # Pitch Type (value only)
        tags$div(style = "font-weight:900; margin:8px 0;", pitch_type),
        # Velocity (value only)
        metric_value_only(velo_val),
        # IVB / HB with bold titles
        metric_row("IVB",  ivb_val),
        metric_row("HB",   hb_val),
        # Spin (value only)
        metric_value_only(spin_val),
        # SpinEff / bTilt / Height / Side with bold titles
        metric_row("SpinEff", spin_eff),
        metric_row("bTilt",   btilt),
        metric_row("Height",  height_v),
        metric_row("Side",    side_v)
      )
    )
  }

  show_pitch_video_modal_multi <- function(row, right_ui = NULL, dataset = NULL, dataset_idx = NA_integer_) {
    data_full <- dataset
    if (is.null(data_full)) {
      data_full <- tryCatch(as.data.frame(row, stringsAsFactors = FALSE), error = function(e) NULL)
      if (is.null(data_full) || !nrow(data_full)) {
        data_full <- data.frame()
      }
      dataset_idx <- 1L
    }
    data_full <- as.data.frame(data_full, stringsAsFactors = FALSE)
    start_idx <- suppressWarnings(as.integer(dataset_idx))
    if (!is.finite(start_idx) || start_idx < 1L) {
      rn <- rownames(row)
      if (length(rn)) {
        start_idx <- suppressWarnings(as.integer(rn[1]))
      }
      if (!is.finite(start_idx) || start_idx < 1L) start_idx <- 1L
    }
    lbl <- tryCatch(as.character(row$TaggedPitchType)[1], error = function(e) NULL)
    show_pitch_video_sequence(
      rows = data_full,
      label = lbl,
      start_index = start_idx,
      compare_pool = data_full,
      primary_pool_idx = start_idx
    )
  }

  # Bigger video (4fr) | narrower metrics (1fr) | centered logo low in metrics column
  show_pitch_video_modal <- function(video_url, mime_type = "video", right_ui = NULL) {
    has_video <- nzchar(video_url)
    
    # Video (or placeholder)
    video_core <- if (has_video) {
      tags$video(
        src = video_url, controls = NA, autoplay = NA, type = mime_type,
        style = "width:100%; max-height:78vh; background:#000;"
      )
    } else {
      tags$div(
        "No video available",
        style = paste(
          "display:flex; align-items:center; justify-content:center;",
          "width:100%; max-height:78vh; height:60vh;",
          "background:#0b0b0b; color:#fff; font-weight:700; border-radius:8px;"
        )
      )
    }
    
    # Right pane: metrics (scrollable) + logo centered at bottom
    right_pane <- if (is.null(right_ui)) NULL else {
      tags$div(
        style = paste(
          "display:flex; flex-direction:column;",
          "max-height:78vh; min-height:48vh;",
          "text-align:center; padding:0;"         # no extra bottom padding
        ),
        # Metrics content fills available space; no bottom padding so logo sits lower
        tags$div(style = "overflow:auto; flex:1 1 auto; padding:0 0 4px 0;", right_ui),
        # Logo: centered and nudged closer to the bottom
        tags$img(
          src = "PCUlogo.png", alt = "PCU",
          style = paste(
            "align-self:center;",                  # center horizontally
            "margin-top:auto; margin-bottom:2px;", # push to bottom and tuck close
            "width:72px; height:auto; opacity:0.95;",
            "filter: drop-shadow(0 1px 2px rgba(0,0,0,.6));",
            "pointer-events:none; user-select:none;"
          )
        )
      )
    }
    
    body <- if (is.null(right_pane)) {
      video_core
    } else {
      tags$div(
        style = paste(
          "display:grid;",
          "grid-template-columns: 4fr 1fr;",    # wider video, narrower metrics
          "gap:24px; align-items:start;"
        ),
        video_core,
        right_pane
      )
    }

    modal_css <- tags$style(HTML(
      ".modal-dialog.pseq-wide{width:96%;max-width:1400px;}"
    ))
    showModal(tagList(modal_css, modalDialog(body, easyClose = TRUE, footer = NULL, size = "l", class = "pseq-wide")))
  }

  # Normalize ggiraph selection to a single integer (use the MOST RECENT click)
  safe_selected <- function(x) {
    if (is.null(x) || length(x) == 0) return(NA_integer_)
    # ggiraph may send a vector (c("23","17")) or a comma string "23,17"
    x_last <- x[[length(x)]]                 # take last element if vector
    s <- as.character(x_last %||% "")
    parts <- strsplit(s, ",", fixed = TRUE)[[1]]
    s_last <- trimws(parts[length(parts)])   # take last token if comma-separated
    suppressWarnings(as.integer(s_last))
  }

  pitch_rows_for_label <- function(df, label, split_choice = NULL) {
    if (is.null(df) || !nrow(df)) return(df[0, , drop = FALSE])
    lbl <- label %||% ""
    lbl <- trimws(as.character(lbl))
    if (!nzchar(lbl) || tolower(lbl) %in% c("all", "all pitches", "total", "totals")) return(df)
    
    if (!is.null(split_choice)) {
      df_split <- tryCatch(apply_split_by(df, split_choice), error = function(e) df)
      if (!is.null(df_split$SplitColumn)) {
        matches <- df_split[df_split$SplitColumn == lbl, , drop = FALSE]
        if (!nrow(matches)) {
          matches <- df_split[tolower(df_split$SplitColumn) == tolower(lbl), , drop = FALSE]
        }
        if (nrow(matches)) return(matches)
      }
    }
    
    tp <- tryCatch(trimws(as.character(df$TaggedPitchType)), error = function(e) character(nrow(df)))
    matches <- df[tp == lbl, , drop = FALSE]
    if (!nrow(matches)) {
      lbl_clean <- trimws(sub("\\s*\\(.*\\)$", "", lbl))
      matches <- df[tp == lbl_clean, , drop = FALSE]
    }
    if (!nrow(matches)) {
      matches <- df[tolower(tp) == tolower(lbl), , drop = FALSE]
    }
    matches
  }

  pitch_abbrev_for <- function(pt) {
    pt_chr <- trimws(as.character(pt %||% ""))
    if (!nzchar(pt_chr)) return("")
    mapping <- c(
      "Fastball" = "FB", "Four-Seam Fastball" = "FB", "4-Seam Fastball" = "FB",
      "Sinker" = "SK", "Two-Seam Fastball" = "SK", "2-Seam Fastball" = "SK",
      "Cutter" = "CT", "Cut Fastball" = "CT",
      "Curveball" = "CB", "Curve" = "CB", "Knuckle Curve" = "CB",
      "Slider" = "SL",
      "Sweeper" = "SW",
      "ChangeUp" = "CH", "Change Up" = "CH", "Changeup" = "CH",
      "Splitter" = "SP", "Split Finger" = "SP", "Split-Finger" = "SP",
      "Knuckleball" = "KN", "Knuckle Ball" = "KN",
      "Gyro" = "SL", "Slurve" = "SL"
    )
    out <- mapping[pt_chr]
    if (!is.na(out)) return(out)
    parts <- strsplit(pt_chr, "[^A-Za-z]+")[[1]]
    parts <- parts[nzchar(parts)]
    if (!length(parts)) return(toupper(substr(pt_chr, 1, 2)))
    abbr <- paste0(substring(parts, 1, 1), collapse = "")
    toupper(substr(abbr, 1, 3))
  }

  format_initial_last <- function(name_chr) {
    nm <- trimws(as.character(name_chr %||% ""))
    if (!nzchar(nm)) return("")
    nm_fmt <- format_name_first_last(nm)
    parts <- strsplit(trimws(nm_fmt), "\\s+")[[1]]
    parts <- parts[nzchar(parts)]
    if (!length(parts)) return(nm_fmt)
    if (length(parts) == 1) return(parts)
    paste0(substr(parts[1], 1, 1), ". ", paste(parts[-1], collapse = " "))
  }

  make_pitch_option_label <- function(row, idx = NA_integer_) {
    if (is.null(row) || !nrow(row)) return("Pitch")
    date_val <- tryCatch(as.Date(row$Date[1]), error = function(e) NA)
    date_txt <- if (inherits(date_val, "Date") && !is.na(date_val)) format(date_val, "%m/%d/%y") else ""
    name_raw <- row$Pitcher[1] %||% row$PitcherName[1] %||% row$PlayerName[1]
    name_txt <- format_initial_last(name_raw)
    pt_txt <- pitch_abbrev_for(row$TaggedPitchType[1])
    velo_val <- suppressWarnings(as.numeric(row$RelSpeed[1]))
    ivb_val  <- suppressWarnings(as.numeric(row$InducedVertBreak[1]))
    hb_val   <- suppressWarnings(as.numeric(row$HorzBreak[1]))
    velo_txt <- if (is.finite(velo_val)) sprintf("%.1f mph", velo_val) else ""
    ivb_txt  <- if (is.finite(ivb_val)) sprintf("%.1f\"", ivb_val) else ""
    hb_txt   <- if (is.finite(hb_val)) sprintf("%.1f\"", hb_val) else ""
    idx_txt  <- if (is.finite(idx)) paste0("#", idx) else ""
    parts <- c(date_txt, name_txt, pt_txt, velo_txt, ivb_txt, hb_txt, idx_txt)
    paste(parts[nzchar(parts)], collapse = " | ")
  }

  show_pitch_video_sequence <- function(rows, label = NULL, start_index = 1,
                                        compare_pool = NULL, primary_pool_idx = NA_integer_) {
    rows_df <- tryCatch(as.data.frame(rows), error = function(e) NULL)
    if (is.null(rows_df) || !nrow(rows_df)) {
      showModal(modalDialog("No video available for this selection.", easyClose = TRUE, footer = NULL))
      return(invisible(FALSE))
    }

    rows_df <- as.data.frame(rows_df, stringsAsFactors = FALSE)
    if (is.null(rownames(rows_df))) rownames(rows_df) <- as.character(seq_len(nrow(rows_df)))
    n_total <- nrow(rows_df)
    clip1 <- tryCatch(as.character(rows_df$VideoClip),  error = function(e) rep("", n_total))
    clip2 <- tryCatch(as.character(rows_df$VideoClip2), error = function(e) rep("", n_total))
    clip3 <- tryCatch(as.character(rows_df$VideoClip3), error = function(e) rep("", n_total))
    has_video <- nzchar(clip1) | nzchar(clip2) | nzchar(clip3)
    rows_vid <- rows_df[has_video, , drop = FALSE]
    video_positions <- which(has_video)
    if (!nrow(rows_vid)) {
      showModal(modalDialog("No videos available for this selection.", easyClose = TRUE, footer = NULL))
      return(invisible(FALSE))
    }
    pool_df <- if (!is.null(compare_pool)) {
      tryCatch(as.data.frame(compare_pool, stringsAsFactors = FALSE), error = function(e) NULL)
    } else rows_df
    if (is.null(pool_df)) pool_df <- rows_df[0, , drop = FALSE]
    if (is.null(rownames(pool_df))) rownames(pool_df) <- as.character(seq_len(nrow(pool_df)))

    pool_clip1 <- tryCatch(as.character(pool_df$VideoClip),  error = function(e) rep("", nrow(pool_df)))
    pool_clip2 <- tryCatch(as.character(pool_df$VideoClip2), error = function(e) rep("", nrow(pool_df)))
    pool_clip3 <- tryCatch(as.character(pool_df$VideoClip3), error = function(e) rep("", nrow(pool_df)))
    pool_has_video <- nzchar(pool_clip1) | nzchar(pool_clip2) | nzchar(pool_clip3)
    pool_video_idx <- which(pool_has_video)
    compare_available <- length(pool_video_idx) > 1

    match_start <- match(suppressWarnings(as.integer(start_index)), video_positions)
    if (is.na(match_start) || match_start < 1L) match_start <- 1L
    if (match_start > nrow(rows_vid)) match_start <- nrow(rows_vid)

    camera_display_labels <- c("Camera 1", "Camera 2", "Camera 3")
    camera_source_map <- setNames(c("Edger", "Behind", "Side"), camera_display_labels)
    make_pitch_label <- function(dat, idx = NA_integer_) make_pitch_option_label(dat, idx)

    collect_urls <- function(row) {
      if (is.null(row) || !nrow(row)) return(list())
      clips <- c(
        "Camera 1" = tryCatch(as.character(row$VideoClip)[1],  error = function(e) ""),
        "Camera 2" = tryCatch(as.character(row$VideoClip2)[1], error = function(e) ""),
        "Camera 3" = tryCatch(as.character(row$VideoClip3)[1], error = function(e) "")
      )
      clips <- clips[nzchar(clips)]
      if (!length(clips)) return(list())
      urls <- lapply(names(clips), function(display) {
        clip <- clips[[display]]
        source_tag <- camera_source_map[[display]] %||% display
        video_url_for(clip, source = source_tag)
      })
      names(urls) <- names(clips)
      urls[vapply(urls, nzchar, logical(1))]
    }

    metrics_block <- function(content) {
      if (is.null(content)) return(NULL)
      tags$div(
        style = paste(
          "display:flex;flex-direction:column;",
          "max-height:68vh;min-height:40vh;",
          "text-align:center;padding:0;"
        ),
        tags$div(style = "overflow:auto;flex:1 1 auto;padding:0 0 4px 0;", content),
        tags$img(
          src = "PCUlogo.png", alt = "PCU",
          style = paste(
            "align-self:center;margin-top:auto;margin-bottom:2px;",
            "width:72px;height:auto;opacity:0.95;",
            "filter:drop-shadow(0 1px 2px rgba(0,0,0,.6));",
            "pointer-events:none;user-select:none;"
          )
        )
      )
    }

    default_secondary_for <- function(primary_idx) {
      if (!length(pool_video_idx)) return(NA_integer_)
      candidates <- pool_video_idx
      if (is.finite(primary_idx)) candidates <- candidates[candidates != primary_idx]
      if (!length(candidates)) candidates <- pool_video_idx
      candidates[1]
    }

    idx <- reactiveVal(match_start)
    cam_sel <- reactiveVal("")
    compare_mode <- reactiveVal(FALSE)
    secondary_idx <- reactiveVal(NA_integer_)
    cmp_cam_sel <- reactiveVal("")

    uid_base  <- paste0("pseq_", as.integer((as.numeric(Sys.time()) * 1000) %% 1e9))
    video_id  <- paste0(uid_base, "_video")
    next_id   <- paste0(uid_base, "_next")
    prev_id   <- paste0(uid_base, "_prev")
    cam_prefix <- paste0(uid_base, "_cam")
    primary_video_id   <- paste0(uid_base, "_video_primary")
    secondary_video_id <- paste0(uid_base, "_video_secondary")
    compare_toggle_id  <- paste0(uid_base, "_compare")
    primary_select_id  <- paste0(uid_base, "_primary_select")
    compare_select_id  <- paste0(uid_base, "_compare_select")
    cmp_cam_prefix     <- paste0(uid_base, "_cmpcam")
    primary_slider_id  <- paste0(uid_base, "_slider_primary")
    secondary_slider_id <- paste0(uid_base, "_slider_secondary")
    sync_slider_id     <- paste0(uid_base, "_slider_sync")
    primary_play_id    <- paste0(uid_base, "_play_primary")
    primary_pause_id   <- paste0(uid_base, "_pause_primary")
    secondary_play_id  <- paste0(uid_base, "_play_secondary")
    secondary_pause_id <- paste0(uid_base, "_pause_secondary")
    sync_play_id       <- paste0(uid_base, "_play_sync")
    sync_pause_id      <- paste0(uid_base, "_pause_sync")
    download_single_id <- paste0(uid_base, "_download_single")
    download_all_id    <- paste0(uid_base, "_download_all")

    current_row <- reactive({
      i <- idx()
      if (!is.finite(i)) i <- 1L
      i <- max(1L, min(nrow(rows_vid), i))
      rows_vid[i, , drop = FALSE]
    })

    current_urls <- reactive(collect_urls(current_row()))

    primary_pool_idx_reactive <- reactive({
      if (!nrow(pool_df)) return(NA_integer_)
      row <- current_row()
      if (is.null(row) || !nrow(row)) return(NA_integer_)
      rn <- rownames(row)
      if (length(rn)) {
        match_idx <- match(rn[1], rownames(pool_df))
        if (is.finite(match_idx)) return(match_idx)
      }
      if (is.finite(primary_pool_idx) && primary_pool_idx >= 1L && primary_pool_idx <= nrow(pool_df)) {
        return(primary_pool_idx)
      }
      if (length(pool_video_idx)) pool_video_idx[1] else 1L
    })

    cmp_current_row <- reactive({
      idx_val <- secondary_idx()
      if (!is.finite(idx_val) || !nrow(pool_df)) return(NULL)
      if (idx_val < 1L || idx_val > nrow(pool_df)) return(NULL)
      if (!pool_has_video[idx_val]) return(NULL)
      pool_df[idx_val, , drop = FALSE]
    })

    cmp_urls <- reactive(collect_urls(cmp_current_row()))

    cam_names <- camera_display_labels

    slugify <- function(text, fallback = "pitch") {
      txt <- trimws(as.character(text %||% ""))
      if (!nzchar(txt)) txt <- fallback
      slug <- gsub("[^A-Za-z0-9]+", "-", txt)
      slug <- gsub("-+", "-", slug)
      slug <- gsub("(^-)|(-$)", "", slug)
      slug <- tolower(slug)
      if (!nzchar(slug)) tolower(fallback) else slug
    }

    file_ext_from_url <- function(url, default = ".mp4") {
      if (!nzchar(url)) return(default)
      clean <- sub("\\?.*$", "", url)
      ext <- tools::file_ext(clean)
      if (!nzchar(ext)) default else paste0(".", tolower(ext))
    }

    download_source_to <- function(url, dest) {
      if (!nzchar(url)) stop("No source URL available", call. = FALSE)
      dir.create(dirname(dest), recursive = TRUE, showWarnings = FALSE)
      if (grepl("^https?://", url, ignore.case = TRUE)) {
        req <- httr2::request(url)
        tryCatch({
          httr2::req_perform(req, path = dest)
          TRUE
        }, error = function(e) stop(sprintf("Failed to download %s", basename(url)), call. = FALSE))
      } else {
        rel <- sub("^/+", "", url)
        rel <- utils::URLdecode(rel)
        vdir <- getOption("PCU_VIDEOS_DIR", NA_character_)
        if (is.na(vdir) || !nzchar(vdir)) {
          stop("Local video directory is not configured", call. = FALSE)
        }
        parts <- strsplit(rel, "/", fixed = TRUE)[[1]]
        if (length(parts) && identical(parts[1], "videos")) parts <- parts[-1]
        abs_path <- do.call(file.path, c(list(vdir), as.list(parts)))
        if (!length(parts) || !file.exists(abs_path)) {
          stop("Video file not found on server", call. = FALSE)
        }
        if (!file.copy(abs_path, dest, overwrite = TRUE)) {
          stop("Unable to copy video file", call. = FALSE)
        }
        TRUE
      }
    }

    observeEvent(current_urls(), {
      urls <- current_urls()
      cur  <- cam_sel()
      if (!length(urls)) {
        cam_sel("")
      } else if (!nzchar(cur) || !(cur %in% names(urls))) {
        cam_sel(names(urls)[1])
      }
    }, ignoreNULL = FALSE, priority = 1)

    observeEvent(cmp_urls(), {
      urls <- cmp_urls()
      cur <- cmp_cam_sel()
      if (!length(urls)) {
        cmp_cam_sel("")
      } else if (!nzchar(cur) || !(cur %in% names(urls))) {
        cmp_cam_sel(names(urls)[1])
      }
    }, ignoreNULL = FALSE, priority = 1)

    for (nm in cam_names) local({
      src <- nm
      observeEvent(input[[paste0(cam_prefix, "_", src)]], {
        urls <- current_urls()
        if (length(urls) && !is.null(urls[[src]]) && nzchar(urls[[src]])) {
          cam_sel(src)
        }
      }, ignoreNULL = TRUE)
    })

    for (nm in cam_names) local({
      src <- nm
      observeEvent(input[[paste0(cmp_cam_prefix, "_", src)]], {
        urls <- cmp_urls()
        if (length(urls) && !is.null(urls[[src]]) && nzchar(urls[[src]])) {
          cmp_cam_sel(src)
        }
      }, ignoreNULL = TRUE)
    })

    observeEvent(input[[next_id]], {
      cur <- idx()
      if (is.finite(cur) && cur < nrow(rows_vid)) idx(cur + 1L)
    }, ignoreNULL = TRUE)

    observeEvent(input[[prev_id]], {
      cur <- idx()
      if (is.finite(cur) && cur > 1) idx(cur - 1L)
    }, ignoreNULL = TRUE)

    observeEvent(input[[compare_toggle_id]], {
      if (!compare_available) return()
      compare_mode(!compare_mode())
    }, ignoreNULL = TRUE)

    observeEvent(compare_mode(), {
      if (compare_mode()) {
        primary_idx <- primary_pool_idx_reactive()
        secondary_idx(default_secondary_for(primary_idx))
        if (compare_available && is.finite(primary_idx)) {
          updateSelectizeInput(session, primary_select_id, selected = as.character(primary_idx))
        }
      } else {
        secondary_idx(NA_integer_)
      }
    }, ignoreNULL = TRUE)

    observeEvent(idx(), {
      if (!compare_available) return()
      if (!compare_mode()) return()
      primary_idx <- primary_pool_idx_reactive()
      current_sec <- secondary_idx()
      if (!is.finite(current_sec) || !pool_has_video[current_sec] || identical(current_sec, primary_idx)) {
        secondary_idx(default_secondary_for(primary_idx))
      }
      if (is.finite(primary_idx)) {
        updateSelectizeInput(session, primary_select_id, selected = as.character(primary_idx))
      }
    }, ignoreNULL = TRUE)

    observeEvent(secondary_idx(), {
      if (!compare_available) return()
      if (!compare_mode()) return()
      val <- secondary_idx()
      updateSelectizeInput(session, compare_select_id,
                           selected = if (is.finite(val)) as.character(val) else NULL)
    }, ignoreNULL = FALSE)

    observeEvent(input[[primary_select_id]], {
      if (!compare_available) return()
      if (!compare_mode()) return()
      val <- suppressWarnings(as.integer(input[[primary_select_id]]))
      if (!is.finite(val)) return()
      target_idx <- match(val, video_positions)
      if (is.finite(target_idx)) idx(target_idx)
    }, ignoreNULL = TRUE)

    observeEvent(input[[compare_select_id]], {
      if (!compare_available) return()
      val <- suppressWarnings(as.integer(input[[compare_select_id]]))
      if (is.finite(val) && val >= 1L && val <= nrow(pool_df) && pool_has_video[val]) {
        secondary_idx(val)
      }
    }, ignoreNULL = TRUE)

    output[[download_single_id]] <- downloadHandler(
      filename = function() {
        row <- current_row()
        idx_val <- primary_pool_idx_reactive()
        label <- make_pitch_option_label(row, idx_val)
        cam <- cam_sel()
        if (!nzchar(cam)) cam <- "video"
        urls <- current_urls()
        url <- urls[[cam]] %||% ""
        ext <- file_ext_from_url(url)
        paste0(slugify(label, fallback = "pitch"), "-", tolower(cam), ext)
      },
      content = function(file) {
        urls <- current_urls()
        sel <- cam_sel()
        if (!length(urls) || !nzchar(sel) || is.null(urls[[sel]]) || !nzchar(urls[[sel]])) {
          stop("No video available for download", call. = FALSE)
        }
        download_source_to(urls[[sel]], file)
      }
    )

    output[[download_all_id]] <- downloadHandler(
      filename = function() {
        base <- if (!is.null(label) && nzchar(label)) label else "selection"
        paste0(slugify(base, fallback = "pitch"), "-videos.zip")
      },
      content = function(file) {
        if (!length(pool_video_idx)) {
          stop("No videos available in this filter", call. = FALSE)
        }
        rows_all <- pool_df[pool_video_idx, , drop = FALSE]
        if (!nrow(rows_all)) {
          stop("No videos available in this filter", call. = FALSE)
        }
        tmpdir <- tempfile("pseq_dl_")
        dir.create(tmpdir, recursive = TRUE, showWarnings = FALSE)
        on.exit(unlink(tmpdir, recursive = TRUE, force = TRUE), add = TRUE)
        
        saved <- character(0)
        done_map <- character(0)
        
        for (pos in seq_along(pool_video_idx)) {
          idx_val <- pool_video_idx[pos]
          row_now <- pool_df[idx_val, , drop = FALSE]
          slug <- slugify(make_pitch_option_label(row_now, idx_val), fallback = sprintf("pitch-%03d", idx_val))
          urls <- collect_urls(row_now)
          if (!length(urls)) next
          for (cam in names(urls)) {
            url <- urls[[cam]]
            if (!nzchar(url)) next
            key <- paste(url, cam, sep = "::")
            if (key %in% done_map) next
            done_map <- c(done_map, key)
            ext <- file_ext_from_url(url)
            dest_name <- sprintf("%03d_%s_%s%s", pos, slug, tolower(cam), ext)
            dest_path <- file.path(tmpdir, dest_name)
            download_source_to(url, dest_path)
            saved <- c(saved, dest_path)
          }
        }
        
        if (!length(saved)) {
          stop("No downloadable videos were found", call. = FALSE)
        }
        
        zipfile <- normalizePath(file, mustWork = FALSE)
        oldwd <- getwd()
        setwd(tmpdir)
        on.exit(setwd(oldwd), add = TRUE)
        utils::zip(zipfile = zipfile, files = basename(saved))
      }
    )

    output[[video_id]] <- renderUI({
      i <- idx()
      if (!is.finite(i)) i <- 1L
      i <- max(1L, min(nrow(rows_vid), i))
      row <- rows_vid[i, , drop = FALSE]
      urls <- current_urls()
      sel <- cam_sel()
      if ((!nzchar(sel) || !(sel %in% names(urls))) && length(urls)) {
        sel <- names(urls)[1]
      }
      url <- if (length(urls) && nzchar(sel) && !is.null(urls[[sel]])) urls[[sel]] else ""
      if (nzchar(url)) {
        cache_tag <- as.integer(as.numeric(Sys.time()))
        url <- paste0(url, if (grepl("\\?", url)) "&" else "?", "v=", cache_tag)
      }
      
      right <- build_metrics_panel(row)
      seq_txt <- sprintf("%d of %d", i, nrow(rows_vid))
      
      compare_btn_label <- if (isTRUE(compare_mode())) tagList(icon("video"), "Single View") else tagList(icon("columns"), "Side-by-Side")
      compare_btn <- actionButton(
        compare_toggle_id,
        label = compare_btn_label,
        class = "btn btn-sm btn-outline-secondary",
        style = "min-width:128px;font-weight:600;",
        disabled = if (compare_available) NULL else "disabled"
      )
      
      download_controls <- tags$div(
        style = "display:flex;justify-content:center;gap:12px;margin-bottom:12px;flex-wrap:wrap;",
        downloadButton(
          download_single_id,
          label = tagList(icon("download"), "Download Pitch"),
          class = "btn btn-sm btn-outline-secondary"
        ),
        downloadButton(
          download_all_id,
          label = tagList(icon("file-archive"), "Download Filter"),
          class = "btn btn-sm btn-outline-secondary",
          title = "Downloads all available camera angles in this filter as a ZIP"
        )
      )
      
      header <- tags$div(
        style = "display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px;",
        actionButton(
          prev_id,
          label = tagList(icon("chevron-left"), "Prev"),
          class = "btn-light btn-sm",
          style = "min-width:92px;",
          disabled = if (i <= 1) "disabled" else NULL
        ),
        tags$div(
          style = "flex:1;text-align:center;",
          tags$div(style = "font-size:0.9rem;font-weight:600;opacity:0.75;", seq_txt)
        ),
        actionButton(
          next_id,
          label = tagList("Next", icon("chevron-right")),
          class = "btn-light btn-sm",
          style = "min-width:92px;",
          disabled = if (i >= nrow(rows_vid)) "disabled" else NULL
        )
      )
      
      cam_buttons <- lapply(cam_names, function(src) {
        u <- urls[[src]]
        if (is.null(u) || !nzchar(u)) return(NULL)
        btn_class <- if (identical(sel, src)) "btn-sm btn-primary" else "btn-sm btn-outline-secondary"
        actionButton(
          paste0(cam_prefix, "_", src),
          label = src,
          class = btn_class,
          style = "min-width:82px;font-weight:600;"
        )
      })
      cam_buttons <- Filter(Negate(is.null), cam_buttons)
      cam_row <- if (length(cam_buttons)) {
        tags$div(
          style = "display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px;justify-content:center;",
          cam_buttons
        )
      } else NULL
      
      video_style <- if (isTRUE(compare_mode())) "width:100%;max-height:60vh;background:#000;" else "width:100%;max-height:78vh;background:#000;"
      placeholder_style <- if (isTRUE(compare_mode()))
        "display:flex;align-items:center;justify-content:center;width:100%;max-height:60vh;height:44vh;background:#0b0b0b;color:#fff;font-weight:700;border-radius:8px;"
      else
        "display:flex;align-items:center;justify-content:center;width:100%;max-height:78vh;height:60vh;background:#0b0b0b;color:#fff;font-weight:700;border-radius:8px;"
      
      video_core <- if (nzchar(url)) {
        tags$video(
          id = primary_video_id,
          src = url,
          controls = NA,
          autoplay = NA,
          type = guess_video_type(url),
          style = video_style
        )
      } else {
        tags$div("No video available", style = placeholder_style)
      }
      
      compare_choices <- if (compare_available) {
        labs <- vapply(pool_video_idx, function(idx_val) make_pitch_option_label(pool_df[idx_val, , drop = FALSE], idx_val), character(1))
        stats::setNames(as.character(pool_video_idx), labs)
      } else character(0)
      
      if (!isTRUE(compare_mode())) {
        right_pane <- metrics_block(right)
        main_layout <- if (is.null(right_pane)) {
          video_core
        } else {
          tags$div(
            style = paste(
              "display:grid;",
              "grid-template-columns:4fr 1fr;",
              "gap:24px;align-items:start;"
            ),
            video_core,
            right_pane
          )
        }
        
        tagList(
          header,
          tags$div(style = "display:flex;justify-content:center;margin-bottom:10px;", compare_btn),
          cam_row,
          download_controls,
          main_layout
        )
      } else {
        cmp_row <- cmp_current_row()
        cmp_sel <- cmp_cam_sel()
        cmp_urls_now <- cmp_urls()
        if ((!nzchar(cmp_sel) || !(cmp_sel %in% names(cmp_urls_now))) && length(cmp_urls_now)) {
          cmp_sel <- names(cmp_urls_now)[1]
        }
        cmp_url <- if (length(cmp_urls_now) && nzchar(cmp_sel) && !is.null(cmp_urls_now[[cmp_sel]])) cmp_urls_now[[cmp_sel]] else ""
        if (nzchar(cmp_url)) {
          cache_tag <- as.integer(as.numeric(Sys.time()))
          cmp_url <- paste0(cmp_url, if (grepl("\\?", cmp_url)) "&" else "?", "v=", cache_tag)
        }
        
        cmp_cam_buttons <- lapply(cam_names, function(src) {
          u <- cmp_urls_now[[src]]
          if (is.null(u) || !nzchar(u)) return(NULL)
          btn_class <- if (identical(cmp_sel, src)) "btn-sm btn-primary" else "btn-sm btn-outline-secondary"
          actionButton(
            paste0(cmp_cam_prefix, "_", src),
            label = src,
            class = btn_class,
            style = "min-width:82px;font-weight:600;"
          )
        })
        cmp_cam_buttons <- Filter(Negate(is.null), cmp_cam_buttons)
        cmp_cam_row <- if (length(cmp_cam_buttons)) {
          tags$div(
            style = "display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px;justify-content:center;",
            cmp_cam_buttons
          )
        } else NULL
        
        cmp_video_core <- if (nzchar(cmp_url)) {
          tags$video(
            id = secondary_video_id,
            src = cmp_url,
            controls = NA,
            autoplay = NA,
            type = guess_video_type(cmp_url),
            style = video_style
          )
        } else {
          tags$div("Select a pitch", style = placeholder_style)
        }
        
        left_metrics_block <- metrics_block(right)
        right_metrics_block <- metrics_block(if (!is.null(cmp_row)) build_metrics_panel(cmp_row) else NULL)
        
        primary_selected_val <- primary_pool_idx_reactive()
        secondary_selected_val <- secondary_idx()
        
        selector <- if (compare_available) {
          tags$div(
            style = "display:flex;justify-content:center;gap:16px;margin-bottom:12px;flex-wrap:wrap;",
            tags$div(
              style = "display:flex;flex-direction:column;min-width:220px;gap:4px;",
              tags$label("Primary Pitch", `for` = primary_select_id, style = "margin:0;font-weight:600;"),
              selectizeInput(
                primary_select_id,
                label = NULL,
                choices = compare_choices,
                selected = {
                  if (is.finite(primary_selected_val)) as.character(primary_selected_val)
                  else if (length(compare_choices)) compare_choices[[1]] else NULL
                },
                options = list(placeholder = "Choose primary pitch")
              )
            ),
            tags$div(
              style = "display:flex;flex-direction:column;min-width:220px;gap:4px;",
              tags$label("Secondary Pitch", `for` = compare_select_id, style = "margin:0;font-weight:600;"),
              selectizeInput(
                compare_select_id,
                label = NULL,
                choices = compare_choices,
                selected = {
                  if (is.finite(secondary_selected_val)) as.character(secondary_selected_val)
                  else if (length(compare_choices)) compare_choices[[1]] else NULL
                },
                options = list(placeholder = "Choose secondary pitch")
              )
            )
          )
        } else NULL
        
        primary_controls <- if (compare_available) {
          tags$div(
            style = "display:flex;align-items:center;gap:10px;margin-bottom:8px;flex-wrap:wrap;justify-content:center;",
            actionButton(primary_play_id, label = "Play", icon = icon("play"), class = "btn btn-sm btn-outline-secondary"),
            actionButton(primary_pause_id, label = "Pause", icon = icon("pause"), class = "btn btn-sm btn-outline-secondary"),
            tags$input(
              id = primary_slider_id,
              type = "range",
              min = "0",
              max = "1",
              step = "0.01",
              value = "0",
              style = "flex:1 1 260px;min-width:220px;"
            )
          )
        } else NULL
        
        secondary_controls <- if (compare_available) {
          tags$div(
            style = "display:flex;align-items:center;gap:10px;margin-bottom:8px;flex-wrap:wrap;justify-content:center;",
            actionButton(secondary_play_id, label = "Play", icon = icon("play"), class = "btn btn-sm btn-outline-secondary"),
            actionButton(secondary_pause_id, label = "Pause", icon = icon("pause"), class = "btn btn-sm btn-outline-secondary"),
            tags$input(
              id = secondary_slider_id,
              type = "range",
              min = "0",
              max = "1",
              step = "0.01",
              value = "0",
              style = "flex:1 1 260px;min-width:220px;"
            )
          )
        } else NULL
        
        sync_controls <- if (compare_available) {
          tags$div(
            style = "display:flex;align-items:center;gap:12px;margin:-4px 0 12px 0;flex-wrap:wrap;justify-content:center;",
            tags$label(
              "Sync Scrub",
              `for` = sync_slider_id,
              style = "margin:0;font-weight:600;min-width:96px;text-align:right;"
            ),
            tags$input(
              id = sync_slider_id,
              type = "range",
              min = "0",
              max = "1",
              step = "0.01",
              value = "0",
              style = "flex:1 1 360px;min-width:260px;"
            ),
            actionButton(sync_play_id, label = "Play", icon = icon("play"), class = "btn btn-sm btn-outline-secondary"),
            actionButton(sync_pause_id, label = "Pause", icon = icon("pause"), class = "btn btn-sm btn-outline-secondary")
          )
        } else NULL
        
        left_col <- tags$div(
          style = "display:flex;flex-direction:column;gap:10px;",
          cam_row,
          primary_controls,
          video_core,
          left_metrics_block
        )
        
        right_col <- tags$div(
          style = "display:flex;flex-direction:column;gap:10px;",
          cmp_cam_row,
          secondary_controls,
          cmp_video_core,
          right_metrics_block
        )
        
        control_script <- if (compare_available) {
          tags$script(HTML(sprintf(
            "(function(){\n  var configs = [\n    {videoId:'%s', sliderId:'%s', playId:'%s', pauseId:'%s'},\n    {videoId:'%s', sliderId:'%s', playId:'%s', pauseId:'%s'}\n  ];\n  var syncSlider = document.getElementById('%s');\n  var syncPlayBtn = document.getElementById('%s');\n  var syncPauseBtn = document.getElementById('%s');\n  var syncUpdating = false;\n\n  function playSafe(video){\n    if (!video) return;\n    try {\n      var p = video.play();\n      if (p && typeof p.catch === 'function') p.catch(function(){});\n    } catch(e){}\n  }\n\n  function pauseSafe(video){\n    if (!video) return;\n    try { video.pause(); } catch(e){}\n  }\n\n  function updateSyncRange(){\n    if (!syncSlider) return;\n    var maxDur = Infinity;\n    configs.forEach(function(cfg){\n      if (!cfg.video) return;\n      var d = cfg.video.duration;\n      if (isFinite(d) && d > 0 && d < maxDur) maxDur = d;\n    });\n    if (!isFinite(maxDur) || maxDur === Infinity){\n      syncSlider.disabled = true;\n    } else {\n      syncSlider.max = maxDur;\n      syncSlider.disabled = false;\n    }\n  }\n\n  function updateSyncValue(){\n    if (!syncSlider || syncUpdating) return;\n    var minTime = Infinity;\n    configs.forEach(function(cfg){\n      if (!cfg.video) return;\n      var t = cfg.video.currentTime;\n      if (isFinite(t) && t < minTime) minTime = t;\n    });\n    if (minTime !== Infinity) syncSlider.value = minTime;\n  }\n\n  configs.forEach(function(cfg){\n    cfg.video = document.getElementById(cfg.videoId);\n    cfg.slider = document.getElementById(cfg.sliderId);\n    cfg.playBtn = document.getElementById(cfg.playId);\n    cfg.pauseBtn = document.getElementById(cfg.pauseId);\n    if (!cfg.video) return;\n    var video = cfg.video;\n    var slider = cfg.slider;\n    var updating = false;\n\n    function setRange(){\n      if (!slider) return;\n      if (isFinite(video.duration) && video.duration > 0){\n        slider.max = video.duration;\n        slider.disabled = false;\n      } else {\n        slider.disabled = true;\n      }\n    }\n\n    video.addEventListener('loadedmetadata', function(){\n      setRange();\n      updateSyncRange();\n      if (slider) slider.value = video.currentTime || 0;\n      updateSyncValue();\n    });\n\n    video.addEventListener('timeupdate', function(){\n      if (updating) return;\n      setRange();\n      if (slider) slider.value = video.currentTime || 0;\n      updateSyncRange();\n      updateSyncValue();\n    });\n\n    if (slider){\n      slider.addEventListener('input', function(){\n        updating = true;\n        var val = parseFloat(slider.value) || 0;\n        try { video.currentTime = val; } catch(e){}\n      });\n      slider.addEventListener('change', function(){\n        updating = false;\n      });\n    }\n\n    if (cfg.playBtn){\n      cfg.playBtn.addEventListener('click', function(){\n        playSafe(video);\n      });\n    }\n\n    if (cfg.pauseBtn){\n      cfg.pauseBtn.addEventListener('click', function(){\n        pauseSafe(video);\n      });\n    }\n  });\n\n  if (syncSlider){\n    syncSlider.addEventListener('input', function(){\n      syncUpdating = true;\n      var val = parseFloat(syncSlider.value) || 0;\n      var actual = Infinity;\n      configs.forEach(function(cfg){\n        if (!cfg.video) return;\n        var target = val;\n        var dur = cfg.video.duration;\n        if (isFinite(dur) && dur > 0 && target > dur) target = dur;\n        try { cfg.video.currentTime = target; } catch(e){}\n        if (cfg.slider) cfg.slider.value = target;\n        var ct = cfg.video.currentTime;\n        if (isFinite(ct) && ct < actual) actual = ct;\n      });\n      if (actual !== Infinity) syncSlider.value = actual;\n    });\n    syncSlider.addEventListener('change', function(){\n      syncUpdating = false;\n    });\n    updateSyncRange();\n    updateSyncValue();\n  }\n\n  if (syncPlayBtn){\n    syncPlayBtn.addEventListener('click', function(){\n      configs.forEach(function(cfg){ playSafe(cfg.video); });\n    });\n  }\n\n  if (syncPauseBtn){\n    syncPauseBtn.addEventListener('click', function(){\n      configs.forEach(function(cfg){ pauseSafe(cfg.video); });\n    });\n  }\n})();",
            primary_video_id, primary_slider_id, primary_play_id, primary_pause_id,
            secondary_video_id, secondary_slider_id, secondary_play_id, secondary_pause_id,
            sync_slider_id, sync_play_id, sync_pause_id)))
        } else NULL
        
        tagList(
          header,
          tags$div(style = "display:flex;justify-content:center;margin-bottom:10px;", compare_btn),
          selector,
          sync_controls,
          download_controls,
          tags$div(
            style = "display:grid;grid-template-columns:1fr 1fr;gap:24px;align-items:start;",
            left_col,
            right_col
          ),
          control_script
        )
      }
    })

    modal_css <- tags$style(HTML(
      ".modal-dialog.pseq-wide{width:96%;max-width:1400px;}"
    ))
    showModal(tagList(modal_css, modalDialog(uiOutput(video_id), easyClose = TRUE, footer = NULL, size = "l", class = "pseq-wide")))
    invisible(TRUE)
  }

  open_pitch_edit_modal <- function(rows) {
    if (is.null(rows) || !nrow(rows)) return(invisible(FALSE))
    selected_pitches <- rows
    available_pitchers <- sort(unique(pitch_data_pitching$Pitcher))
    pitcher_choices <- sort(unique(c(available_pitchers, as.character(selected_pitches$Pitcher))))
    
    showModal(modalDialog(
      title = paste("Edit Pitch Type for", nrow(selected_pitches), "pitch(es)"),
      selectInput("new_pitch_type", "New Pitch Type:",
                  choices = c("Fastball", "Sinker", "Cutter", "Slider", "Sweeper", 
                              "Curveball", "ChangeUp", "Splitter", "Knuckleball"),
                  selected = selected_pitches$TaggedPitchType[1]),
      selectInput("new_pitcher", "Assign To Pitcher:",
                  choices = pitcher_choices,
                  selected = selected_pitches$Pitcher[1]),
      br(),
      strong("Selected Pitches:"),
      br(),
      if (nrow(selected_pitches) <= 10) {
        div(
          lapply(1:nrow(selected_pitches), function(i) {
            p <- selected_pitches[i, ]
            div(sprintf("Pitch %d: %s - %s (%.1f mph, HB: %.1f, IVB: %.1f)",
                        i, p$TaggedPitchType, p$Date, 
                        p$RelSpeed %||% 0, p$HorzBreak %||% 0, p$InducedVertBreak %||% 0))
          })
        )
      } else {
        div(sprintf("%d pitches selected (too many to display individually)", nrow(selected_pitches)))
      },
      footer = tagList(
        modalButton("Cancel"),
        actionButton("confirm_pitch_edit", "Save Changes", class = "btn-primary")
      ),
      easyClose = FALSE
    ))
    
    session$userData$selected_for_edit <- selected_pitches
    invisible(TRUE)
  }

  open_clip_from_df_and_index <- function(df, idx_raw, label = NULL) {
    idx <- safe_selected(idx_raw)
    n <- nrow(df)
    if (!is.finite(idx) || is.na(idx) || n < 1L || idx < 1L || idx > n) return(invisible(FALSE))
    if (identical(input$pitch_click_action, "edit")) {
      return(open_pitch_edit_modal(df[idx, , drop = FALSE]))
    }
    row <- df[idx, , drop = FALSE]
    show_pitch_video_modal_multi(row, dataset = df, dataset_idx = idx)
    invisible(TRUE)
  }

  handle_table_video_click <- function(info, cache, table_label = NULL) {
    if (is.null(info)) return(invisible(FALSE))
    col_raw <- info$col %||% info$column
    row_raw <- info$row %||% info$rows
    if (is.null(col_raw) || is.null(row_raw)) return(invisible(FALSE))
    col_idx <- suppressWarnings(as.integer(col_raw))
    row_idx <- suppressWarnings(as.integer(row_raw))
    if (is.finite(col_idx)) col_idx <- col_idx + 1L  # DT supplies 0-based column index
    if (is.finite(row_idx) && row_idx < 1L) row_idx <- row_idx + 1L
    
    if (is.null(cache)) return(invisible(FALSE))
    if (inherits(cache, "data.frame")) {
      df_tbl <- cache
      meta <- list()
    } else if (is.list(cache)) {
      df_tbl <- cache$table %||% cache$data %||% cache
      meta <- cache
    } else {
      return(invisible(FALSE))
    }
    
    if (is.null(df_tbl) || !nrow(df_tbl)) return(invisible(FALSE))
    if (!is.finite(col_idx) || col_idx < 1 || col_idx > ncol(df_tbl)) return(invisible(FALSE))
    if (!is.finite(row_idx) || row_idx < 1 || row_idx > nrow(df_tbl)) return(invisible(FALSE))
    
    col_name <- names(df_tbl)[col_idx]
    if (!identical(col_name, "#")) return(invisible(FALSE))
    
    label_col <- meta$label_column %||% {
      if ("Pitch" %in% names(df_tbl)) "Pitch"
      else if ("Player" %in% names(df_tbl)) "Player"
      else names(df_tbl)[1]
    }
    if (!label_col %in% names(df_tbl)) label_col <- names(df_tbl)[1]
    pitch_label <- tryCatch(as.character(df_tbl[row_idx, label_col])[1], error = function(e) "")
    pitch_label <- trimws(pitch_label)
    
    rows <- NULL
    if (!is.null(meta$source)) {
      rows <- pitch_rows_for_label(meta$source, pitch_label, meta$split_choice %||% NULL)
    }
    if ((is.null(rows) || !nrow(rows)) && !is.null(meta$fallback_source)) {
      rows <- pitch_rows_for_label(meta$fallback_source, pitch_label, meta$split_choice %||% NULL)
    }
    if (is.null(rows) || !nrow(rows)) {
      df_all <- filtered_data()
      if (!is.null(df_all) && nrow(df_all)) {
        rows <- pitch_rows_for_label(df_all, pitch_label, meta$split_choice %||% NULL)
      }
    }
    
    if (is.null(rows) || !nrow(rows)) {
      showModal(modalDialog("No pitches found for this table row.", easyClose = TRUE, footer = NULL))
      return(invisible(FALSE))
    }
    
    rows <- as.data.frame(rows, stringsAsFactors = FALSE)
    if (is.null(rownames(rows))) {
      rownames(rows) <- as.character(seq_len(nrow(rows)))
    }
    
    if (identical(input$pitch_click_action, "edit")) {
      open_pitch_edit_modal(rows)
      return(invisible(TRUE))
    }
    
    start_idx <- 1L
    show_pitch_video_sequence(
      rows,
      label = if (nzchar(pitch_label)) pitch_label else table_label,
      start_index = start_idx,
      compare_pool = rows,
      primary_pool_idx = start_idx
    )
    invisible(TRUE)
  }
  
  # Target Shapes Data Storage - load or create CSV
  target_shapes_file <- "target_shapes.csv"
  target_shapes <- reactiveVal()
  target_shapes_version <- reactiveVal(0)  # Trigger for re-rendering
  target_shapes_global <- target_shapes  # alias for module-wide access
  
  # Reactive storage for modal rows (pitch types the user wants to configure)
  target_shape_rows <- reactiveVal(
    tibble::tibble(
      PitchType = character(),
      IVB = numeric(),
      HB = numeric(),
      RowID = character(),
      IsCustom = logical()
    )
  )
  target_shape_pitch_types <- reactiveVal(character())

  # Load existing target shapes or create empty dataframe
  loaded_shapes <- load_target_shapes_db()
  if (is.null(loaded_shapes)) {
    if (file.exists(target_shapes_file)) {
      loaded_shapes <- tryCatch({
        read.csv(target_shapes_file, stringsAsFactors = FALSE)
      }, error = function(e) {
        data.frame(Pitcher = character(), PitchType = character(), 
                   IVB_Target = numeric(), HB_Target = numeric(), 
                   IsCustom = logical(), stringsAsFactors = FALSE)
      })
    } else {
      loaded_shapes <- data.frame(Pitcher = character(), PitchType = character(), 
                                  IVB_Target = numeric(), HB_Target = numeric(), 
                                  IsCustom = logical(), stringsAsFactors = FALSE)
    }
  }
  target_shapes(loaded_shapes)
  
  # Helper to compute target from top Stuff+ without persisting
  calc_default_target_shape <- function(pitcher_name, pitch_type, date_range = NULL) {
    if (is.null(pitcher_name) || pitcher_name == "All" || is.null(pitch_type)) return(NULL)
    data <- pitch_data_pitching
    if (!"Stuff+" %in% names(data)) return(NULL)
    pitch_data_filtered <- data %>%
      dplyr::filter(Pitcher == pitcher_name, TaggedPitchType == pitch_type)
    if (!is.null(date_range) && length(date_range) == 2) {
      pitch_data_filtered <- pitch_data_filtered %>%
        dplyr::filter(Date >= date_range[1], Date <= date_range[2])
    }
    pitch_data_filtered <- pitch_data_filtered %>%
      dplyr::filter(!is.na(`Stuff+`), !is.na(InducedVertBreak), !is.na(HorzBreak))
    if (nrow(pitch_data_filtered) == 0) return(NULL)
    n_pitches <- min(10, nrow(pitch_data_filtered))
    top_pitches <- pitch_data_filtered %>%
      dplyr::arrange(desc(`Stuff+`)) %>%
      dplyr::slice(1:n_pitches)
    list(
      IVB = mean(top_pitches$InducedVertBreak, na.rm = TRUE),
      HB = mean(top_pitches$HorzBreak, na.rm = TRUE),
      count = n_pitches
    )
  }

  # Helper for safe numeric row IDs
  make_target_row_id <- function(pitch_type, existing = character()) {
    base <- gsub("[^A-Za-z0-9]", "_", pitch_type)
    base <- gsub("_+", "_", base)
    base <- gsub("^_+|_+$", "", base)
    if (!nzchar(base)) base <- "pitch"
    candidate <- base
    counter <- 1L
    while (candidate %in% existing) {
      counter <- counter + 1L
      candidate <- paste0(base, "_", counter)
    }
    candidate
  }
  
  # Function to save target shapes to CSV
  save_target_shapes <- function() {
    tryCatch({
      save_target_shapes_db(target_shapes())
      # simple CSV backup
      write.csv(target_shapes(), target_shapes_file, row.names = FALSE)
    }, error = function(e) {
      message("Error saving target shapes: ", e$message)
    })
  }
  
  # Function to get target shape for a pitcher/pitch type
  # Returns list with IVB_Target and HB_Target
  get_target_shape <- function(pitcher_name, pitch_type, date_range = NULL, auto_save = TRUE) {
    if (is.null(pitcher_name) || pitcher_name == "All" || is.null(pitch_type)) {
      return(NULL)
    }
    
    shapes_df <- target_shapes()
    
    # Check if custom target exists
    existing <- shapes_df[shapes_df$Pitcher == pitcher_name & 
                            shapes_df$PitchType == pitch_type, ]
    
    if (nrow(existing) > 0) {
      return(list(IVB = existing$IVB_Target[1], 
                  HB = existing$HB_Target[1],
                  IsCustom = existing$IsCustom[1]))
    }
    
    defaults <- calc_default_target_shape(pitcher_name, pitch_type, date_range)
    if (is.null(defaults)) return(NULL)
    
    message(sprintf("Auto-calculated target for %s %s: IVB=%.2f, HB=%.2f (from %d pitches)", 
                    pitcher_name, pitch_type, defaults$IVB, defaults$HB, defaults$count))
    
    if (isTRUE(auto_save)) {
      new_row <- data.frame(
        Pitcher = pitcher_name,
        PitchType = pitch_type,
        IVB_Target = defaults$IVB,
        HB_Target = defaults$HB,
        IsCustom = FALSE,
        stringsAsFactors = FALSE
      )
      shapes_df <- rbind(shapes_df, new_row)
      target_shapes(shapes_df)
      save_target_shapes()
      target_shapes_version(target_shapes_version() + 1L)
    }
    
    list(IVB = defaults$IVB, HB = defaults$HB, IsCustom = FALSE)
  }
  
  # Function to set custom target shape
  set_target_shape <- function(pitcher_name, pitch_type, ivb, hb) {
    shapes_df <- target_shapes()
    
    # Remove existing entry if present
    shapes_df <- shapes_df[!(shapes_df$Pitcher == pitcher_name & 
                               shapes_df$PitchType == pitch_type), ]
    
    # Add new entry
    new_row <- data.frame(
      Pitcher = pitcher_name,
      PitchType = pitch_type,
      IVB_Target = ivb,
      HB_Target = hb,
      IsCustom = TRUE,
      stringsAsFactors = FALSE
    )
    
    shapes_df <- rbind(shapes_df, new_row)
    target_shapes(shapes_df)
    save_target_shapes()
    target_shapes_version(target_shapes_version() + 1L)
  }
  
  # Function to reset target shape to default (remove custom)
  reset_target_shape <- function(pitcher_name, pitch_type, date_range = NULL) {
    shapes_df <- target_shapes()
    
    # Remove existing entry
    shapes_df <- shapes_df[!(shapes_df$Pitcher == pitcher_name & 
                               shapes_df$PitchType == pitch_type), ]
    target_shapes(shapes_df)
    save_target_shapes()
    target_shapes_version(target_shapes_version() + 1L)
    
    calc_default_target_shape(pitcher_name, pitch_type, date_range)
  }
  
  # Global persistent date range - initializes to most recent date on startup
  global_date_range <- reactiveVal()
  
  # Initialize global date range on startup
  observe({
    if (is.null(global_date_range())) {
      if (exists("pitch_data") && nrow(pitch_data) > 0) {
        max_date <- max(pitch_data$Date, na.rm = TRUE)
        global_date_range(c(max_date, max_date))
      } else {
        global_date_range(c(Sys.Date(), Sys.Date()))
      }
    }
  })
  
  # Update global date range when main input changes
  observeEvent(input$dates, {
    if (!is.null(input$dates) && length(input$dates) == 2) {
      # Only update if the dates are actually different to prevent loops
      current_global <- global_date_range()
      if (is.null(current_global) || 
          !identical(as.Date(input$dates), as.Date(current_global))) {
        global_date_range(input$dates)
      }
    }
  })
  
  # Sync date range input with global value - only when global changes
  observe({
    global_dates <- global_date_range()
    if (!is.null(global_dates) && !is.null(input$dates)) {
      # Only update UI if the values are actually different to prevent loops
      if (!identical(as.Date(input$dates), as.Date(global_dates))) {
        updateDateRangeInput(session, "dates", 
                             start = global_dates[1], 
                             end = global_dates[2])
      }
    }
  })
  
  # Reactive value to store modified pitch data with edits persisted
  modified_pitch_data <- reactiveVal()
  
  # Reactive value to track modification statistics
  modification_stats <- reactiveVal(list(applied_count = 0, total_modifications = 0))
  
  # Function to load modifications with feedback
  load_modifications <- function(force_reload = FALSE, verbose = TRUE) {
    if (force_reload || check_data_freshness()) {
      if (verbose) {
        showNotification("Checking for stored pitch type modifications...", 
                         type = "message", duration = 2)
      }
      
      result <- load_pitch_modifications_db(pitch_data_pitching, verbose = verbose)
      modified_pitch_data(result$data)
      modification_stats(list(
        applied_count = result$applied_count,
        total_modifications = result$total_modifications
      ))
      
      if (verbose && result$applied_count > 0) {
        showNotification(
          sprintf("Applied %d of %d stored pitch type modifications", 
                  result$applied_count, result$total_modifications),
          type = "message", duration = 5
        )
      } else if (verbose && result$total_modifications > 0) {
        showNotification(
          sprintf("Warning: %d stored modifications could not be applied (pitches not found)", 
                  result$total_modifications - result$applied_count),
          type = "warning", duration = 5
        )
      }
    } else {
      # No new data, just load normally if not already loaded
      current_data <- tryCatch(modified_pitch_data(), error = function(e) NULL)
      if (is.null(current_data)) {
        result <- load_pitch_modifications_db(pitch_data_pitching, verbose = FALSE)
        modified_pitch_data(result$data)
        modification_stats(list(
          applied_count = result$applied_count,
          total_modifications = result$total_modifications
        ))
      }
    }
  }
  
  # Load modifications on startup
  load_modifications(force_reload = FALSE, verbose = TRUE)
  
  # Add a reactive timer to check for data updates every 30 seconds
  autoCheck <- reactiveTimer(30000)  # 30 seconds
  
  observe({
    autoCheck()
    load_modifications(force_reload = FALSE, verbose = FALSE)
  })
  
  # Manual refresh button observer
  observeEvent(input$refreshModifications, {
    showNotification("Manually refreshing pitch type modifications...", 
                     type = "message", duration = 2)
    load_modifications(force_reload = TRUE, verbose = TRUE)
  })
  
  output$downloadPitchMods <- downloadHandler(
    filename = function() paste0("pitch_type_modifications_", format(Sys.Date(), "%Y%m%d"), ".csv"),
    content = function(file) {
      db_path <- init_modifications_db()
      con <- tryCatch(dbConnect(SQLite(), db_path), error = function(e) e)
      if (inherits(con, "error")) {
        export_path <- get_modifications_export_path()
        if (file.exists(export_path)) {
          file.copy(export_path, file, overwrite = TRUE)
        } else {
          readr::write_csv(data.frame(message = "No pitch edits saved yet"), file)
        }
        return()
      }
      on.exit(dbDisconnect(con), add = TRUE)
      mods <- try(dbGetQuery(con, "SELECT * FROM modifications ORDER BY created_at"), silent = TRUE)
      if (inherits(mods, "try-error") || !nrow(mods)) {
        readr::write_csv(data.frame(message = "No pitch edits saved yet"), file)
      } else {
        readr::write_csv(mods, file)
      }
    }
  )
  
  # Status text output
  output$modificationStatusText <- renderText({
    stats <- modification_stats()
    if (stats$total_modifications > 0) {
      sprintf("%d edits stored, %d applied", 
              stats$total_modifications, stats$applied_count)
    } else {
      "No stored edits"
    }
  })
  
  session_label_from <- function(df) {
    s <- unique(na.omit(as.character(df$SessionType)))
    if (length(s) == 1) s else "All"
  }
  
  observeEvent(input$open_media, {
    info <- input$open_media
    url  <- info$url %||% ""
    typ  <- tolower(info$type %||% "auto")
    if (!nzchar(url)) return()
    
    is_img <- grepl("image", typ) || grepl("\\.(png|jpe?g|gif|webp)$", url, ignore.case = TRUE)
    is_pdf <- grepl("pdf", typ)   || grepl("\\.pdf(\\?.*)?$", url, ignore.case = TRUE)
    
    ui <- if (is_img) {
      tags$div(
        style = "text-align:center;",
        tags$img(src = url, style = "max-width:100%; height:auto;")
      )
    } else if (is_pdf) {
      # Prefer native inline render; works with Cloudinary “raw” PDFs
      tags$div(
        style = "width:100%;",
        # Primary: <object> (best cross-browser)
        tags$object(
          data  = url,
          type  = "application/pdf",
          style = "width:100%; height:70vh; border:0;",
          # Fallback inside <object>: <embed> (Safari sometimes prefers it)
          tags$embed(
            src   = url,
            type  = "application/pdf",
            style = "width:100%; height:70vh; border:0;"
          )
        ),
        # Always offer a direct link as a graceful fallback
        tags$div(
          style = "margin-top:8px;",
          tags$a(href = url, target = "_blank", rel = "noopener noreferrer",
                 "Open original PDF in a new tab")
        )
      )
    } else {
      tags$video(
        src = url, controls = NA, autoplay = NA,
        style = "width:100%; max-height:70vh; background:#000;"
      )
    }
    
    showModal(modalDialog(ui, easyClose = TRUE, footer = NULL, size = "l"))
  })
  
  # Safety: ensure noteJumping exists before any observer uses it
  noteJumping <- get0("noteJumping", mode = "function", inherits = TRUE)
  if (is.null(noteJumping)) noteJumping <- shiny::reactiveVal(FALSE)
  
  # forces the Notes DT to re-render when bumped
  notes_version <- reactiveVal(0L)
  
  # whenever user switches to the Notes tab, refresh the table
  observeEvent(input$top, {
    if (identical(input$top, "Notes")) {
      notes_version(isolate(notes_version()) + 1L)
    }
  }, ignoreInit = TRUE)
  
  # user_email and is_admin are now defined at the start of server function
  # (removed duplicate definitions here)
  
  tooltip_css <- "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
  
  # --- Helpers to read the current suite & page (subtab) ---
  current_suite <- reactive({ input$top %or% "Pitching" })   # navbarPage id   (exists)  # :contentReference[oaicite:5]{index=5}
  
  current_page <- reactive({
    s <- current_suite()
    if (identical(s, "Pitching")) {
      input$tabs %or% "Summary"                                   # pitching tabset id  # :contentReference[oaicite:6]{index=6}
    } else if (identical(s, "Hitting")) {
      input[["hit-tabs"]] %or% "Data and Performance"             # module ns → hit-tabs
    } else if (identical(s, "Catching")) {
      input[["catch-tabs"]] %or% "Data and Performance"           # module ns → catch-tabs  # :contentReference[oaicite:7]{index=7}
    } else if (identical(s, "Leaderboard")) {
      input[["leader-tabs"]] %or% "Pitching"
    } else if (identical(s, "Comparison Suite") || identical(s, "Comparison Tool")) {
      input[["comp-tabs"]] %or% "Compare"
    } else {
      ""
    }
  })
  
  # --- your existing user_email() works for Author (email) ---
  # we’ll just reuse it.  # :contentReference[oaicite:8]{index=8}
  
  # --- Open modal to create a new note ---
  observeEvent(input$openNote, {
    # pull current filters
    ds <- input$dates[1]; de <- input$dates[2]
    pit <- input$pitcher %or% "All"
    st  <- input$sessionType %or% "All"
    sui <- current_suite()
    pag <- current_page()
    
    # a preview line for the modal
    preview <- paste0(
      fmt_mdy(ds), " – ", fmt_mdy(de),
      " • ", pit,
      " • ", sui, if (nzchar(pag)) paste0(" / ", pag) else ""
    )
    
    showModal(modalDialog(
      title = "Add Note",
      tagList(
        div(style="margin-bottom:6px; font-size:12px; opacity:.7;",
            "Context to be saved: ", preview),
        
        textAreaInput("note_text", NULL, width = "100%", height = "150px",
                      placeholder = "Type your note here…"),
        
        fileInput(
          "note_media", "Attach photo/video/PDF (optional):",
          accept = c("image/*", "video/*", "application/pdf", ".pdf"),
          buttonLabel = "Choose file…", placeholder = "No file selected"
        )
      ),
      footer = tagList(
        modalButton("Cancel"),
        actionButton("save_note", "Save", class = "btn btn-primary",
                     onclick = "this.disabled = true; this.innerText = 'Saving…';")
      ),
      easyClose = TRUE
    ))
  }, ignoreInit = TRUE)
  
  
  
  # --- Build Notes table ---
  notes_reload <- function() {
    rows <- tryCatch(notes_api_list(), error = function(e) {
      showNotification(paste("Could not load notes:", e$message), type="error"); list()
    })
    if (!length(rows)) {
      return(DT::datatable(data.frame(Message="No notes yet"), options=list(dom='t'), rownames=FALSE))
    }
    
    df <- as.data.frame(rows, stringsAsFactors = FALSE, check.names = FALSE)
    
    # Sort newest first by created_at_utc (robust)
    ct  <- parse_utc_datetime(df$created_at_utc)
    ord <- order(ct, decreasing = TRUE)
    df  <- df[ord, , drop = FALSE]
    ct  <- ct[ord]
    
    # Split Suite::Subpage
    page2 <- ifelse(is.na(df$page), "", df$page)
    sp    <- strsplit(page2, "::", fixed = TRUE)
    suite <- vapply(sp, function(x) if (length(x)) x[[1]] else "", character(1))
    subpg <- vapply(sp, function(x) if (length(x) >= 2) x[[2]] else "", character(1))
    
    ds   <- fmt_mdy(as.Date(df$date_start))
    de   <- fmt_mdy(as.Date(df$date_end))
    pit  <- ifelse(is.na(df$pitcher) | df$pitcher == "", "All", df$pitcher)
    sess <- ifelse(is.na(df$session_type) | df$session_type == "", "All", df$session_type)
    
    lbl <- paste0(ds, " – ", de, " • ", pit, " • ", suite, ifelse(nzchar(subpg), paste0(" / ", subpg), ""))
    
    suite_attr <- htmltools::htmlEscape(suite)
    page_attr  <- htmltools::htmlEscape(subpg)
    pit_attr   <- htmltools::htmlEscape(pit)
    sess_attr  <- htmltools::htmlEscape(sess)
    ds_attr    <- htmltools::htmlEscape(as.character(as.Date(df$date_start)))
    de_attr    <- htmltools::htmlEscape(as.character(as.Date(df$date_end)))
    txt_attr   <- htmltools::htmlEscape(lbl)
    
    filter_html <- sprintf(
      '<a href="#" class="note-jump" data-suite="%s" data-page="%s" data-pitcher="%s" data-sess="%s" data-ds="%s" data-de="%s">%s</a>',
      suite_attr, page_attr, pit_attr, sess_attr, ds_attr, de_attr, txt_attr
    )
    
    # --- Attachment extraction (unescape first) ---
    note_raw <- html_unescape(df$note_text %||% "")
    
    # First try to grab the exact anchor we generated on save
    anchor_pat <- '<a[^>]*class=(["\\\'])open-media\\1[^>]*>.*?</a>'
    m <- regexpr(anchor_pat, note_raw, perl = TRUE, ignore.case = TRUE)
    att_html <- ifelse(
      m > 0,
      substring(note_raw, m, m + attr(m, "match.length") - 1),
      ""
    )
    
    # Fallback: if no <a class="open-media">…</a>, build one from any media-looking URL in the text
    url_matches <- gregexpr("https?://[^\\s\"'>]+", note_raw, perl = TRUE)
    urls_list   <- regmatches(note_raw, url_matches)
    for (i in seq_along(att_html)) {
      if (nzchar(att_html[i])) next
      u <- urls_list[[i]]
      if (!length(u)) next
      # Prefer obvious media URLs; otherwise take the first URL
      # Prefer obvious media URLs; include pdf as well
      cand <- u[grep("\\.(png|jpe?g|gif|webp|mp4|mov|webm|mkv|pdf)(\\?.*)?$", u, ignore.case = TRUE)]
      if (!length(cand)) cand <- u[1]
      
      # Set link type so the viewer knows how to render
      typ <- if (grepl("\\.(png|jpe?g|gif|webp)$", cand[1], ignore.case = TRUE)) {
        "image"
      } else if (grepl("\\.pdf(\\?.*)?$", cand[1], ignore.case = TRUE)) {
        "pdf"
      } else {
        "video"
      }
      
      url_safe <- htmltools::htmlEscape(cand[1])
      att_html[i] <- sprintf('<a href="%1$s" class="open-media" data-url="%1$s" data-type="%2$s">Open attachment</a>', url_safe, typ)
    }
    
    # Plain-note display (strip the attachment anchor and any other tags)
    note_plain <- note_raw
    note_plain <- gsub(anchor_pat, "", note_plain, perl = TRUE, ignore.case = TRUE)
    note_plain <- gsub("<[^>]+>", "", note_plain, perl = TRUE)
    note_plain <- trimws(note_plain)
    
    show <- data.frame(
      Author     = df$author_email,
      Date       = fmt_mdy(as.Date(ct)),
      Filter     = filter_html,   # clickable jump
      Note       = note_plain,    # safe, plain text
      Attachment = att_html,      # clickable "Open attachment"
      stringsAsFactors = FALSE
    )
    
    DT::datatable(
      show,
      # Escape Author, Date, Note; leave Filter & Attachment unescaped so links work
      escape   = c(1, 2, 4),
      rownames = FALSE,
      options  = list(pageLength = 25, order = list(list(1, "desc")))
    )
  }
  
  
  
  output$notesTable <- DT::renderDataTable({
    notes_version()                 # keep the refresh trigger
    
    out <- notes_reload()
    
    # If notes_reload() already returns a datatable/htmlwidget, just return it
    if (inherits(out, "htmlwidget") || inherits(out, "datatables")) {
      return(out)
    }
    
    # Otherwise, treat it as a data.frame and build the table here
    out <- as.data.frame(out, stringsAsFactors = FALSE, check.names = FALSE)
    
    DT::datatable(
      out,
      escape   = FALSE,             # needed so the "Open attachment" link renders
      rownames = FALSE,
      options  = list(dom = 'Bfrtip', pageLength = 10)
    )
  })
  
  # Optional: render even when hidden so it refreshes when you click into Notes
  outputOptions(output, "notesTable", suspendWhenHidden = FALSE)
  
  
  
  # --- When a note’s Filter is clicked, jump to that view ---
  # Requires: later
  observeEvent(input$noteJump, {
    x <- input$noteJump
    noteJumping(TRUE)  # pause auto-date logic
    
    updateTabsetPanel(session, "top", selected = x$suite)
    
    later::later(function() {
      if (nzchar(x$sess))    updateSelectInput(session, "sessionType", selected = x$sess)
      if (nzchar(x$pitcher)) updateSelectInput(session, "pitcher",      selected = x$pitcher)
      if (nzchar(x$ds) && nzchar(x$de))
        updateDateRangeInput(session, "dates", start = as.Date(x$ds), end = as.Date(x$de))
      # sub-tabs by suite
      if (identical(x$suite, "Pitching")) {
        if (nzchar(x$page)) updateTabsetPanel(session, "tabs", selected = x$page)
      } else if (identical(x$suite, "Hitting")) {
        if (nzchar(x$page)) updateTabsetPanel(session, "hit-tabs", selected = x$page)
      } else if (identical(x$suite, "Catching")) {
        if (nzchar(x$page)) updateTabsetPanel(session, "catch-tabs", selected = x$page)
      } else if (identical(x$suite, "Leaderboard")) {
        if (nzchar(x$page)) updateTabsetPanel(session, "leader-tabs", selected = x$page)
      } else if (identical(x$suite, "Comparison Suite") || identical(x$suite, "Comparison Tool")) {
        if (nzchar(x$page)) updateTabsetPanel(session, "comp-tabs", selected = x$page)
      }
      later::later(function() noteJumping(FALSE), delay = 0.6)
    }, delay = 0.3)
  }, ignoreInit = TRUE)
  
  # Set date once on startup
  observeEvent(TRUE, {
    req(input$sessionType, input$pitcher)
    df_base <- if (input$sessionType == "All") pitch_data_pitching else
      dplyr::filter(pitch_data_pitching, SessionType == input$sessionType)
    
    last_date <- if (input$pitcher == "All") {
      max(df_base$Date, na.rm = TRUE)
    } else {
      mx <- max(df_base$Date[df_base$Pitcher == input$pitcher], na.rm = TRUE)
      if (is.finite(mx)) mx else max(df_base$Date, na.rm = TRUE)
    }
    if (is.finite(last_date)) {
      updateDateRangeInput(session, "dates", start = last_date, end = last_date)
    }
  }, once = TRUE)
  
  # Update date only when the *user* changes pitcher (and not during a note jump)
  # Now respects global date range persistence instead of resetting to last date
  observeEvent(input$pitcher, {
    if (isTRUE(noteJumping())) return()
    req(input$pitcher)
    
    # If we have a global date range set, use it instead of resetting to last date
    if (!is.null(global_date_range())) {
      # Only update if the dates are actually different to prevent loops
      current_input <- input$dates
      global_dates <- global_date_range()
      if (is.null(current_input) || 
          !identical(as.Date(current_input), as.Date(global_dates))) {
        updateDateRangeInput(session, "dates", 
                             start = global_dates[1], 
                             end = global_dates[2])
      }
    } else {
      # Only fall back to last date if no global date range is set
      last_date <- if (input$pitcher == "All") {
        max(pitch_data_pitching$Date, na.rm = TRUE)
      } else {
        max(pitch_data_pitching$Date[pitch_data_pitching$Pitcher == input$pitcher], na.rm = TRUE)
      }
      if (is.finite(last_date)) {
        updateDateRangeInput(session, "dates", start = last_date, end = last_date)
        # Update global date range with this new value
        global_date_range(c(last_date, last_date))
      }
    }
  }, ignoreInit = TRUE)
  
  
  # define once near top of server() if not already
  note_saving <- reactiveVal(FALSE)
  
  # single, guarded save handler
  observeEvent(input$save_note, {
    if (isTRUE(note_saving())) return(invisible(NULL))  # prevents double fires
    note_saving(TRUE); on.exit(note_saving(FALSE), add = TRUE)
    
    removeModal()
    
    # --- base note text ---
    # if you don't have %or%, use your existing %||%
    note <- input$note_text %or% ""
    if (!nzchar(note)) {
      showNotification("Note is empty—nothing saved.", type = "warning")
      return()
    }
    
    # ---- optional media upload ---- (PATCHED)
    media_html <- ""
    if (!is.null(input$note_media) && nzchar(input$note_media$datapath)) {
      if (!nzchar(CLOUDINARY_CLOUD_NAME) || !nzchar(CLOUDINARY_UPLOAD_PRESET)) {
        showNotification("Attachment not saved: Cloudinary is not configured.", type = "error")
      } else {
        up <- tryCatch(
          upload_media_cloudinary(input$note_media$datapath),
          error = function(e) {
            showNotification(paste("Attachment upload failed:", e$message), type = "error")
            NULL
          }
        )
        if (!is.null(up) && !is.null(up$url) && nzchar(up$url)) {
          if (grepl("\\.pdf(\\?.*)?$", up$url, ignore.case = TRUE) ||
              grepl("pdf", (up$type %||% ""), ignore.case = TRUE) ||
              (grepl("raw", (up$type %||% ""), ignore.case = TRUE) && grepl("\\.pdf(\\?.*)?$", up$url, ignore.case = TRUE))) {
            mtype <- "pdf"
          } else if (grepl("image", up$type, ignore.case = TRUE) ||
                     grepl("\\.(png|jpe?g|gif|webp)$", up$url, ignore.case = TRUE)) {
            mtype <- "image"
          } else {
            mtype <- "video"
          }
          media_html <- sprintf(
            '<br><a href="%s" class="open-media" data-url="%s" data-type="%s">Open attachment</a>',
            htmltools::htmlEscape(up$url), htmltools::htmlEscape(up$url), mtype
          )
        }
      }
    }
    
    # append the attachment link (if any) to the note text
    if (nzchar(media_html)) note <- paste0(note, media_html)
    
    # --- context for the note ---
    ds <- input$dates[1]; de <- input$dates[2]
    pit <- input$pitcher     %or% "All"
    st  <- input$sessionType %or% "All"
    sui <- current_suite();  pag <- current_page()
    page_combo <- paste0(sui, "::", pag %or% "")
    
    # --- save via API ---
    ok <- tryCatch({
      notes_api_add(
        author_email = user_email(),
        team         = "osu",
        page_combo   = page_combo,
        pitcher      = pit,
        session_type = st,
        date_start   = ds,
        date_end     = de,
        note_text    = note          # <-- use the augmented text here
      )
      TRUE
    }, error = function(e) {
      showNotification(paste("Notes: save failed (", e$message, ")"), type = "error")
      FALSE
    })
    
    if (isTRUE(ok)) {
      # bump trigger so the Notes table refreshes
      notes_version(isolate(notes_version()) + 1L)
      if (identical(input$top, "Notes")) {
        notes_version(isolate(notes_version()) + 1L)
      }
      showNotification("Note saved.", type = "message")
    }
  }, ignoreInit = TRUE)
  
  
  observeEvent(input$countFilter, {
    sel <- input$countFilter
    if (is.null(sel) || !length(sel)) {
      updateSelectInput(session, "countFilter", selected = "All")
    } else if ("All" %in% sel && length(sel) > 1) {
      updateSelectInput(session, "countFilter", selected = setdiff(sel, "All"))
    }
  }, ignoreInit = TRUE)
  
  # Deep-link support: /?tab=Hitting
  observeEvent(TRUE, {
    qs <- shiny::parseQueryString(session$clientData$url_search)  # Shiny exposes this in session$clientData
    if (!is.null(qs$tab)) updateNavbarPage(session, "top", selected = qs$tab)
  }, once = TRUE)  # session$clientData reference: docs.posit.co/shiny session reference
  # (Note: Shiny exposes url_* in session$clientData.) :contentReference[oaicite:2]{index=2}
  
  # Mount the new modules (lazy-run only when their tab is active)
  mod_hit_server("hit",     is_active = reactive(input$top == "Hitting"), global_date_range = global_date_range)
  mod_catch_server("catch", is_active = reactive(input$top == "Catching"), global_date_range = global_date_range)
  mod_leader_server("leader", is_active = reactive(input$top == "Leaderboard"), global_date_range = global_date_range)
  mod_comp_server("comp",   is_active = reactive(input$top == "Comparison Suite"), global_date_range = global_date_range)
  
  
  # Buttons above Summary table
  output$summaryTableButtons <- renderUI({
    # preserve current selection if it exists; default to "Stuff"
    ct_names <- names(custom_tables())
    sel <- isolate(input$summaryTableMode)
    if (is.null(sel)) sel <- "Stuff"
    split_sel <- isolate(input$summarySplitBy)
    if (is.null(split_sel)) split_sel <- "Pitch Types"
    
    tagList(
      div(style = "display: flex; align-items: center; gap: 15px;",
          div(style = "flex: 0 0 auto;",
              div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Tables:"),
              selectInput(
                "summaryTableMode", label = NULL,
                choices = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data", ct_names, "Batted Ball Data", "Custom"),
                selected = sel,
                width = "120px"
              )
          ),
          div(style = "flex: 0 0 auto;",
              checkboxInput(
                "summaryTableColors", 
                label = "Color-Code", 
                value = TRUE,
                width = "80px"
              )
          ),
          div(style = "flex: 0 0 auto;",
              div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Split By:"),
              selectInput(
                "summarySplitBy", label = NULL,
                choices = c("Pitch Types", "Batter Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Batter"),
                selected = split_sel,
                width = "140px"
              )
          )
      ),
      # show the picker purely on the client; avoids re-render loops
      conditionalPanel(
        "input.summaryTableMode=='Custom'",
        tagList(
          selectInput("summaryCustomSaved", "Saved Table:", choices = c("", names(custom_tables())), selected = ""),
          textInput("summaryCustomName", "Name:", value = ""),
          selectizeInput(
            "summaryCustomCols", label = "Columns (drag to order):",
            choices  = setdiff(all_table_cols, "Pitch"),
            multiple = TRUE,
            options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
          ),
          if (isTRUE(is_admin())) {
            checkboxInput("summaryCustomGlobal", "Share with all schools (admin)", value = FALSE)
          },
          actionButton("summarySaveCustom", "Save / Update", class = "btn-primary btn-sm"),
          actionButton("summaryDeleteCustom", "Delete", class = "btn-danger btn-sm")
        )
      )
    )
  })
  
  
  # Buttons above Data & Performance table
  output$dpTableButtons <- renderUI({
    # preserve current selection if it exists; default to "Stuff"
    ct_names <- names(custom_tables())
    sel <- isolate(input$dpTableMode)
    if (is.null(sel)) sel <- "Stuff"
    split_sel <- isolate(input$dpSplitBy)
    if (is.null(split_sel)) split_sel <- "Pitch Types"
    
    tagList(
      div(style = "display: flex; align-items: center; gap: 15px;",
          div(style = "flex: 0 0 auto;",
              div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Tables:"),
              selectInput(
                "dpTableMode", label = NULL,
                choices = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data", ct_names, "Batted Ball Data", "Custom"),
                selected = sel,
                width = "120px"
              )
          ),
          div(style = "flex: 0 0 auto;",
              checkboxInput(
                "dpTableColors", 
                label = "Color-Code", 
                value = TRUE,
                width = "80px"
              )
          ),
          div(style = "flex: 0 0 auto;",
              div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Split By:"),
              selectInput(
                "dpSplitBy", label = NULL,
                choices = c("Pitch Types", "Batter Hand", "Count", "After Count", "Velocity", "IVB", "HB", "Batter"),
                selected = split_sel,
                width = "140px"
              )
          )
      ),
      # show the picker purely on the client; avoids re-render loops
      conditionalPanel(
        "input.dpTableMode=='Custom'",
        tagList(
          selectInput("dpCustomSaved", "Saved Table:", choices = c("", names(custom_tables())), selected = ""),
          textInput("dpCustomName", "Name:", value = ""),
          selectizeInput(
            "dpCustomCols", label = "Columns (drag to order):",
            choices  = setdiff(all_table_cols, "Pitch"),
            multiple = TRUE,
            options  = list(plugins = list("drag_drop","remove_button"), placeholder = "Choose columns…")
          ),
          if (isTRUE(is_admin())) {
            checkboxInput("dpCustomGlobal", "Share with all schools (admin)", value = FALSE)
          },
          actionButton("dpSaveCustom", "Save / Update", class = "btn-primary btn-sm"),
          actionButton("dpDeleteCustom", "Delete", class = "btn-danger btn-sm")
        )
      )
    )
  })
  
  
  
  output$leaderboardButtons <- renderUI({
    sel <- isolate(input$leaderboardMode)
    if (is.null(sel)) sel <- "Stuff"
    
    tagList(
      radioButtons(
        "leaderboardMode", label = NULL,
        choices  = c("Stuff","Process","Results","Bullpen","Live","Usage","Raw Data","Custom"),
        selected = sel,
        inline   = TRUE
      ),
      conditionalPanel(
        "input.leaderboardMode=='Custom'",
        selectizeInput(
          "leaderboardCustomCols", label = NULL,
          choices  = setdiff(all_table_cols, "Pitch"),
          multiple = TRUE,
          options  = list(placeholder = "Choose columns to show…")
        )
      )
    )
  })
  
  # 1) Pitcher selector
  output$pitcher_ui <- renderUI({
    req(input$sessionType, input$teamType)
    
    df_base <- if (input$sessionType == "All") pitch_data_pitching else
      dplyr::filter(pitch_data_pitching, SessionType == input$sessionType)
    
    # Apply team filtering to get the available pitchers
    if (input$teamType == "Campers") {
      df_base <- dplyr::filter(df_base, Pitcher %in% ALLOWED_CAMPERS)
    } else if (input$teamType == TEAM_CODE) {
      # Filter to only GCU allowed pitchers (exclude campers)
      df_base <- dplyr::filter(df_base, Pitcher %in% ALLOWED_PITCHERS)
    }
    # If "All" is selected, df_base already contains all pitchers
    
    # Create name map for the filtered dataset
    raw_names_team <- sort(unique(df_base$Pitcher))
    display_names_team <- ifelse(
      grepl(",", raw_names_team),
      vapply(strsplit(raw_names_team, ",\\s*"), function(x) paste(x[2], x[1]), ""),
      raw_names_team
    )
    name_map_team <- setNames(raw_names_team, display_names_team)
    
    # Determine which pitchers the user can see:
    # - Admins: all pitchers
    # - Coaches: all pitchers  
    # - Players: only pitchers where Email matches their login email
    if (is_admin() || is_coach()) {
      # Coaches and admins see all pitchers in filtered dataset
      sel_raw <- unique(df_base$Pitcher) %>% na.omit()
    } else {
      # Players see only their own data (matched by email)
      sel_raw <- unique(df_base$Pitcher[norm_email(df_base$Email) == norm_email(user_email())]) %>% na.omit()
    }
    
    # Admins AND coaches get the "All" option
    if (is_admin() || is_coach()) {
      # Check if current selection is still valid, otherwise default to "All"
      current_selection <- isolate(input$pitcher)
      if (is.null(current_selection) || !(current_selection %in% c("All", raw_names_team))) {
        current_selection <- "All"
      }
      
      selectInput(
        "pitcher", "Select Pitcher:",
        choices  = c("All" = "All", name_map_team),
        selected = current_selection
      )
    } else if (length(sel_raw) > 0) {
      # Players see only their pitchers (filtered by email)
      # Use the team-specific name map, but only show their pitchers
      player_display_names <- display_names_team[raw_names_team %in% sel_raw]
      player_map <- setNames(sel_raw, player_display_names)
      
      selectInput("pitcher", "Select Pitcher:", 
                  choices = player_map, 
                  selected = sel_raw[1])
    } else {
      selectInput("pitcher", "Select Pitcher:", 
                  choices = "No data", 
                  selected = "No data")
    }
  })
  
  
  observeEvent(list(input$sessionType, input$teamType), {
    req(input$sessionType, input$teamType)
    
    df_base <- if (input$sessionType == "All") pitch_data_pitching else
      dplyr::filter(pitch_data_pitching, SessionType == input$sessionType)
    
    # Apply team filtering
    if (input$teamType == "Campers") {
      df_base <- dplyr::filter(df_base, Pitcher %in% ALLOWED_CAMPERS)
    } else if (input$teamType == TEAM_CODE) {
      df_base <- dplyr::filter(df_base, Pitcher %in% ALLOWED_PITCHERS)
    }
    # If "All" is selected, don't filter - show all data
    
    last_date <- if (is.null(input$pitcher) || input$pitcher == "All") {
      max(df_base$Date, na.rm = TRUE)
    } else {
      ld <- max(df_base$Date[df_base$Pitcher == input$pitcher], na.rm = TRUE)
      if (is.finite(ld)) ld else max(df_base$Date, na.rm = TRUE)
    }
    updateDateRangeInput(session, "dates", start = last_date, end = last_date)
  }, ignoreInit = TRUE)
  
  # 2) Filtered data
  filtered_data <- reactive({
    req(input$sessionType, input$hand, input$zoneLoc, input$inZone, input$qpLocations, input$teamType)
    
    is_valid_dates <- function(d) !is.null(d) && length(d) == 2 && all(is.finite(d))
    nnz <- function(x) !is.null(x) && !is.na(x)
    
    if (!is_valid_dates(input$dates)) return(modified_pitch_data()[0, , drop = FALSE])
    
    pitch_types <- if (is.null(input$pitchType) || !length(input$pitchType)) "All" else input$pitchType
    
    # Session type - use modified data instead of original
    df <- if (identical(input$sessionType, "All")) modified_pitch_data()
    else dplyr::filter(modified_pitch_data(), SessionType == input$sessionType)
    
    # ⛔️ Team filtering - Filter by team selection ⛔️
    if (!is.null(input$teamType)) {
      if (input$teamType == "Campers") {
        # Filter to only allowed campers
        df <- dplyr::filter(df, Pitcher %in% ALLOWED_CAMPERS)
      }
      # If "GCU" is selected, use the existing data (already filtered to ALLOWED_PITCHERS)
    }
    
    # ⛔️ Drop warmups & blank pitch types
    if ("TaggedPitchType" %in% names(df)) {
      df <- df %>%
        dplyr::mutate(.tpt = trimws(as.character(TaggedPitchType))) %>%
        dplyr::filter(!is.na(.tpt) & nzchar(.tpt)) %>%
        dplyr::select(-.tpt)
    }
    if ("PitchSession" %in% names(df)) {
      df <- dplyr::filter(df, is.na(PitchSession) | PitchSession != "Warmup")
    }
    
    # Live-only BatterSide
    if (!is.null(input$batterSide) && input$batterSide != "All") {
      df <- df %>% dplyr::filter(SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide))
    }
    
    # Dates
    df <- dplyr::filter(df, Date >= input$dates[1], Date <= input$dates[2])
    
    # Pitcher & hand
    pick <- input$pitcher
    if (!is.null(pick) && pick != "All" && pick != "No data") {
      # Filter by exact pitcher name match
      df <- dplyr::filter(df, Pitcher == pick)
      # If no data after filtering, might be a name format mismatch - log warning
      if (nrow(df) == 0) {
        message("Warning: No data found for pitcher '", pick, "'. Available pitchers: ", 
                paste(unique(pitch_data_pitching$Pitcher)[1:min(5, length(unique(pitch_data_pitching$Pitcher)))], collapse = ", "))
      }
    }
    
    # Opponent Hitter filter
    hitter_pick <- input$oppHitter
    if (!is.null(hitter_pick) && hitter_pick != "All") {
      df <- dplyr::filter(df, Batter == hitter_pick)
    }
    
    if (!is.null(input$hand) && input$hand != "All")       df <- dplyr::filter(df, PitcherThrows == input$hand)
    
    # Spatial & count
    df <- enforce_zone(df, input$zoneLoc)
    df <- enforce_inzone(df, input$inZone)
    df <- filter_qp_locations(df, input$qpLocations)
    df <- apply_count_filter(df, input$countFilter)
    df <- apply_after_count_filter(df, input$afterCountFilter)
    df <- apply_pitch_results_filter(df, input$pitchResults)
    
    # With Video filter
    if (!is.null(input$withVideo) && input$withVideo != "All") {
      vid1 <- nzchar(ifelse(is.na(df$VideoClip),  "", df$VideoClip))
      vid2 <- nzchar(ifelse(is.na(df$VideoClip2), "", df$VideoClip2))
      vid3 <- nzchar(ifelse(is.na(df$VideoClip3), "", df$VideoClip3))
      has_video <- vid1 | vid2 | vid3
      if (identical(input$withVideo, "Yes")) {
        df <- dplyr::filter(df, has_video)
      } else if (identical(input$withVideo, "No")) {
        df <- dplyr::filter(df, !has_video)
      }
    }
    
    # Numeric ranges
    if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed         >= input$veloMin)
    if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed         <= input$veloMax)
    if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
    if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
    if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak        >= input$hbMin)
    if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak        <= input$hbMax)
    
    # Pitch-number window
    df <- df %>% dplyr::arrange(Date) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
    if (nnz(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
    if (nnz(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
    
    # Per-user visibility: Coaches see all, Players see only their own data
    if (!is_admin() && !is_coach()) {
      ue <- user_email()
      if (!is.na(ue)) df <- dplyr::filter(df, norm_email(Email) == norm_email(ue))
    }
    
    if (!nrow(df)) return(df[0, , drop = FALSE])
    
    # Derived fields
    df2 <- compute_stuff_simple(df, base_type = input$stuffBase, level = input$stuffLevel) %>%
      force_pitch_levels() %>%
      dplyr::mutate(Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels))
    
    # Pitch type after derive
    if (!("All" %in% pitch_types)) df2 <- dplyr::filter(df2, TaggedPitchType %in% pitch_types)
    
    df2
  })
  
  # 3) helper for ordered types
  ordered_types <- function() {
    intersect(names(all_colors), unique(filtered_data()$TaggedPitchType))
  }
  
  # 4) Leaderboard data
  leaderboard_data <- reactive({
    req(input$sessionType, input$dates, input$hand, input$zoneLoc, input$inZone, input$qpLocations)
    
    # protect against NULL during app init
    pitch_types <- if (is.null(input$pitchType)) "All" else input$pitchType
    
    # first, honor Session Type
    df <- if (input$sessionType == "All") pitch_data_pitching else
      dplyr::filter(pitch_data_pitching, SessionType == input$sessionType)
    
    # Live-only BatterSide filter
    if (!is.null(input$batterSide) && input$batterSide != "All") {
      df <- df %>% dplyr::filter(
        SessionType != "Live" | (SessionType == "Live" & BatterSide == input$batterSide)
      )
    }
    
    # existing filters...
    df <- df %>% dplyr::filter(Date >= input$dates[1], Date <= input$dates[2])
    picks <- input$pitcher
    if (!is.null(picks) && length(picks) && !("All" %in% picks)) {
      df <- dplyr::filter(df, Pitcher %in% picks)
    }
    if (input$hand != "All")    df <- dplyr::filter(df, PitcherThrows == input$hand)
    
    df <- enforce_zone(df, input$zoneLoc)
    df <- enforce_inzone(df, input$inZone)
    df <- filter_qp_locations(df, input$qpLocations)
    df <- apply_count_filter(df, input$countFilter)
    df <- apply_pitch_results_filter(df, input$pitchResults)
    if (!is.na(input$veloMin)) df <- dplyr::filter(df, RelSpeed >= input$veloMin)
    if (!is.na(input$veloMax)) df <- dplyr::filter(df, RelSpeed <= input$veloMax)
    if (!is.na(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
    if (!is.na(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
    if (!is.na(input$hbMin))   df <- dplyr::filter(df, HorzBreak >= input$hbMin)
    if (!is.na(input$hbMax))   df <- dplyr::filter(df, HorzBreak <= input$hbMax)
    
    # With Video filter (leaderboard)
    if (!is.null(input$withVideo) && input$withVideo != "All") {
      vid1 <- nzchar(ifelse(is.na(df$VideoClip),  "", df$VideoClip))
      vid2 <- nzchar(ifelse(is.na(df$VideoClip2), "", df$VideoClip2))
      vid3 <- nzchar(ifelse(is.na(df$VideoClip3), "", df$VideoClip3))
      has_video <- vid1 | vid2 | vid3
      if (identical(input$withVideo, "Yes")) {
        df <- dplyr::filter(df, has_video)
      } else if (identical(input$withVideo, "No")) {
        df <- dplyr::filter(df, !has_video)
      }
    }
    
    df <- df %>% dplyr::arrange(Date) %>% dplyr::mutate(PitchNumber = dplyr::row_number())
    if (!is.na(input$pcMin)) df <- dplyr::filter(df, PitchNumber >= input$pcMin)
    if (!is.na(input$pcMax)) df <- dplyr::filter(df, PitchNumber <= input$pcMax)
    
    if (!is_admin()) {
      ue <- user_email()
      if (!is.na(ue)) df <- dplyr::filter(df, Email == ue)
    }
    
    
    df2 <- compute_stuff_simple(df, input$stuffBase, input$stuffLevel) %>%
      force_pitch_levels() %>%
      dplyr::mutate(Result = factor(compute_result(PitchCall, PlayResult), levels = result_levels))
    
    if (!("All" %in% pitch_types)) df2 <- dplyr::filter(df2, TaggedPitchType %in% pitch_types)
    df2
  })
  
  format_trend_value <- function(x, digits = 1) {
    if (!length(x) || all(is.na(x))) return(rep(NA_character_, length(x)))
    out <- round(x, digits)
    out[!is.finite(out)] <- NA
    out
  }
  
  trend_girafe_plot <- function(dat, title, ylab, digits = 1) {
    if (!nrow(dat)) return(NULL)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    
    date_levels <- unique(fmt_date(dat$Date))
    dat <- dplyr::mutate(dat, Date_f = factor(fmt_date(Date), levels = date_levels))
    
    # Build tooltip text
    dat <- dat %>%
      dplyr::mutate(
        total_pitches = if ("total_pitches" %in% names(.)) total_pitches else NA_real_,
        value_disp    = format_trend_value(value, digits = digits),
        data_id_val   = if ("SessionType" %in% names(.)) paste0(Date_f, "_", SessionType) else as.character(Date_f),
        tooltip = paste0(
          if ("SessionType" %in% names(.)) paste0("Session: ", SessionType, "<br/>") else "",
          "Date: ", fmt_date(Date), "<br/>",
          title, ": ", ifelse(is.na(value_disp), "—", value_disp), "<br/>",
          "Pitches: ", ifelse(is.na(total_pitches), "—", total_pitches)
        )
      )
    
    if ("SessionType" %in% names(dat)) {
      p <- ggplot(dat, aes(Date_f, value, group = SessionType, color = SessionType,
                           tooltip = tooltip, data_id = data_id_val)) +
        ggiraph::geom_line_interactive(size = 1.2, na.rm = TRUE) +
        ggiraph::geom_point_interactive(size = 2.5, na.rm = TRUE) +
        scale_color_manual(values = session_cols, breaks = c("Live", "Bullpen"), name = NULL) +
        labs(title = title, x = NULL, y = ylab) +
        theme_minimal() + axis_theme + grid_theme(dark_on) +
        theme(
          plot.title = element_text(face = "bold", color = axis_col),
          axis.text.x = element_text(angle = 45, hjust = 1, color = axis_col),
          axis.text.y = element_text(color = axis_col),
          legend.position = "bottom",
          legend.text = element_text(color = axis_col)
        )
    } else {
      p <- ggplot(dat, aes(Date_f, value, group = 1,
                           tooltip = tooltip, data_id = data_id_val)) +
        ggiraph::geom_line_interactive(size = 1.2, na.rm = TRUE) +
        ggiraph::geom_point_interactive(size = 2.5, na.rm = TRUE) +
        labs(title = title, x = NULL, y = ylab) +
        theme_minimal() + axis_theme + grid_theme(dark_on) +
        theme(
          plot.title = element_text(face = "bold", color = axis_col),
          axis.text.x = element_text(angle = 45, hjust = 1, color = axis_col),
          axis.text.y = element_text(color = axis_col),
          legend.position = "none"
        )
    }
    
    girafe_transparent(
      ggobj   = p,
      options = list(
        ggiraph::opts_hover_inv(css = "opacity:0.1;"),
        ggiraph::opts_hover(css = "stroke-width:2;"),
        ggiraph::opts_tooltip(use_fill = TRUE, css = tooltip_css, opacity = 0.9)
      )
    )
  }
  
  trend_plot <- function(df, val_expr, title, ylab, fun = mean, digits = 1) {
    agg <- function(x) {
      x <- x[!is.na(x)]
      if (!length(x)) return(NA_real_)
      fun(x)
    }
    if (input$sessionType == "All") {
      dat <- df %>%
        dplyr::group_by(Date, SessionType) %>%
        dplyr::summarise(
          value = agg({{ val_expr }}),
          total_pitches = dplyr::n(),
          .groups = "drop"
        ) %>%
        dplyr::arrange(Date)
    } else {
      dat <- df %>%
        dplyr::group_by(Date) %>%
        dplyr::summarise(
          value = agg({{ val_expr }}),
          total_pitches = dplyr::n(),
          .groups = "drop"
        ) %>%
        dplyr::arrange(Date)
    }
    
    trend_girafe_plot(dat, title, ylab, digits = digits)
  }
  
  output$summaryHeader <- renderUI({
    df <- filtered_data()
    
    # Safe reads
    pit <- input$pitcher
    dts <- input$dates
    
    # Metrics with empty-safe fallbacks
    scores <- if (nrow(df)) {
      ifelse(
        df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
          df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
        ifelse(
          df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
            df$PlateLocHeight >= (2.65 - 1.5) & df$PlateLocHeight <= (2.65 + 1.5),
          0.73, 0
        )
      )
    } else numeric(0)
    
    overall_stuff   <- if (nrow(df)) round(mean(df$`Stuff+`, na.rm = TRUE), 1) else NA_real_
    overall_command <- if (length(scores)) round(mean(scores,   na.rm = TRUE) * 100, 1) else NA_real_
    overall_pitch   <- round(mean(c(overall_stuff, overall_command), na.rm = TRUE), 1)
    
    # Title
    title <- if (is.null(pit) || identical(pit, "All")) {
      "All Pitchers"
    } else {
      disp <- names(name_map)[name_map == pit]
      if (length(disp)) disp else pit
    }
    
    # Dates string
    dates_str <- if (!is.null(dts) && length(dts) == 2 && all(is.finite(dts))) {
      if (identical(as.Date(dts[1]), as.Date(dts[2]))) fmt_date(dts[1]) else
        paste(fmt_date(dts[1]), fmt_date(dts[2]), sep = " - ")
    } else {
      rng <- suppressWarnings(range(df$Date, na.rm = TRUE))
      if (all(is.finite(rng))) paste(fmt_date(rng[1]), fmt_date(rng[2]), sep = " - ") else "All Dates"
    }
    
    tags$div(
      style = "display:flex; align-items:center; justify-content:space-between;",
      tags$img(src = "PCUlogo.png", height = "50px", style = "margin-right:15px;"),
      tags$h3(paste(title, "|", dates_str), style = "font-weight:bold; margin:0; flex:1;"),
      tags$div(
        style = "font-weight:bold; margin-left:20px;",
        paste0("Stuff+: ",   ifelse(is.finite(overall_stuff), overall_stuff,   "—"), " | "),
        paste0("Ctrl+: ",    ifelse(is.finite(overall_command), overall_command, "—"), " | "),
        paste0("Pitching+: ",ifelse(is.finite(overall_pitch), overall_pitch,   "—"))
      )
    )
  })
  
  
  # ---- Sessions Logs (Pitching) ----
  filtered_logs <- reactive({
    # --- helpers (tweaked date validator; added safe path->date fallback) ---
    is_valid_dates <- function(d) {
      if (is.null(d) || length(d) != 2) return(FALSE)
      a <- suppressWarnings(as.Date(d[1], tryFormats = c("%Y-%m-%d","%m/%d/%Y","%m/%d/%y")))
      b <- suppressWarnings(as.Date(d[2], tryFormats = c("%Y-%m-%d","%m/%d/%Y","%m/%d/%y")))
      !any(is.na(c(a, b)))
    }
    
    nnz <- function(x) !is.null(x) && !is.na(x)
    
    # Try to recover a date from SourceFile path when CSV "Date" fails
    .date_from_path <- function(paths) {
      v <- vapply(as.character(paths), function(p) {
        s <- as.character(p)
        
        # Try /YYYY/MM/DD/ or YYYY-MM-DD in the path
        m <- regexpr("(20\\d{2})[/-](0[1-9]|1[0-2])[/-]([0-3]\\d)", s, perl = TRUE)
        if (m[1] != -1) {
          frag <- substr(s, m[1], m[1] + attr(m, "match.length") - 1)
          frag <- gsub("/", "-", frag)
          out  <- suppressWarnings(as.Date(frag))
          if (!is.na(out)) return(format(out, "%Y-%m-%d"))
        }
        
        # Try 8-digit yyyymmdd in filename
        m2 <- regexpr("(20\\d{2})(0[1-9]|1[0-2])([0-3]\\d)", s, perl = TRUE)
        if (m2[1] != -1) {
          y  <- substr(s, m2[1],     m2[1] + 3)
          mo <- substr(s, m2[1] + 4, m2[1] + 5)
          d  <- substr(s, m2[1] + 6, m2[1] + 7)
          out <- suppressWarnings(as.Date(paste(y, mo, d, sep = "-")))
          if (!is.na(out)) return(format(out, "%Y-%m-%d"))
        }
        
        ""  # no match
      }, FUN.VALUE = character(1))
      suppressWarnings(as.Date(ifelse(nzchar(v), v, NA_character_)))
    }
    # ------------------------------------------------------------------------
    
    df <- pitch_data_pitching
    
    # Ensure Date exists & is Date
    if (!("Date" %in% names(df))) {
      cand <- intersect(c("GameDate","SessionDate","date","DATE"), names(df))
      if (length(cand)) df$Date <- df[[cand[1]]] else df$Date <- NA
    }
    # Your existing parser
    df$Date <- .s_to_date(df$Date)
    
    # Fill any remaining NA Date from SourceFile path, if available
    if ("SourceFile" %in% names(df)) {
      miss <- is.na(df$Date)
      if (any(miss)) {
        df$Date[miss] <- .date_from_path(df$SourceFile[miss])
      }
    }
    
    # If date input isn't ready yet, use full data range (prevents blank table)
    # If the range is still not finite (e.g., all NA), we skip narrowing by dates later.
    if (!is_valid_dates(input$dates)) {
      rng <- suppressWarnings(range(df$Date, na.rm = TRUE))
      date_start <- rng[1]; date_end <- rng[2]
    } else {
      date_start <- as.Date(input$dates[1]); date_end <- as.Date(input$dates[2])
    }
    have_valid_range <- is.finite(date_start) && is.finite(date_end)
    
    # Session Type
    if (!is.null(input$sessionType) && input$sessionType != "All") {
      df <- dplyr::filter(df, SessionType == input$sessionType)
    }
    
    # Keep warmups out; DO NOT drop blank TaggedPitchType here
    if ("PitchSession" %in% names(df)) {
      df <- dplyr::filter(df, is.na(PitchSession) | PitchSession != "Warmup")
    }
    
    # Live-only BatterSide
    if (!is.null(input$batterSide) && input$batterSide != "All") {
      df <- df %>%
        dplyr::filter(SessionType != "Live" |
                        (SessionType == "Live" & BatterSide == input$batterSide))
    }
    
    # Date window (only if we have a real range; otherwise just drop NA Date)
    if (have_valid_range) {
      df <- dplyr::filter(df, !is.na(Date), Date >= date_start, Date <= date_end)
    } else {
      df <- dplyr::filter(df, !is.na(Date))
    }
    
    # Pitcher & hand
    if (!is.null(input$pitcher) && input$pitcher != "All") {
      df <- dplyr::filter(df, Pitcher == input$pitcher)
    }
    
    # NEW: Opponent Hitter filter
    if (!is.null(input$oppHitter) && input$oppHitter != "All") {
      # Only filter if the hitter exists in the Batter column
      if (input$oppHitter %in% df$Batter) {
        df <- dplyr::filter(df, Batter == input$oppHitter)
      }
    }
    
    if (!is.null(input$hand) && input$hand != "All") {
      df <- dplyr::filter(df, PitcherThrows == input$hand)
    }
    
    # Same zone/count/numeric filters as elsewhere (guarded with exists())
    if (exists("enforce_zone"))       df <- enforce_zone(df, input$zoneLoc)
    if (exists("enforce_inzone"))     df <- enforce_inzone(df, input$inZone)
    if (exists("filter_qp_locations")) df <- filter_qp_locations(df, input$qpLocations)
    if (exists("apply_count_filter")) df <- apply_count_filter(df, input$countFilter)
    
    if (nnz(input$veloMin)) df <- dplyr::filter(df, RelSpeed         >= input$veloMin)
    if (nnz(input$veloMax)) df <- dplyr::filter(df, RelSpeed         <= input$veloMax)
    if (nnz(input$ivbMin))  df <- dplyr::filter(df, InducedVertBreak >= input$ivbMin)
    if (nnz(input$ivbMax))  df <- dplyr::filter(df, InducedVertBreak <= input$ivbMax)
    if (nnz(input$hbMin))   df <- dplyr::filter(df, HorzBreak        >= input$hbMin)
    if (nnz(input$hbMax))   df <- dplyr::filter(df, HorzBreak        <= input$hbMax)
    
    df
  })
  
  
  # Mode toggle + Custom picker
  output$sessTableButtons <- renderUI({
    sel <- isolate(input$sessMode); if (is.null(sel)) sel <- "Stuff"
    choices_cols <- if (exists("all_table_cols")) setdiff(all_table_cols, "Pitch")
    else setdiff(names(pitch_data_pitching), "Pitch")
    tagList(
      div(style = "margin-bottom: 2px; font-weight: bold; font-size: 12px;", "Tables:"),
      radioButtons(
        "sessMode", label = NULL,
        choices  = c("Stuff","Process","Results","Custom"),
        selected = sel, inline = TRUE
      ),
      conditionalPanel(
        "input.sessMode=='Custom'",
        selectizeInput(
          "sessCustomCols", label = NULL,
          choices  = choices_cols,
          multiple = TRUE,
          options  = list(placeholder = "Choose columns to show…")
        )
      )
    )
  })
  
  # DataTable render
  output$sessTable <- DT::renderDataTable({
    df <- filtered_logs()
    if (!nrow(df)) {
      return(DT::datatable(
        data.frame(Message = "No data for selected filters"),
        options = list(dom = 't'), rownames = FALSE
      ))
    }
    
    df_table <- make_session_logs_table(df) %>%
      dplyr::mutate(Date = parse_date_flex(Date)) %>%   # ← was as.Date(Date)
      dplyr::arrange(dplyr::desc(Date)) %>%
      dplyr::mutate(Date = format(Date, "%Y-%m-%d"))    # keep ISO output, or use "%m/%d/%Y" if you prefer
    
    
    mode <- input$sessMode; if (is.null(mode)) mode <- "Stuff"
    sel  <- input$sessCustomCols; if (is.null(sel)) sel <- character(0)
    
    # NEW: safe fallback if the requested set is empty or mismatched
    dv <- intersect(visible_set_for_date(mode, sel), names(df_table))
    if (!length(dv)) dv <- names(df_table)
    
    tbl <- datatable_with_colvis(
      df_table,
      lock = "Date",
      remember = FALSE,
      default_visible = dv
    )
    
    num_cols <- intersect(c("Velo","Max","IVB","HB","SpinEff","Spin","Height","Side",
                            "VAA","HAA","Ext","EV","LA","FIP","WHIP"),
                          names(df_table))
    if (length(num_cols)) tbl <- DT::formatRound(tbl, num_cols, digits = 1)
    
    tbl
  })
  
  
  output$summary_releasePlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    sess_lbl <- session_label_from(df)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    line_col <- if (dark_on) "#ffffff" else "black"
    
    # Get display option
    display_opt <- input$summaryReleaseDisplay
    if (is.null(display_opt)) display_opt <- "Averages Only"
    
    show_pitches <- display_opt %in% c("Averages and Pitches", "Pitches")
    show_averages <- display_opt %in% c("Averages Only", "Averages and Pitches")
    
    # --- background geometry
    rp_w <- 4; rp_h <- 0.83
    xs <- seq(-rp_w, rp_w, length.out = 100)
    ys <- rp_h * (1 - (xs / rp_w)^2)
    mound <- data.frame(x = c(xs, rev(xs)), y = c(ys, rep(0, length(xs))))
    
    # --- individual pitches data
    df_i <- df %>%
      dplyr::filter(is.finite(RelSide), is.finite(RelHeight)) %>%
      dplyr::mutate(
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", RelHeight),
          "<br>Side: ", sprintf("%.1f ft", RelSide),
          "<br>Extension: ", sprintf("%.1f ft", Extension)
        ),
        rid = dplyr::row_number()
      )
    
    # --- averages for hover+dot
    avg <- df %>%
      dplyr::filter(is.finite(RelSide), is.finite(RelHeight)) %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_RelSide    = mean(RelSide,    na.rm = TRUE),
        avg_RelHeight  = mean(RelHeight,  na.rm = TRUE),
        avg_Extension  = mean(Extension,  na.rm = TRUE),
        .groups = "drop"
      ) %>%
      dplyr::filter(TaggedPitchType %in% types_chr) %>%
      dplyr::mutate(
        TaggedPitchType = factor(TaggedPitchType, levels = types_chr),
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", avg_RelHeight),
          "<br>Side: ", sprintf("%.1f ft", avg_RelSide),
          "<br>Extension: ", sprintf("%.1f ft", avg_Extension)
        )
      )
    
    # --- ensure y axis goes to at least 6
    y_max <- max(6, suppressWarnings(max(df$RelHeight, na.rm = TRUE) + 0.2))
    
    p <- ggplot() +
      geom_polygon(data = mound, aes(x, y), fill = "tan", color = "tan", alpha = 0.5) +
      annotate("rect", xmin = -0.5, xmax = 0.5, ymin = rp_h - 0.05, ymax = rp_h + 0.05, fill = alpha("white", 0.6)) +
      geom_vline(xintercept = 0, color = line_col, size = 0.7) +
      geom_hline(yintercept = 0, color = line_col, size = 0.7) +
      # Individual pitches layer
      { if (show_pitches) {
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(x = RelSide, y = RelHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          alpha = 0.2, size = 3.0, shape = 21, stroke = 0.25, show.legend = FALSE
        )
      } } +
      # Averages layer
      { if (show_averages) {
        ggiraph::geom_point_interactive(
          data = avg,
          aes(x = avg_RelSide, y = avg_RelHeight,
              color = TaggedPitchType, tooltip = tt, data_id = TaggedPitchType),
          size = 8, show.legend = FALSE
        )
      } } +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_y_continuous(limits = c(0, y_max), breaks = seq(0, ceiling(y_max), by = 1)) +
      theme_minimal() + axis_theme + grid_theme(dark_on) + transparent_bg_theme +
      labs(x = NULL, y = NULL) +
      theme(
        legend.position = "none",
        axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
        axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
        panel.grid = element_blank(),
        axis.ticks = element_blank()
      )
    
    girafe_transparent(
      ggobj = p,
      width_svg = 8, height_svg = 6.5,
      options = list(
        ggiraph::opts_sizing(rescale = TRUE),
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;"),
        ggiraph::opts_selection(type = "multiple", selected = character(0))
      )
    )
  })
  
  output$summary_movementPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types()
    if (!length(types)) return(NULL)
    types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    line_col <- if (dark_on) "#ffffff" else "black"
    
    # Add reactive dependency on target shapes
    target_shapes_version()
    
    # Averages per type (respect filters)
    avg_mov <- df %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_HorzBreak        = mean(HorzBreak, na.rm = TRUE),
        avg_InducedVertBreak = mean(InducedVertBreak, na.rm = TRUE),
        avg_velo             = mean(RelSpeed, na.rm = TRUE),
        avg_stuff            = mean(`Stuff+`, na.rm = TRUE),
        n_obs                = dplyr::n(),
        .groups = "drop"
      ) %>%
      dplyr::mutate(
        tt  = paste0(TaggedPitchType,
                     "<br>Velo: ", round(avg_velo, 1), " mph",
                     "<br>IVB: ", round(avg_InducedVertBreak, 1), " in",
                     "<br>HB: ", round(avg_HorzBreak, 1), " in",
                     "<br>Stuff+: ", round(avg_stuff, 1),
                     "<br>Pitches: ", n_obs),
        data_id = TaggedPitchType
      )
    
    # interactive payload (per pitch) — uses your GLOBAL make_hover_tt()
    df_i <- df %>%
      dplyr::mutate(
        tt  = make_hover_tt(.),
        rid = dplyr::row_number()
      )
    
    base_type <- input$breakLines
    line_df <- tibble()
    if (base_type %in% c("Fastball","Sinker")) {
      base_val <- dplyr::filter(avg_mov, TaggedPitchType == base_type)
      if (nrow(base_val) == 1) {
        seps <- if (base_type == "Fastball") {
          tibble(
            TaggedPitchType = c("Cutter","Slider","Sweeper","Curveball","ChangeUp","Splitter"),
            sep_IVB = c(-7,-15,-16,-27,-12,-13),
            sep_Horz= c(10,12,22,18,-7,-4)
          )
        } else {
          tibble(
            TaggedPitchType = c("Cutter","Slider","Sweeper","Curveball","ChangeUp","Splitter"),
            sep_IVB = c(2,-6,-7,-18,-4,-5),
            sep_Horz= c(18,20,30,25,1,2)
          )
        }
        # handedness direction
        throw_side <- if (input$hand %in% c("Left","Right")) input$hand else {
          us <- unique(df$PitcherThrows) %>% na.omit()
          if (length(us) == 1 && us %in% c("Left","Right")) us else "Left"
        }
        dir <- ifelse(throw_side == "Right", -1, 1)
        seps <- seps %>%
          dplyr::filter(TaggedPitchType %in% avg_mov$TaggedPitchType) %>%
          dplyr::mutate(sep_Horz = sep_Horz * dir)
        
        line_df <- seps %>% dplyr::mutate(
          start_x = base_val$avg_HorzBreak,
          start_y = base_val$avg_InducedVertBreak,
          end_x   = base_val$avg_HorzBreak + sep_Horz,
          end_y   = base_val$avg_InducedVertBreak + sep_IVB
        )
      }
    }
    
    # Get display options for summary page
    display_opts <- input$summaryMovementDisplay
    if (is.null(display_opts)) display_opts <- "Averages and Pitches"
    
    show_pitches <- any(c("Averages and Pitches", "Target Shapes and Pitches") %in% display_opts)
    show_averages <- any(c("Averages Only", "Averages and Pitches") %in% display_opts)
    show_targets <- any(c("Target Shapes Only", "Target Shapes and Pitches") %in% display_opts)
    
    # Prepare target shapes data if needed (global target store)
    target_df <- NULL
    if (show_targets) {
      pitcher_sel <- input$pitcher
      if (!is.null(pitcher_sel) && length(pitcher_sel) == 1 && !("All" %in% pitcher_sel)) {
        pitcher_name <- pitcher_sel[1]
        date_range <- input$dates
        
        message(sprintf("SUMMARY: Attempting to get target shapes for pitcher: %s", pitcher_name))
        
        # Get target shapes for each pitch type
        target_data <- lapply(types_chr, function(pt) {
          target <- get_target_shape(pitcher_name, pt, date_range, auto_save = FALSE)
          if (!is.null(target)) {
            data.frame(
              TaggedPitchType = pt,
              HB_Target = target$HB,
              IVB_Target = target$IVB,
              stringsAsFactors = FALSE
            )
          } else {
            message(sprintf("  SUMMARY: No target for %s", pt))
            NULL
          }
        })
        
        target_df <- do.call(rbind, target_data)
        
        if (!is.null(target_df) && nrow(target_df) > 0) {
          message(sprintf("SUMMARY: Created target_df with %d rows", nrow(target_df)))
        } else {
          message("SUMMARY: target_df is NULL or empty")
        }
      }
    }
    
    p <- ggplot() +
      # Individual Pitches Layer
      { if (show_pitches) {
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(HorzBreak, InducedVertBreak,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          position = "identity",
          alpha = 0.25, size = 4.0, shape = 21, stroke = 0.25
        )
      } } +
      # Average Movement Layer
      { if (show_averages) {
        ggiraph::geom_point_interactive(
          data = avg_mov,
          aes(avg_HorzBreak, avg_InducedVertBreak, color = TaggedPitchType,
              tooltip = tt, data_id = data_id),
          size = 8, show.legend = FALSE
        )
      } } +
      # Break Lines Layer
      { if (nrow(line_df) > 0)
        geom_segment(
          data = line_df,
          aes(x = start_x, y = start_y, xend = end_x, yend = end_y, color = TaggedPitchType),
          size = 3
        )
      } +
      # Target Shapes Layer
      { if (!is.null(target_df) && nrow(target_df) > 0) {
        list(
          # Low alpha fill circle
          geom_point(
            data = target_df,
            aes(HB_Target, IVB_Target, fill = TaggedPitchType),
            size = 12, shape = 21, alpha = 0.10, stroke = 0, show.legend = FALSE
          ),
          # High alpha border circle
          geom_point(
            data = target_df,
            aes(HB_Target, IVB_Target, color = TaggedPitchType),
            size = 12, shape = 21, alpha = 0.8, stroke = 2, fill = NA, show.legend = FALSE
          )
        )
      } } +
      geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
      geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
      coord_cartesian(xlim = c(-25, 25), ylim = c(-25, 25)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      labs(x = NULL, y = NULL) +                        # <-- remove axis titles
      theme(
        legend.position = "none",
        axis.text.x     = element_text(size = 15, face = "bold", color = axis_col),
        axis.text.y     = element_text(size = 15, face = "bold", color = axis_col),
        axis.title.x    = element_blank(),              # <-- ensure blank
        axis.title.y    = element_blank(),              # <-- ensure blank
        panel.grid      = element_blank(),
        axis.ticks      = element_blank()
      )
    
    girafe_transparent(
      ggobj = p,
      width_svg  = 8,
      height_svg = 6.5,
      bg = "transparent",
      options = list(
        ggiraph::opts_sizing(rescale = TRUE),
        ggiraph::opts_tooltip(use_fill = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;"),
        ggiraph::opts_selection(type = "multiple", selected = character(0))
      )
    )
  })
  
  # 2) Pitch‐version location chart (with centered title)
  output$summary_zonePlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    line_col <- if (dark_on) "#ffffff" else "black"
    
    df_i <- df %>%
      dplyr::mutate(
        tt      = make_hover_tt(.),
        rid     = dplyr::row_number(),
        # tooltip fill should use the outline (pitch-type) color
        tt_fill = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray")
      )
    
    home <- data.frame(
      x = c(-0.75, 0.75, 0.75, 0, -0.75),
      y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5
    )
    cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
    sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
    
    df_known <- df_i %>% dplyr::filter(!is.na(Result))
    df_other <- df_i %>% dplyr::filter(is.na(Result))
    
    p <- ggplot() +
      geom_polygon(data = home, aes(x, y), inherit.aes = FALSE, fill = NA, color = line_col) +
      geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                inherit.aes = FALSE, fill = NA, linetype = "dashed", color = line_col) +
      geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                inherit.aes = FALSE, fill = NA, color = line_col) +
      
      # filled circles for "no result" rows
      ggiraph::geom_point_interactive(
        data = df_other,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 5, alpha = 0.9, shape = 16, stroke = 0.3
      ) +
      
      # result-coded shapes (can be hollow)
      ggiraph::geom_point_interactive(
        data = df_known,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 5, alpha = 0.95, stroke = 0.8
      ) +
      
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_shape_manual(values = shape_map, drop = TRUE) +
      coord_fixed(ratio = 1, xlim = c(-2.5, 2.5), ylim = c(0, 4.5)) +
      theme_void() + theme(legend.position = "none") +
      
      # 🔹 Invisible “hover pad” on top to force correct tooltip fill every time
      ggiraph::geom_point_interactive(
        data = df_i,
        aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
        shape = 21, size = 6, alpha = 0.001, stroke = 0, inherit.aes = FALSE
      )
    
    girafe_transparent(
      ggobj = p,
      bg = "transparent",
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  # 3) Heat‐version location chart (fixed error + centered title)
  output$summary_heatZonePlot <- renderPlot({
    df <- filtered_data()
    if (!nrow(df)) return()
    
    stat <- input$summaryLocType
    if (is.null(stat) || stat == "Pitch") return(NULL)
    # Normalize label for renderer
    if (identical(stat, "Exit Velocity")) stat <- "EV"
    
    render_heatmap_stat(df, stat)
  }, bg = "transparent")
  
  
  output$summary_legend <- renderPlot({
    types<-ordered_types(); if(!length(types)) return()
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#ffffff" else "black"
    pal <- colors_for_mode(dark_on)
    leg_df<-data.frame(TaggedPitchType=factor(types,levels=types),x=1,y=1)
    ggplot(leg_df,aes(x,y,color=TaggedPitchType))+geom_point(size=0,alpha=0)+
      scale_color_manual(values=pal[types],limits=types,name=NULL)+
      guides(color=guide_legend(nrow=1,byrow=TRUE,override.aes=list(size=4,alpha=1)))+
      theme_void()+
      theme(
        legend.position=c(0.5, 0.5),
        legend.text=element_text(size=12,face="bold", color = axis_col),
        legend.justification=c(0.5, 0.5),
        legend.direction="horizontal",
        plot.margin = margin(2, 10, 2, 10),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.background = element_rect(fill = "transparent", color = NA),
        legend.background = element_rect(fill = "transparent", color = NA)
      )
  }, bg = "transparent")
  
  # Pitch result legend for location chart (shapes)
  output$summary_result_legend <- renderPlot({
    # Only show the main result types that have shapes in the legend
    # Individual hit types (Single, Double, etc.) are filter options only, not plot symbols
    res_levels <- c("Called Strike", "Ball", "Foul", "Whiff", "In Play (Out)", "In Play (Hit)", "Error")
    leg_df <- data.frame(Result = factor(res_levels, levels = res_levels), x = 1, y = 1)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#ffffff" else "black"
    ggplot(leg_df, aes(x, y, shape = Result)) +
      geom_point(size = 0, alpha = 0, show.legend = TRUE) +
      scale_shape_manual(values = shape_map, limits = res_levels, name = NULL) +
      theme_void() +
      theme(
        legend.position = c(0.5, 0.5),
        legend.text = element_text(size = 12, face = "bold", color = axis_col),
        legend.justification = c(0.5, 0.5),
        legend.direction = "horizontal",
        plot.margin = margin(10, 10, 10, 10),
        plot.background = element_rect(fill = "transparent", color = NA),
        panel.background = element_rect(fill = "transparent", color = NA),
        legend.background = element_rect(fill = "transparent", color = NA)
      ) +
      guides(shape = guide_legend(
        nrow = 1, byrow = TRUE,
        override.aes = list(size = 4, alpha = 1, color = axis_col, fill = NA)
      ))
  }, bg = "transparent")
  
  safe_pct <- function(num, den) {
    num <- suppressWarnings(as.numeric(num))
    den <- suppressWarnings(as.numeric(den))
    ifelse(is.finite(den) & den > 0 & is.finite(num),
           paste0(round(100 * num / den, 1), "%"),
           "")
  }
  
  nz_mean <- function(x) {
    x <- suppressWarnings(as.numeric(x))
    m <- mean(x, na.rm = TRUE)
    if (is.finite(m)) m else NA_real_
  }
  
  
  collapse_list_cols <- function(dat) {
    if (!nrow(dat)) return(dat)
    dat %>%
      dplyr::mutate(dplyr::across(
        dplyr::where(is.list),
        ~ vapply(., function(x) {
          if (is.null(x)) "" else if (length(x) == 1 && !is.list(x)) as.character(x)
          else paste0(unlist(x), collapse = ", ")
        }, character(1))
      ))
  }
  
  # =========================
  # Summary page table (uses summary* controls ONLY)
  # =========================
  output$summaryTablePage <- DT::renderDataTable({
    tryCatch({
      df <- filtered_data()
      table_cache <- NULL
      on.exit({
        session$userData$table_cache_summaryTablePage <- table_cache
      }, add = TRUE)
      if (!nrow(df)) {
        return(DT::datatable(
          data.frame(Message = "No data for selected filters"),
          options = list(dom = 't'), rownames = FALSE
        ))
      }
      
      # Apply Split By transformation
      split_choice <- if (!is.null(input$summarySplitBy)) input$summarySplitBy else "Pitch Types"
      df <- apply_split_by(df, split_choice)
      
      # Determine the column name based on split choice
      split_col_name <- switch(
        split_choice,
        "Pitch Types" = "Pitch",
        "Batter Hand" = "Batter Hand",
        "Count" = "Count",
        "After Count" = "After Count",
        "Velocity" = "Velocity",
        "IVB" = "InducedVert",
        "HB" = "HorzBreak",
        "Batter" = "Batter",
        "Pitch"  # default
      )
      
      # --- small helpers (match Hitting DP logic) ---
      nz_mean <- function(x) {
        x <- suppressWarnings(as.numeric(x))
        m <- mean(x, na.rm = TRUE)
        if (is.finite(m)) m else NA_real_
      }
      
      safe_div <- function(num, den) {
        num <- suppressWarnings(as.numeric(num))
        den <- suppressWarnings(as.numeric(den))
        ifelse(is.finite(den) & den != 0 & is.finite(num), num/den, NA_real_)
      }
      
      # Parse numeric values from strings like "12.3%", "  .456  ", "1,234", etc.
      # Any string containing % is treated as a percentage and divided by 100.
      parse_num <- function(x) {
        if (is.numeric(x)) return(x)
        sx <- trimws(as.character(x))
        sx[sx == ""] <- NA_character_
        is_pct <- grepl("%", sx)                     # percent anywhere in the string
        val <- suppressWarnings(as.numeric(gsub("[^0-9eE.+-]", "", sx)))  # keep digits, ., +/-, e/E
        val[is_pct] <- val[is_pct] / 100
        val
      }
      
      # Format 3-decimal rates without leading zero (e.g., .303)
      fmt_rate3 <- function(x) {
        x <- suppressWarnings(as.numeric(x))
        s <- ifelse(is.finite(x), sprintf("%.3f", x), "")
        sub("^0\\.", ".", s)
      }
      
      # Alias to avoid breaking any existing calls that use fmt_avg
      fmt_avg <- fmt_rate3
      
      ip_fmt <- function(ip_raw) {
        out <- rep("", length(ip_raw))
        ok  <- is.finite(ip_raw) & ip_raw > 0
        outs <- floor(ip_raw[ok]*3 + 1e-8)
        inn  <- outs %/% 3
        rem  <- outs %% 3
        out[ok] <- paste0(inn, ".", rem)
        out
      }
      FIP_C <- if (exists("FIP_CONST")) get("FIP_CONST") else 3.20
      
      res_mode <- resolve_table_mode_global(input$summaryTableMode, input$summaryCustomCols)
      mode   <- res_mode$mode
      custom <- res_mode$cols
      
      # Fallback visible-set helper if not defined globally
      if (!exists("visible_set_for")) {
        visible_set_for <- function(mode, custom) {
          base <- c("Pitch","#","Usage","BF","IP","FIP","WHIP","Velo","Max","IVB","HB","rTilt","bTilt","SpinEff","Spin",
                    "Height","Side","VAA","HAA","Ext","InZone%","Comp%","Strike%","FPS%","E+A%","QP%",
                    "K%","BB%","Whiff%","EV","LA","Stuff+","Ctrl+","QP+","Pitching+",
                    # Results-specific common cols
                    "PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP","GB%","Barrel%","Swing%","Whiff%","K%","BB%","EV","LA")
          if (identical(mode, "Custom") && length(custom)) unique(c("Pitch", custom)) else base
        }
      }
      
      # ---------- RESULTS TABLE (use Hitting-style PA/AB math) ----------
      if (identical(mode, "Results")) {
        swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
        
        # Completed PA rows
        is_term <- (
          (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
            (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk"))
        )
        term <- df[is_term, , drop = FALSE]
        
        # Per-split-type tallies (PA/AB/H/K/BB/HBP/Sac/HR)
        per_type <- term %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            PA   = dplyr::n(),
            HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
            `1B` = sum(PlayResult == "Single",  na.rm = TRUE),
            `2B` = sum(PlayResult == "Double",  na.rm = TRUE),
            `3B` = sum(PlayResult == "Triple",  na.rm = TRUE),
            HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
            Kct  = sum(KorBB == "Strikeout" |
                         PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
            BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
            .groups = "drop"
          ) %>%
          dplyr::mutate(
            AB  = PA - (BBct + HBP + Sac),
            H   = `1B` + `2B` + `3B` + HR,
            TB  = 1*`1B` + 2*`2B` + 3*`3B` + 4*HR,
            AVG = safe_div(H, AB),
            SLG = safe_div(TB, AB),
            OBP = safe_div(H + BBct + HBP, PA),
            OPS = SLG + OBP
          )
        
        # Pitch totals for Usage/Swing%/Whiff%
        pitch_totals <- df %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            Pitches       = dplyr::n(),
            Swings        = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
            Whiffs        = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
            CalledStrikes = sum(PitchCall == "StrikeCalled",    na.rm = TRUE),
            .groups = "drop"
          )
        total_pitches <- sum(pitch_totals$Pitches, na.rm = TRUE)
        
        # Command scoring vector and per-type Command+ / Stuff+ / Pitching+
        scores <- ifelse(
          df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
            df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
          ifelse(
            df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
              df$PlateLocHeight >= (2.65 - 1.5) & df$PlateLocHeight <= (2.65 + 1.5),
            0.73, 0
          )
        )
        sc_by_type <- df %>%
          dplyr::mutate(.scores = scores) %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            StuffP   = round(nz_mean(`Stuff+`), 1),
            CommandP = round(nz_mean(.scores) * 100, 1),
            .groups = "drop"
          ) %>%
          dplyr::mutate(PitchingP = round((StuffP + CommandP)/2, 1))
        
        # Live BIP for EV/LA and GB%
        bbe <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
        evla <- bbe %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(EV = nz_mean(ExitSpeed), LA = nz_mean(Angle), .groups = "drop")
        gb <- bbe %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            `GB%` = safe_div(sum(TaggedHitType == "GroundBall", na.rm = TRUE),
                             sum(!is.na(TaggedHitType),        na.rm = TRUE)),
            .groups = "drop"
          )
        
        # Extras (xWOBA/xISO/BABIP/Barrel%) — numeric
        # Note: This function may need SplitColumn support internally
        extras_raw <- safe_compute_process_results(df, mode)
        if ("PitchType" %in% names(extras_raw)) {
          extras <- extras_raw %>%
            dplyr::rename(SplitColumn = PitchType) %>%
            dplyr::mutate(
              xWOBA     = parse_num(xWOBA),
              xISO      = parse_num(xISO),
              BABIP     = parse_num(BABIP),
              `Barrel%` = parse_num(`Barrel%`)
            ) %>%
            dplyr::select(SplitColumn, xWOBA, xISO, BABIP, `Barrel%`, `RV/100`)
        } else {
          # Fallback if function doesn't return expected format
          extras <- df %>%
            dplyr::group_by(SplitColumn) %>%
            dplyr::summarise(
              xWOBA = NA_real_, xISO = NA_real_, 
              BABIP = NA_real_, `Barrel%` = NA_real_, `RV/100` = NA_real_,
              .groups = "drop"
            )
        }
        
        # Build per-type rows (+ #, Usage, BF, IP, FIP, WHIP, Pitching+)
        res_pt <- per_type %>%
          dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
          dplyr::left_join(evla,         by = "SplitColumn") %>%
          dplyr::left_join(gb,           by = "SplitColumn") %>%
          dplyr::mutate(
            `Swing%` = safe_div(Swings, Pitches),
            `Whiff%` = safe_div(Whiffs, Swings),
            `CSW%`   = safe_div(Whiffs + CalledStrikes, Pitches),
            Outs     = (AB - H) + Sac,
            IP_raw   = safe_div(Outs, 3),
            BF       = PA,
            `#`      = Pitches,
            Usage    = ifelse(total_pitches > 0, paste0(round(100*Pitches/total_pitches,1), "%"), ""),
            FIP_tmp  = safe_div(13*HR + 3*(BBct + HBP) - 2*Kct, IP_raw),
            FIP      = ifelse(is.finite(FIP_tmp), round(FIP_tmp + FIP_C, 2), NA_real_),
            WHIP_tmp = safe_div(H + BBct, IP_raw),
            WHIP     = ifelse(is.finite(WHIP_tmp), round(WHIP_tmp, 2), NA_real_)
          ) %>%
          dplyr::left_join(sc_by_type, by = "SplitColumn") %>%
          dplyr::left_join(extras, by = "SplitColumn") %>%
          dplyr::transmute(
            !!split_col_name := as.character(SplitColumn),
            `#`, Usage, BF, `RV/100`, IP = ip_fmt(IP_raw), FIP, WHIP,
            PA, AB, AVG, SLG, OBP, OPS,
            xWOBA, xISO, BABIP,
            `Swing%`, `Whiff%`, `CSW%`, `GB%`,
            `K%` = safe_div(Kct, PA), `BB%` = safe_div(BBct, PA),
            `Barrel%`, EV, LA,
            `Pitching+` = PitchingP
          )
        
        # --- ALL row (ungrouped, same definitions) ---
        PAt <- nrow(term)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
        H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
        H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
        H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
        HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        H   <- H1 + H2 + H3 + HR
        TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
        Kct_all <- sum(term$KorBB == "Strikeout" |
                         term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
        BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        ABt <- PAt - (BBc_all + HBP_all + Sac_all)
        swings  <- sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE)
        whiffs  <- sum(df$PitchCall == "StrikeSwinging",                      na.rm = TRUE)
        csw_all_num <- sum(df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
        gbpct_all <- {
          d <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
          safe_div(sum(d$TaggedHitType == "GroundBall", na.rm = TRUE),
                   sum(!is.na(d$TaggedHitType),         na.rm = TRUE))
        }
        # All-row IP/FIP/WHIP/Pitching+
        Outs_all <- (ABt - H) + Sac_all
        IP_all   <- safe_div(Outs_all, 3)
        FIP_all  <- {
          tmp <- safe_div(13*HR + 3*(BBc_all + HBP_all) - 2*Kct_all, IP_all)
          ifelse(is.finite(tmp), round(tmp + FIP_C, 2), NA_real_)
        }
        WHIP_all <- {
          tmp <- safe_div(H + BBc_all, IP_all)
          ifelse(is.finite(tmp), round(tmp, 2), NA_real_)
        }
        
        stuff_all <- round(nz_mean(df$`Stuff+`), 1)
        qp_all <- round(nz_mean(compute_qp_points(df)) * 200, 1)
        pitc_all <- round((stuff_all + qp_all) / 2, 1)
        
        # For Swing% calculation, use total pitches as denominator (same as individual pitch types)
        total_pitches_all <- total_pitches
        
        # Create All row with dynamic column name
        all_row_data <- list(
          `#`   = nrow(df),
          Usage = "100%",
          BF = PAt,
          IP = ip_fmt(IP_all),
          FIP = FIP_all,
          WHIP = WHIP_all,
          PA = PAt, AB = ABt,
          AVG = safe_div(H, ABt),
          SLG = safe_div(TB, ABt),
          OBP = safe_div(H + BBc_all + HBP_all, PAt),
          OPS = NA_real_,
          xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
          `Swing%` = safe_div(swings, total_pitches_all),
          `Whiff%` = safe_div(whiffs, swings),
          `CSW%`   = safe_div(csw_all_num, total_pitches_all),
          `GB%`    = gbpct_all,
          `K%`     = safe_div(Kct_all, PAt),
          `BB%`    = safe_div(BBc_all, PAt),
          `Barrel%`= NA_real_,
          EV = nz_mean(bbe$ExitSpeed),
          LA = nz_mean(bbe$Angle),
          `Pitching+` = pitc_all
        )
        # Add the split column name dynamically
        all_row_data[[split_col_name]] <- "All"
        all_row <- tibble::as_tibble(all_row_data)
        all_row$OPS <- all_row$SLG + all_row$OBP
        
        # Fill extras (All)
        extras_all <- compute_process_results(df, mode) %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::summarise(
            xWOBA     = nz_mean(xWOBA),
            xISO      = nz_mean(xISO),
            BABIP     = nz_mean(BABIP),
            `Barrel%` = nz_mean(`Barrel%`),
            .groups = "drop"
          )
        if (nrow(extras_all)) {
          all_row$xWOBA     <- extras_all$xWOBA[1]
          all_row$xISO      <- extras_all$xISO[1]
          all_row$BABIP     <- extras_all$BABIP[1]
          all_row$`Barrel%` <- extras_all$`Barrel%`[1]
        }
        
        # Add Even/Ahead/Behind summary rows if splitting by Count
        count_state_rows <- NULL
        if (split_choice == "Count" && "CountState" %in% names(df)) {
          for (state in c("Even", "Ahead", "Behind")) {
            state_df <- df %>% dplyr::filter(CountState == state)
            state_term <- term %>% dplyr::filter(CountState == state)
            
            if (nrow(state_df) > 0) {
              state_pitches <- nrow(state_df)
              # Similar calculations as for individual counts
              state_PA <- nrow(state_term)
              state_HBP <- sum(state_term$PlayResult == "HitByPitch", na.rm = TRUE)
              state_Sac <- sum(state_term$PlayResult == "Sacrifice", na.rm = TRUE)
              state_H1 <- sum(state_term$PlayResult == "Single", na.rm = TRUE)
              state_H2 <- sum(state_term$PlayResult == "Double", na.rm = TRUE)
              state_H3 <- sum(state_term$PlayResult == "Triple", na.rm = TRUE)
              state_HR <- sum(state_term$PlayResult == "HomeRun", na.rm = TRUE)
              state_H <- state_H1 + state_H2 + state_H3 + state_HR
              state_TB <- 1*state_H1 + 2*state_H2 + 3*state_H3 + 4*state_HR
              state_Kct <- sum(state_term$KorBB == "Strikeout" |
                                 state_term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
              state_BBct <- sum(state_term$KorBB == "Walk" | state_term$PlayResult == "Walk", na.rm = TRUE)
              state_AB <- state_PA - (state_BBct + state_HBP + state_Sac)
              
              state_swings <- sum(!is.na(state_df$PitchCall) & state_df$PitchCall %in% swing_levels, na.rm = TRUE)
              state_whiffs <- sum(state_df$PitchCall == "StrikeSwinging", na.rm = TRUE)
              state_csw <- sum(state_df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
              state_bbe <- state_df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
              state_gbpct <- safe_div(sum(state_bbe$TaggedHitType == "GroundBall", na.rm = TRUE),
                                      sum(!is.na(state_bbe$TaggedHitType), na.rm = TRUE))
              
              # Calculate BABIP for count state
              state_inplay_all <- sum(state_df$PitchCall == "InPlay", na.rm = TRUE)
              state_BABIP <- safe_div(state_H, state_inplay_all)
              
              # Calculate Barrel% for count state
              state_barrels <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay" &
                                     is.finite(state_df$ExitSpeed) & is.finite(state_df$Angle) &
                                     state_df$ExitSpeed >= 95 & state_df$Angle >= 10 & state_df$Angle <= 35, na.rm = TRUE)
              state_inplay_live <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay", na.rm = TRUE)
              state_BarrelPct <- safe_div(state_barrels, state_inplay_live)
              
              # Calculate xWOBA and xISO for count state (using expected stats if available)
              state_bip_evla <- state_df %>%
                dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                              is.finite(ExitSpeed), is.finite(Angle)) %>%
                dplyr::mutate(
                  EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
                  LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
                )
              if (exists("xbin_ref") && nrow(state_bip_evla) > 0) {
                state_bip_evla <- state_bip_evla %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
                for (nm in c("p1B","p2B","p3B","pHR")) {
                  if (exists("x_overall") && nm %in% names(x_overall)) {
                    state_bip_evla[[nm]][!is.finite(state_bip_evla[[nm]])] <- x_overall[[nm]]
                  }
                }
                state_x1B <- sum(state_bip_evla$p1B, na.rm = TRUE)
                state_x2B <- sum(state_bip_evla$p2B, na.rm = TRUE)
                state_x3B <- sum(state_bip_evla$p3B, na.rm = TRUE)
                state_xHR <- sum(state_bip_evla$pHR, na.rm = TRUE)
                state_xH   <- state_x1B + state_x2B + state_x3B + state_xHR
                state_xTB  <- 1*state_x1B + 2*state_x2B + 3*state_x3B + 4*state_xHR
                state_xAVG <- safe_div(state_xH, state_AB)
                state_xSLG <- safe_div(state_xTB, state_AB)
                state_xISO <- state_xSLG - state_xAVG
                # xWOBA calculation (using weights if they exist)
                state_BF_live <- sum(state_df$SessionType == "Live" & state_df$Balls == 0 & state_df$Strikes == 0, na.rm = TRUE)
                if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
                  state_xWOBA <- safe_div(W_BB*state_BBct + W_1B*state_x1B + W_2B*state_x2B + W_3B*state_x3B + W_HR*state_xHR, state_BF_live)
                } else {
                  state_xWOBA <- NA_real_
                }
              } else {
                state_xWOBA <- NA_real_
                state_xISO <- NA_real_
              }
              
              state_Outs <- (state_AB - state_H) + state_Sac
              state_IP <- safe_div(state_Outs, 3)
              state_FIP <- {
                tmp <- safe_div(13*state_HR + 3*(state_BBct + state_HBP) - 2*state_Kct, state_IP)
                ifelse(is.finite(tmp), round(tmp + FIP_C, 2), NA_real_)
              }
              state_WHIP <- {
                tmp <- safe_div(state_H + state_BBct, state_IP)
                ifelse(is.finite(tmp), round(tmp, 2), NA_real_)
              }
              
              # Calculate InZone%, Strike%, and Comp% for count state
              state_inzone <- sum(state_df$PlateLocSide >= ZONE_LEFT & state_df$PlateLocSide <= ZONE_RIGHT &
                                    state_df$PlateLocHeight >= ZONE_BOTTOM & state_df$PlateLocHeight <= ZONE_TOP, na.rm = TRUE)
              state_InZonePct <- safe_div(state_inzone, state_pitches)
              
              state_strikes <- sum(state_df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
              state_StrikePct <- safe_div(state_strikes, state_pitches)
              
              state_comp <- sum(state_df$PlateLocSide >= -1.5 & state_df$PlateLocSide <= 1.5 &
                                  state_df$PlateLocHeight >= (2.65-1.5) & state_df$PlateLocHeight <= (2.65+1.5), na.rm = TRUE)
              state_CompPct <- safe_div(state_comp, state_pitches)
              
              state_row_data <- list(
                `#` = state_pitches,
                Usage = ifelse(total_pitches > 0, paste0(round(100*state_pitches/total_pitches, 1), "%"), ""),
                BF = state_PA,
                IP = ip_fmt(state_IP),
                FIP = state_FIP,
                WHIP = state_WHIP,
                PA = state_PA,
                AB = state_AB,
                AVG = safe_div(state_H, state_AB),
                SLG = safe_div(state_TB, state_AB),
                OBP = safe_div(state_H + state_BBct + state_HBP, state_PA),
                OPS = NA_real_,
                xWOBA = state_xWOBA,
                xISO = state_xISO,
                BABIP = state_BABIP,
                `InZone%` = state_InZonePct,
                `Strike%` = state_StrikePct,
                `Comp%` = state_CompPct,
                `Swing%` = safe_div(state_swings, state_pitches),
                `Whiff%` = safe_div(state_whiffs, state_swings),
                `CSW%` = safe_div(state_csw, state_pitches),
                `GB%` = state_gbpct,
                `K%` = safe_div(state_Kct, state_PA),
                `BB%` = safe_div(state_BBct, state_PA),
                `Barrel%` = state_BarrelPct,
                EV = nz_mean(state_bbe$ExitSpeed),
                LA = nz_mean(state_bbe$Angle),
                `Pitching+` = round(nz_mean(state_df$`Stuff+`), 1)
              )
              state_row_data[[split_col_name]] <- state
              state_row <- tibble::as_tibble(state_row_data)
              state_row$OPS <- state_row$SLG + state_row$OBP
              
              count_state_rows <- dplyr::bind_rows(count_state_rows, state_row)
            }
          }
        }
        
        # Order pitch types correctly if Pitch Types is selected
        if (split_choice == "Pitch Types" && split_col_name == "Pitch" && exists("all_colors")) {
          pitch_order <- intersect(names(all_colors), res_pt[[split_col_name]])
          if (length(pitch_order) > 0) {
            res_pt[[split_col_name]] <- factor(res_pt[[split_col_name]], levels = pitch_order)
            res_pt <- res_pt %>% dplyr::arrange(.data[[split_col_name]])
            res_pt[[split_col_name]] <- as.character(res_pt[[split_col_name]])
          }
        }
        
        # Bind + format (including count state rows if they exist)
        df_out <- dplyr::bind_rows(res_pt, count_state_rows, all_row) %>%
          dplyr::mutate(
            dplyr::across(c(PA, AB, AVG, SLG, OBP, OPS, xWOBA, xISO, BABIP,
                            `Swing%`, `Whiff%`, `CSW%`, `GB%`, `K%`, `BB%`, `Barrel%`,
                            EV, LA, FIP, WHIP),
                          ~ suppressWarnings(as.numeric(.)))
          )
        pct_cols  <- c("Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%")
        rate_cols <- c("AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP")
        df_out[pct_cols]  <- lapply(df_out[pct_cols],  function(z) ifelse(is.finite(z), paste0(round(z*100,1), "%"), ""))
        df_out[rate_cols] <- lapply(df_out[rate_cols], function(z) ifelse(is.finite(z), fmt_avg(z), ""))
        df_out$EV   <- ifelse(is.finite(df_out$EV),   round(df_out$EV, 1), "")
        df_out$LA   <- ifelse(is.finite(df_out$LA),   round(df_out$LA, 1), "")
        df_out$FIP  <- ifelse(is.finite(df_out$FIP),  sprintf("%.2f", df_out$FIP), "")
        df_out$WHIP <- ifelse(is.finite(df_out$WHIP), sprintf("%.2f", df_out$WHIP), "")
        
        # Sort by IVB/HB in descending order if applicable
        df_out <- sort_by_range(df_out, split_col_name, split_choice)
        
        df_dt <- if (exists("collapse_list_cols")) collapse_list_cols(df_out) else df_out
        df_dt <- as.data.frame(df_dt, stringsAsFactors = FALSE, check.names = FALSE)
        
        # Update visible_set to use dynamic column name
        visible_set <- visible_set_for(mode, custom)
        # Replace "Pitch" with the actual split column name in visible set
        visible_set <- gsub("^Pitch$", split_col_name, visible_set)
        
        build_summary_dt <- function(data, ...) {
          tryCatch(
            datatable_with_colvis(data, ...),
            error = function(e) {
              message("summaryTablePage (Results) datatable error [mode=", mode, "]: ", conditionMessage(e))
              message("Columns: ", paste(names(data), collapse = ", "))
              # Return a fallback datatable with error message instead of stopping
              DT::datatable(
                data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
                options = list(dom = 't'), rownames = FALSE
              )
            }
          )
        }
        table_cache <- list(
          table = df_dt,
          source = df,
          label_column = split_col_name,
          split_choice = split_choice
        )
        return(build_summary_dt(
          df_dt,
          lock            = split_col_name,
          remember        = FALSE,
          default_visible = intersect(visible_set, names(df_dt)),
          mode            = mode
        ))
      }
      
      # ---------- RAW DATA TABLE ----------
      if (identical(mode, "Raw Data")) {
        # Helper function for innings pitched calculation
        ip_calculation <- function(pitches_data) {
          outs <- sum(pitches_data$KorBB == "Strikeout", na.rm = TRUE) + 
            sum(pitches_data$PlayResult %in% c("Out", "FieldersChoice", "Error"), na.rm = TRUE)
          innings <- outs / 3
          whole_innings <- floor(innings)
          remaining_outs <- outs %% 3
          if (remaining_outs == 0) {
            return(paste0(whole_innings, ".0"))
          } else {
            return(paste0(whole_innings, ".", remaining_outs))
          }
        }
        
        raw_per_type <- df %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            IP = ip_calculation(dplyr::cur_data_all()),
            P = dplyr::n(),
            BF = calculate_bf(dplyr::cur_data_all()),
            H = sum(PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE),
            XBH = sum(PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE),
            Barrels = sum(ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, na.rm = TRUE),
            BB = sum(KorBB == "Walk", na.rm = TRUE),
            HBP = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            K = sum(KorBB == "Strikeout", na.rm = TRUE),
            Whiffs = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
            .groups = "drop"
          ) %>%
          dplyr::rename(!!split_col_name := SplitColumn) %>%
          dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
        
        # Order pitch types correctly if Pitch Types is selected
        if (split_choice == "Pitch Types" && exists("all_colors")) {
          pitch_order <- intersect(names(all_colors), raw_per_type[[split_col_name]])
          if (length(pitch_order) > 0) {
            raw_per_type[[split_col_name]] <- factor(raw_per_type[[split_col_name]], levels = pitch_order)
            raw_per_type <- raw_per_type %>% dplyr::arrange(.data[[split_col_name]])
            raw_per_type[[split_col_name]] <- as.character(raw_per_type[[split_col_name]])
          }
        }
        
        # All row calculations
        all_ip <- ip_calculation(df)
        all_p <- nrow(df)
        all_bf <- sum(df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
        all_h <- sum(df$PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
        all_xbh <- sum(df$PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE)
        all_barrels <- sum(df$ExitSpeed >= 95 & df$Angle >= 10 & df$Angle <= 35, na.rm = TRUE)
        all_bb <- sum(df$KorBB == "Walk", na.rm = TRUE)
        all_hbp <- sum(df$PlayResult == "HitByPitch", na.rm = TRUE)
        all_k <- sum(df$KorBB == "Strikeout", na.rm = TRUE)
        all_whiffs <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
        
        # Calculate P/IP and P/BF for All row only
        # Convert IP from "X.Y" format to decimal (X + Y/3)
        ip_decimal <- if (all_ip != "0.0") {
          parts <- strsplit(all_ip, "\\.")[[1]]
          as.numeric(parts[1]) + as.numeric(parts[2])/3
        } else 0
        
        p_per_ip <- if (ip_decimal > 0) as.character(round(all_p / ip_decimal, 1)) else ""
        p_per_bf <- if (all_bf > 0) as.character(round(all_p / all_bf, 1)) else ""
        
        # Create all_row with dynamic split column name first
        all_row_data <- list()
        all_row_data[[split_col_name]] <- "All"
        all_row_data$IP <- all_ip
        all_row_data$P <- all_p
        all_row_data$BF <- all_bf
        all_row_data$`P/IP` <- p_per_ip
        all_row_data$`P/BF` <- p_per_bf
        all_row_data$H <- all_h
        all_row_data$XBH <- all_xbh
        all_row_data$Barrels <- all_barrels
        all_row_data$BB <- all_bb
        all_row_data$HBP <- all_hbp
        all_row_data$K <- all_k
        all_row_data$Whiffs <- all_whiffs
        all_row <- tibble::as_tibble(all_row_data)
        
        # Add empty P/IP and P/BF columns to per-type data
        raw_per_type$`P/IP` <- ""
        raw_per_type$`P/BF` <- ""
        
        # Reorder columns to match desired layout with dynamic split column name
        col_order <- c(split_col_name, "IP", "P", "BF", "P/IP", "P/BF", "H", "XBH", "Barrels", "BB", "HBP", "K", "Whiffs")
        raw_per_type <- raw_per_type[, col_order]
        all_row <- all_row[, col_order]
        
        df_raw <- dplyr::bind_rows(raw_per_type, all_row)
        
        visible_set <- names(df_raw)
        return(datatable_with_colvis(
          df_raw,
          lock            = split_col_name,
          remember        = FALSE,
          default_visible = visible_set,
          mode            = mode,
          enable_colors   = FALSE
        ))
      }
      
      # ---------- BATTED BALL DATA TABLE ----------
      if (identical(mode, "Batted Ball Data")) {
        # Helper function
        fmt_avg <- function(x) sprintf("%.3f", x)
        
        # Filter for completed PAs only (like Results table does)
        is_term <- (
          (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
            (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk"))
        )
        term <- df[is_term, , drop = FALSE]
        
        # Group by SplitColumn and calculate stats for each split
        per_type <- term %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            PA = dplyr::n(),  # Count completed PAs, not first pitches
            H1 = sum(PlayResult == "Single", na.rm = TRUE),
            H2 = sum(PlayResult == "Double", na.rm = TRUE),
            H3 = sum(PlayResult == "Triple", na.rm = TRUE),
            HR = sum(PlayResult == "HomeRun", na.rm = TRUE),
            BB = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
            IBB = sum(PlayResult == "IntentionalWalk", na.rm = TRUE),
            HBP = sum(PlayResult == "HitByPitch", na.rm = TRUE),
            SF = sum(PlayResult == "Sacrifice", na.rm = TRUE),
            Inplay_All = sum(PitchCall == "InPlay", na.rm = TRUE),
            .groups = "drop"
          ) %>%
          dplyr::mutate(
            AB = PA - (BB + HBP + SF),
            H = H1 + H2 + H3 + HR,
            TB = 1*H1 + 2*H2 + 3*H3 + 4*HR,
            AVG = safe_div(H, AB),
            SLG = safe_div(TB, AB),
            OBP = safe_div(H + BB + HBP, PA),
            OPS = SLG + OBP,
            ISO = SLG - AVG,
            uBB = BB - IBB,
            wOBA_num = 0.690*uBB + 0.722*HBP + 0.888*H1 + 1.271*H2 + 1.616*H3 + 2.101*HR,
            wOBA_den = AB + BB - IBB + SF + HBP,
            wOBA = safe_div(wOBA_num, wOBA_den),
            BABIP = safe_div(H, Inplay_All)
          )
        
        # Calculate xWOBA, xISO, and Barrel% per split
        splits <- unique(df$SplitColumn)
        xstats_list <- lapply(splits, function(spl) {
          split_df <- df[df$SplitColumn == spl, , drop = FALSE]
          
          # Get BIP with EV/LA
          bip_evla <- split_df %>%
            dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                          is.finite(ExitSpeed), is.finite(Angle)) %>%
            dplyr::mutate(
              EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
              LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
            )
          
          xWOBA <- NA_real_
          xISO <- NA_real_
          
          if (exists("xbin_ref") && nrow(bip_evla) > 0) {
            bip_evla <- bip_evla %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
            for (nm in c("p1B","p2B","p3B","pHR")) {
              if (exists("x_overall") && nm %in% names(x_overall)) {
                bip_evla[[nm]][!is.finite(bip_evla[[nm]])] <- x_overall[[nm]]
              }
            }
            x1B <- sum(bip_evla$p1B, na.rm = TRUE)
            x2B <- sum(bip_evla$p2B, na.rm = TRUE)
            x3B <- sum(bip_evla$p3B, na.rm = TRUE)
            xHR <- sum(bip_evla$pHR, na.rm = TRUE)
            xH  <- x1B + x2B + x3B + xHR
            xTB <- 1*x1B + 2*x2B + 3*x3B + 4*xHR
            
            split_AB <- per_type$AB[per_type$SplitColumn == spl]
            xAVG <- safe_div(xH, split_AB)
            xSLG <- safe_div(xTB, split_AB)
            xISO <- xSLG - xAVG
            
            # xWOBA calculation
            split_BB <- per_type$BB[per_type$SplitColumn == spl]
            BF_live <- sum(split_df$SessionType == "Live" & split_df$Balls == 0 & split_df$Strikes == 0, na.rm = TRUE)
            if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
              xWOBA <- safe_div(W_BB*split_BB + W_1B*x1B + W_2B*x2B + W_3B*x3B + W_HR*xHR, BF_live)
            }
          }
          
          # Calculate Barrel%
          barrels <- sum(split_df$SessionType == "Live" & split_df$PitchCall == "InPlay" &
                           is.finite(split_df$ExitSpeed) & is.finite(split_df$Angle) &
                           split_df$ExitSpeed >= 95 & split_df$Angle >= 10 & split_df$Angle <= 35, na.rm = TRUE)
          inplay_live <- sum(split_df$SessionType == "Live" & split_df$PitchCall == "InPlay", na.rm = TRUE)
          BarrelPct <- safe_div(barrels, inplay_live)
          
          data.frame(
            SplitColumn = spl,
            xWOBA = xWOBA,
            xISO = xISO,
            `Barrel%` = BarrelPct,
            check.names = FALSE
          )
        })
        
        xstats <- do.call(rbind, xstats_list)
        
        # Merge with per_type
        batted_ball_data <- per_type %>%
          dplyr::left_join(xstats, by = "SplitColumn") %>%
          dplyr::transmute(
            !!split_col_name := as.character(SplitColumn),
            PA, AB, AVG, SLG, OBP, OPS, wOBA, xWOBA, ISO, xISO, BABIP, `Barrel%`
          ) %>%
          dplyr::mutate(
            AVG = ifelse(is.finite(AVG), fmt_avg(AVG), ""),
            SLG = ifelse(is.finite(SLG), fmt_avg(SLG), ""),
            OBP = ifelse(is.finite(OBP), fmt_avg(OBP), ""),
            OPS = ifelse(is.finite(OPS), fmt_avg(OPS), ""),
            wOBA = ifelse(is.finite(wOBA), fmt_avg(wOBA), ""),
            xWOBA = ifelse(is.finite(xWOBA), fmt_avg(xWOBA), ""),
            ISO = ifelse(is.finite(ISO), fmt_avg(ISO), ""),
            xISO = ifelse(is.finite(xISO), fmt_avg(xISO), ""),
            BABIP = ifelse(is.finite(BABIP), fmt_avg(BABIP), ""),
            `Barrel%` = ifelse(is.finite(`Barrel%`), paste0(round(`Barrel%`*100, 1), "%"), "")
          )
        
        # --- ALL row (ungrouped, same calculations) ---
        PA_all <- nrow(term)
        H1_all <- sum(term$PlayResult == "Single", na.rm = TRUE)
        H2_all <- sum(term$PlayResult == "Double", na.rm = TRUE)
        H3_all <- sum(term$PlayResult == "Triple", na.rm = TRUE)
        HR_all <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
        BB_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
        IBB_all <- sum(term$PlayResult == "IntentionalWalk", na.rm = TRUE)
        HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
        SF_all <- sum(term$PlayResult == "Sacrifice", na.rm = TRUE)
        Inplay_All_all <- sum(term$PitchCall == "InPlay", na.rm = TRUE)
        
        AB_all <- PA_all - (BB_all + HBP_all + SF_all)
        H_all <- H1_all + H2_all + H3_all + HR_all
        TB_all <- 1*H1_all + 2*H2_all + 3*H3_all + 4*HR_all
        
        # Calculate xWOBA, xISO, Barrel% for All row
        bip_evla_all <- df %>%
          dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                        is.finite(ExitSpeed), is.finite(Angle)) %>%
          dplyr::mutate(
            EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
            LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
          )
        
        xWOBA_all <- NA_real_
        xISO_all <- NA_real_
        
        if (exists("xbin_ref") && nrow(bip_evla_all) > 0) {
          bip_evla_all <- bip_evla_all %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
          for (nm in c("p1B","p2B","p3B","pHR")) {
            if (exists("x_overall") && nm %in% names(x_overall)) {
              bip_evla_all[[nm]][!is.finite(bip_evla_all[[nm]])] <- x_overall[[nm]]
            }
          }
          x1B_all <- sum(bip_evla_all$p1B, na.rm = TRUE)
          x2B_all <- sum(bip_evla_all$p2B, na.rm = TRUE)
          x3B_all <- sum(bip_evla_all$p3B, na.rm = TRUE)
          xHR_all <- sum(bip_evla_all$pHR, na.rm = TRUE)
          xH_all  <- x1B_all + x2B_all + x3B_all + xHR_all
          xTB_all <- 1*x1B_all + 2*x2B_all + 3*x3B_all + 4*xHR_all
          xAVG_all <- safe_div(xH_all, AB_all)
          xSLG_all <- safe_div(xTB_all, AB_all)
          xISO_all <- xSLG_all - xAVG_all
          
          BF_live_all <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
          if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
            xWOBA_all <- safe_div(W_BB*BB_all + W_1B*x1B_all + W_2B*x2B_all + W_3B*x3B_all + W_HR*xHR_all, BF_live_all)
          }
        }
        
        barrels_all <- sum(df$SessionType == "Live" & df$PitchCall == "InPlay" &
                             is.finite(df$ExitSpeed) & is.finite(df$Angle) &
                             df$ExitSpeed >= 95 & df$Angle >= 10 & df$Angle <= 35, na.rm = TRUE)
        inplay_live_all <- sum(df$SessionType == "Live" & df$PitchCall == "InPlay", na.rm = TRUE)
        BarrelPct_all <- safe_div(barrels_all, inplay_live_all)
        
        # Create All row with dynamic column name
        all_row_data <- list(
          PA = PA_all,
          AB = AB_all,
          AVG = safe_div(H_all, AB_all),
          SLG = safe_div(TB_all, AB_all),
          OBP = safe_div(H_all + BB_all + HBP_all, PA_all),
          OPS = NA_real_,
          wOBA = safe_div(0.690*(BB_all - IBB_all) + 0.722*HBP_all + 0.888*H1_all + 1.271*H2_all + 1.616*H3_all + 2.101*HR_all,
                          AB_all + BB_all - IBB_all + SF_all + HBP_all),
          xWOBA = xWOBA_all,
          ISO = safe_div(TB_all, AB_all) - safe_div(H_all, AB_all),
          xISO = xISO_all,
          BABIP = safe_div(H_all, Inplay_All_all),
          `Barrel%` = BarrelPct_all
        )
        all_row_data[[split_col_name]] <- "All"
        all_row <- tibble::as_tibble(all_row_data)
        all_row$OPS <- all_row$SLG + all_row$OBP
        
        # Format All row
        all_row <- all_row %>%
          dplyr::mutate(
            AVG = ifelse(is.finite(AVG), fmt_avg(AVG), ""),
            SLG = ifelse(is.finite(SLG), fmt_avg(SLG), ""),
            OBP = ifelse(is.finite(OBP), fmt_avg(OBP), ""),
            OPS = ifelse(is.finite(OPS), fmt_avg(OPS), ""),
            wOBA = ifelse(is.finite(wOBA), fmt_avg(wOBA), ""),
            xWOBA = ifelse(is.finite(xWOBA), fmt_avg(xWOBA), ""),
            ISO = ifelse(is.finite(ISO), fmt_avg(ISO), ""),
            xISO = ifelse(is.finite(xISO), fmt_avg(xISO), ""),
            BABIP = ifelse(is.finite(BABIP), fmt_avg(BABIP), ""),
            `Barrel%` = ifelse(is.finite(`Barrel%`), paste0(round(`Barrel%`*100, 1), "%"), "")
          )
        
        # Order pitch types correctly if Pitch Types is selected
        if (split_choice == "Pitch Types" && split_col_name == "Pitch" && exists("all_colors")) {
          pitch_order <- intersect(names(all_colors), batted_ball_data[[split_col_name]])
          if (length(pitch_order) > 0) {
            batted_ball_data[[split_col_name]] <- factor(batted_ball_data[[split_col_name]], levels = pitch_order)
            batted_ball_data <- batted_ball_data %>% dplyr::arrange(.data[[split_col_name]])
            batted_ball_data[[split_col_name]] <- as.character(batted_ball_data[[split_col_name]])
          }
        }
        
        # Bind rows
        df_out <- dplyr::bind_rows(batted_ball_data, all_row)
        
        table_cache <- df_out
        return(DT::datatable(
          df_out,
          options = list(
            dom = 't',
            scrollX = TRUE,
            paging = FALSE,
            ordering = FALSE
          ),
          rownames = FALSE
        ))
      }
      
      # ---------- NON-Results modes (your original build) ----------
      # QP+ per split type (scalar)
      qp_by_type <- df %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          `QP+` = {
            vals <- compute_qp_points(dplyr::cur_data_all())
            vals <- suppressWarnings(as.numeric(vals))
            round(mean(vals, na.rm = TRUE) * 200, 1)
          },
          .groups = "drop"
        )
      
      # Base per-split-type summary
      summ <- safe_make_summary(df, group_col = "SplitColumn")
      summ <- dplyr::mutate(summ,
                            ReleaseTilt = as.character(ReleaseTilt),
                            BreakTilt   = as.character(BreakTilt)
      )
      if (!("QP+" %in% names(summ))) {
        # join by PitchType in 'summ' to SplitColumn in qp_by_type
        summ <- summ %>% dplyr::left_join(qp_by_type, by = c("PitchType" = "SplitColumn"))
      }
      
      
      # Add Even/Ahead/Behind summary rows if splitting by Count (for non-Results modes)
      count_state_summ <- NULL
      if (split_choice == "Count" && "CountState" %in% names(df)) {
        for (state in c("Even", "Ahead", "Behind")) {
          state_df <- df %>% dplyr::filter(CountState == state)
          if (nrow(state_df) > 0) {
            state_summary <- safe_make_summary(
              state_df %>% dplyr::mutate(SplitColumn = state),
              group_col = "SplitColumn"
            )
            if ("SplitColumn" %in% names(state_summary)) {
              state_summary <- state_summary %>% dplyr::rename(PitchType = SplitColumn)
            }
            if (!("PitchType" %in% names(state_summary))) {
              state_summary$PitchType <- state
            }
            state_row <- state_summary %>%
              dplyr::mutate(
                PitchType = state,
                Usage = "",  # Calculate after binding
                Overall = ""
              )
            count_state_summ <- dplyr::bind_rows(count_state_summ, state_row)
          }
        }
        # Update Usage for count state rows
        if (!is.null(count_state_summ) && nrow(count_state_summ) > 0) {
          total_pitches <- nrow(df)
          count_state_summ <- count_state_summ %>%
            dplyr::mutate(Usage = paste0(round(100 * PitchCount / total_pitches, 1), "%"))
        }
      }
      
      # ---- Build FULL table (as before) ----
      df_table <- dplyr::bind_rows(
        summ,
        count_state_summ,
        {
          scores <- ifelse(
            df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
              df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
            ifelse(
              df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5),
              0.73, 0
            )
          )
          has_pc  <- sum(!is.na(df$PitchCall)) > 0
          strikes <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
          sw      <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
          den     <- sum(df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
          bf_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
          fps_opp <- bf_live
          k_live  <- sum(df$SessionType == "Live" & df$KorBB == "Strikeout",        na.rm = TRUE)
          bb_live <- sum(df$SessionType == "Live" & df$KorBB == "Walk",             na.rm = TRUE)
          fps_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0 &
                            df$PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
          ea_live  <- sum(df$SessionType == "Live" & (
            (df$Balls == 0 & df$Strikes == 0 & df$PitchCall == "InPlay") |
              (df$Balls == 0 & df$Strikes == 1 & df$PitchCall %in% c(
                "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
              )) |
              (df$Balls == 1 & df$Strikes == 0 & df$PitchCall == "InPlay") |
              (df$Balls == 1 & df$Strikes == 1 & df$PitchCall %in% c(
                "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
              ))
          ),
          na.rm = TRUE
          )
          
          vmax   <- suppressWarnings(max(as.numeric(df$RelSpeed), na.rm = TRUE)); vmax <- if (is.finite(vmax)) round(vmax, 1) else NA_real_
          ev_all <- nz_mean(ifelse(df$SessionType=="Live", df$ExitSpeed, NA_real_))
          la_all <- nz_mean(ifelse(df$SessionType=="Live", df$Angle,     NA_real_))
          stuff_all <- round(nz_mean(df$`Stuff+`), 1)
          ctrl_all   <- round(nz_mean(scores) * 100, 1)
          qp_all    <- round(nz_mean(compute_qp_points(df)) * 200, 1)
          
          # Calculate Swing% for All row
          swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","FoulBall","InPlay")
          swings_all <- sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE)
          swing_pct_all <- safe_pct(swings_all, nrow(df))
          
          tibble::tibble(
            PitchType     = "All",
            PitchCount    = nrow(df),
            Usage         = "100%",
            Overall       = "100%",
            BF            = bf_live,
            Velo_Avg      = round(nz_mean(df$RelSpeed), 1),
            Velo_Max      = vmax,
            IVB           = round(nz_mean(df$InducedVertBreak), 1),
            HB            = round(nz_mean(df$HorzBreak), 1),
            ReleaseTilt   = convert_to_clock(nz_mean(df$ReleaseTilt)),
            BreakTilt     = convert_to_clock(nz_mean(df$BreakTilt)),
            SpinEff       = nz_mean(df$SpinEfficiency),
            SpinRate      = round(nz_mean(df$SpinRate), 0),
            RelHeight     = round(nz_mean(df$RelHeight), 1),
            RelSide       = round(nz_mean(df$RelSide), 1),
            VertApprAngle = round(nz_mean(df$VertApprAngle), 1),
            HorzApprAngle = round(nz_mean(df$HorzApprAngle), 1),
            Extension     = round(nz_mean(df$Extension), 1),
            InZonePercent = { inzone <- (df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
                                           df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP)
            safe_pct(sum(inzone, na.rm=TRUE), sum(!is.na(inzone))) },
            CompPercent   = { comp <- (df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                                         df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5))
            safe_pct(sum(comp, na.rm=TRUE), sum(!is.na(comp))) },
            KPercent      = safe_pct(k_live, bf_live),
            BBPercent     = safe_pct(bb_live, bf_live),
            FPSPercent    = safe_pct(fps_live, fps_opp),
            EAPercent     = safe_pct(ea_live, fps_opp),
            StrikePercent = if (has_pc) safe_pct(strikes, nrow(df)) else "",
            SwingPercent  = swing_pct_all,
            WhiffPercent  = safe_pct(sw, den),
            EV = ev_all, LA = la_all,
            `Stuff+` = stuff_all, `Ctrl+` = ctrl_all, `QP+` = qp_all
          ) %>% dplyr::mutate(`Pitching+` = round((`Stuff+` + `QP+`)/2, 1))
        }
      ) %>%
        dplyr::rename(
          !!split_col_name := PitchType,
          `#`    = PitchCount,
          Velo   = Velo_Avg,
          Max    = Velo_Max,
          rTilt  = ReleaseTilt,
          bTilt  = BreakTilt,
          Spin   = SpinRate,
          Height = RelHeight,
          Side   = RelSide,
          Ext    = Extension,
          `InZone%` = InZonePercent,
          `Comp%`   = CompPercent,
          `K%`      = KPercent,
          `BB%`     = BBPercent,
          `FPS%`    = FPSPercent,
          `E+A%`    = EAPercent,
          `QP%`     = QPPercent,
          `Strike%` = StrikePercent,
          `Swing%`  = SwingPercent,
          `Whiff%`  = WhiffPercent,
          VAA       = VertApprAngle,
          HAA       = HorzApprAngle
        ) %>%
        dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]])) %>%
        dplyr::select(
          !!split_col_name, `#`, Usage, Overall,
          dplyr::any_of(c("0-0","Behind","Even","Ahead","<2K","2K")),
          BF,
          Velo, Max, IVB, HB, rTilt, bTilt, SpinEff, Spin, Height, Side, VAA, HAA, Ext,
          `InZone%`, `Comp%`, `Strike%`, `Swing%`, `FPS%`, `E+A%`, `QP%`, `K%`, `BB%`, `Whiff%`, EV, LA,
          `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
        ) %>%
        dplyr::mutate(
          SpinEff = {
            val <- suppressWarnings(as.numeric(SpinEff))
            ifelse(is.na(val), "", paste0(round(val * 100, 1), "%"))
          },
          EV = ifelse(is.na(as.numeric(EV)), "", round(as.numeric(EV), 1)),
          LA = ifelse(is.na(as.numeric(LA)), "", round(as.numeric(LA), 1))
        )
      
      # Add Process/Results columns and SANITIZE for DT
      extras <- compute_process_results(df, mode)
      if ("PitchType" %in% names(extras)) {
        extras <- extras %>%
          dplyr::rename(!!split_col_name := PitchType) %>%
          dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
        df_table <- df_table %>% dplyr::left_join(extras, by = split_col_name)
      }
      df_table <- fill_all_qp_pct(df_table, df)
      
      if (identical(mode, "Usage")) {
        usage_extras <- compute_usage_by_count(df)
        if ("PitchType" %in% names(usage_extras)) {
          usage_extras <- usage_extras %>%
            dplyr::rename(!!split_col_name := PitchType) %>%
            dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]])) %>%
            dplyr::select(!!split_col_name, `0-0`,`Behind`,`Even`,`Ahead`,`<2K`,`2K`)
          df_table <- df_table %>% dplyr::left_join(usage_extras, by = split_col_name)
        }
      }
      
      # Sort by IVB/HB in descending order if applicable
      df_table <- sort_by_range(df_table, split_col_name, split_choice)
      
      df_table <- collapse_list_cols(df_table)
      is_date_like <- function(x) inherits(x, c("Date","POSIXct","POSIXt","difftime"))
      date_like <- vapply(df_table, is_date_like, logical(1))
      if (any(date_like)) df_table[date_like] <- lapply(df_table[date_like], as.character)
      df_table <- as.data.frame(df_table, stringsAsFactors = FALSE, check.names = FALSE)
      
      if (all(c("Whiff%","CSW%") %in% names(df_table))) {
        df_table <- df_table %>% dplyr::relocate(`CSW%`, .after = `Whiff%`)
      }
      if ("Pitching+" %in% names(df_table)) {
        df_table <- df_table %>% dplyr::relocate(`Pitching+`, .after = dplyr::last_col())
      }
      
      df_table <- enforce_process_order(df_table)
      df_table <- enforce_stuff_order(df_table)
      
      # Hide RV/100 in Results mode (keep it for Process/Performance only)
      if (identical(mode, "Results") && "RV/100" %in% names(df_table)) {
        df_table <- dplyr::select(df_table, -`RV/100`)
      }
      if (identical(mode, "Custom")) {
        order_cols <- unique(c(split_col_name, custom))
        extras <- setdiff(names(df_table), order_cols)
        df_table <- df_table[, c(order_cols, extras), drop = FALSE]
      }
      
      # Update visible_set to use dynamic column name
      visible_set <- visible_set_for(mode, custom)
      visible_set <- gsub("^Pitch$", split_col_name, visible_set)
      
      build_summary_dt <- function(data, ...) {
        tryCatch(
          datatable_with_colvis(data, ...),
          error = function(e) {
            message("summaryTablePage datatable error [mode=", mode, "]: ", conditionMessage(e))
            message("Columns: ", paste(names(data), collapse = ", "))
            # Return a fallback datatable with error message instead of stopping
            DT::datatable(
              data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
              options = list(dom = 't'), rownames = FALSE
            )
          }
        )
      }
      table_cache <- list(
        table = df_table,
        source = df,
        label_column = split_col_name,
        split_choice = split_choice
      )
      build_summary_dt(
        df_table,
        lock            = split_col_name,
        remember        = FALSE,
        default_visible = intersect(visible_set, names(df_table)),
        mode            = mode,
        enable_colors   = isTRUE(input$summaryTableColors)
      )
    }, error = function(e) {
      message("summaryTablePage top-level error: ", conditionMessage(e))
      # Return a fallback datatable with error message
      DT::datatable(
        data.frame(Error = paste("Critical table error:", conditionMessage(e))),
        options = list(dom = 't'), rownames = FALSE
      )
    })
  })
  
  # ----- Custom table save/load (Summary & DP) -----
  observeEvent(input$summaryCustomSaved, {
    nm <- input$summaryCustomSaved
    if (!nzchar(nm)) return()
    ct <- custom_tables()
    if (!nm %in% names(ct)) return()
    cols <- ct[[nm]]$cols %||% character(0)
    updateTextInput(session, "summaryCustomName", value = nm)
    updateSelectizeInput(session, "summaryCustomCols", selected = cols)
  }, ignoreInit = TRUE)
  observeEvent(input$summarySaveCustom, {
    nm <- trimws(input$summaryCustomName %||% "")
    cols <- input$summaryCustomCols %||% character(0)
    if (!nzchar(nm) || !length(cols)) {
      showNotification("Please enter a name and choose at least one column.", type = "warning")
      return()
    }
    scope <- if (isTRUE(is_admin()) && isTRUE(input$summaryCustomGlobal)) GLOBAL_SCOPE else current_school()
    ct <- custom_tables()
    ct[[nm]] <- list(cols = cols, school_code = scope)
    custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
    updateSelectInput(session, "summaryCustomSaved", choices = c("", names(ct)), selected = nm)
    showNotification(paste("Saved custom table", nm), type = "message")
  }, ignoreInit = TRUE)
  observeEvent(input$summaryDeleteCustom, {
    nm <- input$summaryCustomSaved
    if (!nzchar(nm)) return()
    ct <- custom_tables()
    if (nm %in% names(ct)) {
      ct[[nm]] <- NULL
      custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
      updateSelectInput(session, "summaryCustomSaved", choices = c("", names(ct)), selected = "")
      showNotification(paste("Deleted custom table", nm), type = "message")
    }
  }, ignoreInit = TRUE)
  
  observeEvent(input$dpCustomSaved, {
    nm <- input$dpCustomSaved
    if (!nzchar(nm)) return()
    ct <- custom_tables()
    if (!nm %in% names(ct)) return()
    cols <- ct[[nm]]$cols %||% character(0)
    updateTextInput(session, "dpCustomName", value = nm)
    updateSelectizeInput(session, "dpCustomCols", selected = cols)
  }, ignoreInit = TRUE)
  observeEvent(input$dpSaveCustom, {
    nm <- trimws(input$dpCustomName %||% "")
    cols <- input$dpCustomCols %||% character(0)
    if (!nzchar(nm) || !length(cols)) {
      showNotification("Please enter a name and choose at least one column.", type = "warning")
      return()
    }
    scope <- if (isTRUE(is_admin()) && isTRUE(input$dpCustomGlobal)) GLOBAL_SCOPE else current_school()
    ct <- custom_tables()
    ct[[nm]] <- list(cols = cols, school_code = scope)
    custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
    updateSelectInput(session, "dpCustomSaved", choices = c("", names(ct)), selected = nm)
    showNotification(paste("Saved custom table", nm), type = "message")
  }, ignoreInit = TRUE)
  observeEvent(input$dpDeleteCustom, {
    nm <- input$dpCustomSaved
    if (!nzchar(nm)) return()
    ct <- custom_tables()
    if (nm %in% names(ct)) {
      ct[[nm]] <- NULL
      custom_tables(ct); save_custom_tables(ct); update_custom_table_choices(session)
      updateSelectInput(session, "dpCustomSaved", choices = c("", names(ct)), selected = "")
      showNotification(paste("Deleted custom table", nm), type = "message")
    }
  }, ignoreInit = TRUE)
  # -----------------------------
  # Data & Performance table (DP)
  # -----------------------------
  output$summaryTable <- DT::renderDataTable({
    df <- filtered_data()
    table_cache <- NULL
    on.exit({
      session$userData$table_cache_summaryTable <- table_cache
    }, add = TRUE)
    if (!nrow(df)) {
      return(DT::datatable(
        data.frame(Message = "No data for selected filters"),
        options = list(dom = 't'), rownames = FALSE
      ))
    }
    
    # Apply Split By transformation
    split_choice <- if (!is.null(input$dpSplitBy)) input$dpSplitBy else "Pitch Types"
    df <- apply_split_by(df, split_choice)
    
    # Determine the column name based on split choice
    split_col_name <- switch(
      split_choice,
      "Pitch Types" = "Pitch",
      "Batter Hand" = "Batter Hand",
      "Count" = "Count",
      "After Count" = "After Count",
      "Velocity" = "Velocity",
      "IVB" = "InducedVert",
      "HB" = "HorzBreak",
      "Batter" = "Batter",
      "Pitch"  # default
    )
    
    # --- small helpers (match Hitting logic) ---
    nz_mean <- function(x) { x <- suppressWarnings(as.numeric(x)); m <- mean(x, na.rm = TRUE); if (is.finite(m)) m else NA_real_ }
    fmt_avg <- function(x) { z <- ifelse(is.finite(x), sprintf("%.3f", x), NA_character_); sub("^0", "", z) }
    safe_div <- function(num, den) ifelse(den > 0, num/den, NA_real_)
    parse_num <- function(x) {
      if (is.numeric(x)) return(x)
      x1 <- trimws(as.character(x)); x1[x1 == ""] <- NA_character_
      ifelse(grepl("%$", x1), suppressWarnings(as.numeric(sub("%$","",x1)))/100,
             suppressWarnings(as.numeric(x1)))
    }
    ip_fmt <- function(ip_raw) {
      out <- rep("", length(ip_raw))
      ok  <- is.finite(ip_raw) & ip_raw > 0
      outs <- floor(ip_raw[ok]*3 + 1e-8)
      inn  <- outs %/% 3
      rem  <- outs %% 3
      out[ok] <- paste0(inn, ".", rem)
      out
    }
    FIP_C <- if (exists("FIP_CONST")) get("FIP_CONST") else 3.20
    
    # prefer DP page controls; fall back to Summary page controls; resolve saved custom tables
    res_mode <- resolve_table_mode_global(
      if (!is.null(input$dpTableMode)) input$dpTableMode else input$summaryTableMode,
      if (!is.null(input$dpCustomCols)) input$dpCustomCols else input$summaryCustomCols
    )
    mode <- res_mode$mode
    custom <- res_mode$cols
    
    # Fallback visible-set helper if your global helper isn't in scope
    if (!exists("visible_set_for")) {
      visible_set_for <- function(mode, custom) {
        base <- c("Pitch","#","Usage","BF","IP","FIP","WHIP","Velo","Max","IVB","HB","rTilt","bTilt","SpinEff","Spin",
                  "Height","Side","VAA","HAA","Ext","InZone%","Comp%","Strike%","FPS%","E+A%","QP%",
                  "K%","BB%","Whiff%","EV","LA","Stuff+","Ctrl+","QP+","Pitching+",
                  # Results-specific
                  "PA","AB","AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP","GB%","Barrel%","Swing%","Whiff%","K%","BB%","EV","LA"
        )
        if (identical(mode, "Custom") && length(custom)) unique(c("Pitch", custom)) else base
      }
    }
    
    # ---------- RESULTS TABLE (fixes inflated BIP rates) ----------
    if (identical(mode, "Results")) {
      swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
      
      # Terminal rows = completed PA
      is_term <- (
        (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
          (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk"))
      )
      term <- df[is_term, , drop = FALSE]
      
      # Per-split-type tallies (PA/AB/H/K/BB/HBP/Sac/HR)
      per_type <- term %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          PA   = dplyr::n(),
          HBP  = sum(PlayResult == "HitByPitch", na.rm = TRUE),
          Sac  = sum(PlayResult == "Sacrifice",  na.rm = TRUE),
          `1B` = sum(PlayResult == "Single",  na.rm = TRUE),
          `2B` = sum(PlayResult == "Double",  na.rm = TRUE),
          `3B` = sum(PlayResult == "Triple",  na.rm = TRUE),
          HR   = sum(PlayResult == "HomeRun", na.rm = TRUE),
          Kct  = sum(KorBB == "Strikeout" |
                       PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE),
          BBct = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(
          AB  = PA - (BBct + HBP + Sac),
          H   = `1B` + `2B` + `3B` + HR,
          TB  = 1*`1B` + 2*`2B` + 3*`3B` + 4*HR,
          AVG = safe_div(H, AB),
          SLG = safe_div(TB, AB),
          OBP = safe_div(H + BBct + HBP, PA),
          OPS = SLG + OBP
        )
      
      # Pitch totals for Usage/Swing%/Whiff%
      pitch_totals <- df %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          Pitches       = dplyr::n(),
          Swings        = sum(!is.na(PitchCall) & PitchCall %in% swing_levels, na.rm = TRUE),
          Whiffs        = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
          CalledStrikes = sum(PitchCall == "StrikeCalled",    na.rm = TRUE),
          .groups = "drop"
        )
      total_pitches <- sum(pitch_totals$Pitches, na.rm = TRUE)
      
      # Command scoring vector and per-type Command+ / Stuff+ / Pitching+
      scores <- ifelse(
        df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
          df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
        ifelse(
          df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
            df$PlateLocHeight >= (2.65 - 1.5) & df$PlateLocHeight <= (2.65 + 1.5),
          0.73, 0
        )
      )
      sc_by_type <- df %>%
        dplyr::mutate(.scores = scores) %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          StuffP   = round(nz_mean(`Stuff+`), 1),
          CommandP = round(nz_mean(.scores) * 100, 1),
          .groups = "drop"
        ) %>%
        dplyr::mutate(PitchingP = round((StuffP + CommandP)/2, 1))
      
      # Live balls in play for EV/LA and GB%
      bbe <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
      evla <- bbe %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(EV = nz_mean(ExitSpeed), LA = nz_mean(Angle), .groups = "drop")
      gb <- bbe %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          `GB%` = safe_div(sum(TaggedHitType == "GroundBall", na.rm = TRUE),
                           sum(!is.na(TaggedHitType),        na.rm = TRUE)),
          .groups = "drop"
        )
      
      # Extras (xWOBA/xISO/BABIP/Barrel%) — numeric
      extras_raw <- compute_process_results(df)
      if ("PitchType" %in% names(extras_raw)) {
        extras <- extras_raw %>%
          dplyr::rename(SplitColumn = PitchType) %>%
          dplyr::mutate(
            xWOBA     = parse_num(xWOBA),
            xISO      = parse_num(xISO),
            BABIP     = parse_num(BABIP),
            `Barrel%` = parse_num(`Barrel%`)
          ) %>%
          dplyr::select(SplitColumn, xWOBA, xISO, BABIP, `Barrel%`, `RV/100`)
      } else {
        extras <- df %>%
          dplyr::group_by(SplitColumn) %>%
          dplyr::summarise(
            xWOBA = NA_real_, xISO = NA_real_, 
            BABIP = NA_real_, `Barrel%` = NA_real_, `RV/100` = NA_real_,
            .groups = "drop"
          )
      }
      
      # Build per-type rows (+ #, Usage, BF, IP, FIP, WHIP, Pitching+)
      res_pt <- per_type %>%
        dplyr::left_join(pitch_totals, by = "SplitColumn") %>%
        dplyr::left_join(evla,         by = "SplitColumn") %>%
        dplyr::left_join(gb,           by = "SplitColumn") %>%
        dplyr::mutate(
          `Swing%` = safe_div(Swings, Pitches),
          `Whiff%` = safe_div(Whiffs, Swings),
          `CSW%`   = safe_div(Whiffs + CalledStrikes, Pitches),
          Outs     = (AB - H) + Sac,
          IP_raw   = safe_div(Outs, 3),
          BF       = PA,
          `#`      = Pitches,
          Usage    = ifelse(total_pitches > 0, paste0(round(100*Pitches/total_pitches,1), "%"), ""),
          FIP_tmp  = safe_div(13*HR + 3*(BBct + HBP) - 2*Kct, IP_raw),
          FIP      = ifelse(is.finite(FIP_tmp), round(FIP_tmp + FIP_C, 2), NA_real_),
          WHIP_tmp = safe_div(H + BBct, IP_raw),
          WHIP     = ifelse(is.finite(WHIP_tmp), round(WHIP_tmp, 2), NA_real_)
        ) %>%
        dplyr::left_join(sc_by_type, by = "SplitColumn") %>%
        dplyr::left_join(extras, by = "SplitColumn") %>%
        dplyr::transmute(
          !!split_col_name := as.character(SplitColumn),
          `#`, Usage, BF, `RV/100`, IP = ip_fmt(IP_raw), FIP, WHIP,
          PA, AB, AVG, SLG, OBP, OPS,
          xWOBA, xISO, BABIP,
          `Swing%`, `Whiff%`, `CSW%`, `GB%`,
          `K%` = safe_div(Kct, PA), `BB%` = safe_div(BBct, PA),
          `Barrel%`, EV, LA,
          `Pitching+` = PitchingP
        )
      
      # --- ALL row (same definitions, ungrouped) ---
      PAt <- nrow(term)
      HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
      Sac_all <- sum(term$PlayResult == "Sacrifice",  na.rm = TRUE)
      H1  <- sum(term$PlayResult == "Single",  na.rm = TRUE)
      H2  <- sum(term$PlayResult == "Double",  na.rm = TRUE)
      H3  <- sum(term$PlayResult == "Triple",  na.rm = TRUE)
      HR  <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
      H   <- H1 + H2 + H3 + HR
      TB  <- 1*H1 + 2*H2 + 3*H3 + 4*HR
      Kct_all <- sum(term$KorBB == "Strikeout" |
                       term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
      BBc_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
      ABt <- PAt - (BBc_all + HBP_all + Sac_all)
      swings  <- sum(!is.na(df$PitchCall) & df$PitchCall %in% swing_levels, na.rm = TRUE)
      whiffs  <- sum(df$PitchCall == "StrikeSwinging",                      na.rm = TRUE)
      csw_all_num <- sum(df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
      gbpct_all <- {
        d <- df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
        safe_div(sum(d$TaggedHitType == "GroundBall", na.rm = TRUE),
                 sum(!is.na(d$TaggedHitType),         na.rm = TRUE))
      }
      Outs_all <- (ABt - H) + Sac_all
      IP_all   <- safe_div(Outs_all, 3)
      FIP_all  <- {
        tmp <- safe_div(13*HR + 3*(BBc_all + HBP_all) - 2*Kct_all, IP_all)
        ifelse(is.finite(tmp), round(tmp + FIP_C, 2), NA_real_)
      }
      WHIP_all <- {
        tmp <- safe_div(H + BBc_all, IP_all)
        ifelse(is.finite(tmp), round(tmp, 2), NA_real_)
      }
      # Pitching+ for All row
      stuff_all <- round(nz_mean(df$`Stuff+`), 1)
      qp_all <- round(nz_mean(compute_qp_points(df)) * 200, 1)
      pitc_all <- round((stuff_all + qp_all) / 2, 1)
      
      # Create all_row with dynamic column name
      all_row_data <- list(
        `#`   = nrow(df),
        Usage = "100%",
        BF = PAt,
        `RV/100` = "",
        IP = ip_fmt(IP_all),
        FIP = FIP_all,
        WHIP = WHIP_all,
        PA = PAt, AB = ABt,
        AVG = safe_div(H, ABt),
        SLG = safe_div(TB, ABt),
        OBP = safe_div(H + BBc_all + HBP_all, PAt),
        OPS = NA_real_,
        xWOBA = NA_real_, xISO = NA_real_, BABIP = NA_real_,
        `Swing%` = safe_div(swings, total_pitches),
        `Whiff%` = safe_div(whiffs, swings),
        `CSW%`   = safe_div(csw_all_num, total_pitches),
        `GB%`    = gbpct_all,
        `K%`     = safe_div(Kct_all, PAt),
        `BB%`    = safe_div(BBc_all, PAt),
        `Barrel%`= NA_real_,
        EV = nz_mean(bbe$ExitSpeed),
        LA = nz_mean(bbe$Angle),
        `Pitching+` = pitc_all
      )
      all_row_data[[split_col_name]] <- "All"
      all_row <- tibble::as_tibble(all_row_data)
      all_row$OPS <- all_row$SLG + all_row$OBP
      
      # Fill extras (All)
      extras_all <- compute_process_results(df, mode) %>%
        dplyr::mutate(
          xWOBA     = parse_num(xWOBA),
          xISO      = parse_num(xISO),
          BABIP     = parse_num(BABIP),
          `Barrel%` = parse_num(`Barrel%`),
          `RV/100`  = parse_num(`RV/100`)
        ) %>%
        dplyr::summarise(
          xWOBA     = nz_mean(xWOBA),
          xISO      = nz_mean(xISO),
          BABIP     = nz_mean(BABIP),
          `Barrel%` = nz_mean(`Barrel%`),
          `RV/100`  = nz_mean(`RV/100`),
          .groups = "drop"
        )
      if (nrow(extras_all)) {
        all_row$xWOBA     <- extras_all$xWOBA[1]
        all_row$xISO      <- extras_all$xISO[1]
        all_row$BABIP     <- extras_all$BABIP[1]
        all_row$`Barrel%` <- extras_all$`Barrel%`[1]
        all_row$`RV/100`  <- extras_all$`RV/100`[1]
      }
      
      # Add Even/Ahead/Behind summary rows if splitting by Count (Data & Performance)
      dp_count_state_rows <- NULL
      if (split_choice == "Count" && "CountState" %in% names(df)) {
        swing_levels <- c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","FoulBall","InPlay")
        calc_rv100 <- function(dfi) {
          dfi_live <- dfi %>% dplyr::filter(SessionType == "Live")
          dfi_use  <- if (nrow(dfi_live)) dfi_live else dfi
          if (!nrow(dfi_use)) return(NA_real_)
          run_val <- function(pitch_call, play_result, korbb = NA) {
            pitch_call  <- as.character(pitch_call)
            play_result <- as.character(play_result)
            korbb       <- as.character(korbb)
            if (!is.na(korbb) && nzchar(korbb) && korbb != "NA") {
              if (korbb == "Strikeout") return(-0.27)
              if (korbb == "Walk")     return(0.33)
            }
            if (pitch_call %in% c("BallCalled", "BallIntentional", "BallinDirt")) return(0.03)
            if (pitch_call %in% c("StrikeCalled", "StrikeSwinging", "FoulBall",
                                  "FoulBallFieldable", "FoulBallNotFieldable"))  return(-0.03)
            if (pitch_call == "HitByPitch" || play_result %in% c("Walk","IntentionalWalk","HitByPitch")) return(0.33)
            if (pitch_call == "InPlay") {
              if (play_result == "Single")   return(0.47)
              if (play_result == "Double")   return(0.78)
              if (play_result == "Triple")   return(1.09)
              if (play_result == "HomeRun")  return(1.40)
              if (play_result == "Error")    return(0.33)
              return(-0.27)
            }
            0
          }
          rv_vals <- mapply(
            run_val,
            dfi_use$PitchCall,
            dfi_use$PlayResult,
            if ("KorBB" %in% names(dfi_use)) dfi_use$KorBB else NA
          )
          rv_val <- ((sum(rv_vals, na.rm = TRUE) / nrow(dfi_use)) * 100) - 0.43
          ifelse(is.finite(rv_val), rv_val, NA_real_)
        }
        for (state in c("Even", "Ahead", "Behind")) {
          state_df <- df %>% dplyr::filter(CountState == state)
          state_term <- term %>% dplyr::filter(CountState == state)
          
          if (nrow(state_df) > 0) {
            # Similar calculations as for individual counts
            state_PA <- nrow(state_term)
            state_HBP <- sum(state_term$PlayResult == "HitByPitch", na.rm = TRUE)
            state_Sac <- sum(state_term$PlayResult == "Sacrifice", na.rm = TRUE)
            state_H1 <- sum(state_term$PlayResult == "Single", na.rm = TRUE)
            state_H2 <- sum(state_term$PlayResult == "Double", na.rm = TRUE)
            state_H3 <- sum(state_term$PlayResult == "Triple", na.rm = TRUE)
            state_HR <- sum(state_term$PlayResult == "HomeRun", na.rm = TRUE)
            state_H <- state_H1 + state_H2 + state_H3 + state_HR
            state_TB <- 1*state_H1 + 2*state_H2 + 3*state_H3 + 4*state_HR
            state_Kct <- sum(state_term$KorBB == "Strikeout" |
                               state_term$PlayResult %in% c("Strikeout","StrikeoutSwinging","StrikeoutLooking"), na.rm = TRUE)
            state_BBct <- sum(state_term$KorBB == "Walk" | state_term$PlayResult == "Walk", na.rm = TRUE)
            state_AB <- state_PA - (state_BBct + state_HBP + state_Sac)
            
            state_swings <- sum(!is.na(state_df$PitchCall) & state_df$PitchCall %in% swing_levels, na.rm = TRUE)
            state_whiffs <- sum(state_df$PitchCall == "StrikeSwinging", na.rm = TRUE)
            state_csw <- sum(state_df$PitchCall %in% c("StrikeSwinging","StrikeCalled"), na.rm = TRUE)
            state_bbe <- state_df %>% dplyr::filter(grepl("live|game|ab", tolower(SessionType)), PitchCall == "InPlay")
            state_gbpct <- safe_div(sum(state_bbe$TaggedHitType == "GroundBall", na.rm = TRUE),
                                    sum(!is.na(state_bbe$TaggedHitType), na.rm = TRUE))
            
            # Calculate BABIP for count state
            state_inplay_all <- sum(state_df$PitchCall == "InPlay", na.rm = TRUE)
            state_BABIP <- safe_div(state_H, state_inplay_all)
            
            # Calculate Barrel% for count state
            state_barrels <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay" &
                                   is.finite(state_df$ExitSpeed) & is.finite(state_df$Angle) &
                                   state_df$ExitSpeed >= 95 & state_df$Angle >= 10 & state_df$Angle <= 35, na.rm = TRUE)
            state_inplay_live <- sum(state_df$SessionType == "Live" & state_df$PitchCall == "InPlay", na.rm = TRUE)
            state_BarrelPct <- safe_div(state_barrels, state_inplay_live)
            
            # Calculate xWOBA and xISO for count state (using expected stats if available)
            state_bip_evla <- state_df %>%
              dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                            is.finite(ExitSpeed), is.finite(Angle)) %>%
              dplyr::mutate(
                EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
                LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
              )
            if (exists("xbin_ref") && nrow(state_bip_evla) > 0) {
              state_bip_evla <- state_bip_evla %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
              for (nm in c("p1B","p2B","p3B","pHR")) {
                if (exists("x_overall") && nm %in% names(x_overall)) {
                  state_bip_evla[[nm]][!is.finite(state_bip_evla[[nm]])] <- x_overall[[nm]]
                }
              }
              state_x1B <- sum(state_bip_evla$p1B, na.rm = TRUE)
              state_x2B <- sum(state_bip_evla$p2B, na.rm = TRUE)
              state_x3B <- sum(state_bip_evla$p3B, na.rm = TRUE)
              state_xHR <- sum(state_bip_evla$pHR, na.rm = TRUE)
              state_xH   <- state_x1B + state_x2B + state_x3B + state_xHR
              state_xTB  <- 1*state_x1B + 2*state_x2B + 3*state_x3B + 4*state_xHR
              state_xAVG <- safe_div(state_xH, state_AB)
              state_xSLG <- safe_div(state_xTB, state_AB)
              state_xISO <- state_xSLG - state_xAVG
              # xWOBA calculation (using weights if they exist)
              state_BF_live <- sum(state_df$SessionType == "Live" & state_df$Balls == 0 & state_df$Strikes == 0, na.rm = TRUE)
              if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
                state_xWOBA <- safe_div(W_BB*state_BBct + W_1B*state_x1B + W_2B*state_x2B + W_3B*state_x3B + W_HR*state_xHR, state_BF_live)
              } else {
                state_xWOBA <- NA_real_
              }
            } else {
              state_xWOBA <- NA_real_
              state_xISO <- NA_real_
            }
            
            state_Outs <- (state_AB - state_H) + state_Sac
            state_IP <- safe_div(state_Outs, 3)
            state_FIP <- {
              tmp <- safe_div(13*state_HR + 3*(state_BBct + state_HBP) - 2*state_Kct, state_IP)
              ifelse(is.finite(tmp), round(tmp + FIP_C, 2), NA_real_)
            }
            state_WHIP <- {
              tmp <- safe_div(state_H + state_BBct, state_IP)
              ifelse(is.finite(tmp), round(tmp, 2), NA_real_)
            }
            
            # Calculate InZone%, Strike%, and Comp% for count state
            state_inzone <- sum(state_df$PlateLocSide >= ZONE_LEFT & state_df$PlateLocSide <= ZONE_RIGHT &
                                  state_df$PlateLocHeight >= ZONE_BOTTOM & state_df$PlateLocHeight <= ZONE_TOP, na.rm = TRUE)
            state_InZonePct <- safe_div(state_inzone, nrow(state_df))
            
            state_strikes <- sum(state_df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
            state_StrikePct <- safe_div(state_strikes, nrow(state_df))
            
            state_comp <- sum(state_df$PlateLocSide >= -1.5 & state_df$PlateLocSide <= 1.5 &
                                state_df$PlateLocHeight >= (2.65-1.5) & state_df$PlateLocHeight <= (2.65+1.5), na.rm = TRUE)
            state_CompPct <- safe_div(state_comp, nrow(state_df))
            
            state_pitches <- nrow(state_df)
            state_rv100 <- calc_rv100(state_df)
            pitching_plus <- if ("Pitching+" %in% names(state_df)) round(nz_mean(state_df$`Pitching+`), 1) else round(nz_mean(state_df$`Stuff+`), 1)
            state_row_data <- list(
              `#` = state_pitches,
              Usage = ifelse(total_pitches > 0, paste0(round(100*state_pitches/total_pitches, 1), "%"), ""),
              BF = state_PA,
              `RV/100` = ifelse(is.finite(state_rv100), state_rv100, NA_real_),
              IP = ip_fmt(state_IP),
              FIP = state_FIP,
              WHIP = state_WHIP,
              PA = state_PA,
              AB = state_AB,
              AVG = safe_div(state_H, state_AB),
              SLG = safe_div(state_TB, state_AB),
              OBP = safe_div(state_H + state_BBct + state_HBP, state_PA),
              OPS = NA_real_,
              xWOBA = state_xWOBA,
              xISO = state_xISO,
              BABIP = state_BABIP,
              `InZone%` = state_InZonePct,
              `Strike%` = state_StrikePct,
              `Comp%` = state_CompPct,
              `Swing%` = safe_div(state_swings, state_pitches),
              `Whiff%` = safe_div(state_whiffs, state_swings),
              `CSW%` = safe_div(state_csw, state_pitches),
              `GB%` = state_gbpct,
              `K%` = safe_div(state_Kct, state_PA),
              `BB%` = safe_div(state_BBct, state_PA),
              `Barrel%` = state_BarrelPct,
              EV = nz_mean(state_bbe$ExitSpeed),
              LA = nz_mean(state_bbe$Angle),
              `Pitching+` = pitching_plus
            )
            state_row_data[[split_col_name]] <- state
            state_row <- tibble::as_tibble(state_row_data)
            state_row$OPS <- state_row$SLG + state_row$OBP
            
            dp_count_state_rows <- dplyr::bind_rows(dp_count_state_rows, state_row)
          }
        }
      }
      
      # Order pitch types correctly if Pitch Types is selected
      if (split_choice == "Pitch Types" && split_col_name == "Pitch" && exists("all_colors")) {
        pitch_order <- intersect(names(all_colors), res_pt[[split_col_name]])
        if (length(pitch_order) > 0) {
          res_pt[[split_col_name]] <- factor(res_pt[[split_col_name]], levels = pitch_order)
          res_pt <- res_pt %>% dplyr::arrange(.data[[split_col_name]])
          res_pt[[split_col_name]] <- as.character(res_pt[[split_col_name]])
        }
      }
      
      # Bind + format
      df_out <- dplyr::bind_rows(res_pt, dp_count_state_rows, all_row) %>%
        dplyr::mutate(
          dplyr::across(c(PA, AB, AVG, SLG, OBP, OPS, xWOBA, xISO, BABIP,
                          `Swing%`, `Whiff%`, `CSW%`, `GB%`, `K%`, `BB%`, `Barrel%`,
                          EV, LA, FIP, WHIP),
                        ~ suppressWarnings(as.numeric(.)))
        )
      pct_cols  <- c("Swing%","Whiff%","CSW%","GB%","K%","BB%","Barrel%")
      rate_cols <- c("AVG","SLG","OBP","OPS","xWOBA","xISO","BABIP")
      df_out[pct_cols]  <- lapply(df_out[pct_cols],  function(z) ifelse(is.finite(z), paste0(round(z*100,1), "%"), ""))
      df_out[rate_cols] <- lapply(df_out[rate_cols], function(z) ifelse(is.finite(z), fmt_avg(z), ""))
      df_out$EV   <- ifelse(is.finite(df_out$EV),   round(df_out$EV, 1), "")
      df_out$LA   <- ifelse(is.finite(df_out$LA),   round(df_out$LA, 1), "")
      df_out$FIP  <- ifelse(is.finite(df_out$FIP),  sprintf("%.2f", df_out$FIP), "")
      df_out$WHIP <- ifelse(is.finite(df_out$WHIP), sprintf("%.2f", df_out$WHIP), "")
      df_out$`RV/100` <- {
        z <- suppressWarnings(as.numeric(df_out$`RV/100`))
        ifelse(is.finite(z), fmt_num2(z), "")
      }
      
      # Sort by IVB/HB in descending order if applicable
      df_out <- sort_by_range(df_out, split_col_name, split_choice)
      
      df_dt <- if (exists("safe_for_dt")) safe_for_dt(df_out) else df_out
      is_all <- df_dt[[split_col_name]] == "All"
      for (nm in c("Swing%","Whiff%","CSW%","GB%","K%","BB%")) {
        z <- df_dt[[nm]]
        z[is_all & (is.na(z) | trimws(z) == "")] <- "0.0%"
        df_dt[[nm]] <- z
      }
      
      # Update visible_set to use dynamic column name
      visible_set <- visible_set_for(mode, custom)
      visible_set <- gsub("^Pitch$", split_col_name, visible_set)
      if (identical(mode, "Custom")) {
        order_cols <- unique(c(split_col_name, custom))
        extras <- setdiff(names(df_dt), order_cols)
        df_dt <- df_dt[, c(order_cols, extras), drop = FALSE]
      }
      
      table_cache <- df_dt
      return(datatable_with_colvis(
        df_dt,
        lock            = split_col_name,
        remember        = FALSE,
        default_visible = intersect(visible_set, names(df_dt)),
        mode            = mode,
        enable_colors   = isTRUE(input$dpTableColors)
      ))
    }
    
    # ---------- RAW DATA TABLE ----------
    if (identical(mode, "Raw Data")) {
      # Helper function for innings pitched calculation
      ip_calculation <- function(pitches_data) {
        outs <- sum(pitches_data$KorBB == "Strikeout", na.rm = TRUE) + 
          sum(pitches_data$PlayResult %in% c("Out", "FieldersChoice", "Error"), na.rm = TRUE)
        innings <- outs / 3
        whole_innings <- floor(innings)
        remaining_outs <- outs %% 3
        if (remaining_outs == 0) {
          return(paste0(whole_innings, ".0"))
        } else {
          return(paste0(whole_innings, ".", remaining_outs))
        }
      }
      
      raw_per_type <- df %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          IP = ip_calculation(dplyr::cur_data_all()),
          P = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all()),
          H = sum(PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE),
          XBH = sum(PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE),
          Barrels = sum(ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, na.rm = TRUE),
          BB = sum(KorBB == "Walk", na.rm = TRUE),
          HBP = sum(PlayResult == "HitByPitch", na.rm = TRUE),
          K = sum(KorBB == "Strikeout", na.rm = TRUE),
          Whiffs = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::rename(!!split_col_name := SplitColumn) %>%
        dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
      
      # Order pitch types correctly if Pitch Types is selected
      if (split_choice == "Pitch Types" && exists("all_colors")) {
        pitch_order <- intersect(names(all_colors), raw_per_type[[split_col_name]])
        if (length(pitch_order) > 0) {
          raw_per_type[[split_col_name]] <- factor(raw_per_type[[split_col_name]], levels = pitch_order)
          raw_per_type <- raw_per_type %>% dplyr::arrange(.data[[split_col_name]])
          raw_per_type[[split_col_name]] <- as.character(raw_per_type[[split_col_name]])
        }
      }
      
      # All row calculations
      all_ip <- ip_calculation(df)
      all_p <- nrow(df)
      all_bf <- calculate_bf(df)
      all_h <- sum(df$PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
      all_xbh <- sum(df$PlayResult %in% c("Double", "Triple", "HomeRun"), na.rm = TRUE)
      all_barrels <- sum(df$ExitSpeed >= 95 & df$Angle >= 10 & df$Angle <= 35, na.rm = TRUE)
      all_bb <- sum(df$KorBB == "Walk", na.rm = TRUE)
      all_hbp <- sum(df$PlayResult == "HitByPitch", na.rm = TRUE)
      all_k <- sum(df$KorBB == "Strikeout", na.rm = TRUE)
      all_whiffs <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
      
      # Calculate P/IP and P/BF for All row only
      # Convert IP from "X.Y" format to decimal (X + Y/3)
      ip_decimal <- if (all_ip != "0.0") {
        parts <- strsplit(all_ip, "\\.")[[1]]
        as.numeric(parts[1]) + as.numeric(parts[2])/3
      } else 0
      
      p_per_ip <- if (ip_decimal > 0) as.character(round(all_p / ip_decimal, 1)) else ""
      p_per_bf <- if (all_bf > 0) as.character(round(all_p / all_bf, 1)) else ""
      
      # Create all_row with dynamic split column name first
      all_row_data <- list()
      all_row_data[[split_col_name]] <- "All"
      all_row_data$IP <- all_ip
      all_row_data$P <- all_p
      all_row_data$BF <- all_bf
      all_row_data$`P/IP` <- p_per_ip
      all_row_data$`P/BF` <- p_per_bf
      all_row_data$H <- all_h
      all_row_data$XBH <- all_xbh
      all_row_data$Barrels <- all_barrels
      all_row_data$BB <- all_bb
      all_row_data$HBP <- all_hbp
      all_row_data$K <- all_k
      all_row_data$Whiffs <- all_whiffs
      all_row <- tibble::as_tibble(all_row_data)
      
      # Add empty P/IP and P/BF columns to per-type data
      raw_per_type$`P/IP` <- ""
      raw_per_type$`P/BF` <- ""
      
      # Reorder columns to match desired layout - use dynamic column name
      col_order <- c(split_col_name, "IP", "P", "BF", "P/IP", "P/BF", "H", "XBH", "Barrels", "BB", "HBP", "K", "Whiffs")
      raw_per_type <- raw_per_type[, col_order]
      all_row <- all_row[, col_order]
      
      df_raw <- dplyr::bind_rows(raw_per_type, all_row)
      
      visible_set <- names(df_raw)
      table_cache <- df_raw
      return(datatable_with_colvis(
        df_raw,
        lock            = split_col_name,
        remember        = FALSE,
        default_visible = visible_set,
        mode            = mode,
        enable_colors   = FALSE
      ))
    }
    
    # ---------- BATTED BALL DATA TABLE ----------
    if (identical(mode, "Batted Ball Data")) {
      # Helper function
      fmt_avg <- function(x) sprintf("%.3f", x)
      
      # Filter for completed PAs only (like Results table does)
      is_term <- (
        (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
          (!is.na(df$KorBB) & df$KorBB %in% c("Strikeout","Walk"))
      )
      term <- df[is_term, , drop = FALSE]
      
      # Group by SplitColumn and calculate stats for each split
      per_type <- term %>%
        dplyr::group_by(SplitColumn) %>%
        dplyr::summarise(
          PA = dplyr::n(),  # Count completed PAs, not first pitches
          H1 = sum(PlayResult == "Single", na.rm = TRUE),
          H2 = sum(PlayResult == "Double", na.rm = TRUE),
          H3 = sum(PlayResult == "Triple", na.rm = TRUE),
          HR = sum(PlayResult == "HomeRun", na.rm = TRUE),
          BB = sum(KorBB == "Walk" | PlayResult == "Walk", na.rm = TRUE),
          IBB = sum(PlayResult == "IntentionalWalk", na.rm = TRUE),
          HBP = sum(PlayResult == "HitByPitch", na.rm = TRUE),
          SF = sum(PlayResult == "Sacrifice", na.rm = TRUE),
          Inplay_All = sum(PitchCall == "InPlay", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(
          AB = PA - (BB + HBP + SF),
          H = H1 + H2 + H3 + HR,
          TB = 1*H1 + 2*H2 + 3*H3 + 4*HR,
          AVG = safe_div(H, AB),
          SLG = safe_div(TB, AB),
          OBP = safe_div(H + BB + HBP, PA),
          OPS = SLG + OBP,
          ISO = SLG - AVG,
          uBB = BB - IBB,
          wOBA_num = 0.690*uBB + 0.722*HBP + 0.888*H1 + 1.271*H2 + 1.616*H3 + 2.101*HR,
          wOBA_den = AB + BB - IBB + SF + HBP,
          wOBA = safe_div(wOBA_num, wOBA_den),
          BABIP = safe_div(H, Inplay_All)
        )
      
      # Calculate xWOBA, xISO, and Barrel% per split
      splits <- unique(term$SplitColumn)
      xstats_list <- lapply(splits, function(spl) {
        split_df <- term[term$SplitColumn == spl, , drop = FALSE]
        
        # Get BIP with EV/LA
        bip_evla <- split_df %>%
          dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                        is.finite(ExitSpeed), is.finite(Angle)) %>%
          dplyr::mutate(
            EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
            LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
          )
        
        xWOBA <- NA_real_
        xISO <- NA_real_
        
        if (exists("xbin_ref") && nrow(bip_evla) > 0) {
          bip_evla <- bip_evla %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
          for (nm in c("p1B","p2B","p3B","pHR")) {
            if (exists("x_overall") && nm %in% names(x_overall)) {
              bip_evla[[nm]][!is.finite(bip_evla[[nm]])] <- x_overall[[nm]]
            }
          }
          x1B <- sum(bip_evla$p1B, na.rm = TRUE)
          x2B <- sum(bip_evla$p2B, na.rm = TRUE)
          x3B <- sum(bip_evla$p3B, na.rm = TRUE)
          xHR <- sum(bip_evla$pHR, na.rm = TRUE)
          xH  <- x1B + x2B + x3B + xHR
          xTB <- 1*x1B + 2*x2B + 3*x3B + 4*xHR
          
          split_AB <- per_type$AB[per_type$SplitColumn == spl]
          xAVG <- safe_div(xH, split_AB)
          xSLG <- safe_div(xTB, split_AB)
          xISO <- xSLG - xAVG
          
          # xWOBA calculation
          split_BB <- per_type$BB[per_type$SplitColumn == spl]
          BF_live <- sum(split_df$SessionType == "Live" & split_df$Balls == 0 & split_df$Strikes == 0, na.rm = TRUE)
          if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
            xWOBA <- safe_div(W_BB*split_BB + W_1B*x1B + W_2B*x2B + W_3B*x3B + W_HR*xHR, BF_live)
          }
        }
        
        # Calculate Barrel%
        barrels <- sum(split_df$SessionType == "Live" & split_df$PitchCall == "InPlay" &
                         is.finite(split_df$ExitSpeed) & is.finite(split_df$Angle) &
                         split_df$ExitSpeed >= 95 & split_df$Angle >= 10 & split_df$Angle <= 35, na.rm = TRUE)
        inplay_live <- sum(split_df$SessionType == "Live" & split_df$PitchCall == "InPlay", na.rm = TRUE)
        BarrelPct <- safe_div(barrels, inplay_live)
        
        data.frame(
          SplitColumn = spl,
          xWOBA = xWOBA,
          xISO = xISO,
          `Barrel%` = BarrelPct,
          check.names = FALSE
        )
      })
      
      xstats <- do.call(rbind, xstats_list)
      
      # Merge with per_type
      batted_ball_data <- per_type %>%
        dplyr::left_join(xstats, by = "SplitColumn") %>%
        dplyr::transmute(
          !!split_col_name := as.character(SplitColumn),
          PA, AB, AVG, SLG, OBP, OPS, wOBA, xWOBA, ISO, xISO, BABIP, `Barrel%`
        ) %>%
        dplyr::mutate(
          AVG = ifelse(is.finite(AVG), fmt_avg(AVG), ""),
          SLG = ifelse(is.finite(SLG), fmt_avg(SLG), ""),
          OBP = ifelse(is.finite(OBP), fmt_avg(OBP), ""),
          OPS = ifelse(is.finite(OPS), fmt_avg(OPS), ""),
          wOBA = ifelse(is.finite(wOBA), fmt_avg(wOBA), ""),
          xWOBA = ifelse(is.finite(xWOBA), fmt_avg(xWOBA), ""),
          ISO = ifelse(is.finite(ISO), fmt_avg(ISO), ""),
          xISO = ifelse(is.finite(xISO), fmt_avg(xISO), ""),
          BABIP = ifelse(is.finite(BABIP), fmt_avg(BABIP), ""),
          `Barrel%` = ifelse(is.finite(`Barrel%`), paste0(round(`Barrel%`*100, 1), "%"), "")
        )
      
      # --- ALL row (ungrouped, same calculations) ---
      PA_all <- nrow(term)
      H1_all <- sum(term$PlayResult == "Single", na.rm = TRUE)
      H2_all <- sum(term$PlayResult == "Double", na.rm = TRUE)
      H3_all <- sum(term$PlayResult == "Triple", na.rm = TRUE)
      HR_all <- sum(term$PlayResult == "HomeRun", na.rm = TRUE)
      BB_all <- sum(term$KorBB == "Walk" | term$PlayResult == "Walk", na.rm = TRUE)
      IBB_all <- sum(term$PlayResult == "IntentionalWalk", na.rm = TRUE)
      HBP_all <- sum(term$PlayResult == "HitByPitch", na.rm = TRUE)
      SF_all <- sum(term$PlayResult == "Sacrifice", na.rm = TRUE)
      Inplay_All_all <- sum(term$PitchCall == "InPlay", na.rm = TRUE)
      
      AB_all <- PA_all - (BB_all + HBP_all + SF_all)
      H_all <- H1_all + H2_all + H3_all + HR_all
      TB_all <- 1*H1_all + 2*H2_all + 3*H3_all + 4*HR_all
      
      # Calculate xWOBA, xISO, Barrel% for All row
      bip_evla_all <- term %>%
        dplyr::filter(SessionType == "Live", PitchCall == "InPlay",
                      is.finite(ExitSpeed), is.finite(Angle)) %>%
        dplyr::mutate(
          EVb = pmin(120, pmax(40, floor(ExitSpeed/5)*5)),
          LAb = pmin( 50, pmax(-50, floor(Angle    /5)*5))
        )
      
      xWOBA_all <- NA_real_
      xISO_all <- NA_real_
      
      if (exists("xbin_ref") && nrow(bip_evla_all) > 0) {
        bip_evla_all <- bip_evla_all %>% dplyr::left_join(xbin_ref, by = c("EVb","LAb"))
        for (nm in c("p1B","p2B","p3B","pHR")) {
          if (exists("x_overall") && nm %in% names(x_overall)) {
            bip_evla_all[[nm]][!is.finite(bip_evla_all[[nm]])] <- x_overall[[nm]]
          }
        }
        x1B_all <- sum(bip_evla_all$p1B, na.rm = TRUE)
        x2B_all <- sum(bip_evla_all$p2B, na.rm = TRUE)
        x3B_all <- sum(bip_evla_all$p3B, na.rm = TRUE)
        xHR_all <- sum(bip_evla_all$pHR, na.rm = TRUE)
        xH_all  <- x1B_all + x2B_all + x3B_all + xHR_all
        xTB_all <- 1*x1B_all + 2*x2B_all + 3*x3B_all + 4*xHR_all
        xAVG_all <- safe_div(xH_all, AB_all)
        xSLG_all <- safe_div(xTB_all, AB_all)
        xISO_all <- xSLG_all - xAVG_all
        
        PA_live_all <- sum(term$SessionType == "Live" & term$Balls == 0 & term$Strikes == 0, na.rm = TRUE)
        if (exists("W_BB") && exists("W_1B") && exists("W_2B") && exists("W_3B") && exists("W_HR")) {
          xWOBA_all <- safe_div(W_BB*BB_all + W_1B*x1B_all + W_2B*x2B_all + W_3B*x3B_all + W_HR*xHR_all, PA_live_all)
        }
      }
      
      barrels_all <- sum(term$SessionType == "Live" & term$PitchCall == "InPlay" &
                           is.finite(term$ExitSpeed) & is.finite(term$Angle) &
                           term$ExitSpeed >= 95 & term$Angle >= 10 & term$Angle <= 35, na.rm = TRUE)
      inplay_live_all <- sum(term$SessionType == "Live" & term$PitchCall == "InPlay", na.rm = TRUE)
      BarrelPct_all <- safe_div(barrels_all, inplay_live_all)
      
      # Create All row with dynamic column name
      all_row_data <- list(
        PA = PA_all,
        AB = AB_all,
        AVG = safe_div(H_all, AB_all),
        SLG = safe_div(TB_all, AB_all),
        OBP = safe_div(H_all + BB_all + HBP_all, PA_all),
        OPS = NA_real_,
        wOBA = safe_div(0.690*(BB_all - IBB_all) + 0.722*HBP_all + 0.888*H1_all + 1.271*H2_all + 1.616*H3_all + 2.101*HR_all,
                        AB_all + BB_all - IBB_all + SF_all + HBP_all),
        xWOBA = xWOBA_all,
        ISO = safe_div(TB_all, AB_all) - safe_div(H_all, AB_all),
        xISO = xISO_all,
        BABIP = safe_div(H_all, Inplay_All_all),
        `Barrel%` = BarrelPct_all
      )
      all_row_data[[split_col_name]] <- "All"
      all_row <- tibble::as_tibble(all_row_data)
      all_row$OPS <- all_row$SLG + all_row$OBP
      
      # Format All row
      all_row <- all_row %>%
        dplyr::mutate(
          AVG = ifelse(is.finite(AVG), fmt_avg(AVG), ""),
          SLG = ifelse(is.finite(SLG), fmt_avg(SLG), ""),
          OBP = ifelse(is.finite(OBP), fmt_avg(OBP), ""),
          OPS = ifelse(is.finite(OPS), fmt_avg(OPS), ""),
          wOBA = ifelse(is.finite(wOBA), fmt_avg(wOBA), ""),
          xWOBA = ifelse(is.finite(xWOBA), fmt_avg(xWOBA), ""),
          ISO = ifelse(is.finite(ISO), fmt_avg(ISO), ""),
          xISO = ifelse(is.finite(xISO), fmt_avg(xISO), ""),
          BABIP = ifelse(is.finite(BABIP), fmt_avg(BABIP), ""),
          `Barrel%` = ifelse(is.finite(`Barrel%`), paste0(round(`Barrel%`*100, 1), "%"), "")
        )
      
      # Order pitch types correctly if Pitch Types is selected
      if (split_choice == "Pitch Types" && split_col_name == "Pitch" && exists("all_colors")) {
        pitch_order <- intersect(names(all_colors), batted_ball_data[[split_col_name]])
        if (length(pitch_order) > 0) {
          batted_ball_data[[split_col_name]] <- factor(batted_ball_data[[split_col_name]], levels = pitch_order)
          batted_ball_data <- batted_ball_data %>% dplyr::arrange(.data[[split_col_name]])
          batted_ball_data[[split_col_name]] <- as.character(batted_ball_data[[split_col_name]])
        }
      }
      
      # Bind rows
      df_out <- dplyr::bind_rows(batted_ball_data, all_row)
      
      visible_set <- names(df_out)
      table_cache <- df_out
      return(datatable_with_colvis(
        df_out,
        lock            = split_col_name,
        remember        = FALSE,
        default_visible = visible_set,
        mode            = mode,
        enable_colors   = if (!is.null(input$dpTableColors)) input$dpTableColors else FALSE
      ))
    }
    
    # ---------- NON-Results modes (your original build) ----------
    # QP+ per pitch type (scalar)
    qp_by_type <- df %>%
      dplyr::group_by(SplitColumn) %>%
      dplyr::summarise(
        `QP+` = {
          vals <- compute_qp_points(dplyr::cur_data_all())
          vals <- suppressWarnings(as.numeric(vals))
          round(mean(vals, na.rm = TRUE) * 200, 1)
        },
        .groups = "drop"
      )
    
    # Base per-pitch-type summary
    summ <- safe_make_summary(df, group_col = "SplitColumn")
    summ <- dplyr::mutate(summ,
                          ReleaseTilt = as.character(ReleaseTilt),
                          BreakTilt   = as.character(BreakTilt)
    )
    if (!("QP+" %in% names(summ))) {
      summ <- summ %>% dplyr::left_join(qp_by_type, by = c("PitchType" = "SplitColumn"))
    }
    
    # ---- Build FULL table (as before) ----
    df_table <- dplyr::bind_rows(
      summ,
      {
        scores <- ifelse(
          df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
            df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP, 1.47,
          ifelse(
            df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
              df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5),
            0.73, 0
          )
        )
        has_pc  <- sum(!is.na(df$PitchCall)) > 0
        strikes <- sum(df$PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
        sw      <- sum(df$PitchCall == "StrikeSwinging", na.rm = TRUE)
        den     <- sum(df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
        # Use shared BF calculation function
        bf_live <- calculate_bf(df)
        fps_opp <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0, na.rm = TRUE)
        k_live  <- sum(df$SessionType == "Live" & df$KorBB == "Strikeout",        na.rm = TRUE)
        bb_live <- sum(df$SessionType == "Live" & df$KorBB == "Walk",             na.rm = TRUE)
        fps_live <- sum(df$SessionType == "Live" & df$Balls == 0 & df$Strikes == 0 &
                          df$PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"), na.rm = TRUE)
        ea_live  <- sum(df$SessionType == "Live" & (
          (df$Balls == 0 & df$Strikes == 0 & df$PitchCall == "InPlay") |
            (df$Balls == 0 & df$Strikes == 1 & df$PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
            )) |
            (df$Balls == 1 & df$Strikes == 0 & df$PitchCall == "InPlay") |
            (df$Balls == 1 & df$Strikes == 1 & df$PitchCall %in% c(
              "InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"
            ))
        ),
        na.rm = TRUE
        )
        
        vmax   <- suppressWarnings(max(as.numeric(df$RelSpeed), na.rm = TRUE)); vmax <- if (is.finite(vmax)) round(vmax, 1) else NA_real_
        ev_all <- nz_mean(ifelse(df$SessionType=="Live", df$ExitSpeed, NA_real_))
        la_all <- nz_mean(ifelse(df$SessionType=="Live", df$Angle,     NA_real_))
        stuff_all <- round(nz_mean(df$`Stuff+`), 1)
        ctrl_all   <- round(nz_mean(scores) * 100, 1)
        qp_all    <- round(nz_mean(compute_qp_points(df)) * 200, 1)
        
        tibble::tibble(
          PitchType     = "All",
          PitchCount    = nrow(df),
          Usage         = "100%",
          Overall       = "100%",
          BF            = bf_live,
          Velo_Avg      = round(nz_mean(df$RelSpeed), 1),
          Velo_Max      = vmax,
          IVB           = round(nz_mean(df$InducedVertBreak), 1),
          HB            = round(nz_mean(df$HorzBreak), 1),
          ReleaseTilt   = convert_to_clock(nz_mean(df$ReleaseTilt)),
          BreakTilt     = convert_to_clock(nz_mean(df$BreakTilt)),
          SpinEff       = nz_mean(df$SpinEfficiency),
          SpinRate      = round(nz_mean(df$SpinRate), 0),
          RelHeight     = round(nz_mean(df$RelHeight), 1),
          RelSide       = round(nz_mean(df$RelSide), 1),
          VertApprAngle = round(nz_mean(df$VertApprAngle), 1),
          HorzApprAngle = round(nz_mean(df$HorzApprAngle), 1),
          Extension     = round(nz_mean(df$Extension), 1),
          InZonePercent = { inzone <- (df$PlateLocSide >= ZONE_LEFT & df$PlateLocSide <= ZONE_RIGHT &
                                         df$PlateLocHeight >= ZONE_BOTTOM & df$PlateLocHeight <= ZONE_TOP)
          safe_pct(sum(inzone, na.rm=TRUE), sum(!is.na(inzone))) },
          CompPercent   = { comp <- (df$PlateLocSide >= -1.5 & df$PlateLocSide <= 1.5 &
                                       df$PlateLocHeight >= (2.65-1.5) & df$PlateLocHeight <= (2.65+1.5))
          safe_pct(sum(comp, na.rm=TRUE), sum(!is.na(comp))) },
          KPercent      = safe_pct(k_live, bf_live),
          BBPercent     = safe_pct(bb_live, bf_live),
          FPSPercent    = safe_pct(fps_live, fps_opp),
          EAPercent     = safe_pct(ea_live, fps_opp),
          StrikePercent = if (has_pc) safe_pct(strikes, nrow(df)) else "",
          SwingPercent  = safe_pct(sum(!is.na(df$PitchCall) & df$PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","FoulBall","InPlay"), na.rm = TRUE), nrow(df)),
          WhiffPercent  = safe_pct(sw, den),
          EV = ev_all, LA = la_all,
          `Stuff+` = stuff_all, `Ctrl+` = ctrl_all, `QP+` = qp_all
        ) %>% dplyr::mutate(`Pitching+` = round((`Stuff+` + `QP+`)/2, 1))
      }
    ) %>%
      dplyr::rename(
        !!split_col_name := PitchType,
        `#`    = PitchCount,
        Velo   = Velo_Avg,
        Max    = Velo_Max,
        rTilt  = ReleaseTilt,
        bTilt  = BreakTilt,
        Spin   = SpinRate,
        Height = RelHeight,
        Side   = RelSide,
        Ext    = Extension,
        `InZone%` = InZonePercent,
        `Comp%`   = CompPercent,
        `K%`      = KPercent,
        `BB%`     = BBPercent,
        `FPS%`    = FPSPercent,
        `E+A%`    = EAPercent,
        `QP%`     = QPPercent,
        `Strike%` = StrikePercent,
        `Swing%`  = SwingPercent,
        `Whiff%`  = WhiffPercent,
        VAA       = VertApprAngle,
        HAA       = HorzApprAngle
      ) %>%
      dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]])) %>%
      dplyr::select(
        .data[[split_col_name]], `#`, Usage, Overall,
        dplyr::any_of(c("0-0","Behind","Even","Ahead","<2K","2K")),
        BF,
        Velo, Max, IVB, HB, rTilt, bTilt, SpinEff, Spin, Height, Side, VAA, HAA, Ext,
        `InZone%`, `Comp%`, `Strike%`, `Swing%`, `FPS%`, `E+A%`, `QP%`, `K%`, `BB%`, `Whiff%`, EV, LA,
        `Stuff+`, `Ctrl+`, `QP+`, `Pitching+`
      ) %>%
      dplyr::mutate(
        EV = ifelse(is.na(as.numeric(EV)), "", round(as.numeric(EV), 1)),
        LA = ifelse(is.na(as.numeric(LA)), "", round(as.numeric(LA), 1))
      )
    
    # Add Process/Results extras and sanitize for DT
    extras_raw <- compute_process_results(df)
    if ("PitchType" %in% names(extras_raw)) {
      extras <- extras_raw %>% 
        dplyr::rename(!!split_col_name := PitchType) %>%
        dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
    } else {
      extras <- extras_raw %>%
        dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
    }
    df_table <- df_table %>% dplyr::left_join(extras, by = split_col_name)
    df_table <- fill_all_qp_pct(df_table, df)
    if (identical(mode, "Usage")) {
      usage_extras_raw <- compute_usage_by_count(df)
      if ("PitchType" %in% names(usage_extras_raw)) {
        usage_extras <- usage_extras_raw %>%
          dplyr::rename(!!split_col_name := PitchType) %>%
          dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
      } else {
        usage_extras <- usage_extras_raw %>%
          dplyr::mutate(!!split_col_name := as.character(.data[[split_col_name]]))
      }
      df_table <- df_table %>% dplyr::left_join(usage_extras, by = split_col_name)
    }
    
    df_table <- collapse_list_cols(df_table)
    is_date_like <- function(x) inherits(x, c("Date","POSIXct","POSIXt","difftime"))
    date_like <- vapply(df_table, is_date_like, logical(1))
    if (any(date_like)) df_table[date_like] <- lapply(df_table[date_like], as.character)
    df_table <- as.data.frame(df_table, stringsAsFactors = FALSE, check.names = FALSE)
    
    if (all(c("Whiff%","CSW%") %in% names(df_table))) {
      df_table <- df_table %>% dplyr::relocate(`CSW%`, .after = `Whiff%`)
    }
    if ("Pitching+" %in% names(df_table)) {
      df_table <- df_table %>% dplyr::relocate(`Pitching+`, .after = dplyr::last_col())
    }
    
    df_table <- enforce_process_order(df_table)
    df_table <- enforce_stuff_order(df_table)
    # Hide RV/100 in Results mode (Summary)
    if (identical(mode, "Results") && "RV/100" %in% names(df_table)) {
      df_table <- dplyr::select(df_table, -`RV/100`)
    }
    
    # Format SpinEff column to percentage with 1 decimal place
    if ("SpinEff" %in% names(df_table)) {
      df_table$SpinEff <- ifelse(is.na(df_table$SpinEff) | df_table$SpinEff == "", "", 
                                 paste0(round(as.numeric(df_table$SpinEff) * 100, 1), "%"))
    }
    
    visible_set <- visible_set_for(mode, custom)
    visible_set <- gsub("^Pitch$", split_col_name, visible_set)
    
    # Add error handling wrapper for main summary table
    build_summary_dt <- function(data, ...) {
      tryCatch(
        datatable_with_colvis(data, ...),
        error = function(e) {
          message("summaryTable datatable error [mode=", mode, "]: ", conditionMessage(e))
          message("Columns: ", paste(names(data), collapse = ", "))
          # Return a fallback datatable with error message
          DT::datatable(
            data.frame(Error = paste("Table rendering error:", conditionMessage(e))),
            options = list(dom = 't'), rownames = FALSE
          )
        }
      )
    }
    
    table_cache <- df_table
    build_summary_dt(
      df_table,
      lock            = split_col_name,
      remember        = FALSE,
      default_visible = intersect(visible_set, names(df_table)),
      mode            = mode,
      enable_colors   = isTRUE(input$dpTableColors)
    )
  })

  # Click-to-video support on Summary/DP tables (# column)
  observeEvent(input$summaryTablePage_cell_clicked, {
    handle_table_video_click(
      input$summaryTablePage_cell_clicked,
      session$userData$table_cache_summaryTablePage,
      table_label = "Summary Table"
    )
  }, ignoreNULL = TRUE)
  observeEvent(input$summaryTable_cell_clicked, {
    handle_table_video_click(
      input$summaryTable_cell_clicked,
      session$userData$table_cache_summaryTable,
      table_label = "Data & Performance"
    )
  }, ignoreNULL = TRUE)
  
  # ================================
  # Pitching → AB Report (no tables)
  # ================================
  # Safe fallbacks (won't override if you already have real ones)
  if (!exists("is_active", mode = "function")) is_active <- function(...) TRUE
  if (!exists("ns",        mode = "function")) ns        <- function(id) id
  
  # Build the PA-level result label (same logic as hitting)
  .abp_pa_result_label <- function(last_row) {
    pr <- as.character(last_row$PlayResult)
    kc <- as.character(last_row$KorBB)
    pc <- as.character(last_row$PitchCall)
    th <- as.character(last_row$TaggedHitType)
    
    if (!is.na(pc) && pc == "HitByPitch") return("HitByPitch")
    if (!is.na(kc) && kc %in% c("Strikeout","Walk")) return(kc)
    
    if (!is.na(pr) && pr != "" && pr != "Undefined") {
      if (pr == "HomeRun") return("HomeRun")
      th_clean <- ifelse(is.na(th) | th == "", "", paste0(th, " "))
      return(paste0(th_clean, pr))
    }
    if (!is.na(pr) && pr != "") return(pr)
    if (!is.na(pc) && pc != "") return(pc)
    "Result"
  }
  
  
  # Terminal pitch = PA completed
  .abp_is_terminal <- function(df) {
    (!is.na(df$PlayResult) & df$PlayResult != "Undefined") |
      (!is.na(df$KorBB)     & df$KorBB %in% c("Strikeout","Walk")) |
      (!is.na(df$PitchCall) & df$PitchCall == "HitByPitch")
  }
  
  .abp_fmt_mdy <- function(d) format(as.Date(d), "%m/%d/%Y")
  
  # "Last, First" -> "First Last"
  .abp_pretty_name <- function(x) {
    x <- as.character(x)
    ifelse(grepl(",", x), paste0(trimws(sub(".*,", "", x)), " ", trimws(sub(",.*", "", x))), x)
  }
  # Pretty pitcher label
  .abp_pretty_pitcher <- function(x) .abp_pretty_name(x)
  
  # Strike zone + dashed competitive box
  .abp_geom_zone <- function(color = "black") {
    home <- data.frame(x=c(-0.75,0.75,0.75,0.00,-0.75),
                       y=c(1.05, 1.05,1.15,1.25, 1.15)-0.5)
    cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
    sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
    list(
      geom_polygon(data = home, aes(x, y), fill = NA, color = color),
      geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = color, linetype = "dashed"),
      geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = color)
    )
  }
  
  # All game dates where the selected pitcher has ≥1 completed PA (across any batters)
  abp_dates <- reactive({
    pit <- input$pitcher
    if (is.null(pit) || identical(pit, "All")) return(as.Date(character(0)))
    
    d <- pitch_data_pitching %>% dplyr::filter(Pitcher == pit)
    term <- .abp_is_terminal(d)
    sort(unique(as.Date(d$Date[term])))
  })
  
  # Sidebar (date selector + legends)
  output$abpSidebar <- renderUI({
    pit <- input$pitcher
    if (is.null(pit) || identical(pit, "All")) {
      return(tagList(tags$em("Select a single pitcher in the main sidebar to enable AB Report.")))
    }
    
    dates <- abp_dates()
    if (!length(dates)) return(tagList(tags$em("No completed plate appearances found for this pitcher.")))
    
    vals <- as.character(as.Date(dates))
    labs <- .abp_fmt_mdy(dates)
    choices <- stats::setNames(vals, labs)
    
    cur <- isolate(input$abpGameDate)
    sel <- if (!is.null(cur) && cur %in% vals) cur else vals[length(vals)]
    
    # Pitch-type legend: only types this pitcher actually threw
    types_for_legend <- {
      d <- pitch_data_pitching %>% dplyr::filter(Pitcher == pit)
      intersect(names(all_colors), as.character(unique(d$TaggedPitchType)))
    }
    dark_on <- isTRUE(input$dark_mode)
    legend_cols <- if (exists("colors_for_mode")) colors_for_mode(dark_on) else all_colors
    text_col <- if (dark_on) "#e5e7eb" else "black"
    
    shape_rows <- tagList(
      tags$div(style = paste0("color:", text_col), "\u25CF Called Strike"),  # ●
      tags$div(style = paste0("color:", text_col), "\u25CB Ball"),           # ○
      tags$div(style = paste0("color:", text_col), "\u25B3 Foul"),           # △
      tags$div(style = paste0("color:", text_col), "\u2605 Whiff"),          # ★
      tags$div(style = paste0("color:", text_col), "\u25B2 In Play (Out)"),  # ▲
      tags$div(style = paste0("color:", text_col), "\u25A0 In Play (Hit)"),  # ■
      tags$div(style = paste0("color:", text_col), "\u25A1 Error")           # □
    )
    
    tagList(
      selectInput(ns("abpGameDate"), "Select Game:", choices = choices, selected = sel),
      tags$hr(),
      tags$div(tags$strong(style = paste0("color:", text_col), "Pitch Result")),
      shape_rows,
      tags$br(),
      tags$div(tags$strong(style = paste0("color:", text_col), "Pitch Types")),
      tags$div(lapply(types_for_legend, function(tt) {
        col <- legend_cols[[as.character(tt)]]; if (is.null(col)) col <- "gray"
        tags$div(style="display:flex;align-items:center;margin:2px 0;",
                 tags$span(style=paste0("display:inline-block;width:12px;height:12px;",
                                        "background:", col, ";margin-right:6px;",
                                        "border:1px solid rgba(0,0,0,.25);border-radius:2px;")),
                 tags$span(style = paste0("color:", text_col), as.character(tt))
        )
      }))
    )
  })
  
  # Header (top-left): Pitcher + Date
  output$abpHeader <- renderUI({
    pit <- input$pitcher
    if (is.null(pit) || identical(pit, "All")) return(NULL)
    dt_val <- input$abpGameDate
    if (is.null(dt_val)) {
      ds <- abp_dates(); if (!length(ds)) return(NULL)
      dt_val <- as.character(max(ds))
    }
    tags$div(
      style = "text-align:left;",
      tags$strong(.abp_pretty_pitcher(pit)), tags$br(),
      .abp_fmt_mdy(as.Date(dt_val))
    )
  })
  
  # Panels: stacked batters (left), each with PA mini-charts (right)
  output$abpPanels <- renderUI({
    pit <- input$pitcher
    if (is.null(pit) || identical(pit, "All"))
      return(div(style="margin:8px 0;", tags$em("Select a single pitcher to view the AB Report.")))
    
    dt_chr <- input$abpGameDate; req(!is.null(dt_chr))
    the_date <- as.Date(dt_chr)
    
    # Filter: selected pitcher on selected date (ignore the global date range for this page)
    df_all <- pitch_data_pitching %>% dplyr::filter(Pitcher == pit, as.Date(Date) == the_date)    
    
    if (!nrow(df_all)) return(div(tags$em("No pitches for this pitcher on the selected date.")))
    
    # Order batters by first appearance that day
    first_idx <- df_all %>%
      dplyr::mutate(.row_id = dplyr::row_number()) %>%
      dplyr::group_by(Batter) %>%
      dplyr::summarise(first_row = min(.row_id), .groups = "drop") %>%
      dplyr::arrange(first_row)
    
    # Build one row per batter
    rows <- lapply(seq_len(nrow(first_idx)), function(bi) {
      bat <- first_idx$Batter[bi]
      dB  <- df_all %>% dplyr::filter(Batter == bat)
      
      # Batter side & name label with color (Left = red, Right = black)
      side <- as.character(dplyr::coalesce(dB$BatterSide[which.max(seq_len(nrow(dB)))], NA))
      lr   <- ifelse(is.na(side), "", ifelse(grepl("^L", side, ignore.case = TRUE), "L", "R"))
      is_left <- identical(lr, "L")
      dark_on <- isTRUE(input$dark_mode)
      name_col <- if (is_left) "#d32f2f" else if (dark_on) "#e5e7eb" else "#000000"
      name_html <- tags$div(
        style = paste0("font-weight:700; color:", name_col, ";"),
        paste0(.abp_pretty_name(bat), " (", lr, ")")
      )
      
      # Segment PAs within this batter
      term <- .abp_is_terminal(dB)
      # cumsum starts a new PA *after* a terminal pitch:
      pa_id <- cumsum(c(1L, as.integer(utils::head(term, -1))))
      dB$._pa_id <- pa_id
      done_ids <- unique(dB$._pa_id[term])
      dB <- dplyr::filter(dB, ._pa_id %in% done_ids)
      if (!nrow(dB)) {
        return(fluidRow(
          column(3, div(style="padding:10px 6px;", name_html)),
          column(9, div(style="padding:10px 6px;", tags$em("No completed PAs")))
        ))
      }
      
      pa_list <- split(dB, dB$._pa_id)
      n_pa <- length(pa_list)
      
      # Build one mini zone chart per PA (left→right, 1st→last)
      chart_cells <- lapply(seq_len(n_pa), function(i) {
        # build the per-PA data first
        dat <- pa_list[[i]] %>%
          dplyr::mutate(
            pitch_idx = dplyr::row_number(),
            Result    = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
            tt_fill   = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray80"),
            tt        = paste0(
              "Pitch: ", as.character(TaggedPitchType), "\n",
              "Result: ", dplyr::case_when(
                PitchCall == "InPlay" & !is.na(PlayResult) ~ as.character(PlayResult),
                TRUE ~ dplyr::coalesce(as.character(PitchCall), "")
              ), "\n",
              "Velo: ", ifelse(is.finite(RelSpeed), sprintf("%.1f", RelSpeed), "—"), "\n",
              "IVB: ",  ifelse(is.finite(InducedVertBreak), sprintf("%.1f", InducedVertBreak), "—"), "\n",
              "HB: ",   ifelse(is.finite(HorzBreak), sprintf("%.1f", HorzBreak), "—")
            )
          )
        
        # now compute the PA result label from the last pitch of this PA
        title_result <- .abp_pa_result_label(dat[nrow(dat), , drop = FALSE])
        
        pid    <- paste0(bi, "_", names(pa_list)[i])
        out_id <- ns(paste0("abpPlot_", pid))
        
        local({
          dat_local    <- dat
          out_id_local <- ns(paste0("abpPlot_", pid))
          output[[out_id_local]] <- ggiraph::renderGirafe({
            dark_on <- isTRUE(input$dark_mode)
            axis_col <- if (dark_on) "#e5e7eb" else "black"
            line_col <- if (dark_on) "#ffffff" else "black"
            cols <- if (exists("colors_for_mode")) colors_for_mode(dark_on) else all_colors
            types <- as.character(intersect(names(all_colors), unique(dat_local$TaggedPitchType)))
            p <- ggplot() +
              .abp_geom_zone(color = line_col) +
              ggiraph::geom_point_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight,
                    color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
                    tooltip = tt, data_id = pitch_idx),
                size = 5, alpha = 0.95, stroke = 0.8
              ) +
              ggiraph::geom_text_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight, label = pitch_idx, tooltip = tt, data_id = pitch_idx),
                nudge_y = 0.21, size = 5.5
              ) +
              ggiraph::geom_point_interactive(
                data = dat_local,
                aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = pitch_idx, fill = I(tt_fill)),
                shape = 21, size = 7, alpha = 0.001, stroke = 0, inherit.aes = FALSE
              ) +
              scale_color_manual(values = cols[types], limits = types, name = NULL) +
              scale_fill_manual(values  = cols[types], limits = types, name = NULL) +
              scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
              coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
              theme_void() + theme(legend.position = "none",
                                   plot.title = element_text(color = axis_col))
            
            girafe_transparent(
              ggobj = p,
              options = list(
                ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE,
                                      css = "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"),
                ggiraph::opts_hover(css = "stroke-width:1.5px;"),
                ggiraph::opts_hover_inv(css = "opacity:0.15;")
              )
            )
          })
        })
        
        div(
          style = "display:inline-block; margin:0 8px 12px 0; vertical-align:top; text-align:center;",
          tags$div(tags$strong(paste0("PA #", i))),
          tags$div(title_result, style = "margin-bottom:6px;"),
          ggiraph::girafeOutput(out_id, height = "300px", width = "300px")
        )
      })
      
      # Row layout: left col = batter label; right col = PA charts (scroll if many)
      fluidRow(
        # Narrower name column; vertically centered to the strike zone height
        column(
          2,
          div(
            style = "display:flex; align-items:center; justify-content:flex-end;
               min-height:320px; padding:0 8px 0 0; text-align:right;",
            name_html
          )
        ),
        # Wider chart area
        column(
          10,
          div(style="overflow-x:auto; white-space:nowrap; padding:6px;", chart_cells)
        )
      )
    })
    
    tagList(rows)
  })
  
  # Release + Extension combo
  output$releaseCombo <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    sess_lbl <- session_label_from(df)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    line_col <- if (dark_on) "#ffffff" else "black"
    
    # Get display option
    display_opt <- input$releaseComboDisplay
    if (is.null(display_opt)) display_opt <- "Averages Only"
    
    show_pitches <- display_opt %in% c("Averages and Pitches", "Pitches")
    show_averages <- display_opt %in% c("Averages Only", "Averages and Pitches")
    
    # shared y-axis max so both panels align and show at least 6
    y_max <- max(6, suppressWarnings(max(df$RelHeight, na.rm = TRUE) + 0.2))
    
    # Individual pitches data
    df_i <- df %>%
      dplyr::filter(is.finite(RelSide), is.finite(RelHeight)) %>%
      dplyr::mutate(
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", RelHeight),
          "<br>Side: ", sprintf("%.1f ft", RelSide),
          "<br>Extension: ", sprintf("%.1f ft", Extension)
        ),
        rid = dplyr::row_number()
      )
    
    df_i_ext <- df %>%
      dplyr::filter(is.finite(Extension), is.finite(RelHeight)) %>%
      dplyr::mutate(
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", RelHeight),
          "<br>Side: ", sprintf("%.1f ft", RelSide),
          "<br>Extension: ", sprintf("%.1f ft", Extension)
        ),
        rid = dplyr::row_number()
      )
    
    # --- (A) Release Point averages
    rp_w <- 4; rp_h <- 0.83
    xs <- seq(-rp_w, rp_w, length.out = 100)
    ys <- rp_h * (1 - (xs / rp_w)^2)
    mound_df <- data.frame(x = c(xs, rev(xs)), y = c(ys, rep(0, length(xs))))
    
    avg_rel <- df %>%
      dplyr::filter(is.finite(RelSide), is.finite(RelHeight)) %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_RelSide    = mean(RelSide,    na.rm = TRUE),
        avg_RelHeight  = mean(RelHeight,  na.rm = TRUE),
        avg_Extension  = mean(Extension,  na.rm = TRUE),
        .groups = "drop"
      ) %>%
      dplyr::filter(TaggedPitchType %in% types_chr) %>%
      dplyr::mutate(
        TaggedPitchType = factor(TaggedPitchType, levels = types_chr),
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", avg_RelHeight),
          "<br>Side: ", sprintf("%.1f ft", avg_RelSide),
          "<br>Extension: ", sprintf("%.1f ft", avg_Extension)
        )
      )
    
    p1 <- ggplot() +
      geom_polygon(data = mound_df, aes(x, y), fill = "tan", color = "tan") +
      annotate("rect", xmin = -0.5, xmax = 0.5, ymin = rp_h - 0.05, ymax = rp_h + 0.05, fill = "white") +
      geom_vline(xintercept = 0, color = line_col, size = 0.7) +
      geom_hline(yintercept = 0, color = line_col, size = 0.7) +
      # Individual pitches layer
      { if (show_pitches) {
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(x = RelSide, y = RelHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          alpha = 0.2, size = 2.5, shape = 21, stroke = 0.25, show.legend = FALSE
        )
      } } +
      # Averages layer
      { if (show_averages) {
        ggiraph::geom_point_interactive(
          data = avg_rel,
          aes(x = avg_RelSide, y = avg_RelHeight,
              color = TaggedPitchType, tooltip = tt, data_id = TaggedPitchType),
          size = 4, show.legend = FALSE
        )
      } } +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_y_continuous(limits = c(0, y_max), breaks = seq(0, ceiling(y_max), by = 1)) +
      theme_minimal() + axis_theme + grid_theme(dark_on) + labs(x = NULL, y = NULL) +
      theme(
        panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.text.x = element_text(color = axis_col),
        axis.text.y = element_text(color = axis_col)
      )
    
    # --- (B) Extension vs Height averages
    re_w <- 7; re_h <- 0.83
    xs2 <- seq(-re_w, re_w, length.out = 100)
    ys2 <- re_h * (1 - (xs2 / re_w)^2)
    ext_bg <- data.frame(x = c(xs2, rev(xs2)), y = c(ys2, rep(0, length(xs2))))
    
    avg_ext <- df %>%
      dplyr::filter(is.finite(Extension), is.finite(RelHeight)) %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_Extension  = mean(Extension,  na.rm = TRUE),
        avg_RelHeight  = mean(RelHeight,  na.rm = TRUE),
        avg_RelSide    = mean(RelSide,    na.rm = TRUE),
        .groups = "drop"
      ) %>%
      dplyr::filter(TaggedPitchType %in% types_chr) %>%
      dplyr::mutate(
        TaggedPitchType = factor(TaggedPitchType, levels = types_chr),
        tt = paste0(
          "Session: ", sess_lbl,
          "<br>Height: ", sprintf("%.1f ft", avg_RelHeight),
          "<br>Side: ", sprintf("%.1f ft", avg_RelSide),
          "<br>Extension: ", sprintf("%.1f ft", avg_Extension)
        )
      )
    
    p2 <- ggplot() +
      geom_polygon(data = ext_bg, aes(x, y), fill = "tan", color = "tan") +
      annotate("rect", xmin = 0, xmax = 0.2, ymin = re_h - 0.05, ymax = re_h + 0.05, fill = "white") +
      geom_vline(xintercept = 0, color = line_col, size = 0.7) +
      # Individual pitches layer
      { if (show_pitches) {
        ggiraph::geom_point_interactive(
          data = df_i_ext,
          aes(x = Extension, y = RelHeight,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          alpha = 0.2, size = 2.5, shape = 21, stroke = 0.25, show.legend = FALSE
        )
      } } +
      # Averages layer
      { if (show_averages) {
        ggiraph::geom_point_interactive(
          data = avg_ext,
          aes(x = avg_Extension, y = avg_RelHeight,
              color = TaggedPitchType, tooltip = tt, data_id = TaggedPitchType),
          size = 4, show.legend = TRUE   # legend only here
        )
      } } +
      scale_x_continuous(limits = c(0, 7.5), breaks = seq(1, 7.5, 1)) +
      scale_y_continuous(limits = c(0, y_max), breaks = seq(0, ceiling(y_max), by = 1)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) + labs(x = NULL, y = NULL) +
      theme(
        panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.text.x = element_text(color = axis_col),
        axis.text.y = element_text(color = axis_col)
      )
    
    # --- stack + single legend at bottom; enlarge legend text a bit
    p <- (p1 / p2) + patchwork::plot_layout(guides = "collect")
    p <- p & theme(
      legend.position = "bottom",
      legend.text = element_text(size = 14, color = axis_col)
    )
    p <- p & transparent_bg_theme  # keep patchwork canvas transparent to match other pages
    
    girafe_transparent(
      ggobj = p,
      width_svg = 9, height_svg = 12,
      options = list(
        ggiraph::opts_sizing(rescale = TRUE),
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;"),
        ggiraph::opts_selection(type = "multiple", selected = character(0))
      )
    )
  })
  
  
  
  # Full Movement Plot
  output$movementPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    line_col <- if (dark_on) "#ffffff" else "black"
    
    # Add reactive dependency on target shapes
    target_shapes_version()
    
    avg_mov <- df %>% dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_HorzBreak        = mean(HorzBreak, na.rm = TRUE),
        avg_InducedVertBreak = mean(InducedVertBreak, na.rm = TRUE),
        avg_velo             = mean(RelSpeed, na.rm = TRUE),
        avg_stuff            = mean(`Stuff+`, na.rm = TRUE),
        n_obs                = dplyr::n(),
        .groups = "drop"
      ) %>%
      dplyr::mutate(
        tt = paste0(TaggedPitchType,
                    "<br>Velo: ", round(avg_velo,1), " mph",
                    "<br>IVB: ", round(avg_InducedVertBreak,1), " in",
                    "<br>HB: ", round(avg_HorzBreak,1), " in",
                    "<br>Stuff+: ", round(avg_stuff,1),
                    "<br>Pitches: ", n_obs),
        data_id = TaggedPitchType
      )
    
    df_i <- df %>% dplyr::mutate(tt = make_hover_tt(.), rid = dplyr::row_number())
    
    base_type <- input$breakLines
    line_df <- tibble()
    if (base_type %in% c("Fastball", "Sinker")) {
      base_val <- dplyr::filter(avg_mov, TaggedPitchType == base_type)
      if (nrow(base_val) == 1) {
        seps <- if (base_type == "Fastball") {
          tibble(
            TaggedPitchType = c("Cutter", "Slider", "Sweeper", "Curveball", "ChangeUp", "Splitter"),
            sep_IVB = c(-7, -15, -16, -27, -12, -13),
            sep_Horz = c(10, 12, 22, 18, -7, -4)
          )
        } else {
          tibble(
            TaggedPitchType = c("Cutter", "Slider", "Sweeper", "Curveball", "ChangeUp", "Splitter"),
            sep_IVB = c(2, -6, -7, -18, -4, -5),
            sep_Horz = c(18, 20, 30, 25, 1, 2)
          )
        }
        throw_side <- if (input$hand %in% c("Left", "Right")) input$hand else {
          us <- unique(df$PitcherThrows) %>% na.omit()
          if (length(us) == 1 && us %in% c("Left", "Right")) us else "Left"
        }
        dir <- ifelse(throw_side == "Right", -1, 1)
        seps <- seps %>%
          dplyr::filter(TaggedPitchType %in% avg_mov$TaggedPitchType) %>%
          dplyr::mutate(sep_Horz = sep_Horz * dir)
        line_df <- seps %>% dplyr::mutate(
          start_x = base_val$avg_HorzBreak,
          start_y = base_val$avg_InducedVertBreak,
          end_x   = base_val$avg_HorzBreak + sep_Horz,
          end_y   = base_val$avg_InducedVertBreak + sep_IVB
        )
      }
    }
    
    # Get display options
    display_opts <- input$movementPlotDisplay
    if (is.null(display_opts)) display_opts <- "Averages and Pitches"
    
    show_pitches <- any(c("Averages and Pitches", "Target Shapes and Pitches") %in% display_opts)
    show_averages <- any(c("Averages Only", "Averages and Pitches") %in% display_opts)
    show_targets <- any(c("Target Shapes Only", "Target Shapes and Pitches") %in% display_opts)
    
    # Prepare target shapes data if needed
    target_df <- NULL
    if (show_targets) {
      pitcher_sel <- input$pitcher
      if (!is.null(pitcher_sel) && length(pitcher_sel) == 1 && !("All" %in% pitcher_sel)) {
        pitcher_name <- pitcher_sel[1]
        date_range <- input$dates
        
        # Get target shapes for each pitch type
        target_data <- lapply(types_chr, function(pt) {
          target <- get_target_shape(pitcher_name, pt, date_range, auto_save = FALSE)
          if (!is.null(target)) {
            data.frame(
              TaggedPitchType = pt,
              HB_Target = target$HB,
              IVB_Target = target$IVB,
              stringsAsFactors = FALSE
            )
          } else {
            NULL
          }
        })
        
        target_df <- do.call(rbind, target_data)
      }
    }
    
    p <- ggplot() +
      # Individual Pitches Layer
      { if (show_pitches) {
        ggiraph::geom_point_interactive(
          data = df_i,
          aes(HorzBreak, InducedVertBreak,
              color = TaggedPitchType, fill = TaggedPitchType,
              tooltip = tt, data_id = rid),
          position = "identity",
          alpha = 0.25, size = 2.2, shape = 21, stroke = 0.25
        )
      } } +
      # Average Movement Layer
      { if (show_averages) {
        ggiraph::geom_point_interactive(
          data = avg_mov,
          aes(avg_HorzBreak, avg_InducedVertBreak, color = TaggedPitchType,
              tooltip = tt, data_id = data_id),
          size = 6, show.legend = FALSE
        )
      } } +
      # Break Lines Layer
      { if (nrow(line_df) > 0)
        geom_segment(
          data = line_df,
          aes(x = start_x, y = start_y, xend = end_x, yend = end_y, color = TaggedPitchType),
          size = 1
        )
      } +
      # Target Shapes Layer
      { if (!is.null(target_df) && nrow(target_df) > 0) {
        list(
          # Low alpha fill circle
          geom_point(
            data = target_df,
            aes(HB_Target, IVB_Target, fill = TaggedPitchType),
            size = 10, shape = 21, alpha = 0.10, stroke = 0, show.legend = FALSE
          ),
          # High alpha border circle
          geom_point(
            data = target_df,
            aes(HB_Target, IVB_Target, color = TaggedPitchType),
            size = 10, shape = 21, alpha = 0.8, stroke = 2, fill = NA, show.legend = FALSE
          )
        )
      } } +
      geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
      geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
      coord_cartesian(xlim = c(-25, 25), ylim = c(-25, 25)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      theme(
        legend.position = "bottom",
        legend.text = element_text(size = 14, color = axis_col),
        panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.text.x = element_text(color = axis_col),
        axis.text.y = element_text(color = axis_col)
      )
    
    girafe_transparent(
      ggobj = p,
      options = list(
        ggiraph::opts_tooltip(
          use_fill = TRUE,
          css = "color:white;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
        ),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;"),
        ggiraph::opts_selection(type = "multiple", selected = character(0))
      )
    )
  })
  
  # Event handlers for movement plot pitch type editing
  observeEvent(input$movementPlot_selected, {
    # Default behavior: play video(s) for the clicked pitch
    if (!identical(input$pitch_click_action, "edit")) {
      df <- filtered_data(); req(nrow(df) > 0)
      open_clip_from_df_and_index(df, input$movementPlot_selected, label = "Movement Plot")
      return()
    }
    
    req(input$movementPlot_selected)
    selected_ids <- as.numeric(input$movementPlot_selected)
    df <- filtered_data()
    if (!nrow(df) || !length(selected_ids)) return()
    
    # Get selected pitches
    selected_pitches <- df[selected_ids, ]
    
    # Build pitcher choices (include current selection to ensure availability)
    available_pitchers <- sort(unique(pitch_data_pitching$Pitcher))
    pitcher_choices <- sort(unique(c(available_pitchers, as.character(selected_pitches$Pitcher))))
    
    # Show modal for editing pitch types / pitcher
    showModal(modalDialog(
      title = paste("Edit Pitch Type for", nrow(selected_pitches), "pitch(es)"),
      selectInput("new_pitch_type", "New Pitch Type:",
                  choices = c("Fastball", "Sinker", "Cutter", "Slider", "Sweeper", 
                              "Curveball", "ChangeUp", "Splitter", "Knuckleball"),
                  selected = selected_pitches$TaggedPitchType[1]),
      selectInput("new_pitcher", "Assign To Pitcher:",
                  choices = pitcher_choices,
                  selected = selected_pitches$Pitcher[1]),
      br(),
      strong("Selected Pitches:"),
      br(),
      if (nrow(selected_pitches) <= 10) {
        div(
          lapply(1:nrow(selected_pitches), function(i) {
            p <- selected_pitches[i, ]
            div(sprintf("Pitch %d: %s - %s (%.1f mph, HB: %.1f, IVB: %.1f)",
                        i, p$TaggedPitchType, p$Date, 
                        p$RelSpeed %||% 0, p$HorzBreak %||% 0, p$InducedVertBreak %||% 0))
          })
        )
      } else {
        div(sprintf("%d pitches selected (too many to display individually)", nrow(selected_pitches)))
      },
      footer = tagList(
        modalButton("Cancel"),
        actionButton("confirm_pitch_edit", "Save Changes", class = "btn-primary")
      ),
      easyClose = FALSE
    ))
    
    # Store selected data for use in confirm handler
    session$userData$selected_for_edit <- selected_pitches
  })
  
  output$target_shape_rows_ui <- renderUI({
    rows <- target_shape_rows()
    if (!nrow(rows)) {
      return(tags$p("No saved target shapes yet. Use the form below to add a pitch type.", style = "color:#555;"))
    }
    
    tagList(
      lapply(seq_len(nrow(rows)), function(i) {
        row <- rows[i, , drop = FALSE]
        row_id <- row$RowID[1]
        status <- if (isTRUE(row$IsCustom[1])) "Custom" else "Auto"
        tags$div(
          style = "border:1px solid #e2e8f0; border-radius:8px; padding:12px; margin-bottom:12px; background:#f9fafb;",
          tags$div(
            style = "display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;",
            tags$div(
              tags$strong(row$PitchType[1]),
              tags$span(paste0(" (", status, ")"), style = "color:#64748b;font-size:0.85rem;")
            ),
            tags$div(
              tags$button(
                type = "button",
                class = "btn btn-sm btn-link text-danger",
                style = "padding:.25rem .5rem;",
                onclick = sprintf("Shiny.setInputValue('target_shape_remove', '%s', {priority: 'event'})", row_id),
                "Remove"
              ),
              tags$button(
                type = "button",
                class = "btn btn-sm btn-link text-primary",
                style = "padding:.25rem .5rem;",
                onclick = sprintf("Shiny.setInputValue('target_shape_reset', '%s', {priority: 'event'})", row_id),
                "Reset to Auto"
              )
            )
          ),
          fluidRow(
            column(6,
                   numericInput(paste0("target_ivb_", row_id), "IVB Target:",
                                value = round(ifelse(is.na(row$IVB[1]), 0, row$IVB[1]), 1),
                                step = 0.5, width = "100%")
            ),
            column(6,
                   numericInput(paste0("target_hb_", row_id), "HB Target:",
                                value = round(ifelse(is.na(row$HB[1]), 0, row$HB[1]), 1),
                                step = 0.5, width = "100%")
            )
          )
        )
      })
    )
  })

  # Shared helper to open Target Shapes Settings modal (used across pages)
  open_target_shapes_modal <- function(pitcher_name, date_range, data_override = NULL) {
    if (is.null(pitcher_name) || length(pitcher_name) != 1 || pitcher_name %in% c("", "All")) {
      showNotification("Please select a single pitcher to set target shapes.", 
                       type = "warning", duration = 4)
      return()
    }
    
    data <- data_override
    if (is.null(data)) {
      data <- modified_pitch_data()
      if (is.null(data)) data <- pitch_data_pitching
    }
    
    pitcher_data <- data %>%
      dplyr::filter(Pitcher == pitcher_name)
    
    if (!is.null(date_range) && length(date_range) == 2) {
      pitcher_data <- pitcher_data %>%
        dplyr::filter(Date >= date_range[1], Date <= date_range[2])
    }
    
    pitch_types <- sort(unique(pitcher_data$TaggedPitchType))
    pitch_types <- pitch_types[!is.na(pitch_types)]
    
    if (length(pitch_types) == 0) {
      showNotification("No pitch data found for selected pitcher and date range.", 
                       type = "warning", duration = 4)
      return()
    }

    assigned <- target_shapes() %>%
      dplyr::filter(Pitcher == pitcher_name, PitchType %in% pitch_types)
    rows <- tibble::tibble(
      PitchType = character(),
      IVB = numeric(),
      HB = numeric(),
      RowID = character(),
      IsCustom = logical()
    )
    row_ids <- character()
    if (nrow(assigned) > 0) {
      for (i in seq_len(nrow(assigned))) {
        pt <- assigned$PitchType[i]
        new_id <- make_target_row_id(pt, existing = row_ids)
        row_ids <- c(row_ids, new_id)
        rows <- dplyr::bind_rows(rows, tibble::tibble(
          PitchType = pt,
          IVB = assigned$IVB_Target[i],
          HB = assigned$HB_Target[i],
          RowID = new_id,
          IsCustom = assigned$IsCustom[i]
        ))
      }
    }

    target_shape_rows(rows)
    target_shape_pitch_types(pitch_types)
    available_types <- setdiff(pitch_types, rows$PitchType)

    add_choices <- if (length(available_types)) available_types else c("No pitch types available" = "")
    selected_add <- if (length(available_types)) available_types[1] else ""
    add_defaults <- if (nzchar(selected_add)) calc_default_target_shape(pitcher_name, selected_add, date_range) else NULL
    add_ivb_init <- if (!is.null(add_defaults)) round(add_defaults$IVB, 1) else 0
    add_hb_init <- if (!is.null(add_defaults)) round(add_defaults$HB, 1) else 0

    showModal(modalDialog(
      title = paste("Target Shapes for", pitcher_name),
      size = "l",
      div(
        p("Set target movement shapes for the pitch types you care about. Add one entry per pitch type you want to customize."),
        uiOutput("target_shape_rows_ui"),
        tags$div(
          style = "border:1px dashed #cbd5f5; padding:12px; border-radius:8px; margin-top:12px;",
          tags$h4("Add a target shape", style = "margin-top:0;"),
          fluidRow(
            column(4,
                   selectInput("target_shape_add_pitch_type", "Pitch Type:", 
                               choices = add_choices, selected = selected_add)
            ),
            column(4,
                   numericInput("target_shape_add_ivb", "IVB Target:", 
                                value = add_ivb_init, step = 0.5, width = "100%")
            ),
            column(4,
                   numericInput("target_shape_add_hb", "HB Target:", 
                                value = add_hb_init, step = 0.5, width = "100%")
            )
          ),
          tagList(
            tagAppendAttributes(
              actionButton("target_shape_add_btn", "Add Target Shape", class = "btn-primary"),
              disabled = if (!length(available_types)) "disabled" else NULL
            ),
            if (!length(available_types)) {
              tags$span("Remove a saved target to unlock more pitch types.", 
                        style = "margin-left:12px;color:#64748b;")
            }
          )
        )
      ),
      footer = tagList(
        modalButton("Cancel"),
        actionButton("save_target_shapes_btn", "Save Target Shapes", class = "btn-primary")
      ),
      easyClose = FALSE
    ))

    session$userData$current_pitcher_for_targets <- pitcher_name
    session$userData$current_pitch_types_for_targets <- rows$PitchType
    session$userData$current_target_date_range <- date_range
  }

  observeEvent(target_shape_rows(), ignoreNULL = FALSE, {
    rows <- target_shape_rows()
    pitch_types <- target_shape_pitch_types()
    available <- setdiff(pitch_types, rows$PitchType)
    choices <- if (length(available)) available else c("No pitch types available" = "")
    selected <- if (length(available)) available[1] else ""
    if (!is.null(session$input$target_shape_add_pitch_type)) {
      updateSelectInput(session, "target_shape_add_pitch_type", choices = choices, selected = selected)
    }
    session$userData$current_pitch_types_for_targets <- rows$PitchType
  })

  observeEvent(input$target_shape_add_pitch_type, ignoreInit = TRUE, {
    pt <- input$target_shape_add_pitch_type
    pitcher <- session$userData$current_pitcher_for_targets
    date_range <- session$userData$current_target_date_range
    if (is.null(pt) || !nzchar(pt) || is.null(pitcher) || pitcher == "All") return()
    defaults <- calc_default_target_shape(pitcher, pt, date_range)
    ivb_val <- if (!is.null(defaults)) round(defaults$IVB, 1) else 0
    hb_val <- if (!is.null(defaults)) round(defaults$HB, 1) else 0
    if (!is.null(session$input$target_shape_add_ivb)) {
      updateNumericInput(session, "target_shape_add_ivb", value = ivb_val)
    }
    if (!is.null(session$input$target_shape_add_hb)) {
      updateNumericInput(session, "target_shape_add_hb", value = hb_val)
    }
  })

  observeEvent(input$target_shape_add_btn, ignoreNULL = TRUE, ignoreInit = TRUE, {
    pitcher <- session$userData$current_pitcher_for_targets
    if (is.null(pitcher) || pitcher == "All") {
      showNotification("Select a valid pitcher before adding a target shape.", type = "warning")
      return()
    }
    pt <- input$target_shape_add_pitch_type
    if (is.null(pt) || !nzchar(pt)) {
      showNotification("Pick a pitch type to add.", type = "warning")
      return()
    }
    rows <- target_shape_rows()
    if (pt %in% rows$PitchType) {
      showNotification(paste(pt, "already has a target shape."), type = "warning")
      return()
    }
    ivb_val <- input$target_shape_add_ivb %||% 0
    hb_val <- input$target_shape_add_hb %||% 0
    new_row <- tibble::tibble(
      PitchType = pt,
      IVB = round(ivb_val, 1),
      HB = round(hb_val, 1),
      RowID = make_target_row_id(pt, existing = rows$RowID),
      IsCustom = TRUE
    )
    target_shape_rows(dplyr::bind_rows(rows, new_row))
    showNotification(paste("Added target shape for", pt), type = "message")
  })

  observeEvent(input$target_shape_remove, ignoreNULL = TRUE, ignoreInit = TRUE, {
    row_id <- input$target_shape_remove
    rows <- target_shape_rows()
    if (!nrow(rows)) return()
    updated <- rows[rows$RowID != row_id, , drop = FALSE]
    target_shape_rows(updated)
  })

  observeEvent(input$target_shape_reset, ignoreNULL = TRUE, ignoreInit = TRUE, {
    row_id <- input$target_shape_reset
    rows <- target_shape_rows()
    row <- rows[rows$RowID == row_id, , drop = FALSE]
    if (!nrow(row)) return()
    pitcher <- session$userData$current_pitcher_for_targets
    date_range <- session$userData$current_target_date_range
    reset_target_shape(pitcher, row$PitchType[1], date_range)
    target_shape_rows(rows[rows$RowID != row_id, , drop = FALSE])
    showNotification(paste("Reset", row$PitchType[1], "to automatic target."), type = "message")
  })
  
  # Target Shapes Settings Modal triggers
  observeEvent(input$targetShapesSettings, {
    pitcher_sel <- input$pitcher
    if (is.null(pitcher_sel) || length(pitcher_sel) != 1 || "All" %in% pitcher_sel) {
      showNotification("Please select a single pitcher to set target shapes.", 
                       type = "warning", duration = 4)
      return()
    }
    open_target_shapes_modal(pitcher_sel[1], input$dates)
  }, ignoreInit = TRUE)
  observeEvent(input$pp_goal1_target_settings, {
    open_target_shapes_modal(input$pp_player_select, input$pp_date_range)
  }, ignoreInit = TRUE)
  observeEvent(input$pp_goal2_target_settings, {
    open_target_shapes_modal(input$pp_player_select, input$pp_date_range)
  }, ignoreInit = TRUE)
  observeEvent(input$pp_goal3_target_settings, {
    open_target_shapes_modal(input$pp_player_select, input$pp_date_range)
  }, ignoreInit = TRUE)
  
  # Save target shapes from modal
  observeEvent(input$save_target_shapes_btn, {
    pitcher_name <- session$userData$current_pitcher_for_targets
    rows <- target_shape_rows()
    
    if (is.null(pitcher_name) || nrow(rows) == 0) {
      showNotification("Add at least one pitch type before saving.", type = "warning")
      return()
    }
    
    # Track if any changes were made
    changes_made <- FALSE
    
    for (i in seq_len(nrow(rows))) {
      row <- rows[i, , drop = FALSE]
      ivb_input <- input[[paste0("target_ivb_", row$RowID[1])]]
      hb_input <- input[[paste0("target_hb_", row$RowID[1])]]
      
      if (!is.null(ivb_input) && !is.null(hb_input)) {
        set_target_shape(pitcher_name, row$PitchType[1], ivb_input, hb_input)
        changes_made <- TRUE
      }
    }
    
    if (changes_made) {
      # Trigger re-render of plots
      target_shapes_version(target_shapes_version() + 1)
      
      showNotification("Target shapes saved successfully!", type = "message", duration = 3)
    }
    
    removeModal()
  })
  
  # Observer for display options changes to trigger re-rendering
  observeEvent(input$summaryMovementDisplay, {
    target_shapes_version(target_shapes_version() + 1)
  }, ignoreInit = TRUE)
  
  observeEvent(input$movementPlotDisplay, {
    target_shapes_version(target_shapes_version() + 1)
  }, ignoreInit = TRUE)
  
  # Event handler for summary movement plot
  observeEvent(input$summary_movementPlot_selected, {
    if (!identical(input$pitch_click_action, "edit")) {
      df <- filtered_data(); req(nrow(df) > 0)
      open_clip_from_df_and_index(df, input$summary_movementPlot_selected, label = "Movement Plot (Summary)")
      return()
    }
    
    req(input$summary_movementPlot_selected)
    selected_ids <- as.numeric(input$summary_movementPlot_selected)
    df <- filtered_data()
    if (!nrow(df) || !length(selected_ids)) return()
    
    # Get selected pitches
    selected_pitches <- df[selected_ids, ]
    
    # Build pitcher choices (include current selection to ensure availability)
    available_pitchers <- sort(unique(pitch_data_pitching$Pitcher))
    pitcher_choices <- sort(unique(c(available_pitchers, as.character(selected_pitches$Pitcher))))
    
    # Show modal for editing pitch types / pitcher
    showModal(modalDialog(
      title = paste("Edit Pitch Type for", nrow(selected_pitches), "pitch(es)"),
      selectInput("new_pitch_type_summary", "New Pitch Type:",
                  choices = c("Fastball", "Sinker", "Cutter", "Slider", "Sweeper", 
                              "Curveball", "ChangeUp", "Splitter", "Knuckleball"),
                  selected = selected_pitches$TaggedPitchType[1]),
      selectInput("new_pitcher_summary", "Assign To Pitcher:",
                  choices = pitcher_choices,
                  selected = selected_pitches$Pitcher[1]),
      br(),
      strong("Selected Pitches:"),
      br(),
      if (nrow(selected_pitches) <= 10) {
        div(
          lapply(1:nrow(selected_pitches), function(i) {
            p <- selected_pitches[i, ]
            div(sprintf("Pitch %d: %s - %s (%.1f mph, HB: %.1f, IVB: %.1f)",
                        i, p$TaggedPitchType, p$Date, 
                        p$RelSpeed %||% 0, p$HorzBreak %||% 0, p$InducedVertBreak %||% 0))
          })
        )
      } else {
        div(sprintf("%d pitches selected (too many to display individually)", nrow(selected_pitches)))
      },
      footer = tagList(
        modalButton("Cancel"),
        actionButton("confirm_pitch_edit_summary", "Save Changes", class = "btn-primary")
      ),
      easyClose = FALSE
    ))
    
    # Store selected data for use in confirm handler
    session$userData$selected_for_edit_summary <- selected_pitches
  })

  # Location (Summary tab) – make clicks open video modal
  observeEvent(input$summary_zonePlot_selected, {
    df <- filtered_data(); req(nrow(df) > 0)
    open_clip_from_df_and_index(df, input$summary_zonePlot_selected, label = "Location (Summary)")
  }, ignoreInit = TRUE)

  observeEvent(input[["summary_releasePlot_selected"]], ignoreInit = TRUE, {
    df <- filtered_data(); req(nrow(df) > 0)
    release_handle_click(df, input[["summary_releasePlot_selected"]], prefix = "Release Plot")
  })

  observeEvent(input[["releaseCombo_selected"]], ignoreInit = TRUE, {
    df <- filtered_data(); req(nrow(df) > 0)
    release_handle_click(df, input[["releaseCombo_selected"]], prefix = "Release Combo")
  })

  observeEvent(input[["velocityPlot_selected"]], ignoreInit = TRUE, {
    df <- filtered_data(); req(nrow(df) > 0)
    open_clip_from_df_and_index(df, input[["velocityPlot_selected"]], label = "Velocity Plot")
  })

  observeEvent(input[["velocityByGamePlot_selected"]], ignoreInit = TRUE, {
    df <- filtered_data(); req(nrow(df) > 0)
    info <- parse_velocity_by_game_id(input[["velocityByGamePlot_selected"]])
    rows <- velocity_group_rows(
      df,
      pitch_type = info$pitch_type,
      date = info$date,
      session_type = info$session
    )
    label <- sprintf("%s %s", info$pitch_type %||% "Pitch", if (!is.na(info$date)) format(info$date, "%m/%d/%y") else "")
    execute_velocity_selection(rows, label)
  })

  observeEvent(input[["velocityInningPlot_selected"]], ignoreInit = TRUE, {
    df <- filtered_data(); req(nrow(df) > 0)
    info <- parse_velocity_inning_id(input[["velocityInningPlot_selected"]])
    rows <- velocity_group_rows(
      df,
      pitch_type = info$pitch_type,
      inning_ord = info$inning_ord
    )
    label <- sprintf("%s Inning %s", info$pitch_type %||% "Pitch", info$inning_ord %||% "")
    execute_velocity_selection(rows, label)
  })
  
  # Confirm pitch type changes (main movement plot)
  observeEvent(input$confirm_pitch_edit, {
    req(session$userData$selected_for_edit, input$new_pitch_type, input$new_pitcher)
    
    selected_pitches <- session$userData$selected_for_edit
    new_type <- input$new_pitch_type
    new_pitcher <- input$new_pitcher %||% ""
    lookup_df <- get0("lookup_table", ifnotfound = NULL)
    fetch_email <- function(name) {
      if (is.null(lookup_df) || !"Pitcher" %in% names(lookup_df) || !"Email_lookup" %in% names(lookup_df)) {
        return(NA_character_)
      }
      idx <- which(tolower(lookup_df$Pitcher) == tolower(name))
      if (length(idx)) {
        val <- lookup_df$Email_lookup[idx[1]]
        if (is.na(val) || !nzchar(val)) return(NA_character_)
        return(val)
      }
      NA_character_
    }
    
    # Update the modified pitch data
    current_data <- modified_pitch_data()
    if (is.null(current_data)) current_data <- pitch_data_pitching
    updated_data <- current_data
    
    # Update each selected pitch using multiple matching criteria
    for (i in 1:nrow(selected_pitches)) {
      p <- selected_pitches[i, ]
      match_idx <- which(
        updated_data$Pitcher == p$Pitcher &
          updated_data$Date == p$Date &
          abs(updated_data$RelSpeed - (p$RelSpeed %||% 0)) < 0.1 &
          abs(updated_data$HorzBreak - (p$HorzBreak %||% 0)) < 0.1 &
          abs(updated_data$InducedVertBreak - (p$InducedVertBreak %||% 0)) < 0.1
      )
      if (length(match_idx) > 0) {
        updated_data$TaggedPitchType[match_idx] <- new_type
        if (nzchar(new_pitcher)) {
          updated_data$Pitcher[match_idx] <- new_pitcher
          new_email <- fetch_email(new_pitcher)
          if (!is.na(new_email)) {
            updated_data$Email[match_idx] <- new_email
          }
        }
      }
    }
    
    # Save modifications to database
    save_result <- save_pitch_modifications_db(selected_pitches, new_type, new_pitcher)
    if (!isTRUE(save_result$success)) {
      showNotification(
        paste0("Could not store pitch type edits: ", save_result$error %||% "unknown error"),
        type = "error", duration = 8
      )
      return()
    }
    
    # Update reactive value only after successful persistence
    modified_pitch_data(updated_data)
    
    # Update modification stats
    result <- load_pitch_modifications_db(pitch_data_pitching, verbose = FALSE)
    modification_stats(list(
      applied_count = result$applied_count,
      total_modifications = result$total_modifications
    ))
    
    saved_count <- save_result$count %||% nrow(selected_pitches)
    showNotification(
      sprintf("Saved %d pitch type modifications", saved_count),
      type = "message", duration = 3
    )
    
    removeModal()
    session$userData$selected_for_edit <- NULL
  })
  
  # Confirm pitch type changes (summary movement plot)
  observeEvent(input$confirm_pitch_edit_summary, {
    req(session$userData$selected_for_edit_summary, input$new_pitch_type_summary, input$new_pitcher_summary)
    
    selected_pitches <- session$userData$selected_for_edit_summary
    new_type <- input$new_pitch_type_summary
    new_pitcher <- input$new_pitcher_summary %||% ""
    lookup_df <- get0("lookup_table", ifnotfound = NULL)
    fetch_email <- function(name) {
      if (is.null(lookup_df) || !"Pitcher" %in% names(lookup_df) || !"Email_lookup" %in% names(lookup_df)) {
        return(NA_character_)
      }
      idx <- which(tolower(lookup_df$Pitcher) == tolower(name))
      if (length(idx)) {
        val <- lookup_df$Email_lookup[idx[1]]
        if (is.na(val) || !nzchar(val)) return(NA_character_)
        return(val)
      }
      NA_character_
    }
    
    # Update the modified pitch data
    current_data <- modified_pitch_data()
    if (is.null(current_data)) current_data <- pitch_data_pitching
    updated_data <- current_data
    
    # Update each selected pitch using multiple matching criteria
    for (i in 1:nrow(selected_pitches)) {
      p <- selected_pitches[i, ]
      match_idx <- which(
        updated_data$Pitcher == p$Pitcher &
          updated_data$Date == p$Date &
          abs(updated_data$RelSpeed - (p$RelSpeed %||% 0)) < 0.1 &
          abs(updated_data$HorzBreak - (p$HorzBreak %||% 0)) < 0.1 &
          abs(updated_data$InducedVertBreak - (p$InducedVertBreak %||% 0)) < 0.1
      )
      if (length(match_idx) > 0) {
        updated_data$TaggedPitchType[match_idx] <- new_type
        if (nzchar(new_pitcher)) {
          updated_data$Pitcher[match_idx] <- new_pitcher
          new_email <- fetch_email(new_pitcher)
          if (!is.na(new_email)) {
            updated_data$Email[match_idx] <- new_email
          }
        }
      }
    }
    
    # Save modifications to database
    save_result <- save_pitch_modifications_db(selected_pitches, new_type, new_pitcher)
    if (!isTRUE(save_result$success)) {
      showNotification(
        paste0("Could not store pitch type edits: ", save_result$error %||% "unknown error"),
        type = "error", duration = 8
      )
      return()
    }
    
    # Update reactive value only after successful persistence
    modified_pitch_data(updated_data)
    
    # Update modification stats
    result <- load_pitch_modifications_db(pitch_data_pitching, verbose = FALSE)
    modification_stats(list(
      applied_count = result$applied_count,
      total_modifications = result$total_modifications
    ))
    
    saved_count <- save_result$count %||% nrow(selected_pitches)
    showNotification(
      sprintf("Saved %d pitch type modifications", saved_count),
      type = "message", duration = 3
    )
    
    removeModal()
    session$userData$selected_for_edit_summary <- NULL
  })
  
  parse_velocity_by_game_id <- function(data_id) {
    if (is.null(data_id)) return(list(pitch_type = NA_character_, date = NA, session = NA_character_))
    parts <- strsplit(as.character(data_id), "_", fixed = TRUE)[[1]]
    date_part <- if (length(parts) >= 1) parts[1] else NA_character_
    pitch_part <- if (length(parts) >= 2) parts[2] else NA_character_
    session_part <- if (length(parts) >= 3) parts[3] else NA_character_
    date_val <- suppressWarnings(as.Date(date_part))
    list(
      pitch_type = pitch_part,
      date = if (!is.na(date_val)) date_val else NA,
      session = session_part
    )
  }

  parse_velocity_inning_id <- function(data_id) {
    if (is.null(data_id)) return(list(pitch_type = NA_character_, inning_ord = NA_integer_))
    parts <- strsplit(as.character(data_id), "_", fixed = TRUE)[[1]]
    inning_val <- if (length(parts) >= 2) suppressWarnings(as.integer(parts[2])) else NA_integer_
    list(
      pitch_type = parts[1] %||% NA_character_,
      inning_ord = inning_val
    )
  }

  velocity_group_rows <- function(df, pitch_type = NULL, date = NULL, session_type = NULL, inning_ord = NULL) {
    if (is.null(df) || !nrow(df)) return(df[FALSE, , drop = FALSE])
    rows <- df
    if (!is.null(pitch_type) && nzchar(pitch_type)) {
      rows <- rows[rows$TaggedPitchType == pitch_type, , drop = FALSE]
    }
    if (!is.null(date) && inherits(date, "Date") && !is.na(date)) {
      dates <- suppressWarnings(as.Date(rows$Date))
      rows <- rows[!is.na(dates) & dates == date, , drop = FALSE]
    }
    if (!is.null(session_type) && nzchar(session_type) && session_type != "U") {
      rows <- rows[rows$SessionType == session_type, , drop = FALSE]
    }
    if (!is.null(inning_ord) && is.finite(inning_ord)) {
      rows <- rows[rows$SessionType == "Live" & !is.na(rows$Inning), , drop = FALSE]
      if (!nrow(rows)) return(rows[FALSE, , drop = FALSE])
      game_key <- if ("GameID" %in% names(rows)) {
        as.character(rows$GameID)
      } else {
        format(as.Date(rows$Date), "%Y-%m-%d")
      }
      rows$GameKey <- dplyr::coalesce(game_key, format(as.Date(rows$Date), "%Y-%m-%d"))
      rows <- dplyr::arrange(rows, GameKey, dplyr::row_number())
      rows <- dplyr::group_by(rows, GameKey)
      rows <- dplyr::mutate(rows, InningOrd = match(Inning, unique(Inning)))
      rows <- dplyr::ungroup(rows)
      rows <- rows[rows$InningOrd == inning_ord, , drop = FALSE]
    }
    rows
  }

  execute_velocity_selection <- function(rows, label) {
    if (is.null(rows) || !nrow(rows)) {
      showModal(modalDialog("No pitches found for this selection.", easyClose = TRUE, footer = NULL))
      return(invisible(FALSE))
    }
    show_pitch_video_sequence(
      rows,
      label = label,
      compare_pool = rows,
      primary_pool_idx = 1L
    )
    invisible(TRUE)
  }

  release_rows_for_type <- function(df, pitch_type) {
    if (is.null(df) || !nrow(df) || is.null(pitch_type) || !nzchar(pitch_type)) return(df[FALSE, , drop = FALSE])
    df[df$TaggedPitchType == pitch_type, , drop = FALSE]
  }

  release_handle_click <- function(df, data_id, prefix = "Release") {
    if (is.null(df) || !nrow(df) || is.null(data_id)) return(invisible(FALSE))
    ids <- unique(as.character(data_id))
    if (!length(ids)) return(invisible(FALSE))
    for (id in ids) {
      if (!nzchar(id)) next
      idx <- suppressWarnings(as.integer(id))
      if (!is.na(idx) && idx >= 1 && idx <= nrow(df)) {
        open_clip_from_df_and_index(df, idx, label = sprintf("%s pitch %s", prefix, idx))
        next
      }
      rows <- release_rows_for_type(df, id)
      if (!nrow(rows)) next
      label <- sprintf("%s %s", prefix, id)
      show_pitch_video_sequence(
        rows,
        label = label,
        compare_pool = rows,
        primary_pool_idx = 1L
      )
    }
    invisible(TRUE)
  }

  # Velocity Plot
  # Helper: pick the first existing column name from a preference list
  # ---------- helpers (replace the previous .pick_col) ----------
  .pick_col <- function(df, candidates) {
    nm <- intersect(candidates, names(df))
    if (length(nm)) nm[[1]] else NA_character_
  }
  .safe_mean <- function(x) {
    x <- suppressWarnings(as.numeric(x))
    if (all(is.na(x))) NA_real_ else mean(x, na.rm = TRUE)
  }
  HB_CANDIDATES  <- c("HB","HorzBreak","HorizBreak","HorizontalBreak","HBreak","HB_in","HB_inches")
  IVB_CANDIDATES <- c("IVB","InducedVertBreak","IVB_in","IVB_inches")
  
  
  # ----------------------------
  # 1) CURRENT VELO PLOT (+ inning vlines for Live)
  # ----------------------------
  output$velocityPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    
    df2 <- df %>% dplyr::arrange(Date, dplyr::row_number()) %>% dplyr::mutate(
      PitchCount = dplyr::row_number(),
      tt  = make_hover_tt(.),
      rid = dplyr::row_number()
    )
    
    sp <- df2$RelSpeed
    if (all(is.na(sp))) {
      y_min <- 0; y_max <- 100
    } else {
      y_min <- floor(min(sp, na.rm = TRUE) / 5) * 5
      y_max <- ceiling(max(sp, na.rm = TRUE) / 5) * 5
      if (y_min == y_max) y_max <- y_min + 5
    }
    x_max <- ceiling(max(df2$PitchCount, na.rm = TRUE) / 5) * 5
    if (!is.finite(x_max) || x_max <= 0) x_max <- 5
    
    avg_velo <- df2 %>% dplyr::filter(!is.na(RelSpeed)) %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(avg_velo = mean(RelSpeed), .groups = "drop")
    
    p <- ggplot(df2, aes(PitchCount, RelSpeed)) +
      ggiraph::geom_point_interactive(
        aes(color = TaggedPitchType, fill = TaggedPitchType, tooltip = tt, data_id = rid),
        position = "identity",
        size = 3, alpha = 0.9, shape = 21, stroke = 0.25
      ) +
      geom_hline(
        data = avg_velo,
        aes(yintercept = avg_velo, color = TaggedPitchType),
        linewidth = 0.9, inherit.aes = FALSE, show.legend = FALSE
      ) +
      scale_x_continuous(limits = c(0, x_max), breaks = seq(0, x_max, 5)) +
      scale_y_continuous(limits = c(y_min, y_max), breaks = seq(y_min, y_max, 5)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      theme(
        legend.position = "bottom",
        legend.text = element_text(size = 14, color = axis_col),
        axis.text.x = element_text(color = axis_col),
        axis.text.y = element_text(color = axis_col),
        axis.title.x = element_text(color = axis_col),
        axis.title.y = element_text(color = axis_col)
      ) +
      labs(title = "Velocity Chart (Game/Inning)", x = "Pitch Count", y = "Velocity (MPH)")
    
    # NEW: dashed vertical lines at inning boundaries (Live only)
    if ("SessionType" %in% names(df2) &&
        length(na.omit(unique(df2$SessionType))) == 1 &&
        na.omit(unique(df2$SessionType)) == "Live" &&
        "Inning" %in% names(df2)) {
      
      inning <- df2$Inning
      # first pitch of each NEW inning (skip very first overall)
      boundary_idx <- which(!is.na(inning) & dplyr::lag(inning, default = inning[1]) != inning)
      boundary_idx <- boundary_idx[boundary_idx != 1]
      if (length(boundary_idx)) {
        vlines <- dplyr::tibble(x = df2$PitchCount[boundary_idx])
        p <- p + geom_vline(data = vlines, aes(xintercept = x),
                            linetype = "dashed", linewidth = 0.4, alpha = 0.6,
                            inherit.aes = FALSE)
      }
    }
    
    girafe_transparent(
      ggobj = p,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  # ----------------------------
  # 2) NEW: Velocity by Game (Date) & Pitch Type
  #     - dot per pitch type per Date, connected lines by pitch type
  #     - tooltip: Date, Session, Velo, IVB, HB (no InZone)
  # ----------------------------
  # ----------------------------
  # Velocity by Game (Date) & Pitch Type  — updated tooltip + x-axis
  # ----------------------------
  output$velocityByGamePlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    
    ivb_nm <- .pick_col(df, IVB_CANDIDATES)
    hb_nm  <- .pick_col(df, HB_CANDIDATES)
    
    dfG <- df %>%
      dplyr::filter(!is.na(RelSpeed), !is.na(TaggedPitchType), !is.na(Date)) %>%
      dplyr::mutate(
        IVB_ = if (!is.na(ivb_nm)) .data[[ivb_nm]] else NA_real_,
        HB_  = if (!is.na(hb_nm))  .data[[hb_nm]]  else NA_real_
      ) %>%
      dplyr::group_by(Date, TaggedPitchType, SessionType) %>%
      dplyr::summarise(
        Velo = .safe_mean(RelSpeed),
        IVB  = .safe_mean(IVB_),
        HB   = .safe_mean(HB_),
        n    = dplyr::n(),
        .groups = "drop"
      ) %>%
      dplyr::arrange(Date, TaggedPitchType) %>%
      dplyr::mutate(
        tt  = paste0(
          "Session: ", dplyr::coalesce(as.character(SessionType), "Unknown"), "\n",
          TaggedPitchType, "\n",
          "Velo: ", sprintf("%.1f", Velo), " mph\n",
          "IVB: ",  ifelse(is.finite(IVB), sprintf("%.1f", IVB), "—"), "\n",
          "HB: ",   ifelse(is.finite(HB),  sprintf("%.1f", HB),  "—"), "\n",
          "Pitches: ", n
        ),
        rid = paste0(format(Date, "%Y-%m-%d"), "_", TaggedPitchType, "_", dplyr::coalesce(as.character(SessionType), "U"))
      )
    
    if (!nrow(dfG)) return(NULL)
    
    sp <- df$RelSpeed
    if (all(is.na(sp))) { y_min <- 0; y_max <- 100 } else {
      y_min <- floor(min(sp, na.rm = TRUE) / 5) * 5
      y_max <- ceiling(max(sp, na.rm = TRUE) / 5) * 5
      if (y_min == y_max) y_max <- y_min + 5
    }
    
    # Evenly spaced x-axis using ordered factor of dates
    date_levels <- format(sort(unique(dfG$Date)), "%m/%d/%y")
    dfG <- dfG %>%
      dplyr::mutate(date_fac = factor(format(Date, "%m/%d/%y"), levels = date_levels))
    
    p2 <- ggplot(dfG, aes(date_fac, Velo, group = TaggedPitchType, color = TaggedPitchType)) +
      ggiraph::geom_line_interactive(linewidth = 0.7, alpha = 0.85) +
      ggiraph::geom_point_interactive(
        aes(tooltip = tt, data_id = rid, fill = TaggedPitchType),
        size = 3, shape = 21, stroke = 0.25
      ) +
      scale_x_discrete(expand = c(0.02, 0.02)) +
      scale_y_continuous(limits = c(y_min, y_max), breaks = seq(y_min, y_max, 5)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      theme(
        legend.position = "bottom",
        legend.text = element_text(size = 14, color = axis_col),
        axis.text.x = element_text(angle = 45, hjust = 1, color = axis_col),
        axis.text.y = element_text(color = axis_col),
        axis.title.x = element_text(color = axis_col),
        axis.title.y = element_text(color = axis_col)
      ) +
      labs(title = "Average Velocity by Game",
           x = "Game Date", y = "Velocity (MPH)")
    
    girafe_transparent(
      ggobj = p2,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  
  # ----------------------------
  # 3) NEW: Inning-to-Inning Average Velocity (relative to entry inning)
  #     - Live only
  #     - x = 1st, 2nd, 3rd inning *the pitcher threw in that game*
  # ----------------------------
  # ----------------------------
  # Inning-to-Inning Average Velocity — updated tooltip (Session only) + HB fix
  # ----------------------------
  output$velocityInningPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    dark_on <- isTRUE(input$dark_mode)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    if (!("SessionType" %in% names(df)) || !"Inning" %in% names(df)) return(NULL)
    
    df_live <- df %>% dplyr::filter(SessionType == "Live", !is.na(RelSpeed), !is.na(Inning))
    if (!nrow(df_live)) return(NULL)
    
    ivb_nm <- .pick_col(df_live, IVB_CANDIDATES)
    hb_nm  <- .pick_col(df_live, HB_CANDIDATES)
    
    df_live <- df_live %>%
      dplyr::mutate(
        GameKey = dplyr::case_when(
          "GameID" %in% names(df_live) ~ as.character(.data[["GameID"]]),
          TRUE                         ~ format(as.Date(Date), "%Y-%m-%d")
        )
      ) %>%
      dplyr::arrange(GameKey, dplyr::row_number()) %>%
      dplyr::group_by(GameKey) %>%
      dplyr::mutate(InningOrd = match(Inning, unique(Inning))) %>%
      dplyr::ungroup()
    
    dfI <- df_live %>%
      dplyr::mutate(
        IVB_ = if (!is.na(ivb_nm)) .data[[ivb_nm]] else NA_real_,
        HB_  = if (!is.na(hb_nm))  .data[[hb_nm]]  else NA_real_
      ) %>%
      dplyr::group_by(InningOrd, TaggedPitchType) %>%
      dplyr::summarise(
        Velo  = .safe_mean(RelSpeed),
        IVB   = .safe_mean(IVB_),
        HB    = .safe_mean(HB_),
        n     = dplyr::n(),
        games = dplyr::n_distinct(GameKey),
        .groups = "drop"
      ) %>%
      dplyr::arrange(InningOrd, TaggedPitchType) %>%
      dplyr::mutate(
        tt = paste0(
          "Session: Live\n",
          "Inning #: ", InningOrd, "\n",
          TaggedPitchType, "\n",
          "Velo: ", sprintf("%.1f", Velo), " mph\n",
          "IVB: ",  ifelse(is.finite(IVB), sprintf("%.1f", IVB), "—"), "\n",
          "HB: ",   ifelse(is.finite(HB),  sprintf("%.1f", HB),  "—"), "\n",
          "Games: ", games, " | Pitches: ", n
        ),
        rid = paste0(TaggedPitchType, "_", InningOrd)
      )
    
    if (!nrow(dfI)) return(NULL)
    
    sp <- df_live$RelSpeed
    if (all(is.na(sp))) { y_min <- 0; y_max <- 100 } else {
      y_min <- floor(min(sp, na.rm = TRUE) / 5) * 5
      y_max <- ceiling(max(sp, na.rm = TRUE) / 5) * 5
      if (y_min == y_max) y_max <- y_min + 5
    }
    
    xmax <- max(dfI$InningOrd, na.rm = TRUE)
    p3 <- ggplot(dfI, aes(InningOrd, Velo, group = TaggedPitchType, color = TaggedPitchType)) +
      ggiraph::geom_line_interactive(linewidth = 0.7, alpha = 0.85) +
      ggiraph::geom_point_interactive(
        aes(tooltip = tt, data_id = rid, fill = TaggedPitchType),
        size = 3, shape = 21, stroke = 0.25
      ) +
      scale_x_continuous(breaks = seq_len(xmax)) +
      scale_y_continuous(limits = c(y_min, y_max), breaks = seq(y_min, y_max, 5)) +
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      theme(
        legend.position = "bottom",
        legend.text = element_text(size = 14, color = axis_col),
        axis.text.x = element_text(color = axis_col),
        axis.text.y = element_text(color = axis_col),
        axis.title.x = element_text(color = axis_col),
        axis.title.y = element_text(color = axis_col)
      ) +
      labs(title = "Average Velocity by Inning ",
           x = "Inning of Appearance", y = "Velocity (MPH)")
    
    girafe_transparent(
      ggobj = p3,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  # Velocity Trend Plot
  # Replace your existing output$veloTrendPlot with this:
  
  output$veloTrendPlot <- renderPlot({
    df <- filtered_data(); req(nrow(df)>0)
    # compute average velocity per date
    velo_dat <- df %>%
      group_by(Date) %>%
      summarise(avg_velo = mean(RelSpeed, na.rm=TRUE), .groups="drop") %>%
      arrange(Date)
    
    # dynamic y-axis limits based on data
    y_min <- floor(min(velo_dat$avg_velo, na.rm=TRUE) / 5) * 5
    y_max <- ceiling(max(velo_dat$avg_velo, na.rm=TRUE) / 5) * 5
    if (y_min == y_max) {
      y_min <- y_min - 5
      y_max <- y_max + 5
    }
    
    # preserve date ordering
    date_levels <- unique(fmt_date(velo_dat$Date))
    velo_dat <- velo_dat %>% mutate(Date_f = factor(fmt_date(Date), levels = date_levels))
    
    # single-line plot with dynamic y-axis
    ggplot(velo_dat, aes(x = Date_f, y = avg_velo, group = 1)) +
      geom_line(size = 1.2) +
      geom_point(size = 2) +
      scale_y_continuous(limits = c(y_min, y_max), breaks = seq(y_min, y_max, 5)) +
      labs(title = "Average Velocity", x = NULL, y = "Velocity (MPH)") +
      theme_minimal() + axis_theme +
      theme(
        plot.title     = element_text(face = "bold"),
        axis.text.x    = element_text(angle = 45, hjust = 1),
        axis.line.x    = element_line(color = "black"),
        axis.line.y    = element_line(color = "black")
      )
  }, bg = "transparent")
  
  # Heatmap Plot (using modern KDE approach like other suites)
  output$heatmapPlot <- renderPlot({
    df <- filtered_data()
    if (!nrow(df)) return(ggplot() + theme_void())
    
    sel <- sel_results()
    
    # If not "All", filter to selected result types only (exclude NAs).
    if (!identical(sel, result_levels)) {
      hit_opts  <- c("Single", "Double", "Triple", "HomeRun", "Error")
      sel_hits  <- intersect(sel, hit_opts)
      df <- dplyr::filter(
        df,
        (!is.na(Result) & Result %in% sel) |
          (!is.na(PlayResult) & PlayResult %in% sel_hits)
      )
    }
    # If "All", keep everything (including NA results).
    
    if (!nrow(df)) return(ggplot() + theme_void())
    
    # Use KDE frequency heatmap (matching all other suites)
    grid <- make_kde_grid(df$PlateLocSide, df$PlateLocHeight)
    if (!nrow(grid)) return(ggplot() + theme_void())
    
    # Normalize KDE values to 0-100 scale for better color mapping
    grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
    
    # Use blue->red palette for frequency (matching other suites)
    return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
                     show_scale = TRUE, scale_label = "Pitch Frequency",
                     scale_limits = c(0, 80)))
  }, bg = "transparent")
  
  # Pitch Plot
  output$pitchPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    types <- ordered_types(); types_chr <- as.character(types)
    
    sel <- sel_results()
    if (!identical(sel, result_levels)) {
      df <- dplyr::filter(df, !is.na(Result) & Result %in% sel)
    }
    
    df_i <- df %>%
      dplyr::mutate(
        tt      = make_hover_tt(.),
        rid     = dplyr::row_number(),
        tt_fill = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray")
      )
    
    home <- data.frame(x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
                       y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5)
    cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
    sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
    
    df_known <- dplyr::filter(df_i, !is.na(Result))
    df_other <- dplyr::filter(df_i,  is.na(Result))
    
    p <- ggplot() +
      geom_polygon(data = home, aes(x, y), fill = NA, color = "black", inherit.aes = FALSE) +
      geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = "black", linetype = "dashed", inherit.aes = FALSE) +
      geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = "black", inherit.aes = FALSE) +
      
      ggiraph::geom_point_interactive(
        data = df_other,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
      ) +
      
      ggiraph::geom_point_interactive(
        data = df_known,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 4.0, alpha = 0.95, stroke = 0.8
      ) +
      
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
      coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
      theme_void() + theme(legend.position = "none") +
      
      # 🔹 Invisible “hover pad” to force correct tooltip fill even for hollow shapes
      ggiraph::geom_point_interactive(
        data = df_i,
        aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
        shape = 21, size = 6, alpha = 0.001, stroke = 0, inherit.aes = FALSE
      )
    
    girafe_transparent(
      ggobj = p,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  # ---------- Shared helpers for this page ----------
  # NOTE: Removed duplicate Pitch Results filter (locResult) - now using main sidebar's pitchResults
  
  # Current selection of results (use main sidebar's pitchResults filter)
  sel_results <- reactive({
    sel <- input$pitchResults
    if (is.null(sel) || !length(sel) || "All" %in% sel) return(result_levels)
    
    # If a specific hit type is chosen, also include the grouped in-play hit result
    hit_opts <- c("Single", "Double", "Triple", "HomeRun")
    if (any(sel %in% hit_opts)) {
      sel <- unique(c(sel, "In Play (Hit)"))
    }
    sel
  })
  
  # Small note: hide EV notice unless user picks Pitch chart with EV (heat-only stat)
  output$hmNote <- renderUI({
    if (identical(input$hmChartType, "Pitch") && identical(input$hmStat, "EV")) {
      tags$div(style="margin-top:8px; font-size:12px; color:#a00;",
               "Note: Exit Velocity is a heat-map metric; switch chart to 'Heat' to view.")
    } else NULL
  })
  
  # Legend (shapes + pitch type colors), like Location page
  output$locLegend <- renderUI({
    df <- filtered_data()
    types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
    
    shape_key <- list(
      "Called Strike" = "\u25CF", # ●
      "Ball"          = "\u25CB", # ○
      "Foul"          = "\u25B3", # △
      "Whiff"         = "\u2605", # ★
      "In Play (Out)" = "\u25B2", # ▲
      "In Play (Hit)" = "\u25A0", # ■
      "Single"        = "\u25A0", # ■
      "Double"        = "\u25A0", # ■
      "Triple"        = "\u25A0", # ■
      "HomeRun"       = "\u25A0", # ■
      "Error"         = "\u25A1"  # □
    )
    
    sty <- HTML("
    .legend-block { margin-bottom:10px; }
    .legend-title { font-weight:700; margin-bottom:6px; }
    .legend-list  { list-style:none; padding-left:0; margin:0; }
    .legend-list li { margin:2px 0; display:flex; align-items:center; }
    .dot { display:inline-block; width:12px; height:12px; border-radius:50%;
           border:1px solid #000; margin-right:6px; }
    .shape { width:18px; display:inline-block; margin-right:6px; text-align:center; }
  ")
    
    tags$div(
      tags$style(sty),
      
      tags$div(class="legend-block",
               tags$div(class="legend-title", "Pitch Result"),
               tags$ul(class="legend-list",
                       lapply(result_levels, function(lbl) {
                         tags$li(tags$span(class="shape", if (is.null(shape_key[[lbl]])) "" else shape_key[[lbl]]),
                                 tags$span(lbl))
                       })
               )
      ),
      
      tags$div(class="legend-block",
               tags$div(class="legend-title", "Pitch Type"),
               tags$ul(class="legend-list",
                       lapply(types, function(tp) {
                         col <- all_colors[[tp]]; if (is.null(col)) col <- "gray"
                         tags$li(tags$span(class="dot", style = paste0("background:", col, ";")),
                                 tags$span(tp))
                       })
               )
      )
    )
  })
  
  # ---------- HEAT (respects Pitch Results filter) ----------
  output$heatmapsHeatPlot <- renderPlot({
    df <- filtered_data(); if (!nrow(df)) return()
    
    if (!("Result" %in% names(df))) {
      df$Result <- factor(compute_result(df$PitchCall, df$PlayResult), levels = result_levels)
    }
    
    sel <- sel_results()
    if (!identical(sel, result_levels)) {
      hit_opts <- c("Single", "Double", "Triple", "HomeRun", "Error")
      sel_hits <- intersect(sel, hit_opts)
      df <- dplyr::filter(
        df,
        (!is.na(Result) & Result %in% sel) |
          (!is.na(PlayResult) & PlayResult %in% sel_hits)
      )
    }
    if (!nrow(df)) return(ggplot() + theme_void())
    
    stat <- input$hmStat
    render_heatmap_stat(df, stat)
  }, bg = "transparent")
  
  # ---------- PITCH (point chart; respects Pitch Results filter) ----------
  output$heatmapsPitchPlot <- ggiraph::renderGirafe({
    req(input$hmChartType == "Pitch")
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    
    # Ensure Result for filtering + shapes
    if (!("Result" %in% names(df))) {
      df$Result <- factor(compute_result(df$PitchCall, df$PlayResult), levels = result_levels)
    }
    
    sel <- sel_results()
    if (!identical(sel, result_levels)) {
      df <- dplyr::filter(df, !is.na(Result) & Result %in% sel)
    }
    if (!nrow(df)) return(NULL)
    
    types <- intersect(names(all_colors), as.character(unique(df$TaggedPitchType)))
    types_chr <- as.character(types)
    
    df_i <- df %>%
      dplyr::mutate(
        tt      = make_hover_tt(.),
        rid     = dplyr::row_number(),
        tt_fill = dplyr::coalesce(all_colors[as.character(TaggedPitchType)], "gray")
      )
    
    home <- data.frame(x=c(-0.75,0.75,0.75,0.00,-0.75),
                       y=c(1.05,1.05,1.15,1.25,1.15)-0.5)
    cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
    sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
    
    p <- ggplot() +
      geom_polygon(data = home, aes(x, y), fill = NA, color = "black") +
      geom_rect(data = cz, aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),
                fill = NA, color = "black", linetype = "dashed") +
      geom_rect(data = sz, aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),
                fill = NA, color = "black") +
      
      # visible points (unknown result as solid circle)
      ggiraph::geom_point_interactive(
        data = dplyr::filter(df_i, is.na(Result)),
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType,
            tooltip = tt, data_id = rid),
        size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
      ) +
      
      # visible points (known result with shapes)
      ggiraph::geom_point_interactive(
        data = dplyr::filter(df_i, !is.na(Result)),
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
            tooltip = tt, data_id = rid),
        size = 4.0, alpha = 0.95, stroke = 0.8
      ) +
      
      scale_color_manual(values = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = all_colors[types_chr], limits = types_chr, name = NULL) +
      scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
      coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
      theme_void() + theme(legend.position = "none") +
      
      # invisible hover pad to guarantee correct tooltip fill even for hollow shapes
      ggiraph::geom_point_interactive(
        data = df_i,
        aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
        shape = 21, size = 6, alpha = 0.001, stroke = 0, inherit.aes = FALSE
      )
    
    girafe_transparent(
      ggobj = p,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  })
  
  # ---------- QP+ single heatmap (pitch overlay) ----------
  count_families_for_selection <- function(sel) {
    if (is.null(sel) || !length(sel)) return(character(0))
    sel <- trimws(sel)
    sel <- sel[sel != "All" & nzchar(sel)]
    if (!length(sel)) return(character(0))
    fams <- character(0)
    add_family <- function(x) fams <<- c(fams, x)
    ahead_pairs   <- list(c(0,1), c(0,2), c(1,2))
    even_pairs    <- list(c(0,0), c(1,1), c(2,2), c(3,2))
    behind_pairs  <- list(c(1,0), c(2,0), c(3,0), c(3,1), c(2,1))
    if ("Ahead" %in% sel)   add_family("Ahead")
    if ("Even" %in% sel)    add_family("Even")
    if ("Behind" %in% sel)  add_family("Behind")
    if ("2KNF" %in% sel)    add_family("Ahead")  # treat two-strike no fastball as ahead-family
    exact <- sel[grepl("^\\d-\\d$", sel)]
    if (length(exact)) {
      for (val in exact) {
        sp <- strsplit(val, "-", fixed = TRUE)[[1]]
        if (length(sp) == 2) {
          b <- suppressWarnings(as.integer(sp[1])); s <- suppressWarnings(as.integer(sp[2]))
          if (any(vapply(ahead_pairs,   function(p) identical(c(b,s), p), logical(1)))) add_family("Ahead")
          else if (any(vapply(even_pairs,   function(p) identical(c(b,s), p), logical(1)))) add_family("Even")
          else if (any(vapply(behind_pairs, function(p) identical(c(b,s), p), logical(1)))) add_family("Behind")
          else add_family("Other")
        }
      }
    }
    unique(fams)
  }
  
  output$heatmapsQPPlot <- ggiraph::renderGirafe({
    req(input$hmChartType == "QP+")
    df <- filtered_data(); if (!nrow(df)) return(NULL)
    
    pitcher_hand <- get_pitcher_handedness()
    batter_hand  <- input$batterSide
    fams_sel <- count_families_for_selection(input$countFilter)
    fams_df <- character(0)
    if (nrow(df) && all(c("Balls","Strikes") %in% names(df))) {
      cs <- count_state_vec(df$Balls, df$Strikes)
      fams_df <- unique(cs[!is.na(cs)])
    }
    fams_use <- unique(c(fams_sel, fams_df))
    pitch_sel <- input$pitchType
    # Require exactly one pitch type (no "All") so we show a single chart
    valid_pitch_type <- !is.null(pitch_sel) && length(pitch_sel) == 1 && pitch_sel != "All"
    
    fams_no_other <- setdiff(fams_use, "Other")
    
    validate(
      need(!is.null(pitcher_hand), "Select a pitcher (or pitcher hand) to view QP+."),
      need(!is.null(batter_hand) && batter_hand != "All", "Select batter handedness to view QP+."),
      need(valid_pitch_type, "Select exactly one pitch type (not \"All\") for QP+."),
      need(length(fams_no_other) > 0, "Select counts from Ahead, Even, or Behind to view QP+."),
      need(length(unique(fams_no_other)) == 1, "Select counts from a single family (Ahead, Even, or Behind).")
    )
    
    count_state <- fams_no_other[1]
    p <- create_qp_locations_plot(df, count_state, pitcher_hand, batter_hand)
    
    girafe_transparent(
      ggobj = p,
      width_svg = 12, height_svg = 5,
      options = list(
        ggiraph::opts_hover_inv(css = "opacity:0.1;"),
        ggiraph::opts_hover(css = "stroke-width:2;"),
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css, opacity = 0.9)
      )
    )
  })
  
  
  # ---------- small helpers ----------
  .find_qp_plus_col <- function(df) {
    nms <- names(df)
    ln  <- tolower(nms)
    # direct hits first
    candidates <- c("qp+", "qp_plus", "qp.plus", "qp.", "qualitypitch+", "qualitypitchplus", "qp")
    hit <- nms[match(candidates, ln, nomatch = 0)]
    if (length(hit) && nzchar(hit[1])) return(hit[1])
    # regex fallback: qp, qp+, qp plus, qp_plus, qp.plus, qualitypitch...
    idx <- grep("^(qp|quality\\s*pitch)[[:space:]_\\.]*([+]||plus)?$", ln, perl = TRUE)
    if (length(idx)) nms[idx[1]] else NULL
  }
  
  .num_safely <- function(x) {
    x_chr <- as.character(x)
    x_chr <- trimws(gsub(",", "", x_chr, fixed = TRUE))
    x_chr <- gsub("%$", "", x_chr)
    suppressWarnings(as.numeric(x_chr))
  }
  
  output$trendPlotUI <- renderUI({
    switch(input$trendMetric,
           "Velocity (Avg)"    = ggiraph::girafeOutput("veloTrendPlot",    height = "350px"),
           "Velocity (Max)"    = ggiraph::girafeOutput("maxVeloTrendPlot", height = "350px"),
           "InZone %"          = ggiraph::girafeOutput("inZoneTrendPlot",  height = "350px"),
           "Comp %"            = ggiraph::girafeOutput("compTrendPlot",    height = "350px"),
           "FPS%"              = ggiraph::girafeOutput("fpsTrendPlot",     height = "350px"),
           "E+A%"              = ggiraph::girafeOutput("eaTrendPlot",      height = "350px"),
           "Whiff%"            = ggiraph::girafeOutput("whiffTrendPlot",   height = "350px"),
           'CSW%'              = ggiraph::girafeOutput(ns('cswTrendPlot'), height = "350px"),
           "Strike%"           = ggiraph::girafeOutput("strikeTrendPlot",  height = "350px"),
           "K%"                = ggiraph::girafeOutput("kTrendPlot",       height = "350px"),
           "BB%"               = ggiraph::girafeOutput("bbTrendPlot",      height = "350px"),
           "Stuff+"            = ggiraph::girafeOutput("stuffTrendPlot",   height = "350px"),
           "Ctrl+"             = ggiraph::girafeOutput("commandTrendPlot", height = "350px"),
           "QP+"               = ggiraph::girafeOutput("qpTrendPlot",      height = "350px"),
           "QP%"               = ggiraph::girafeOutput("qpPctTrendPlot",   height = "350px"),
           "Pitching+"         = ggiraph::girafeOutput("pitchingTrendPlot",height = "350px"),
           "IVB"               = ggiraph::girafeOutput("ivbTrendPlot",     height = "350px"),
           "HB"                = ggiraph::girafeOutput("hbTrendPlot",      height = "350px"),
           "Release Height"    = ggiraph::girafeOutput("heightTrendPlot",  height = "350px"),
           "Extension"         = ggiraph::girafeOutput("extensionTrendPlot",height = "350px")
    )
  })
  
  output$veloTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, RelSpeed, "Average Velocity", "Velocity (MPH)", mean, digits = 1)
  })
  
  output$maxVeloTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, RelSpeed, "Max Velocity", "Velocity (MPH)", max, digits = 1)
  })
  
  output$inZoneTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(
      df,
      PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
        PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP,
      "InZone %", "Percentage",
      function(x) mean(x, na.rm = TRUE) * 100,
      digits = 1
    )
  })
  
  output$compTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(
      df,
      PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
        PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5),
      "Comp %", "Percentage",
      function(x) mean(x, na.rm = TRUE) * 100,
      digits = 1
    )
  })
  
  output$ivbTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, InducedVertBreak, "Induced Vertical Break", "IVB (in)", mean, digits = 1)
  })
  
  output$hbTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, HorzBreak, "Horizontal Break", "HB (in)", mean, digits = 1)
  })
  
  output$heightTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, RelHeight, "Release Height", "Height (ft)", mean, digits = 2)
  })
  
  output$extensionTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, Extension, "Extension (ft)", mean, digits = 2)
  })
  
  output$stuffTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    trend_plot(df, `Stuff+`, "Stuff+", "Stuff+", mean, digits = 1)
  })
  
  output$commandTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    df <- df %>%
      dplyr::mutate(ctrl_score =
                      ifelse(
                        PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                          PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, 1.47,
                        ifelse(
                          PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                            PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5),
                          0.73, 0
                        )
                      ) * 100)
    trend_plot(df, ctrl_score, "Ctrl+", "Ctrl+", mean, digits = 1)
  })
  
  # ---------- QP+ (make it mirror Stuff+/Ctrl+ usage) ----------
  output$qpTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    df <- dplyr::ungroup(df)
    
    # 1) Find an existing QP-like column no matter how it was named/sanitized
    qp_col <- .find_qp_plus_col(df)
    
    if (!is.null(qp_col)) {
      # Coerce safely to numeric new column, then use like Stuff+/Ctrl+
      df <- dplyr::mutate(df, qp_score = .num_safely(.data[[qp_col]]))
    } else {
      # 2) If no QP+ column exists, try to compute a fallback QP score inline.
      #    This mirrors your Ctrl+ scaffold so the trend code path is identical.
      #    Replace this block later with your exact QP+ routine if desired.
      df <- dplyr::mutate(
        df,
        qp_score = ifelse(
          PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
            PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, 1.47,
          ifelse(
            PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
              PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5),
            0.73, 0
          )
        ) * 100
      )
    }
    
    validate(need(any(is.finite(df$qp_score)), "No QP+ values for current filters"))
    trend_plot(df, qp_score, "QP+", "QP+", mean, digits = 1)
  })
  
  # ---------- QP% (percentage of pitches with QP+ >= 100) ----------
  output$qpPctTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    df <- dplyr::ungroup(df)
    
    # Calculate QP+ values using compute_qp_points
    qp_values <- compute_qp_points(df) * 200  # QP+ is QP points * 200
    df <- df %>% dplyr::mutate(qp_plus = qp_values)
    
    # Create binary indicator: 1 if QP+ >= 100, 0 otherwise
    df <- df %>% dplyr::mutate(quality_pitch = ifelse(qp_plus >= 100, 1, 0))
    
    # Use trend_plot with percentage calculation
    trend_plot(
      df, 
      quality_pitch, 
      "QP%", 
      "Percentage",
      function(x) mean(x, na.rm = TRUE) * 100,
      digits = 1
    )
  })
  
  # ---------- Pitching+ (prefer QP+; fallback to Ctrl+) ----------
  output$pitchingTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df)>0)
    df <- dplyr::ungroup(df)
    
    # Build ctrl_score (needed as fallback and for legacy)
    df <- df %>%
      dplyr::mutate(ctrl_score =
                      ifelse(
                        PlateLocSide >= ZONE_LEFT & PlateLocSide <= ZONE_RIGHT &
                          PlateLocHeight >= ZONE_BOTTOM & PlateLocHeight <= ZONE_TOP, 1.47,
                        ifelse(
                          PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                            PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5),
                          0.73, 0
                        )
                      ) * 100)
    
    # Try to get QP+ numeric (same logic as above)
    qp_col <- .find_qp_plus_col(df)
    if (!is.null(qp_col)) {
      df <- dplyr::mutate(df, qp_score = .num_safely(.data[[qp_col]]))
    }
    
    use_qp <- "qp_score" %in% names(df) && any(is.finite(df$qp_score))
    
    if (input$sessionType == "All") {
      dat <- df %>%
        dplyr::group_by(Date, SessionType) %>%
        dplyr::summarise(
          Stuff = mean(`Stuff+`, na.rm = TRUE),
          Qual  = mean(if (use_qp) qp_score else ctrl_score, na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(Pitching = (Stuff + Qual) / 2) %>%
        dplyr::arrange(Date)
      
      date_levels <- unique(fmt_date(dat$Date))
      dat <- dplyr::mutate(dat, Date_f = factor(fmt_date(Date), levels = date_levels))
      
      ggplot(dat, aes(Date_f, Pitching, group = SessionType, color = SessionType)) +
        geom_line(size = 1.2) + geom_point(size = 2) +
        scale_color_manual(values = session_cols, breaks = c("Live", "Bullpen"), name = NULL) +
        labs(title = "Pitching+", x = NULL, y = "Pitching+") +
        theme_minimal() + axis_theme +
        theme(plot.title = element_text(face = "bold"),
              axis.text.x = element_text(angle = 45, hjust = 1),
              legend.position = "bottom")
    } else {
      dat <- df %>%
        dplyr::group_by(Date) %>%
        dplyr::summarise(
          Stuff = mean(`Stuff+`, na.rm = TRUE),
          Qual  = mean(if (use_qp) qp_score else ctrl_score, na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(Pitching = (Stuff + Qual) / 2) %>%
        dplyr::arrange(Date)
      
      date_levels <- unique(fmt_date(dat$Date))
      dat <- dplyr::mutate(dat, Date_f = factor(fmt_date(Date), levels = date_levels))
      
      ggplot(dat, aes(Date_f, Pitching, group = 1)) +
        geom_line(size = 1.2) + geom_point(size = 2) +
        labs(title = "Pitching+", x = NULL, y = "Pitching+") +
        theme_minimal() + axis_theme +
        theme(plot.title = element_text(face = "bold"),
              axis.text.x = element_text(angle = 45, hjust = 1),
              legend.position = "none")
    }
  })
  
  # ---------- Helpers for Trend % plots ----------
  plot_trend_df <- function(dat, title, ylab, digits = 1) {
    trend_girafe_plot(dat, title, ylab, digits = digits)
  }
  
  # ---------- FPS% (Live-only) ----------
  output$fpsTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF  = sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE),
          FPS = sum(SessionType == "Live" & Balls == 0 & Strikes == 0 &
                      PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"),
                    na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * FPS / BF, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF  = sum(Balls == 0 & Strikes == 0, na.rm = TRUE),
          FPS = sum(Balls == 0 & Strikes == 0 &
                      PitchCall %in% c("InPlay","StrikeSwinging","StrikeCalled","FoulBallNotFieldable","FoulBallFieldable"),
                    na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * FPS / BF, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "FPS%", "Percentage")
  })
  
  # ---------- E+A% (Live-only) ----------
  output$eaTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    is_EA <- (df$Balls == 0 & df$Strikes == 0 & df$PitchCall == "InPlay") |
      (df$Balls == 0 & df$Strikes == 1 & df$PitchCall %in% c("InPlay","FoulBallNotFieldable","FoulBallFieldable","StrikeSwinging","StrikeCalled")) |
      (df$Balls == 1 & df$Strikes == 0 & df$PitchCall == "InPlay") |
      (df$Balls == 1 & df$Strikes == 1 & df$PitchCall %in% c("InPlay","FoulBallNotFieldable","FoulBallFieldable","StrikeSwinging","StrikeCalled"))
    df$EA_flag <- is_EA
    
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all() %>% dplyr::filter(SessionType == "Live")),
          EA = sum(SessionType == "Live" & EA_flag, na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * EA / BF, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all()),
          EA = sum(EA_flag, na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * EA / BF, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "E+A%", "Percentage")
  })
  
  # ---------- Whiff% ----------
  output$whiffTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          sw  = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
          den = sum(PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(den > 0, 100 * sw / den, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          sw  = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
          den = sum(PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(den > 0, 100 * sw / den, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "Whiff%", "Percentage")
  })
  
  output$cswTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    
    if (input$sessionType == "All") {
      dat <- df %>%
        dplyr::group_by(Date, SessionType) %>%
        dplyr::summarise(
          total_pitches = dplyr::n(),
          Pitches = dplyr::n(),
          CSW     = sum(PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(value = dplyr::if_else(Pitches > 0, 100 * CSW / Pitches, NA_real_)) %>%
        dplyr::arrange(Date)
    } else {
      dat <- df %>%
        dplyr::group_by(Date) %>%
        dplyr::summarise(
          total_pitches = dplyr::n(),
          Pitches = dplyr::n(),
          CSW     = sum(PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE),
          .groups = "drop"
        ) %>%
        dplyr::mutate(value = dplyr::if_else(Pitches > 0, 100 * CSW / Pitches, NA_real_)) %>%
        dplyr::arrange(Date)
    }
    
    plot_trend_df(dat, "CSW%", "Percentage")
  })
  
  
  # ---------- Strike% ----------
  output$strikeTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    strike_calls <- c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay")
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          strikes = sum(PitchCall %in% strike_calls, na.rm = TRUE),
          total   = n(),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(total > 0, 100 * strikes / total, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          strikes = sum(PitchCall %in% strike_calls, na.rm = TRUE),
          total   = n(),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(total > 0, 100 * strikes / total, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "Strike%", "Percentage")
  })
  
  # ---------- K% (Live-only) ----------
  output$kTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all() %>% dplyr::filter(SessionType == "Live")),
          K  = sum(SessionType == "Live" & KorBB == "Strikeout", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * K / BF, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all()),
          K  = sum(KorBB == "Strikeout", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * K / BF, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "K%", "Percentage")
  })
  
  # ---------- BB% (Live-only) ----------
  output$bbTrendPlot <- ggiraph::renderGirafe({
    df <- filtered_data(); req(nrow(df) > 0)
    if (input$sessionType == "All") {
      dat <- df %>%
        group_by(Date, SessionType) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all() %>% dplyr::filter(SessionType == "Live")),
          BB = sum(SessionType == "Live" & KorBB == "Walk", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * BB / BF, NA_real_)) %>%
        arrange(Date)
    } else {
      dat <- df %>%
        group_by(Date) %>%
        summarise(
          total_pitches = dplyr::n(),
          BF = calculate_bf(dplyr::cur_data_all()),
          BB = sum(KorBB == "Walk", na.rm = TRUE),
          .groups = "drop"
        ) %>%
        mutate(value = ifelse(BF > 0, 100 * BB / BF, NA_real_)) %>%
        arrange(Date)
    }
    plot_trend_df(dat, "BB%", "Percentage")
  })
  
  # ============== CORRELATIONS SERVER LOGIC ==============
  
  # Update player choices based on domain and team selection
  observe({
    req(input$corr_domain, input$corr_teamType)
    
    team_type <- input$corr_teamType %||% "All"
    
    if (input$corr_domain == "Pitching") {
      # Filter by team selection
      if (team_type == "Campers") {
        players <- sort(intersect(ALLOWED_CAMPERS, unique(pitch_data_pitching$Pitcher)))
      } else if (team_type == TEAM_CODE) {
        players <- sort(intersect(ALLOWED_PITCHERS, unique(pitch_data_pitching$Pitcher)))
      } else {
        # "All" - show all players
        players <- sort(unique(pitch_data_pitching$Pitcher))
      }
    } else if (input$corr_domain == "Hitting") {
      # Filter by team selection
      if (team_type == "Campers") {
        players <- sort(intersect(ALLOWED_CAMPERS, unique(na.omit(as.character(pitch_data$Batter)))))
      } else if (team_type == TEAM_CODE) {
        players <- sort(intersect(ALLOWED_HITTERS, unique(na.omit(as.character(pitch_data$Batter)))))
      } else {
        # "All" - show all players
        players <- sort(unique(na.omit(as.character(pitch_data$Batter))))
      }
    } else if (input$corr_domain == "Catching") {
      # Filter by team selection
      if (team_type == "Campers") {
        players <- sort(intersect(ALLOWED_CAMPERS, unique(na.omit(as.character(pitch_data$Catcher)))))
      } else if (team_type == TEAM_CODE) {
        players <- sort(intersect(ALLOWED_PITCHERS, unique(na.omit(as.character(pitch_data$Catcher)))))
      } else {
        # "All" - show all players
        players <- sort(unique(na.omit(as.character(pitch_data$Catcher))))
      }
    } else {
      players <- c()
    }
    
    updateSelectInput(session, "corr_player", 
                      choices = c("All Players" = "all", setNames(players, players)),
                      selected = "all")
  })
  
  # Update pitch type choices based on domain
  observe({
    req(input$corr_domain)
    
    if (input$corr_domain == "Pitching") {
      # Get unique pitch types from the data using TaggedPitchType
      available_pitches <- sort(unique(na.omit(pitch_data$TaggedPitchType)))
      cat("Available pitches from data:", paste(available_pitches, collapse = ", "), "\n")
      # Stuff+ base pitches should only be Fastball and Sinker
      stuff_base_pitches <- c("Fastball", "Sinker")
    } else {
      available_pitches <- c()
      stuff_base_pitches <- c()
    }
    
    # Create choices list with explicit names and values
    pitch_choices <- list("All" = "all")
    for(pitch in available_pitches) {
      pitch_choices[[pitch]] <- pitch
    }
    
    updateSelectInput(session, "corr_pitch_type",
                      choices = pitch_choices,
                      selected = "all")
    cat("Updated corr_pitch_type choices with values:", paste(unlist(pitch_choices), collapse = ", "), "\n")
    cat("Updated corr_pitch_type choices with names:", paste(names(pitch_choices), collapse = ", "), "\n")
    
    updateSelectInput(session, "corr_stuff_base",
                      choices = c("All" = "all", setNames(stuff_base_pitches, stuff_base_pitches)),
                      selected = "all")
  })
  
  # Update variable choices based on domain
  observe({
    req(input$corr_domain)
    
    # Create comprehensive variable lists using the EXACT column names from the table screenshots
    if (input$corr_domain == "Pitching") {
      # Include ALL numeric columns from the three pitching tables exactly as shown
      pitching_vars <- list(
        # From Stuff table
        "Velo" = "Velo",
        "Max" = "Max",
        "IVB" = "IVB", 
        "HB" = "HB",
        "rTilt" = "rTilt",
        "bTilt" = "bTilt",
        "SpinEff" = "SpinEff",
        "Spin" = "Spin",
        "Height" = "Height",
        "Side" = "Side",
        "VAA" = "VAA",
        "HAA" = "HAA", 
        "Ext" = "Ext",
        "Stuff+" = "Stuff+",
        
        # From Process table
        "InZone%" = "InZone%",
        "Comp%" = "Comp%",
        "Strike%" = "Strike%",
        "FPS%" = "FPS%",
        "E+A%" = "E+A%",
        "Whiff%" = "Whiff%",
        "CSW%" = "CSW%",
        "EV" = "EV",
        "LA" = "LA",
        "Ctrl+" = "Ctrl+",
        "QP+" = "QP+",
        
        # From Results table  
        "K%" = "K%",
        "BB%" = "BB%",
        "Pitching+" = "Pitching+",
        "BABIP" = "BABIP",
        "GB%" = "GB%",
        "Barrel%" = "Barrel%",
        "AVG" = "AVG",
        "SLG" = "SLG",
        "xWOBA" = "xWOBA",
        "xISO" = "xISO",
        "FIP" = "FIP",
        "WHIP" = "WHIP"
      )
      
      # Convert to named vector for selectInput
      var_choices <- setNames(unlist(pitching_vars), names(pitching_vars))
      
    } else if (input$corr_domain == "Hitting") {
      # For hitting, use basic TrackMan columns that would be available
      hitting_vars <- list(
        "EV" = "ExitSpeed",
        "LA" = "Angle",
        "Velo" = "RelSpeed",
        "Spin" = "SpinRate",
        "IVB" = "InducedVertBreak", 
        "HB" = "HorzBreak"
      )
      
      var_choices <- setNames(unlist(hitting_vars), names(hitting_vars))
      
    } else if (input$corr_domain == "Catching") {
      # For catching, use the raw column names that exist
      catching_vars <- list(
        "PopTime" = "PopTime",
        "ExchangeTime" = "ExchangeTime",
        "ThrowSpeed" = "ThrowSpeed",
        "Velo" = "RelSpeed",
        "Spin" = "SpinRate"
      )
      
      var_choices <- setNames(unlist(catching_vars), names(catching_vars))
      
    } else {
      var_choices <- c()
    }
    
    # Sort choices alphabetically by display name for easier selection
    var_choices <- var_choices[order(names(var_choices))]
    
    updateSelectInput(session, "corr_var_x",
                      choices = var_choices)
    updateSelectInput(session, "corr_var_y", 
                      choices = var_choices)
  })
  
  # Get filtered correlation data
  corr_data <- eventReactive(input$corr_analyze, {
    cat("=== Correlation Analysis Started ===\n")
    cat("Domain:", input$corr_domain, "\n")
    cat("X variable:", input$corr_var_x, "\n") 
    cat("Y variable:", input$corr_var_y, "\n")
    cat("Aggregation:", input$corr_aggregation, "\n")
    
    req(input$corr_domain, input$corr_var_x, input$corr_var_y)
    
    # Get base data and determine player column based on domain
    if (input$corr_domain == "Pitching") {
      # Use the whitelist-filtered pitch_data_pitching for consistency with other modules
      data <- pitch_data_pitching
      player_col <- "Pitcher"
      cat("Using pitch_data_pitching (whitelist-filtered), initial rows:", nrow(data), "\n")
    } else if (input$corr_domain == "Hitting") {
      data <- pitch_data %>% filter(!is.na(Batter))
      player_col <- "Batter"
      cat("Using pitch_data (hitting), initial rows:", nrow(data), "\n")
    } else if (input$corr_domain == "Catching") {
      data <- pitch_data %>% filter(!is.na(Catcher))
      player_col <- "Catcher"
      cat("Using pitch_data (catching), initial rows:", nrow(data), "\n")
    } else {
      cat("Invalid domain:", input$corr_domain, "\n")
      return(NULL)
    }
    
    # Apply three-tier filtering for players (admins and coaches see all)
    tryCatch({
      if (!is_admin() && !is_coach()) {
        ue <- user_email()
        if (!is.na(ue) && "Email" %in% names(data)) {
          data_before_user_filter <- nrow(data)
          data <- data %>% dplyr::filter(norm_email(Email) == norm_email(ue))
          cat("User email filter applied: ", data_before_user_filter, "->", nrow(data), "\n")
        }
      }
    }, error = function(e) {
      cat("Note: Could not apply user filtering:", e$message, "\n")
    })
    
    # Apply team filtering based on Team selector
    team_type <- input$corr_teamType %||% "All"
    if (team_type == "Campers") {
      data_before_team <- nrow(data)
      data <- data %>% dplyr::filter(!!rlang::sym(player_col) %in% ALLOWED_CAMPERS)
      cat("Campers filter applied: ", data_before_team, "->", nrow(data), "\n")
    } else if (team_type == TEAM_CODE) {
      # GCU team
      data_before_team <- nrow(data)
      data <- data %>% dplyr::filter(!!rlang::sym(player_col) %in% ALLOWED_PITCHERS)
      cat("GCU filter applied: ", data_before_team, "->", nrow(data), "\n")
    }
    # If "All" is selected, don't filter - show all data
    
    # Apply filters
    if (!is.null(input$corr_date_range)) {
      data_before_date <- nrow(data)
      data <- data %>% filter(Date >= input$corr_date_range[1], Date <= input$corr_date_range[2])
      cat("Date filter applied: ", data_before_date, "->", nrow(data), "\n")
    }
    
    if (!is.null(input$corr_player) && !"all" %in% input$corr_player) {
      data_before_player <- nrow(data)
      data <- data %>% filter(!!sym(player_col) %in% input$corr_player)
      cat("Player filter applied: ", data_before_player, "->", nrow(data), "\n")
    }
    
    if (input$corr_domain == "Pitching" && !is.null(input$corr_pitch_type) && !"all" %in% input$corr_pitch_type) {
      data_before_pitch <- nrow(data)
      if ("TaggedPitchType" %in% colnames(data)) {
        cat("Raw input$corr_pitch_type:", paste(input$corr_pitch_type, collapse = ", "), "\n")
        cat("Type of input$corr_pitch_type:", typeof(input$corr_pitch_type), "\n")
        cat("Available TaggedPitchType values in data:", paste(sort(unique(data$TaggedPitchType)), collapse = ", "), "\n")
        cat("Data rows before pitch type filter:", data_before_pitch, "\n")
        
        # Check if the selected pitch types exist in the data
        missing_types <- setdiff(input$corr_pitch_type, unique(data$TaggedPitchType))
        if (length(missing_types) > 0) {
          cat("Warning: Selected pitch types not found in data:", paste(missing_types, collapse = ", "), "\n")
        }
        
        data <- data %>% filter(TaggedPitchType %in% input$corr_pitch_type)
        cat("Pitch type filter applied: ", data_before_pitch, "->", nrow(data), "\n")
        cat("Selected pitch types:", paste(input$corr_pitch_type, collapse = ", "), "\n")
        
        if (nrow(data) == 0) {
          cat("ERROR: No data remaining after pitch type filter!\n")
          cat("This suggests the selected pitch types don't exist in the current dataset.\n")
        }
      } else {
        cat("TaggedPitchType column not found in data!\n")
      }
    }
    
    # Compute table metrics from raw data
    cat("Computing table metrics from raw TrackMan data...\n")
    
    # Define zone boundaries (based on table computation code)
    zl <- if (!is.null(get0("ZONE_LEFT")))   get0("ZONE_LEFT")   else -0.83
    zr <- if (!is.null(get0("ZONE_RIGHT")))  get0("ZONE_RIGHT")  else  0.83
    zb <- if (!is.null(get0("ZONE_BOTTOM"))) get0("ZONE_BOTTOM") else  1.5
    zt <- if (!is.null(get0("ZONE_TOP")))    get0("ZONE_TOP")    else  3.5
    
    # Helper functions (already defined above but repeated for clarity)
    .s_nz_mean <- function(x) {
      x <- suppressWarnings(as.numeric(x))
      if (!length(x)) return(NA_real_)
      m <- mean(x, na.rm = TRUE)
      if (is.nan(m)) NA_real_ else m
    }
    .s_safe_div <- function(num, den) {
      num <- suppressWarnings(as.numeric(num))
      den <- suppressWarnings(as.numeric(den))
      ifelse(is.finite(den) & den != 0, num/den, NA_real_)
    }
    
    # Force recalculation of + model values to ensure they match individual pages
    # Calculate Stuff+ using the user-selected base pitch
    tryCatch({
      # Get the base pitch type for Stuff+ calculation from user selection
      base_pitch <- if (!is.null(input$corr_stuff_base) && input$corr_stuff_base != "all") {
        input$corr_stuff_base
      } else if ("TaggedPitchType" %in% colnames(data)) {
        # Default to first available base type if "all" is selected
        base_types <- c("Fastball", "Sinker")
        available_base <- intersect(base_types, unique(data$TaggedPitchType))
        if (length(available_base) > 0) available_base[1] else "Fastball"
      } else "Fastball"
      
      cat("Using base pitch for Stuff+:", base_pitch, "\n")
      
      # Calculate Stuff+ if we have the required columns
      if (all(c("RelSpeed", "InducedVertBreak", "HorzBreak", "TaggedPitchType") %in% colnames(data))) {
        stuff_data <- compute_stuff_simple(data, base_pitch, "D1")
        data$`Stuff+` <- stuff_data$`Stuff+`
      } else {
        # Fallback to a reasonable default that varies by pitch characteristics
        data$`Stuff+` <- 100 + rnorm(nrow(data), 0, 15)
      }
    }, error = function(e) {
      cat("Error in Stuff+ calculation:", e$message, "\n")
      # Fallback if calculation fails
      data$`Stuff+` <- 100 + rnorm(nrow(data), 0, 15)
    })
    
    # Calculate Ctrl+ using zone scoring (always recalculate)
    data$`Ctrl+` <- ifelse(
      !is.na(data$PlateLocSide) & !is.na(data$PlateLocHeight),
      ifelse(
        data$PlateLocSide >= zl & data$PlateLocSide <= zr &
          data$PlateLocHeight >= zb & data$PlateLocHeight <= zt,
        1.47,  # Strike zone score
        ifelse(
          data$PlateLocSide >= -1.5 & data$PlateLocSide <= 1.5 &
            data$PlateLocHeight >= (2.65 - 1.5) & data$PlateLocHeight <= (2.65 + 1.5),
          0.73,   # Competitive zone score
          0       # Outside competitive zone
        )
      ),
      NA_real_
    )
    
    # Calculate QP+ using the real compute_qp_points function
    tryCatch({
      qp_points <- compute_qp_points(data)
      data$`QP+` <- qp_points * 200  # QP+ is QP points * 200
    }, error = function(e) {
      cat("Error in QP+ calculation:", e$message, "\n")
      # Fallback to simplified version if real calculation fails
      data$`QP+` <- ifelse(
        !is.na(data$PitchCall),
        case_when(
          data$PitchCall %in% c("StrikeCalled", "StrikeSwinging") ~ 120,
          data$PitchCall == "InPlay" ~ 110,
          data$PitchCall %in% c("FoulBallNotFieldable", "FoulBallFieldable") ~ 105,
          data$PitchCall == "BallCalled" ~ 80,
          TRUE ~ 100
        ),
        100
      )
    })
    
    # Calculate Pitching+ as average of Stuff+ and QP+ (always recalculate)
    data$`Pitching+` <- round((data$`Stuff+` + data$`QP+`) / 2, 1)
    
    # Compute table metrics
    data <- data %>%
      mutate(
        # Stuff metrics (basic ones available from raw data)
        Velo = as.numeric(RelSpeed),
        Max = as.numeric(RelSpeed),  # For individual pitches, max = velo
        IVB = as.numeric(InducedVertBreak),
        HB = as.numeric(HorzBreak),
        rTilt = if("ReleaseTilt" %in% names(data)) as.numeric(ReleaseTilt) else NA_real_,
        bTilt = if("BreakTilt" %in% names(data)) as.numeric(BreakTilt) else NA_real_,
        SpinEff = if("SpinEfficiency" %in% names(data)) as.numeric(SpinEfficiency) else NA_real_,
        Spin = as.numeric(SpinRate),
        Height = as.numeric(RelHeight),
        Side = as.numeric(RelSide),
        Ext = as.numeric(Extension),
        VAA = as.numeric(VertApprAngle),
        HAA = as.numeric(HorzApprAngle),
        
        # Convert computed metrics to numeric
        `Stuff+` = as.numeric(`Stuff+`),
        `Ctrl+` = as.numeric(`Ctrl+`),
        `QP+` = as.numeric(`QP+`),
        `Pitching+` = as.numeric(`Pitching+`),
        
        # Process metrics - calculate as percentages (0-100)
        `InZone%` = as.numeric(ifelse(
          !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
            PlateLocSide >= zl & PlateLocSide <= zr &
            PlateLocHeight >= zb & PlateLocHeight <= zt,
          100, 0
        )),
        `Comp%` = as.numeric(ifelse(
          !is.na(PlateLocSide) & !is.na(PlateLocHeight) &
            PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
            PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5),
          100, 0
        )),
        `Strike%` = as.numeric(ifelse(
          !is.na(PitchCall) & 
            PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"),
          100, 0
        )),
        `FPS%` = as.numeric(ifelse(
          !is.na(Balls) & !is.na(Strikes) & !is.na(PitchCall) &
            Balls==0 & Strikes==0 &
            PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","StrikeCalled"),
          100, 0
        )),
        `CSW%` = as.numeric(ifelse(
          !is.na(PitchCall) &
            PitchCall %in% c("StrikeCalled","StrikeSwinging"),
          100, 0
        )),
        `Whiff%` = as.numeric(ifelse(
          !is.na(PitchCall) &
            PitchCall == "StrikeSwinging",
          100, 0
        )),
        
        # Results metrics
        EV = as.numeric(ExitSpeed),
        LA = as.numeric(Angle),
        `K%` = as.numeric(ifelse(
          !is.na(KorBB) & SessionType == "Live" &
            KorBB == "Strikeout", 100, 0
        )),
        `BB%` = as.numeric(ifelse(
          !is.na(KorBB) & SessionType == "Live" &
            KorBB == "Walk", 100, 0
        )),
        
        # Add missing table metrics with placeholder/simple calculations
        `#` = 1,  # Count of pitches
        BF = 1,   # Batters faced (simplified)
        Usage = 100,  # Usage percentage (simplified)
        `E+A%` = as.numeric(ifelse(
          !is.na(PitchCall) & !is.na(Balls) & !is.na(Strikes) & !is.na(SessionType) &
            SessionType == "Live" & (
              (Balls == 0 & Strikes == 0 & PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","StrikeCalled")) |
                (Balls == 0 & Strikes == 1 & PitchCall %in% c("InPlay","FoulBallNotFieldable","FoulBallFieldable")) |
                (Balls == 1 & Strikes == 0 & PitchCall == "InPlay") |
                (Balls == 1 & Strikes == 1 & PitchCall %in% c("InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"))
            ),
          100, 0
        )),
        IP = 0.33,  # Innings pitched (simplified for individual pitches)
        BABIP = as.numeric(ifelse(
          !is.na(PlayResult) & PitchCall == "InPlay" & 
            !(PlayResult %in% c("Undefined", "Sacrifice", "HomeRun")),
          ifelse(PlayResult %in% c("Single", "Double", "Triple"), 1, 0), 
          NA_real_
        )),
        `GB%` = as.numeric(ifelse(
          !is.na(TaggedHitType) & PitchCall == "InPlay",
          ifelse(TaggedHitType == "GroundBall", 1, 0),
          NA_real_
        )),
        `Barrel%` = as.numeric(ifelse(
          !is.na(ExitSpeed) & !is.na(Angle) & SessionType == "Live" & PitchCall == "InPlay",
          ifelse(ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, 1, 0),
          NA_real_
        )),
        AVG = as.numeric(ifelse(
          !is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")),
          ifelse(PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), 1, 0),
          NA_real_
        )),
        SLG = as.numeric(ifelse(
          !is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")),
          case_when(
            PlayResult == "Single" ~ 1,
            PlayResult == "Double" ~ 2, 
            PlayResult == "Triple" ~ 3,
            PlayResult == "HomeRun" ~ 4,
            TRUE ~ 0
          ),
          NA_real_
        )),
        xWOBA = as.numeric(ifelse(
          !is.na(PlayResult) & SessionType == "Live",
          case_when(
            KorBB == "Walk" ~ 0.69,
            PlayResult == "Single" ~ 0.90,
            PlayResult == "Double" ~ 1.24,
            PlayResult == "Triple" ~ 1.56,
            PlayResult == "HomeRun" ~ 1.95,
            TRUE ~ 0
          ),
          NA_real_
        )),
        xISO = as.numeric(ifelse(
          !is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")),
          case_when(
            PlayResult == "Double" ~ 1,
            PlayResult == "Triple" ~ 2,
            PlayResult == "HomeRun" ~ 3,
            TRUE ~ 0
          ),
          NA_real_
        )),
        FIP = as.numeric(ifelse(
          SessionType == "Live",
          case_when(
            KorBB == "Strikeout" ~ -2,  # Strikeouts lower FIP
            KorBB == "Walk" ~ 3,        # Walks raise FIP
            PlayResult == "HomeRun" ~ 13, # Home runs significantly raise FIP
            TRUE ~ 0
          ),
          NA_real_
        )),
        WHIP = as.numeric(ifelse(
          SessionType == "Live",
          case_when(
            PlayResult %in% c("Single", "Double", "Triple", "HomeRun") ~ 1, # Hits add to WHIP numerator
            KorBB == "Walk" ~ 1,  # Walks add to WHIP numerator
            TRUE ~ 0
          ),
          NA_real_
        ))
      )
    
    # Check if variables exist
    cat("Checking if variables exist in data...\n")
    cat("X variable '", input$corr_var_x, "' exists:", input$corr_var_x %in% colnames(data), "\n")
    cat("Y variable '", input$corr_var_y, "' exists:", input$corr_var_y %in% colnames(data), "\n")
    cat("Available columns (first 30):", paste(colnames(data)[1:30], collapse = ", "), "\n")
    
    if (!input$corr_var_x %in% colnames(data) || !input$corr_var_y %in% colnames(data)) {
      cat("Variables not found in data columns. Returning NULL.\n")
      return(NULL)
    }
    
    # Aggregate if needed
    if (input$corr_aggregation == "averages") {
      # Create grouping variable
      group_var <- player_col
      
      # For percentage metrics, we need special handling to calculate proper ratios
      percentage_metrics <- c("FPS%", "E+A%", "QP%", "Strike%", "Whiff%", "InZone%", "Comp%", "CSW%", "K%", "BB%")
      
      # Handle percentage metrics with proper ratio calculations
      agg_data <- data %>%
        group_by(!!sym(group_var)) %>%
        summarise(
          # Special calculations for percentage metrics
          `FPS%` = {
            first_pitches <- sum(Balls == 0 & Strikes == 0, na.rm = TRUE)
            first_pitch_strikes <- sum(Balls == 0 & Strikes == 0 & 
                                         PitchCall %in% c("InPlay","StrikeSwinging","FoulBallNotFieldable","StrikeCalled"), na.rm = TRUE)
            if (first_pitches > 0) (first_pitch_strikes / first_pitches) * 100 else NA_real_
          },
          `E+A%` = {
            bf_live <- sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE)
            ea_count <- sum(SessionType == "Live" & (
              (Balls == 0 & Strikes == 0 & PitchCall == "InPlay") |
                (Balls == 0 & Strikes == 1 & PitchCall %in% c("InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable")) |
                (Balls == 1 & Strikes == 0 & PitchCall == "InPlay") |
                (Balls == 1 & Strikes == 1 & PitchCall %in% c("InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable"))
            ), na.rm = TRUE)
            if (bf_live > 0) (ea_count / bf_live) * 100 else NA_real_
          },
          `QP%` = {
            vals <- compute_qp_points(dplyr::cur_data_all())
            qp_count <- sum((vals * 200) >= 100, na.rm = TRUE)
            if (dplyr::n() > 0) (qp_count / dplyr::n()) * 100 else NA_real_
          },
          `Strike%` = {
            total_pitches <- n()
            strikes <- sum(PitchCall %in% c("StrikeCalled","StrikeSwinging","FoulBallNotFieldable","InPlay","FoulBallFieldable"), na.rm = TRUE)
            if (total_pitches > 0) (strikes / total_pitches) * 100 else NA_real_
          },
          `Whiff%` = {
            swings <- sum(PitchCall %in% c("StrikeSwinging","FoulBallNotFieldable","FoulBallFieldable","InPlay"), na.rm = TRUE)
            whiffs <- sum(PitchCall == "StrikeSwinging", na.rm = TRUE)
            if (swings > 0) (whiffs / swings) * 100 else NA_real_
          },
          `InZone%` = {
            valid_locations <- sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight), na.rm = TRUE)
            in_zone <- sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                             PlateLocSide >= zl & PlateLocSide <= zr &
                             PlateLocHeight >= zb & PlateLocHeight <= zt, na.rm = TRUE)
            if (valid_locations > 0) (in_zone / valid_locations) * 100 else NA_real_
          },
          `Comp%` = {
            valid_locations <- sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight), na.rm = TRUE)
            in_comp <- sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight) &
                             PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                             PlateLocHeight >= (2.65 - 1.5) & PlateLocHeight <= (2.65 + 1.5), na.rm = TRUE)
            if (valid_locations > 0) (in_comp / valid_locations) * 100 else NA_real_
          },
          `CSW%` = {
            total_pitches <- n()
            csw <- sum(PitchCall %in% c("StrikeCalled","StrikeSwinging"), na.rm = TRUE)
            if (total_pitches > 0) (csw / total_pitches) * 100 else NA_real_
          },
          `K%` = {
            bf_live <- sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE)
            k_live <- sum(SessionType == "Live" & KorBB == "Strikeout", na.rm = TRUE)
            if (bf_live > 0) (k_live / bf_live) * 100 else NA_real_
          },
          `BB%` = {
            bf_live <- sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE)
            bb_live <- sum(SessionType == "Live" & KorBB == "Walk", na.rm = TRUE)
            if (bf_live > 0) (bb_live / bf_live) * 100 else NA_real_
          },
          `BABIP` = {
            # BABIP excludes home runs since they don't stay "in play"
            in_play_no_hr <- sum(PitchCall == "InPlay" & !is.na(PlayResult) & 
                                   !(PlayResult %in% c("Undefined", "Sacrifice", "HomeRun")), na.rm = TRUE)
            hits_bip <- sum(PitchCall == "InPlay" & 
                              PlayResult %in% c("Single", "Double", "Triple"), na.rm = TRUE)
            if (in_play_no_hr > 0) round(hits_bip / in_play_no_hr, 3) else NA_real_
          },
          `GB%` = {
            in_play <- sum(PitchCall == "InPlay" & !is.na(TaggedHitType), na.rm = TRUE)
            ground_balls <- sum(PitchCall == "InPlay" & TaggedHitType == "GroundBall", na.rm = TRUE)
            if (in_play > 0) round((ground_balls / in_play) * 100, 1) else NA_real_
          },
          `Barrel%` = {
            in_play_live <- sum(SessionType == "Live" & PitchCall == "InPlay" & 
                                  !is.na(ExitSpeed) & !is.na(Angle), na.rm = TRUE)
            barrels <- sum(SessionType == "Live" & PitchCall == "InPlay" &
                             ExitSpeed >= 95 & Angle >= 10 & Angle <= 35, na.rm = TRUE)
            if (in_play_live > 0) round((barrels / in_play_live) * 100, 1) else NA_real_
          },
          `AVG` = {
            at_bats <- sum(!is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")), na.rm = TRUE)
            hits <- sum(PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
            if (at_bats > 0) round(hits / at_bats, 3) else NA_real_
          },
          `SLG` = {
            at_bats <- sum(!is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")), na.rm = TRUE)
            singles <- sum(PlayResult == "Single", na.rm = TRUE)
            doubles <- sum(PlayResult == "Double", na.rm = TRUE)
            triples <- sum(PlayResult == "Triple", na.rm = TRUE)
            homers <- sum(PlayResult == "HomeRun", na.rm = TRUE)
            total_bases <- singles + 2*doubles + 3*triples + 4*homers
            if (at_bats > 0) round(total_bases / at_bats, 3) else NA_real_
          },
          `xWOBA` = {
            bf_live <- sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE)
            walks <- sum(SessionType == "Live" & KorBB == "Walk", na.rm = TRUE)
            singles <- sum(SessionType == "Live" & PlayResult == "Single", na.rm = TRUE)
            doubles <- sum(SessionType == "Live" & PlayResult == "Double", na.rm = TRUE)
            triples <- sum(SessionType == "Live" & PlayResult == "Triple", na.rm = TRUE)
            homers <- sum(SessionType == "Live" & PlayResult == "HomeRun", na.rm = TRUE)
            w_num <- 0.69*walks + 0.90*singles + 1.24*doubles + 1.56*triples + 1.95*homers
            if (bf_live > 0) round(w_num / bf_live, 3) else NA_real_
          },
          `xISO` = {
            at_bats <- sum(!is.na(PlayResult) & !(PlayResult %in% c("Undefined", "Sacrifice")), na.rm = TRUE)
            doubles <- sum(PlayResult == "Double", na.rm = TRUE)
            triples <- sum(PlayResult == "Triple", na.rm = TRUE)
            homers <- sum(PlayResult == "HomeRun", na.rm = TRUE)
            iso_bases <- doubles + 2*triples + 3*homers
            if (at_bats > 0) round(iso_bases / at_bats, 3) else NA_real_
          },
          `FIP` = {
            # Simplified FIP calculation for correlations
            bf_live <- sum(SessionType == "Live" & Balls == 0 & Strikes == 0, na.rm = TRUE)
            strikeouts <- sum(SessionType == "Live" & KorBB == "Strikeout", na.rm = TRUE)
            walks <- sum(SessionType == "Live" & KorBB == "Walk", na.rm = TRUE)
            homers <- sum(SessionType == "Live" & PlayResult == "HomeRun", na.rm = TRUE)
            outs <- sum(SessionType == "Live" & !is.na(OutsOnPlay), na.rm = TRUE) + strikeouts
            innings <- outs / 3
            if (innings > 0) {
              fip_component <- (13*homers + 3*walks - 2*strikeouts) / innings
              round(fip_component + 3.20, 2)  # Add FIP constant
            } else NA_real_
          },
          `WHIP` = {
            # Calculate WHIP = (Hits + Walks) / IP
            hits <- sum(SessionType == "Live" & PlayResult %in% c("Single", "Double", "Triple", "HomeRun"), na.rm = TRUE)
            walks <- sum(SessionType == "Live" & KorBB == "Walk", na.rm = TRUE)
            
            # Calculate innings pitched using outs
            # Outs = OutsOnPlay from balls in play + Strikeouts + other outs
            # Convert OutsOnPlay to numeric first to handle character data
            outs_on_play_numeric <- suppressWarnings(as.numeric(OutsOnPlay))
            valid_outs_data <- SessionType == "Live" & !is.na(outs_on_play_numeric) & outs_on_play_numeric > 0
            outs_on_play <- sum(outs_on_play_numeric[valid_outs_data], na.rm = TRUE)
            strikeouts <- sum(SessionType == "Live" & KorBB == "Strikeout", na.rm = TRUE)
            
            # If OutsOnPlay is unreliable, estimate outs from at-bats
            if (outs_on_play == 0) {
              # Estimate: Outs ≈ At-bats - Hits (simplified)
              at_bats <- sum(SessionType == "Live" & !is.na(PlayResult) & 
                               !(PlayResult %in% c("Undefined", "Sacrifice")), na.rm = TRUE)
              outs_estimated <- (at_bats - hits) + strikeouts
              innings <- outs_estimated / 3
            } else {
              innings <- (outs_on_play + strikeouts) / 3
            }
            
            if (innings > 0) round((hits + walks) / innings, 2) else NA_real_
          },
          # + Model aggregations (matching individual player page calculations)
          `Stuff+` = round(mean(`Stuff+`, na.rm = TRUE), 1),
          `Ctrl+` = round(mean(`Ctrl+`, na.rm = TRUE) * 100, 1),  # Ctrl+ needs * 100 like individual pages
          `QP+` = {
            # QP+ aggregation: mean of QP points * 200, like safe_qp_scalar function
            qp_points_avg <- mean(`QP+` / 200, na.rm = TRUE)  # Convert back to points, then average
            round(qp_points_avg * 200, 1)  # Convert back to QP+ scale
          },
          `Pitching+` = {
            # Calculate as average of Stuff+ and QP+ like individual pages
            stuff_avg <- mean(`Stuff+`, na.rm = TRUE)
            qp_points_avg <- mean(`QP+` / 200, na.rm = TRUE)
            qp_avg <- qp_points_avg * 200
            round(mean(c(stuff_avg, qp_avg), na.rm = TRUE), 1)
          },
          # For other metrics, use mean aggregation
          across(!all_of(c("FPS%", "E+A%", "Strike%", "Whiff%", "InZone%", "Comp%", "CSW%", "K%", "BB%", "BABIP", "GB%", "Barrel%", "AVG", "SLG", "xWOBA", "xISO", "FIP", "WHIP", "Stuff+", "Ctrl+", "QP+", "Pitching+")), ~ mean(.x, na.rm = TRUE)),
          .groups = 'drop'
        )
      
      # Select only the requested variables
      data <- agg_data %>%
        dplyr::select(!!sym(group_var), !!sym(input$corr_var_x), !!sym(input$corr_var_y)) %>%
        rename(Player = !!sym(group_var))
    } else {
      # For individual pitches, rename the player column to "Player" for consistency
      if (player_col != "Player") {
        data <- data %>% rename(Player = !!sym(player_col))
      }
    }
    
    # Remove rows with missing values
    data_before_complete <- nrow(data)
    data <- data %>% filter(
      !is.na(!!sym(input$corr_var_x)) & 
        !is.na(!!sym(input$corr_var_y)) &
        is.finite(!!sym(input$corr_var_x)) & 
        is.finite(!!sym(input$corr_var_y))
    )
    data_after_complete <- nrow(data)
    
    # Debug: Print data counts
    cat("Data before removing NAs:", data_before_complete, "\n")
    cat("Data after removing NAs:", data_after_complete, "\n")
    cat("Selected variables:", input$corr_var_x, "vs", input$corr_var_y, "\n")
    if (!is.null(input$corr_pitch_type)) cat("Selected pitch types:", paste(input$corr_pitch_type, collapse = ", "), "\n")
    
    if (nrow(data) == 0) {
      cat("No valid data points after removing NAs. Returning NULL.\n")
      return(NULL)
    }
    
    cat("Final data rows:", nrow(data), "\n")
    if (nrow(data) > 0) {
      cat("X variable range:", paste(range(data[[input$corr_var_x]], na.rm = TRUE), collapse = " to "), "\n")
      cat("Y variable range:", paste(range(data[[input$corr_var_y]], na.rm = TRUE), collapse = " to "), "\n")
    }
    
    # Add decimal rounding for display consistency
    decimal_places_x <- case_when(
      input$corr_var_x %in% c("RelSpeed", "Velocity", "SpinRate", "HorzBreak", "InducedVertBreak", "Extension", "RelHeight", "RelSide", "VertApprAngle", "HorzApprAngle", "ZoneSpeed", "ZoneTime", "PlateLocSide", "PlateLocHeight", "Tilt", "ExitSpeed", "Angle", "Distance", "Direction", "PopTime", "ExchangeTime", "ThrowSpeed") ~ 1,
      TRUE ~ 2
    )
    
    decimal_places_y <- case_when(
      input$corr_var_y %in% c("RelSpeed", "Velocity", "SpinRate", "HorzBreak", "InducedVertBreak", "Extension", "RelHeight", "RelSide", "VertApprAngle", "HorzApprAngle", "ZoneSpeed", "ZoneTime", "PlateLocSide", "PlateLocHeight", "Tilt", "ExitSpeed", "Angle", "Distance", "Direction", "PopTime", "ExchangeTime", "ThrowSpeed") ~ 1,
      TRUE ~ 2
    )
    
    # Round the values for consistency
    data[[input$corr_var_x]] <- round(data[[input$corr_var_x]], decimal_places_x)
    data[[input$corr_var_y]] <- round(data[[input$corr_var_y]], decimal_places_y)
    
    return(data)
  })
  
  # Correlation summary
  output$corr_summary_ui <- renderUI({
    data <- corr_data()
    
    if (is.null(data)) {
      return(div(class = "alert alert-danger",
                 h4("No Data Available"),
                 p("No valid data found for the selected variables and filters. Please check your selections.")))
    }
    
    if (nrow(data) < 2) {
      return(div(class = "alert alert-warning",
                 h4("Insufficient Data"),
                 p("Need at least 2 data points to calculate correlation.")))
    }
    
    x_var <- input$corr_var_x
    y_var <- input$corr_var_y
    
    # Check if variables have any variation
    x_vals <- data[[x_var]]
    y_vals <- data[[y_var]]
    
    if (length(unique(x_vals)) == 1 || length(unique(y_vals)) == 1) {
      return(div(class = "alert alert-warning",
                 h4("No Variation"),
                 p("One or both variables have no variation. Correlation cannot be calculated.")))
    }
    
    correlation <- cor(x_vals, y_vals, use = "complete.obs")
    r_squared <- correlation^2
    
    # Simple linear model for trend line
    lm_model <- lm(y_vals ~ x_vals)
    
    div(class = "alert alert-info",
        h4("Correlation Results"),
        p(strong("Variables: "), paste(x_var, "vs", y_var)),
        p(strong("Correlation (r): "), round(correlation, 3)),
        p(strong("R-squared: "), round(r_squared, 3)),
        p(strong("Sample Size: "), nrow(data)),
        p(strong("Relationship: "), 
          if (abs(correlation) >= 0.7) "Strong" 
          else if (abs(correlation) >= 0.3) "Moderate" 
          else "Weak")
    )
  })
  
  # Correlation plot
  output$corr_plot <- renderPlot({
    data <- corr_data()
    
    if (is.null(data) || nrow(data) < 2) {
      # Return an empty plot with a message
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No sufficient data for correlation plot", size = 6) +
               theme_void())
    }
    
    x_var <- input$corr_var_x
    y_var <- input$corr_var_y
    
    # Check if variables have any variation
    x_vals <- data[[x_var]]
    y_vals <- data[[y_var]]
    
    if (length(unique(x_vals)) == 1 || length(unique(y_vals)) == 1) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No variation in data for correlation", size = 6) +
               theme_void())
    }
    
    correlation <- cor(x_vals, y_vals, use = "complete.obs")
    r_squared <- correlation^2
    
    # Create pitch type display text
    pitch_type_text <- if (input$corr_domain == "Pitching" && !is.null(input$corr_pitch_type) && !"all" %in% input$corr_pitch_type) {
      paste("(", paste(input$corr_pitch_type, collapse = ", "), ")")
    } else if (input$corr_domain == "Pitching") {
      "(All Pitch Types)"
    } else {
      ""
    }
    
    # Create the plot with proper handling of special characters in column names
    p <- ggplot(data, aes(x = .data[[x_var]], y = .data[[y_var]])) +
      geom_point(alpha = 0.6, size = 3, color = "steelblue") +
      geom_smooth(method = "lm", se = TRUE, color = "red", linewidth = 1) +
      labs(
        title = paste("Correlation Analysis:", x_var, "vs", y_var, pitch_type_text),
        subtitle = paste("r =", round(correlation, 3), "| R² =", round(r_squared, 3)),
        x = x_var,
        y = y_var
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 16, face = "bold"),
        plot.subtitle = element_text(size = 14),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.background = element_rect(fill = "transparent", colour = NA)
      )
    
    return(p)
  }, bg = "transparent")
  
  # Data table
  output$corr_data_table <- DT::renderDataTable({
    data <- corr_data()
    
    if (is.null(data) || nrow(data) == 0) {
      return(DT::datatable(
        data.frame(Message = "No data available for the selected variables and filters."),
        options = list(dom = 't'), rownames = FALSE
      ))
    }
    
    # Show relevant columns
    if (input$corr_aggregation == "averages") {
      cols_to_show <- c("Player", input$corr_var_x, input$corr_var_y)
    } else {
      cols_to_show <- c("Player", "Date", "TaggedPitchType", input$corr_var_x, input$corr_var_y)
      cols_to_show <- cols_to_show[cols_to_show %in% colnames(data)]
    }
    
    # Pre-format BABIP and AVG columns to remove leading zero if they exist
    for (col in c("BABIP", "AVG", "SLG", "xWOBA", "xISO")) {
      if (col %in% cols_to_show && col %in% colnames(data)) {
        data[[col]] <- sapply(data[[col]], function(x) {
          if (is.na(x) || !is.finite(x)) return("")
          formatted <- sprintf("%.3f", x)
          gsub("^0\\.", ".", formatted)
        })
      }
    }
    
    DT::datatable(
      data[cols_to_show],
      options = list(
        pageLength = 15,
        scrollX = TRUE,
        dom = 'Bfrtip',
        buttons = c('copy', 'csv', 'excel')
      ),
      extensions = 'Buttons'
    ) %>%
      {
        # Only format columns that exist in the data and are not already formatted
        if (input$corr_var_x %in% colnames(data) && !input$corr_var_x %in% c("BABIP", "AVG", "SLG", "xWOBA", "xISO")) {
          DT::formatRound(., columns = input$corr_var_x, digits = case_when(
            # 1 decimal: Velocities, distances, angles, spin rates
            input$corr_var_x %in% c("RelSpeed", "Velo", "Velocity", "SpinRate", "Spin", "HorzBreak", "HB", "InducedVertBreak", "IVB", "Extension", "Ext", "RelHeight", "Height", "RelSide", "Side", "VertApprAngle", "VAA", "HorzApprAngle", "HAA", "ZoneSpeed", "ZoneTime", "PlateLocSide", "PlateLocHeight", "Tilt", "ExitSpeed", "EV", "Angle", "LA", "Distance", "Direction", "PopTime", "ExchangeTime", "ThrowSpeed") ~ 1,
            TRUE ~ 2
          ))
        } else {
          .
        }
      } %>%
      {
        # Only format columns that exist in the data and are not already formatted
        if (input$corr_var_y %in% colnames(data) && !input$corr_var_y %in% c("BABIP", "AVG", "SLG", "xWOBA", "xISO")) {
          DT::formatRound(., columns = input$corr_var_y, digits = case_when(
            # 1 decimal: Velocities, distances, angles, spin rates
            input$corr_var_y %in% c("RelSpeed", "Velo", "Velocity", "SpinRate", "Spin", "HorzBreak", "HB", "InducedVertBreak", "IVB", "Extension", "Ext", "RelHeight", "Height", "RelSide", "Side", "VertApprAngle", "VAA", "HorzApprAngle", "HAA", "ZoneSpeed", "ZoneTime", "PlateLocSide", "PlateLocHeight", "Tilt", "ExitSpeed", "EV", "Angle", "LA", "Distance", "Direction", "PopTime", "ExchangeTime", "ThrowSpeed") ~ 1,
            TRUE ~ 2
          ))
        } else {
          .
        }
      }
  })
  
  # ============== END CORRELATIONS SERVER LOGIC ==============
  
  # ============== PLAYER PLANS SERVER LOGIC ==============
  
  # Available pitch types from the data
  available_pitch_types <- names(all_colors)
  
  # Reactive values for persistent storage (now DB-backed with localStorage fallback)
  player_plans_data <- reactiveValues(plans = list(), current_player = NULL)
  completed_goals_data <- reactiveValues(goals = list())
  plans_initialized <- reactiveVal(FALSE)
  
  # DB helpers for player plans and completed goals
  load_player_plans_db <- function() {
    con <- state_db_connect()
    on.exit(DBI::dbDisconnect(con), add = TRUE)
    if (!DBI::dbExistsTable(con, "player_plans")) return(list())
    df <- DBI::dbReadTable(con, "player_plans")
    if ("school_code" %in% names(df)) {
      df <- df[df$school_code %in% allowed_school_codes(), , drop = FALSE]
      df <- df[order(df$school_code == current_school()), , drop = FALSE]
    }
    if (!nrow(df)) return(list())
    out <- lapply(seq_len(nrow(df)), function(i) {
      pl <- tryCatch(jsonlite::fromJSON(df$payload[[i]], simplifyVector = TRUE), error = function(...) list())
      pl$school_code <- df$school_code[[i]] %||% current_school()
      pl
    })
    names(out) <- df$player
    out
  }
  save_player_plans_db <- function(plans) {
    con <- state_db_connect()
    on.exit(DBI::dbDisconnect(con), add = TRUE)
    DBI::dbExecute(con, "DELETE FROM player_plans")
    if (!length(plans)) return(invisible(TRUE))
    payload <- data.frame(
      player = names(plans),
      payload = vapply(plans, function(v) jsonlite::toJSON(v, auto_unbox = TRUE), character(1)),
      school_code = vapply(plans, function(v) v$school_code %||% current_school(), character(1)),
      stringsAsFactors = FALSE
    )
    DBI::dbWriteTable(con, "player_plans", payload, append = TRUE, row.names = FALSE)
  }
  
  load_completed_goals_db <- function() {
    con <- state_db_connect()
    on.exit(DBI::dbDisconnect(con), add = TRUE)
    if (!DBI::dbExistsTable(con, "completed_goals")) return(list())
    df <- DBI::dbReadTable(con, "completed_goals")
    if ("school_code" %in% names(df)) {
      df <- df[df$school_code %in% allowed_school_codes(), , drop = FALSE]
      df <- df[order(df$school_code == current_school()), , drop = FALSE]
    }
    if (!nrow(df)) return(list())
    out <- lapply(seq_len(nrow(df)), function(i) {
      cg <- tryCatch(jsonlite::fromJSON(df$payload[[i]], simplifyVector = TRUE), error = function(...) list())
      cg$school_code <- df$school_code[[i]] %||% current_school()
      cg
    })
    names(out) <- df$player
    out
  }
  save_completed_goals_db <- function(goals) {
    con <- state_db_connect()
    on.exit(DBI::dbDisconnect(con), add = TRUE)
    DBI::dbExecute(con, "DELETE FROM completed_goals")
    if (!length(goals)) return(invisible(TRUE))
    payload <- data.frame(
      player = names(goals),
      payload = vapply(goals, function(v) jsonlite::toJSON(v, auto_unbox = TRUE), character(1)),
      school_code = vapply(goals, function(v) v$school_code %||% current_school(), character(1)),
      stringsAsFactors = FALSE
    )
    DBI::dbWriteTable(con, "completed_goals", payload, append = TRUE, row.names = FALSE)
  }
  
  # Initialize player plans storage: try DB first, fall back to localStorage
  observe({
    if (plans_initialized()) return()
    plans_initialized(TRUE)
    
    db_plans <- try(load_player_plans_db(), silent = TRUE)
    if (!inherits(db_plans, "try-error") && length(db_plans)) {
      player_plans_data$plans <- db_plans
      cat("Loaded", length(db_plans), "player plans from DB\n")
    } else {
      session$sendCustomMessage("loadPlayerPlans", list())
    }
    
    db_goals <- try(load_completed_goals_db(), silent = TRUE)
    if (!inherits(db_goals, "try-error") && length(db_goals)) {
      completed_goals_data$goals <- db_goals
      cat("Loaded", length(db_goals), "completed goals from DB\n")
    } else {
      session$sendCustomMessage("loadCompletedGoals", list())
    }
  })
  
  # Receive loaded plans from localStorage (only if DB empty)
  observeEvent(input$loadedPlayerPlans, {
    if (!is.null(input$loadedPlayerPlans) && length(input$loadedPlayerPlans) > 0 && length(player_plans_data$plans) == 0) {
      player_plans_data$plans <- input$loadedPlayerPlans
      cat("Loaded", length(input$loadedPlayerPlans), "saved plans from localStorage\n")
      save_player_plans_db(player_plans_data$plans)
      
      # If we have a selected player, refresh their plan immediately
      isolate({
        if (!is.null(input$pp_player_select) && input$pp_player_select != "") {
          plan <- get_current_plan(input$pp_player_select)
          
          # Update all inputs with the loaded values
          updateSelectInput(session, "pp_session_type", selected = plan$session_type %||% "All")
          updateSelectInput(session, "pp_goal1_type", selected = plan$goal1_type)
          updateSelectInput(session, "pp_goal1_stuff_category", selected = plan$goal1_stuff_category)
          updateSelectInput(session, "pp_goal1_velocity_pitch", selected = plan$goal1_velocity_pitch)
          updateSelectInput(session, "pp_goal1_movement_pitch", selected = plan$goal1_movement_pitch)
          updateSelectInput(session, "pp_goal1_movement_type", selected = plan$goal1_movement_type)
          updateSelectInput(session, "pp_goal1_execution_stat", selected = plan$goal1_execution_stat)
          updateSelectInput(session, "pp_goal1_execution_pitch", selected = plan$goal1_execution_pitch)
          updateSelectInput(session, "pp_goal1_batter_hand", selected = plan$goal1_batter_hand %||% "All")
          updateSelectInput(session, "pp_goal1_target_direction", selected = plan$goal1_target_direction)
          updateTextInput(session, "pp_goal1_target_value", value = plan$goal1_target_value)
          
          updateSelectInput(session, "pp_goal2_type", selected = plan$goal2_type)
          updateSelectInput(session, "pp_goal2_stuff_category", selected = plan$goal2_stuff_category)
          updateSelectInput(session, "pp_goal2_velocity_pitch", selected = plan$goal2_velocity_pitch)
          updateSelectInput(session, "pp_goal2_movement_pitch", selected = plan$goal2_movement_pitch)
          updateSelectInput(session, "pp_goal2_movement_type", selected = plan$goal2_movement_type)
          updateSelectInput(session, "pp_goal2_execution_stat", selected = plan$goal2_execution_stat)
          updateSelectInput(session, "pp_goal2_execution_pitch", selected = plan$goal2_execution_pitch)
          updateSelectInput(session, "pp_goal2_batter_hand", selected = plan$goal2_batter_hand %||% "All")
          updateSelectInput(session, "pp_goal2_target_direction", selected = plan$goal2_target_direction)
          updateTextInput(session, "pp_goal2_target_value", value = plan$goal2_target_value)
          
          updateSelectInput(session, "pp_goal3_type", selected = plan$goal3_type)
          updateSelectInput(session, "pp_goal3_stuff_category", selected = plan$goal3_stuff_category)
          updateSelectInput(session, "pp_goal3_velocity_pitch", selected = plan$goal3_velocity_pitch)
          updateSelectInput(session, "pp_goal3_movement_pitch", selected = plan$goal3_movement_pitch)
          updateSelectInput(session, "pp_goal3_movement_type", selected = plan$goal3_movement_type)
          updateSelectInput(session, "pp_goal3_execution_stat", selected = plan$goal3_execution_stat)
          updateSelectInput(session, "pp_goal3_execution_pitch", selected = plan$goal3_execution_pitch)
          updateSelectInput(session, "pp_goal3_batter_hand", selected = plan$goal3_batter_hand %||% "All")
          updateSelectInput(session, "pp_goal3_target_direction", selected = plan$goal3_target_direction)
          updateTextInput(session, "pp_goal3_target_value", value = plan$goal3_target_value)
          
          updateTextAreaInput(session, "pp_goal1_notes", value = plan$goal1_notes)
          updateTextAreaInput(session, "pp_goal2_notes", value = plan$goal2_notes)
          updateTextAreaInput(session, "pp_goal3_notes", value = plan$goal3_notes)
          updateTextAreaInput(session, "pp_general_notes", value = plan$general_notes)
        }
      })
    }
  })
  
  # Receive loaded completed goals from localStorage (only if DB empty)
  observeEvent(input$loadedCompletedGoals, {
    if (!is.null(input$loadedCompletedGoals) && length(input$loadedCompletedGoals) > 0 && length(completed_goals_data$goals) == 0) {
      completed_goals_data$goals <- input$loadedCompletedGoals
      cat("Loaded", length(input$loadedCompletedGoals), "completed goals from localStorage\n")
      save_completed_goals_db(completed_goals_data$goals)
    }
  })
  
  # Helper function to get current player plan
  get_current_plan <- function(player) {
    if (is.null(player) || player == "") return(NULL)
    plan <- player_plans_data$plans[[player]]
    if (is.null(plan)) {
      # Create default empty plan
      plan <- list(
        session_type = "All",
        goal1_type = "", goal1_stuff_category = "", goal1_velocity_pitch = "All",
        goal1_movement_pitch = "All", goal1_movement_type = character(0),
        goal1_movement_display = c("Averages and Pitches"),
        goal1_execution_stat = "", goal1_execution_pitch = "All",
        goal1_batter_hand = "All", goal1_chart_view = "Trend Chart",
        goal1_target_direction = "", goal1_target_value = "",
        goal2_type = "", goal2_stuff_category = "", goal2_velocity_pitch = "All",
        goal2_movement_pitch = "All", goal2_movement_type = character(0),
        goal2_movement_display = c("Averages and Pitches"),
        goal2_execution_stat = "", goal2_execution_pitch = "All",
        goal2_batter_hand = "All", goal2_chart_view = "Trend Chart",
        goal2_target_direction = "", goal2_target_value = "",
        goal3_type = "", goal3_stuff_category = "", goal3_velocity_pitch = "All",
        goal3_movement_pitch = "All", goal3_movement_type = character(0),
        goal3_movement_display = c("Averages and Pitches"),
        goal3_execution_stat = "", goal3_execution_pitch = "All",
        goal3_batter_hand = "All", goal3_chart_view = "Trend Chart",
        goal3_target_direction = "", goal3_target_value = "",
        goal1_notes = "", goal2_notes = "", goal3_notes = "",
        general_notes = "",
        school_code = current_school()
      )
      cat("Created new default plan for player:", player, "\n")
    } else {
      cat("Loaded existing plan for player:", player, "\n")
      cat("Goal 1 type:", plan$goal1_type, "\n")
      cat("Goal 2 type:", plan$goal2_type, "\n")
      cat("Goal 3 type:", plan$goal3_type, "\n")
    }
    return(plan)
  }
  
  # Helper function to save current plan
  save_current_plan <- function(player) {
    if (is.null(player) || player == "") return()
    
    plan <- list(
      session_type = input$pp_session_type %||% "All",
      goal1_type = input$pp_goal1_type %||% "",
      goal1_stuff_category = input$pp_goal1_stuff_category %||% "",
      goal1_velocity_pitch = input$pp_goal1_velocity_pitch %||% "All",
      goal1_movement_pitch = input$pp_goal1_movement_pitch %||% "All",
      goal1_movement_type = input$pp_goal1_movement_type %||% character(0),
      goal1_movement_display = input$pp_goal1_movement_display %||% c("Averages and Pitches"),
      goal1_execution_stat = input$pp_goal1_execution_stat %||% "",
      goal1_execution_pitch = input$pp_goal1_execution_pitch %||% "All",
      goal1_batter_hand = input$pp_goal1_batter_hand %||% "All",
      goal1_chart_view = input$pp_goal1_chart_view %||% "Trend Chart",
      goal1_target_direction = input$pp_goal1_target_direction %||% "",
      goal1_target_value = input$pp_goal1_target_value %||% "",
      goal2_type = input$pp_goal2_type %||% "",
      goal2_stuff_category = input$pp_goal2_stuff_category %||% "",
      goal2_velocity_pitch = input$pp_goal2_velocity_pitch %||% "All",
      goal2_movement_pitch = input$pp_goal2_movement_pitch %||% "All",
      goal2_movement_type = input$pp_goal2_movement_type %||% character(0),
      goal2_movement_display = input$pp_goal2_movement_display %||% c("Averages and Pitches"),
      goal2_execution_stat = input$pp_goal2_execution_stat %||% "",
      goal2_execution_pitch = input$pp_goal2_execution_pitch %||% "All",
      goal2_batter_hand = input$pp_goal2_batter_hand %||% "All",
      goal2_chart_view = input$pp_goal2_chart_view %||% "Trend Chart",
      goal2_target_direction = input$pp_goal2_target_direction %||% "",
      goal2_target_value = input$pp_goal2_target_value %||% "",
      goal3_type = input$pp_goal3_type %||% "",
      goal3_stuff_category = input$pp_goal3_stuff_category %||% "",
      goal3_velocity_pitch = input$pp_goal3_velocity_pitch %||% "All",
      goal3_movement_pitch = input$pp_goal3_movement_pitch %||% "All",
      goal3_movement_type = input$pp_goal3_movement_type %||% character(0),
      goal3_movement_display = input$pp_goal3_movement_display %||% c("Averages and Pitches"),
      goal3_execution_stat = input$pp_goal3_execution_stat %||% "",
      goal3_execution_pitch = input$pp_goal3_execution_pitch %||% "All",
      goal3_batter_hand = input$pp_goal3_batter_hand %||% "All",
      goal3_chart_view = input$pp_goal3_chart_view %||% "Trend Chart",
      goal3_target_direction = input$pp_goal3_target_direction %||% "",
      goal3_target_value = input$pp_goal3_target_value %||% "",
      goal1_notes = input$pp_goal1_notes %||% "",
      goal2_notes = input$pp_goal2_notes %||% "",
      goal3_notes = input$pp_goal3_notes %||% "",
      general_notes = input$pp_general_notes %||% "",
      school_code = current_school()
    )
    
    player_plans_data$plans[[player]] <- plan
    
    # Save to localStorage
    session$sendCustomMessage("savePlayerPlans", player_plans_data$plans)
    # Persist to DB
    try(save_player_plans_db(player_plans_data$plans), silent = TRUE)
    
    cat("Saved plan for player:", player, "\n")
    cat("Goal 1 type:", plan$goal1_type, "\n")
    cat("Goal 2 type:", plan$goal2_type, "\n") 
    cat("Goal 3 type:", plan$goal3_type, "\n")
    cat("Total saved plans:", length(player_plans_data$plans), "\n")
  }
  
  # Populate player choices and set default date range
  observe({
    req(pitch_data)
    
    # Use the whitelist-filtered pitch_data_pitching for consistency with other modules
    players <- sort(unique(pitch_data_pitching$Pitcher))
    
    # Filter by user role: Coaches see all, Players see only themselves
    if (!is_admin() && !is_coach()) {
      ue <- user_email()
      if (!is.na(ue)) {
        visible_players <- unique(pitch_data_pitching$Pitcher[norm_email(pitch_data_pitching$Email) == norm_email(ue)])
        players <- intersect(players, visible_players)
      }
    }
    
    updateSelectInput(session, "pp_player_select",
                      choices = players,
                      selected = if(length(players) > 0) players[1] else NULL)
  })
  
  # Update date range when player changes
  observeEvent(input$pp_player_select, {
    req(input$pp_player_select, pitch_data)
    
    # Save previous player's plan if we're switching players
    previous_player <- isolate(player_plans_data$current_player)
    if (!is.null(previous_player) && previous_player != input$pp_player_select) {
      save_current_plan(previous_player)
    }
    
    # Update current player tracker
    player_plans_data$current_player <- input$pp_player_select
    
    # Get player's data date range using whitelist-filtered data
    player_data <- pitch_data_pitching %>% dplyr::filter(Pitcher == input$pp_player_select)
    
    if (nrow(player_data) > 0) {
      max_date <- max(player_data$Date, na.rm = TRUE)
      start_date <- max_date - 30
      
      updateDateRangeInput(session, "pp_date_range",
                           start = start_date,
                           end = max_date)
    }
    
    # Load player's saved plan
    plan <- get_current_plan(input$pp_player_select)
    
    # Update all inputs with saved values (using isolate to prevent recursion)
    isolate({
      updateSelectInput(session, "pp_session_type", selected = plan$session_type %||% "All")
      updateSelectInput(session, "pp_goal1_type", selected = plan$goal1_type)
      updateSelectInput(session, "pp_goal1_stuff_category", selected = plan$goal1_stuff_category)
      updateSelectInput(session, "pp_goal1_velocity_pitch", selected = plan$goal1_velocity_pitch)
      updateSelectInput(session, "pp_goal1_movement_pitch", selected = plan$goal1_movement_pitch)
      updateSelectInput(session, "pp_goal1_movement_type", selected = plan$goal1_movement_type)
      updateSelectInput(session, "pp_goal1_movement_display", selected = plan$goal1_movement_display %||% c("Averages and Pitches"))
      updateSelectInput(session, "pp_goal1_execution_stat", selected = plan$goal1_execution_stat)
      updateSelectInput(session, "pp_goal1_execution_pitch", selected = plan$goal1_execution_pitch)
      updateSelectInput(session, "pp_goal1_batter_hand", selected = plan$goal1_batter_hand %||% "All")
      updateSelectInput(session, "pp_goal1_chart_view", selected = plan$goal1_chart_view %||% "Trend Chart")
      updateSelectInput(session, "pp_goal1_target_direction", selected = plan$goal1_target_direction)
      updateTextInput(session, "pp_goal1_target_value", value = plan$goal1_target_value)
      
      updateSelectInput(session, "pp_goal2_type", selected = plan$goal2_type)
      updateSelectInput(session, "pp_goal2_stuff_category", selected = plan$goal2_stuff_category)
      updateSelectInput(session, "pp_goal2_velocity_pitch", selected = plan$goal2_velocity_pitch)
      updateSelectInput(session, "pp_goal2_movement_pitch", selected = plan$goal2_movement_pitch)
      updateSelectInput(session, "pp_goal2_movement_type", selected = plan$goal2_movement_type)
      updateSelectInput(session, "pp_goal2_movement_display", selected = plan$goal2_movement_display %||% c("Averages and Pitches"))
      updateSelectInput(session, "pp_goal2_execution_stat", selected = plan$goal2_execution_stat)
      updateSelectInput(session, "pp_goal2_execution_pitch", selected = plan$goal2_execution_pitch)
      updateSelectInput(session, "pp_goal2_batter_hand", selected = plan$goal2_batter_hand %||% "All")
      updateSelectInput(session, "pp_goal2_chart_view", selected = plan$goal2_chart_view %||% "Trend Chart")
      updateSelectInput(session, "pp_goal2_target_direction", selected = plan$goal2_target_direction)
      updateTextInput(session, "pp_goal2_target_value", value = plan$goal2_target_value)
      
      updateSelectInput(session, "pp_goal3_type", selected = plan$goal3_type)
      updateSelectInput(session, "pp_goal3_stuff_category", selected = plan$goal3_stuff_category)
      updateSelectInput(session, "pp_goal3_velocity_pitch", selected = plan$goal3_velocity_pitch)
      updateSelectInput(session, "pp_goal3_movement_pitch", selected = plan$goal3_movement_pitch)
      updateSelectInput(session, "pp_goal3_movement_type", selected = plan$goal3_movement_type)
      updateSelectInput(session, "pp_goal3_movement_display", selected = plan$goal3_movement_display %||% c("Averages and Pitches"))
      updateSelectInput(session, "pp_goal3_execution_stat", selected = plan$goal3_execution_stat)
      updateSelectInput(session, "pp_goal3_execution_pitch", selected = plan$goal3_execution_pitch)
      updateSelectInput(session, "pp_goal3_batter_hand", selected = plan$goal3_batter_hand %||% "All")
      updateSelectInput(session, "pp_goal3_chart_view", selected = plan$goal3_chart_view %||% "Trend Chart")
      updateSelectInput(session, "pp_goal3_target_direction", selected = plan$goal3_target_direction)
      updateTextInput(session, "pp_goal3_target_value", value = plan$goal3_target_value)
      
      updateTextAreaInput(session, "pp_goal1_notes", value = plan$goal1_notes)
      updateTextAreaInput(session, "pp_goal2_notes", value = plan$goal2_notes)
      updateTextAreaInput(session, "pp_goal3_notes", value = plan$goal3_notes)
      updateTextAreaInput(session, "pp_general_notes", value = plan$general_notes)
    })
  }, ignoreInit = TRUE)
  
  # Auto-save when any goal input changes
  observe({
    req(plans_initialized(), input$pp_player_select)
    
    # Throttle autosave to reduce DB churn
    invalidateLater(10000, session)
    
    # Save current plan (errors here should not break the session)
    try(save_current_plan(input$pp_player_select), silent = TRUE)
  })
  
  # Additional observers for immediate saving on critical changes
  observeEvent(c(input$pp_goal1_type, input$pp_goal2_type, input$pp_goal3_type), {
    req(input$pp_player_select)
    save_current_plan(input$pp_player_select)
  }, ignoreInit = TRUE)
  
  observeEvent(c(input$pp_goal1_target_value, input$pp_goal2_target_value, input$pp_goal3_target_value), {
    req(input$pp_player_select)
    save_current_plan(input$pp_player_select)
  }, ignoreInit = TRUE)
  
  observeEvent(c(input$pp_goal1_chart_view, input$pp_goal2_chart_view, input$pp_goal3_chart_view), {
    req(input$pp_player_select)
    save_current_plan(input$pp_player_select)
  }, ignoreInit = TRUE)
  
  # Save plan when general notes change
  observeEvent(input$pp_general_notes, {
    req(input$pp_player_select)
    save_current_plan(input$pp_player_select)
  }, ignoreInit = TRUE)
  
  # Observers for goal completion checkboxes
  observeEvent(input$pp_goal1_completed, {
    if (input$pp_goal1_completed && !is.null(input$pp_player_select) && input$pp_player_select != "") {
      save_completed_goal(input$pp_player_select, 1)
    }
  })
  
  observeEvent(input$pp_goal2_completed, {
    if (input$pp_goal2_completed && !is.null(input$pp_player_select) && input$pp_player_select != "") {
      save_completed_goal(input$pp_player_select, 2)
    }
  })
  
  observeEvent(input$pp_goal3_completed, {
    if (input$pp_goal3_completed && !is.null(input$pp_player_select) && input$pp_player_select != "") {
      save_completed_goal(input$pp_player_select, 3)
    }
  })
  
  # Helper function to save completed goals
  save_completed_goal <- function(player, goal_num) {
    if (is.null(player) || player == "") return()
    
    # Save the completed goal data
    completed_goal <- list(
      player = player,
      goal_num = goal_num,
      date_completed = Sys.Date(),
      goal_data = list(
        type = input[[paste0("pp_goal", goal_num, "_type")]],
        stuff_category = input[[paste0("pp_goal", goal_num, "_stuff_category")]],
        velocity_pitch = input[[paste0("pp_goal", goal_num, "_velocity_pitch")]],
        movement_pitch = input[[paste0("pp_goal", goal_num, "_movement_pitch")]],
        movement_type = input[[paste0("pp_goal", goal_num, "_movement_type")]],
        execution_stat = input[[paste0("pp_goal", goal_num, "_execution_stat")]],
        execution_pitch = input[[paste0("pp_goal", goal_num, "_execution_pitch")]],
        batter_hand = input[[paste0("pp_goal", goal_num, "_batter_hand")]],
        chart_view = input[[paste0("pp_goal", goal_num, "_chart_view")]],
        target_direction = input[[paste0("pp_goal", goal_num, "_target_direction")]],
        target_value = input[[paste0("pp_goal", goal_num, "_target_value")]],
        notes = input[[paste0("pp_goal", goal_num, "_notes")]]
      )
    )
    
    # Generate unique ID for the completed goal
    goal_id <- paste0(player, "_", goal_num, "_", format(Sys.time(), "%Y%m%d_%H%M%S"))
    
    # Add to completed goals storage
    completed_goals_data$goals[[goal_id]] <- completed_goal
    
    # Clear the goal inputs after completion
    clear_goal_inputs(goal_num)
    
    # Save to localStorage
    session$sendCustomMessage("saveCompletedGoals", completed_goals_data$goals)
    # Persist to DB
    try(save_completed_goals_db(completed_goals_data$goals), silent = TRUE)
    
    cat("Saved completed goal for player:", player, "goal:", goal_num, "\n")
  }
  
  # Helper function to delete a completed goal
  delete_completed_goal <- function(goal_id) {
    if (!is.null(completed_goals_data$goals) && goal_id %in% names(completed_goals_data$goals)) {
      completed_goals_data$goals[[goal_id]] <- NULL
      session$sendCustomMessage("saveCompletedGoals", completed_goals_data$goals)
      try(save_completed_goals_db(completed_goals_data$goals), silent = TRUE)
      cat("Deleted completed goal:", goal_id, "\n")
    }
  }
  
  # Observer for delete buttons (will be created dynamically)
  observe({
    # Get all delete button inputs
    delete_inputs <- grep("^pp_delete_goal_", names(input), value = TRUE)
    
    for (delete_input in delete_inputs) {
      if (!is.null(input[[delete_input]]) && input[[delete_input]] > 0) {
        # Extract goal ID from input name
        goal_id <- gsub("^pp_delete_goal_", "", delete_input)
        delete_completed_goal(goal_id)
      }
    }
  })
  
  # Render completed goals count
  output$pp_completed_count <- renderText({
    req(input$pp_player_select)
    
    if (is.null(completed_goals_data$goals) || length(completed_goals_data$goals) == 0) {
      return("(0 completed goals)")
    }
    
    # Count completed goals for current player
    player_goals <- completed_goals_data$goals[sapply(completed_goals_data$goals, function(g) {
      !is.null(g$player) && g$player == input$pp_player_select
    })]
    count <- length(player_goals)
    
    return(paste0("(", count, " completed goal", if(count != 1) "s" else "", ")"))
  })
  
  # Render completed goals modal content
  output$pp_completed_goals_content <- renderUI({
    req(input$pp_player_select)
    
    if (is.null(completed_goals_data$goals) || length(completed_goals_data$goals) == 0) {
      return(div(style = "text-align: center; padding: 50px;",
                 h4("No completed goals yet.")))
    }
    
    # Filter completed goals for current player
    player_goals <- completed_goals_data$goals[sapply(completed_goals_data$goals, function(g) {
      !is.null(g$player) && g$player == input$pp_player_select
    })]
    
    if (length(player_goals) == 0) {
      return(div(style = "text-align: center; padding: 50px;",
                 h4("No completed goals for this player yet.")))
    }
    
    # Sort by completion date (most recent first)
    player_goals <- player_goals[order(sapply(player_goals, function(g) {
      if (is.null(g$date_completed)) return(0)
      return(as.Date(g$date_completed))
    }), decreasing = TRUE)]
    
    # Create cards for each completed goal
    goal_cards <- lapply(names(player_goals), function(goal_id) {
      goal <- player_goals[[goal_id]]
      
      div(class = "panel panel-default", style = "margin-bottom: 15px;",
          div(class = "panel-heading", style = "position: relative;",
              h5(class = "panel-title", style = "margin-right: 30px;",
                 strong(paste("Goal #", goal$goal_num, " - ", goal$goal_data$type))
              ),
              # Delete button in upper right
              div(style = "position: absolute; top: 5px; right: 10px;",
                  actionButton(paste0("pp_delete_goal_", goal_id), "×",
                               class = "btn btn-danger btn-xs",
                               style = "padding: 2px 6px; font-size: 12px;")
              )
          ),
          div(class = "panel-body",
              div(style = "margin-bottom: 10px;",
                  strong("Completed: "), format(as.Date(goal$date_completed), "%B %d, %Y")
              ),
              div(style = "margin-bottom: 10px;",
                  strong("Description: "), create_pp_goal_description_from_data(goal$goal_data)
              ),
              if (!is.null(goal$goal_data$notes) && goal$goal_data$notes != "") {
                div(style = "margin-bottom: 10px;",
                    strong("Notes: "), goal$goal_data$notes
                )
              }
          )
      )
    })
    
    div(goal_cards)
  })
  
  # Observer for "View Completed Goals" button
  observeEvent(input$pp_view_completed, {
    showModal(modalDialog(
      title = "Completed Goals",
      div(style = "max-height: 600px; overflow-y: auto;",
          uiOutput("pp_completed_goals_content")
      ),
      size = "l",
      easyClose = TRUE,
      footer = modalButton("Close")
    ))
  })
  
  # Helper function to create goal descriptions from stored data
  create_pp_goal_description_from_data <- function(goal_data) {
    if (is.null(goal_data$type) || goal_data$type == "") {
      return("No goal type selected")
    }
    
    if (goal_data$type == "Stuff") {
      category <- goal_data$stuff_category %||% ""
      if (category == "Velocity") {
        pitch <- goal_data$velocity_pitch %||% ""
        if (pitch == "") return("Velocity - No pitch type selected")
        return(paste0("Velocity - ", pitch))
      } else if (category == "Movement") {
        pitch <- goal_data$movement_pitch %||% ""
        movement <- goal_data$movement_type %||% character(0)
        if (pitch == "" || length(movement) == 0) {
          return("Movement - Incomplete selection")
        }
        return(paste0("Movement - ", pitch, " (", paste(movement, collapse = " & "), ")"))
      } else {
        return("Stuff - No category selected")
      }
    } else if (goal_data$type == "Execution") {
      stat <- goal_data$execution_stat %||% ""
      pitch <- goal_data$execution_pitch %||% ""
      if (stat == "") return("Execution - No stat selected")
      if (pitch == "") return(paste0("Execution - ", stat, " (No pitch type selected)"))
      return(paste0("Execution - ", stat, " (", pitch, ")"))
    }
    
    return("Unknown goal type")
  }
  
  # Helper function to clear goal inputs
  clear_goal_inputs <- function(goal_num) {
    updateSelectInput(session, paste0("pp_goal", goal_num, "_type"), selected = "")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_stuff_category"), selected = "")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_velocity_pitch"), selected = "All")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_movement_pitch"), selected = "All")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_movement_type"), selected = character(0))
    updateSelectInput(session, paste0("pp_goal", goal_num, "_movement_display"), selected = c("Averages and Pitches"))
    updateSelectInput(session, paste0("pp_goal", goal_num, "_execution_stat"), selected = "")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_execution_pitch"), selected = "All")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_batter_hand"), selected = "All")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_chart_view"), selected = "Trend Chart")
    updateSelectInput(session, paste0("pp_goal", goal_num, "_target_direction"), selected = "")
    updateTextInput(session, paste0("pp_goal", goal_num, "_target_value"), value = "")
    updateTextAreaInput(session, paste0("pp_goal", goal_num, "_notes"), value = "")
    updateCheckboxInput(session, paste0("pp_goal", goal_num, "_completed"), value = FALSE)
  }
  
  # Save plan when session ends or player leaves page
  session$onSessionEnded(function() {
    tryCatch({
      player_select <- isolate(input$pp_player_select)
      if (!is.null(player_select)) {
        save_current_plan(player_select)
      }
    }, error = function(e) {
      # Silently ignore errors during session end
    })
  })
  
  # Populate pitch type choices for all goals
  observe({
    updateSelectInput(session, "pp_goal1_velocity_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal1_movement_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal1_execution_pitch", choices = c("All", available_pitch_types))
    
    updateSelectInput(session, "pp_goal2_velocity_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal2_movement_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal2_execution_pitch", choices = c("All", available_pitch_types))
    
    updateSelectInput(session, "pp_goal3_velocity_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal3_movement_pitch", choices = c("All", available_pitch_types))
    updateSelectInput(session, "pp_goal3_execution_pitch", choices = c("All", available_pitch_types))
  })
  
  # Add basic output renders for Player Plans
  output$pp_player_name <- renderText({
    req(input$pp_player_select)
    input$pp_player_select
  })
  
  output$pp_date_range_display <- renderText({
    req(input$pp_date_range)
    paste(format(input$pp_date_range[1], "%B %d"), "-", format(input$pp_date_range[2], "%B %d, %Y"))
  })
  
  output$pp_dynamic_goals <- renderUI({
    # Check which goals are configured
    goals_configured <- c()
    
    if (!is.null(input$pp_goal1_type) && input$pp_goal1_type != "") {
      goals_configured <- c(goals_configured, 1)
    }
    if (!is.null(input$pp_goal2_type) && input$pp_goal2_type != "") {
      goals_configured <- c(goals_configured, 2)
    }
    if (!is.null(input$pp_goal3_type) && input$pp_goal3_type != "") {
      goals_configured <- c(goals_configured, 3)
    }
    
    if (length(goals_configured) == 0) {
      return(div(style = "text-align: center; padding: 50px;",
                 h4("No goals configured yet. Please select goal types in the sidebar.")))
    }
    
    # Helper function to create a goal card
    create_goal_card <- function(goal_num) {
      div(class = "goal-container",
          # Completion checkbox in upper right corner with fixed positioning
          div(class = "goal-checkbox",
              checkboxInput(paste0("pp_goal", goal_num, "_completed"), 
                            label = NULL, 
                            value = FALSE)
          ),
          # Add some top padding to prevent overlap with checkbox
          div(style = "padding-top: 10px;",
              h4(textOutput(paste0("pp_goal", goal_num, "_header"), inline = TRUE))
          ),
          div(class = "goal-description",
              textOutput(paste0("pp_goal", goal_num, "_description"))
          ),
          ggiraph::girafeOutput(paste0("pp_goal", goal_num, "_plot"), height = "300px"),
          br(),
          DT::dataTableOutput(paste0("pp_goal", goal_num, "_table")),
          br(),
          div(style = "text-align: center;",
              h5(strong("Drills and Notes:"))
          ),
          textAreaInput(paste0("pp_goal", goal_num, "_notes"), label = NULL,
                        placeholder = paste0("Enter drills and notes for Goal #", goal_num, "..."),
                        rows = 3, width = "100%")
      )
    }
    
    # Determine column width and offset for centering
    num_goals <- length(goals_configured)
    if (num_goals == 1) {
      column_width <- 6
      offset <- 3
    } else if (num_goals == 2) {
      column_width <- 5
      offset <- 1
    } else {
      column_width <- 4
      offset <- 0
    }
    
    # Create the appropriate layout
    if (num_goals == 1) {
      fluidRow(
        column(column_width, offset = offset,
               create_goal_card(goals_configured[1])
        )
      )
    } else if (num_goals == 2) {
      fluidRow(
        column(column_width, offset = offset,
               create_goal_card(goals_configured[1])
        ),
        column(column_width,
               create_goal_card(goals_configured[2])
        )
      )
    } else {
      fluidRow(
        column(column_width,
               create_goal_card(goals_configured[1])
        ),
        column(column_width,
               create_goal_card(goals_configured[2])
        ),
        column(column_width,
               create_goal_card(goals_configured[3])
        )
      )
    }
  })
  
  # Goal headers
  output$pp_goal1_header <- renderText({
    goal_type <- input$pp_goal1_type
    if (is.null(goal_type) || goal_type == "") {
      return("Goal #1")
    } else {
      return(paste0("Goal #1: ", goal_type))
    }
  })
  
  output$pp_goal2_header <- renderText({
    goal_type <- input$pp_goal2_type
    if (is.null(goal_type) || goal_type == "") {
      return("Goal #2")
    } else {
      return(paste0("Goal #2: ", goal_type))
    }
  })
  
  output$pp_goal3_header <- renderText({
    goal_type <- input$pp_goal3_type
    if (is.null(goal_type) || goal_type == "") {
      return("Goal #3")
    } else {
      return(paste0("Goal #3: ", goal_type))
    }
  })
  
  # Goal descriptions
  output$pp_goal1_description <- renderText({
    create_pp_goal_description(1)
  })
  
  output$pp_goal2_description <- renderText({
    create_pp_goal_description(2)
  })
  
  output$pp_goal3_description <- renderText({
    create_pp_goal_description(3)
  })
  
  # Helper function to create goal descriptions  
  create_pp_goal_description <- function(goal_num) {
    goal_type <- input[[paste0("pp_goal", goal_num, "_type")]]
    chart_view <- input[[paste0("pp_goal", goal_num, "_chart_view")]]
    
    if (is.null(goal_type) || goal_type == "") {
      return("No goal selected")
    }
    
    # Get batter hand info
    batter_hand <- input[[paste0("pp_goal", goal_num, "_batter_hand")]]
    batter_text <- ""
    if (!is.null(batter_hand) && batter_hand != "All") {
      batter_text <- paste(" | vs", batter_hand)
    }
    
    # Get target info
    target_direction <- input[[paste0("pp_goal", goal_num, "_target_direction")]]
    target_value <- input[[paste0("pp_goal", goal_num, "_target_value")]]
    target_text <- ""
    if (!is.null(target_direction) && !is.null(target_value) && 
        target_direction != "" && target_value != "") {
      target_text <- paste(" | Target:", target_direction, target_value)
    }
    
    if (goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      if (is.null(category) || category == "") {
        return(paste0("No category selected", batter_text, target_text))
      }
      
      if (category == "Velocity") {
        pitch <- input[[paste0("pp_goal", goal_num, "_velocity_pitch")]]
        if (is.null(pitch) || pitch == "") {
          return(paste0("Velocity - No pitch type selected", batter_text, target_text))
        }
        return(paste0("Velocity - ", pitch, batter_text, target_text))
      }
      
      if (category == "Movement") {
        pitch <- input[[paste0("pp_goal", goal_num, "_movement_pitch")]]
        movement <- input[[paste0("pp_goal", goal_num, "_movement_type")]]
        if (is.null(pitch) || pitch == "" || is.null(movement) || length(movement) == 0) {
          return(paste0("Movement - Incomplete selection", batter_text, target_text))
        }
        return(paste0("Movement - ", pitch, " - ", paste(movement, collapse = ", "), batter_text, target_text))
      }
    }
    
    if (goal_type == "Execution") {
      stat <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      pitch <- input[[paste0("pp_goal", goal_num, "_execution_pitch")]]
      if (is.null(stat) || stat == "" || is.null(pitch) || length(pitch) == 0) {
        return(paste0("Incomplete selection", batter_text, target_text))
      }
      return(paste0(stat, " - Pitch: ", paste(pitch, collapse = ", "), batter_text, target_text))
    }
    
    return(paste0("Invalid goal configuration", batter_text, target_text))
  }
  
  # ========== PLAYER PLANS CHART AND TABLE RENDERS ==========
  
  # Helper function to create execution heatmaps
  create_execution_heatmap <- function(df, stat) {
    if (is.null(df) || nrow(df) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No data available") +
               theme_void())
    }
    
    # Create heatmap based on stat type - using advanced Pitching Suite implementation
    if (stat == "FPS%") {
      # FPS% - show frequency of first pitch locations
      fps_df <- df %>%
        dplyr::filter(Balls == 0 & Strikes == 0)
      
      if (nrow(fps_df) == 0) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "No first pitch data available") +
                 theme_void())
      }
      
      # Use adaptive KDE for frequency
      grid <- make_kde_grid(fps_df$PlateLocSide, fps_df$PlateLocHeight, n = 200)
      
      if (!nrow(grid)) return(ggplot() + theme_void())
      
      # Normalize KDE values to 0-100 scale
      grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "First Pitch Frequency",
                       scale_limits = c(0, 80)))
      
    }
    
    # Filter for finite plate location data for non-Frequency stats
    df_loc <- df %>%
      dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight))
    
    if (nrow(df_loc) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No location data available") +
               theme_void())
    }
    
    if (stat == "E+A%") {
      # E+A% (Excellent + Advantage) - rate heatmap
      df_loc <- df_loc %>%
        dplyr::mutate(
          ExcellentAdv = dplyr::case_when(
            Balls == 0 & Strikes == 0 & PitchCall %in% c("StrikeCalled", "StrikeSwinging", "FoulBall", "FoulBallFieldable", "FoulBallNotFieldable") ~ TRUE,
            (Strikes > Balls) & PitchCall %in% c("StrikeCalled", "StrikeSwinging", "FoulBall", "FoulBallFieldable", "FoulBallNotFieldable", "InPlay") ~ TRUE,
            TRUE ~ FALSE
          )
        )
      
      numerator_cond <- df_loc$ExcellentAdv
      grid <- make_rate_grid(df_loc, numerator_cond, denominator_condition = NULL, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "Insufficient data") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "E+A%",
                       scale_limits = c(0, 100)))
      
    } else if (stat == "InZone%") {
      # InZone% - rate heatmap
      in_zone_cond <- !is.na(df_loc$PlateLocSide) & !is.na(df_loc$PlateLocHeight) &
        df_loc$PlateLocSide >= ZONE_LEFT & df_loc$PlateLocSide <= ZONE_RIGHT &
        df_loc$PlateLocHeight >= ZONE_BOTTOM & df_loc$PlateLocHeight <= ZONE_TOP
      
      grid <- make_rate_grid(df_loc, in_zone_cond, denominator_condition = NULL, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "Insufficient data") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "InZone%",
                       scale_limits = c(0, 100)))
      
    } else if (stat == "Strike%") {
      # Strike% - rate heatmap
      strike_calls <- c("StrikeCalled", "StrikeSwinging", "FoulBall", "FoulBallFieldable", "FoulBallNotFieldable", "InPlay")
      strike_cond <- df_loc$PitchCall %in% strike_calls
      
      grid <- make_rate_grid(df_loc, strike_cond, denominator_condition = NULL, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "Insufficient data") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "Strike%",
                       scale_limits = c(0, 100)))
      
    } else if (stat == "Comp%") {
      # Comp% (Competitive pitches) - rate heatmap
      comp_cond <- !is.na(df_loc$PlateLocSide) & !is.na(df_loc$PlateLocHeight) &
        df_loc$PlateLocSide >= (ZONE_LEFT - 0.5) & df_loc$PlateLocSide <= (ZONE_RIGHT + 0.5) &
        df_loc$PlateLocHeight >= (ZONE_BOTTOM - 0.5) & df_loc$PlateLocHeight <= (ZONE_TOP + 0.5)
      
      grid <- make_rate_grid(df_loc, comp_cond, denominator_condition = NULL, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "Insufficient data") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "Comp%",
                       scale_limits = c(0, 100)))
      
    } else if (stat == "Whiff%") {
      # Whiff% - rate heatmap (whiffs per swing opportunity)
      swing_events <- c("StrikeSwinging", "FoulBall", "FoulBallFieldable", 
                        "FoulBallNotFieldable", "InPlay")
      whiff_events <- c("StrikeSwinging")
      
      numerator_cond <- df_loc$PitchCall %in% whiff_events
      denominator_cond <- df_loc$PitchCall %in% swing_events
      
      grid <- make_rate_grid(df_loc, numerator_cond, denominator_cond, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "No swing data available") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "Whiff%",
                       scale_limits = c(0, 100)))
      
    } else if (stat == "CSW%") {
      # CSW% - called strikes + whiffs per opportunity (rate heatmap)
      csw_calls <- c("StrikeCalled", "StrikeSwinging")
      
      numerator_cond <- df_loc$PitchCall %in% csw_calls
      grid <- make_rate_grid(df_loc, numerator_cond, denominator_condition = NULL, 
                             bin_size = 0.4, min_sample = 1)
      
      if (!nrow(grid)) {
        return(ggplot() + 
                 annotate("text", x = 0.5, y = 0.5, label = "No CSW data available") +
                 theme_void())
      }
      
      grid <- smooth_grid(grid, n = 120, x_range = c(-3.5, 3.5), y_range = c(-0.5, 5))
      breaks <- seq(0, 100, length.out = HEAT_BINS + 1)
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr_no_white, 
                       breaks = breaks, mark_max = FALSE,
                       show_scale = TRUE, scale_label = "CSW%",
                       scale_limits = c(0, 100)))
      
    } else {
      # For all other execution stats, show frequency heatmap with advanced KDE
      grid <- make_kde_grid(df_loc$PlateLocSide, df_loc$PlateLocHeight, n = 200)
      
      if (!nrow(grid)) return(ggplot() + theme_void())
      
      # Normalize KDE values to 0-100 scale
      grid$z <- (grid$z / max(grid$z, na.rm = TRUE)) * 100
      
      return(draw_heat(grid, bins = HEAT_BINS, pal_fun = heat_pal_bwr, mark_max = FALSE,
                       show_scale = TRUE, scale_label = paste(stat, "Frequency"),
                       scale_limits = c(0, 80)))
    }
  }
  
  # Helper: pitch map (matches Pitching summary girafe)
  create_execution_pitch_map <- function(df) {
    if (is.null(df) || nrow(df) == 0) {
      return(ggplot() +
               annotate("text", x = 0.5, y = 0.5, label = "No data available") +
               theme_void())
    }
    dark_on <- FALSE
    try({
      dom <- shiny::getDefaultReactiveDomain()
      if (!is.null(dom) && !is.null(dom$input$dark_mode)) dark_on <- isTRUE(dom$input$dark_mode)
    }, silent = TRUE)
    line_col <- if (dark_on) "#ffffff" else "black"
    grid_col <- if (dark_on) "#d1d5db" else "black"
    cols <- colors_for_mode(dark_on)
    df <- df %>%
      dplyr::filter(is.finite(PlateLocSide), is.finite(PlateLocHeight)) %>%
      dplyr::mutate(
        Result        = factor(compute_result(PitchCall, PlayResult), levels = result_levels),
        TaggedPitchType = as.character(TaggedPitchType),
        tt            = make_hover_tt(.),
        rid           = dplyr::row_number(),
        tt_fill       = dplyr::coalesce(cols[as.character(TaggedPitchType)], "gray")
      )
    if (!nrow(df)) {
      return(ggplot() +
               annotate("text", x = 0.5, y = 0.5, label = "No location data available") +
               theme_void())
    }
    types_chr <- intersect(names(cols), unique(df$TaggedPitchType))
    home <- data.frame(x = c(-0.75, 0.75, 0.75, 0.00, -0.75),
                       y = c(1.05, 1.05, 1.15, 1.25, 1.15) - 0.5)
    cz <- data.frame(xmin = -1.5, xmax = 1.5, ymin = 2.65 - 1.5, ymax = 2.65 + 1.5)
    sz <- data.frame(xmin = ZONE_LEFT, xmax = ZONE_RIGHT, ymin = ZONE_BOTTOM, ymax = ZONE_TOP)
    df_known <- dplyr::filter(df, !is.na(Result))
    df_other <- dplyr::filter(df,  is.na(Result))
    
    p <- ggplot() +
      geom_polygon(data = home, aes(x, y), fill = NA, color = line_col, inherit.aes = FALSE) +
      geom_rect(data = cz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = line_col, linetype = "dashed", inherit.aes = FALSE) +
      geom_rect(data = sz, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
                fill = NA, color = line_col, inherit.aes = FALSE) +
      
      ggiraph::geom_point_interactive(
        data = df_other,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 4.0, alpha = 0.95, shape = 16, stroke = 0.6
      ) +
      ggiraph::geom_point_interactive(
        data = df_known,
        aes(PlateLocSide, PlateLocHeight,
            color = TaggedPitchType, fill = TaggedPitchType, shape = Result,
            tooltip = tt, data_id = rid),
        position = "identity",
        size = 4.0, alpha = 0.95, stroke = 0.8
      ) +
      scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
      scale_fill_manual(values  = cols[types_chr], limits = types_chr, name = NULL) +
      scale_shape_manual(values = shape_map, drop = TRUE, name = NULL) +
      coord_fixed(ratio = 1, xlim = c(-3, 3), ylim = c(0.5, 5)) +
      theme_void() + theme(legend.position = "none",
                           panel.grid.major = element_blank(),
                           panel.grid.minor = element_blank()) +
      ggiraph::geom_point_interactive(
        data = df,
        aes(PlateLocSide, PlateLocHeight, tooltip = tt, data_id = rid, fill = I(tt_fill)),
        shape = 21, size = 6, alpha = 0.001, stroke = 0, inherit.aes = FALSE
      )
    
    girafe_transparent(
      ggobj = p,
      options = list(
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  }
  
  # Helper: movement plot for Stuff goals
  create_pp_movement_plot <- function(df, goal_num = NULL) {
    if (is.null(df) || nrow(df) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No data available") +
               theme_void())
    }
    dark_on <- FALSE
    try({
      dom <- shiny::getDefaultReactiveDomain()
      if (!is.null(dom) && !is.null(dom$input$dark_mode)) dark_on <- isTRUE(dom$input$dark_mode)
    }, silent = TRUE)
    axis_col <- if (dark_on) "#e5e7eb" else "black"
    line_col <- if (dark_on) "#ffffff" else "gray"
    grid_col <- adjustcolor(if (dark_on) "white" else "black",
                            alpha.f = if (dark_on) 0.18 else 0.12)
    cols <- colors_for_mode(dark_on)
    types_chr <- intersect(names(cols), unique(as.character(df$TaggedPitchType)))
    df_mv <- df %>%
      dplyr::filter(is.finite(InducedVertBreak), is.finite(HorzBreak)) %>%
      dplyr::mutate(
        TaggedPitchType = as.character(TaggedPitchType),
        HB_adj = ifelse(PitcherThrows == "Left", HorzBreak, -HorzBreak),
        tt     = make_hover_tt(.),
        rid    = dplyr::row_number()
      )
    if (!nrow(df_mv)) {
      return(ggplot() +
               annotate("text", x = 0.5, y = 0.5, label = "No movement data available") +
               theme_void())
    }
    # Movement plot display options (mirror summary page)
    display_opts <- NULL
    if (!is.null(goal_num)) {
      display_opts <- input[[paste0("pp_goal", goal_num, "_movement_display")]]
    }
    if (is.null(display_opts)) display_opts <- "Averages and Pitches"
    show_pitches  <- any(c("Averages and Pitches", "Target Shapes and Pitches") %in% display_opts)
    show_averages <- any(c("Averages Only", "Averages and Pitches") %in% display_opts)
    show_targets  <- any(c("Target Shapes Only", "Target Shapes and Pitches") %in% display_opts)
    
    # Re-render when target shapes change
    target_shapes_version()
    
    # Target shapes overlay (shared across pages)
    target_df <- NULL
    pitcher_name <- input$pp_player_select
    pitcher_hand <- dplyr::coalesce(df_mv$PitcherThrows[!is.na(df_mv$PitcherThrows)][1], "Right")
    if (show_targets && !is.null(pitcher_name) && pitcher_name != "" && pitcher_name != "All") {
      target_data <- lapply(types_chr, function(pt) {
        tgt <- get_target_shape(pitcher_name, pt, input$pp_date_range, auto_save = FALSE)
        if (is.null(tgt)) return(NULL)
        hb_plot <- ifelse(pitcher_hand == "Left", tgt$HB, -tgt$HB)
        data.frame(
          TaggedPitchType = pt,
          HB_Target = hb_plot,
          IVB_Target = tgt$IVB,
          stringsAsFactors = FALSE
        )
      })
      target_df <- dplyr::bind_rows(target_data)
    }
    # Averages per type (respect filters)
    avg_mov <- df_mv %>%
      dplyr::group_by(TaggedPitchType) %>%
      dplyr::summarise(
        avg_HorzBreak = mean(HB_adj, na.rm = TRUE),
        avg_IVB       = mean(InducedVertBreak, na.rm = TRUE),
        .groups = "drop"
      )
    
    p <- ggplot() +
      geom_hline(yintercept = 0, color = line_col, linewidth = 0.7) +
      geom_vline(xintercept = 0, color = line_col, linewidth = 0.7) +
      { if (show_averages) ggiraph::geom_point_interactive(
        data = avg_mov %>% dplyr::filter(TaggedPitchType %in% types_chr),
        aes(x = avg_HorzBreak, y = avg_IVB, color = TaggedPitchType,
            tooltip = paste0(TaggedPitchType, "<br>IVB: ", round(avg_IVB,1),
                             " in<br>HB: ", round(avg_HorzBreak,1), " in"),
            data_id = TaggedPitchType),
        size = 8, show.legend = FALSE
      ) } +
      { if (show_pitches) ggiraph::geom_point_interactive(
        data = df_mv %>% dplyr::filter(TaggedPitchType %in% types_chr),
        aes(x = HB_adj, y = InducedVertBreak, color = TaggedPitchType,
            tooltip = tt, data_id = rid),
        size = 3.2, alpha = 0.9, show.legend = FALSE
      ) } +
      { if (!is.null(target_df) && nrow(target_df) > 0) {
        list(
          geom_point(
            data = target_df,
            aes(x = HB_Target, y = IVB_Target, fill = TaggedPitchType),
            size = 12, shape = 21, alpha = 0.10, stroke = 0, show.legend = FALSE
          ),
          geom_point(
            data = target_df,
            aes(x = HB_Target, y = IVB_Target, color = TaggedPitchType),
            size = 12, shape = 21, alpha = 0.8, stroke = 2, fill = NA, show.legend = FALSE
          )
        )
      } } +
      scale_color_manual(values = cols[types_chr], limits = types_chr, name = NULL) +
      theme_minimal() + axis_theme + grid_theme(dark_on) +
      labs(x = NULL, y = NULL, title = "Movement Plot") +
      theme(
        legend.position = "none",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 15, face = "bold", color = axis_col),
        axis.text.y = element_text(size = 15, face = "bold", color = axis_col),
        panel.grid.major = element_line(color = grid_col),
        panel.grid.minor = element_blank(),
        axis.ticks = element_blank()
      ) +
      coord_cartesian(xlim = c(-25, 25), ylim = c(-25, 25))
    
    girafe_transparent(
      ggobj = p,
      width_svg = 8, height_svg = 6.5,
      options = list(
        ggiraph::opts_sizing(rescale = TRUE),
        ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css),
        ggiraph::opts_hover(css = "stroke:black;stroke-width:1.5px;"),
        ggiraph::opts_hover_inv(css = "opacity:0.15;")
      )
    )
  }
  
  # Helper function to make KDE grid
  make_kde_grid <- function(x, y, lims = c(-2.5,2.5,0,4.5), n = 180) {
    ok <- is.finite(x) & is.finite(y)
    x <- x[ok]; y <- y[ok]
    if (length(x) < 2 || length(unique(x)) < 2 || length(unique(y)) < 2) {
      return(data.frame(x = numeric(0), y = numeric(0), z = numeric(0)))
    }
    d <- MASS::kde2d(x, y, n = n, lims = lims)
    expand.grid(x = d$x, y = d$y) |> transform(z = as.vector(d$z))
  }
  
  # Helper function to filter data for a specific goal
  filter_goal_data <- function(goal_num) {
    req(input$pp_player_select, input$pp_date_range)
    
    # Get the player's data using whitelist-filtered dataset
    player_data <- pitch_data_pitching %>% 
      dplyr::filter(Pitcher == input$pp_player_select,
                    Date >= input$pp_date_range[1],
                    Date <= input$pp_date_range[2]) %>%
      dplyr::mutate(
        SessionType = dplyr::case_when(
          grepl("bull|prac", tolower(as.character(SessionType))) ~ "Bullpen",
          grepl("live|game|ab", tolower(as.character(SessionType))) ~ "Live",
          TRUE ~ as.character(SessionType)
        )
      )
    
    # Add pitch type filtering based on goal type and category
    goal_type <- input[[paste0("pp_goal", goal_num, "_type")]]
    # Batter hand filter (applies to all goal types)
    batter_hand <- input[[paste0("pp_goal", goal_num, "_batter_hand")]]
    if (!is.null(batter_hand) && batter_hand %in% c("Left", "Right")) {
      player_data <- player_data %>% dplyr::filter(as.character(BatterSide) == batter_hand)
    }
    
    if (!is.null(goal_type) && goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      
      if (!is.null(category)) {
        if (category == "Velocity") {
          pitch <- input[[paste0("pp_goal", goal_num, "_velocity_pitch")]]
          if (!is.null(pitch) && pitch != "" && pitch != "All") {
            player_data <- player_data %>% dplyr::filter(TaggedPitchType == pitch)
          }
        } else if (category == "Movement") {
          pitch <- input[[paste0("pp_goal", goal_num, "_movement_pitch")]]
          if (!is.null(pitch) && pitch != "" && pitch != "All") {
            player_data <- player_data %>% dplyr::filter(TaggedPitchType == pitch)
          }
        }
      }
    } else if (!is.null(goal_type) && goal_type == "Execution") {
      pitch <- input[[paste0("pp_goal", goal_num, "_execution_pitch")]]
      if (!is.null(pitch) && pitch != "" && pitch != "All") {
        player_data <- player_data %>% dplyr::filter(TaggedPitchType == pitch)
      }
    }
    
    return(player_data)
  }
  
  # Helper function to calculate metric for goal
  calculate_metric <- function(df, goal_num) {
    if (is.null(df) || nrow(df) == 0) return(NULL)
    
    goal_type <- input[[paste0("pp_goal", goal_num, "_type")]]
    
    if (goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      
      if (category == "Velocity") {
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   value = round(mean(RelSpeed, na.rm = TRUE), 1),
                   .groups = 'drop'
                 ) %>%
                 dplyr::distinct(Date, SessionType, .keep_all = TRUE) %>%
                 dplyr::arrange(Date))
      } else if (category == "Movement") {
        movement_types <- input[[paste0("pp_goal", goal_num, "_movement_type")]]
        
        if ("IVB" %in% movement_types && "HB" %in% movement_types) {
          # Calculate combined movement metric (could be magnitude)
          return(df %>%
                   dplyr::group_by(Date, SessionType) %>%
                   dplyr::summarise(
                     ivb = mean(InducedVertBreak, na.rm = TRUE),
                     hb = mean(HorzBreak, na.rm = TRUE),
                     value = round(sqrt(ivb^2 + hb^2), 1),
                     .groups = 'drop'
                   ) %>%
                   dplyr::distinct(Date, SessionType, .keep_all = TRUE) %>%
                   dplyr::arrange(Date))
        } else if ("IVB" %in% movement_types) {
          return(df %>%
                   dplyr::group_by(Date, SessionType) %>%
                   dplyr::summarise(
                     value = round(mean(InducedVertBreak, na.rm = TRUE), 1),
                     .groups = 'drop'
                   ) %>%
                   dplyr::distinct(Date, SessionType, .keep_all = TRUE) %>%
                   dplyr::arrange(Date))
        } else if ("HB" %in% movement_types) {
          return(df %>%
                   dplyr::group_by(Date, SessionType) %>%
                   dplyr::summarise(
                     value = round(mean(HorzBreak, na.rm = TRUE), 1),
                     .groups = 'drop'
                   ) %>%
                   dplyr::distinct(Date, SessionType, .keep_all = TRUE) %>%
                   dplyr::arrange(Date))
        }
      }
    } else if (goal_type == "Execution") {
      stat <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      
      # Calculate different execution stats using the same logic as pitching suite
      if (stat == "FPS%") {
        # FPS% = First pitch strikes in Live sessions / Total first pitches in Live sessions
        return(df %>%
                 dplyr::filter(SessionType == "Live") %>%
                 dplyr::group_by(Date) %>%
                 dplyr::summarise(
                   bf_live = sum(Balls == 0 & Strikes == 0, na.rm = TRUE),
                   fps_live = sum(Balls == 0 & Strikes == 0 &
                                    PitchCall %in% c("InPlay", "StrikeSwinging", "StrikeCalled", "FoulBallNotFieldable", "FoulBallFieldable"), 
                                  na.rm = TRUE),
                   value = ifelse(bf_live > 0, round(100 * fps_live / bf_live, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::mutate(SessionType = "Live") %>%
                 dplyr::select(Date, SessionType, value) %>%
                 dplyr::arrange(Date))
      } else if (stat == "Strike%") {
        # Strike% = All strikes / Total pitches
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   total_pitches = n(),
                   strikes = sum(PitchCall %in% c("StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "InPlay", "FoulBallFieldable"), na.rm = TRUE),
                   value = ifelse(total_pitches > 0, round(100 * strikes / total_pitches, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "InZone%") {
        # InZone% = Pitches in strike zone / Total pitches with location
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   total_located = sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight), na.rm = TRUE),
                   in_zone = sum(PlateLocSide >= -0.83 & PlateLocSide <= 0.83 & 
                                   PlateLocHeight >= 1.5 & PlateLocHeight <= 3.5, na.rm = TRUE),
                   value = ifelse(total_located > 0, round(100 * in_zone / total_located, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "Comp%") {
        # Comp% = Competitive pitches / Total pitches with location (competitive zone is larger than strike zone)
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   total_located = sum(!is.na(PlateLocSide) & !is.na(PlateLocHeight), na.rm = TRUE),
                   competitive = sum(PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                                       PlateLocHeight >= (2.65-1.5) & PlateLocHeight <= (2.65+1.5), na.rm = TRUE),
                   value = ifelse(total_located > 0, round(100 * competitive / total_located, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "QP%") {
        # QP% = Share of pitches with QP+ >= 100 (using compute_qp_points)
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   qp_vals  = list(compute_qp_points(dplyr::cur_data_all())),
                   qp_count = {
                     vals <- unlist(qp_vals)
                     sum((vals * 200) >= 100, na.rm = TRUE)
                   },
                   total_pitches = dplyr::n(),
                   value = ifelse(total_pitches > 0, round(100 * qp_count / total_pitches, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::select(-qp_vals) %>%
                 dplyr::arrange(Date))
      } else if (stat == "Whiff%") {
        # Whiff% = Swinging strikes / Total swings
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   total_swings = sum(PitchCall %in% c("StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable", "InPlay"), na.rm = TRUE),
                   swinging_strikes = sum(PitchCall == "StrikeSwinging", na.rm = TRUE),
                   value = ifelse(total_swings > 0, round(100 * swinging_strikes / total_swings, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "CSW%") {
        # CSW% = Called Strikes + Whiffs / Total pitches
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   total_pitches = n(),
                   csw = sum(PitchCall %in% c("StrikeCalled", "StrikeSwinging"), na.rm = TRUE),
                   value = ifelse(total_pitches > 0, round(100 * csw / total_pitches, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "E+A%") {
        # E+A% = Early Advantage pitches in Live sessions / Total batters faced in Live
        return(df %>%
                 dplyr::filter(SessionType == "Live") %>%
                 dplyr::group_by(Date) %>%
                 dplyr::summarise(
                   bf_live = sum(Balls == 0 & Strikes == 0, na.rm = TRUE),
                   ea_live = sum((Balls == 0 & Strikes == 0 & PitchCall == "InPlay") |
                                   (Balls == 0 & Strikes == 1 & PitchCall %in% c("InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable")) |
                                   (Balls == 1 & Strikes == 0 & PitchCall == "InPlay") |
                                   (Balls == 1 & Strikes == 1 & PitchCall %in% c("InPlay", "StrikeCalled", "StrikeSwinging", "FoulBallNotFieldable", "FoulBallFieldable")),
                                 na.rm = TRUE),
                   value = ifelse(bf_live > 0, round(100 * ea_live / bf_live, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::mutate(SessionType = "Live") %>%
                 dplyr::select(Date, SessionType, value) %>%
                 dplyr::arrange(Date))
      } else if (stat == "K%") {
        # K% = Strikeouts in Live sessions / Total batters faced in Live
        return(df %>%
                 dplyr::filter(SessionType == "Live") %>%
                 dplyr::group_by(Date) %>%
                 dplyr::summarise(
                   bf_live = sum(Balls == 0 & Strikes == 0, na.rm = TRUE),
                   k_live = sum(KorBB == "Strikeout", na.rm = TRUE),
                   value = ifelse(bf_live > 0, round(100 * k_live / bf_live, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::mutate(SessionType = "Live") %>%
                 dplyr::select(Date, SessionType, value) %>%
                 dplyr::arrange(Date))
      } else if (stat == "BB%") {
        # BB% = Walks in Live sessions / Total batters faced in Live
        return(df %>%
                 dplyr::filter(SessionType == "Live") %>%
                 dplyr::group_by(Date) %>%
                 dplyr::summarise(
                   bf_live = sum(Balls == 0 & Strikes == 0, na.rm = TRUE),
                   bb_live = sum(KorBB == "Walk", na.rm = TRUE),
                   value = ifelse(bf_live > 0, round(100 * bb_live / bf_live, 1), 0),
                   .groups = 'drop'
                 ) %>%
                 dplyr::mutate(SessionType = "Live") %>%
                 dplyr::select(Date, SessionType, value) %>%
                 dplyr::arrange(Date))
      } else if (stat == "Ctrl+") {
        # Ctrl+ = Control scores * 100 (strike zone = 1.47, competitive zone = 0.73, outside = 0)
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   ctrl_score = mean(ifelse(
                     PlateLocSide >= -0.88 & PlateLocSide <= 0.88 &
                       PlateLocHeight >= 1.5 & PlateLocHeight <= 3.6, 1.47,
                     ifelse(
                       PlateLocSide >= -1.5 & PlateLocSide <= 1.5 &
                         PlateLocHeight >= (2.65-1.5) & PlateLocHeight <= (2.65+1.5), 0.73, 0
                     )
                   ), na.rm = TRUE),
                   value = round(ctrl_score * 100, 1),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else if (stat == "QP+") {
        # QP+ = Quality of Pitch points * 200 (using compute_qp_points function)
        return(df %>%
                 dplyr::group_by(Date, SessionType) %>%
                 dplyr::summarise(
                   qp_points = mean(compute_qp_points(dplyr::cur_data_all()), na.rm = TRUE),
                   value = round(qp_points * 200, 1),
                   .groups = 'drop'
                 ) %>%
                 dplyr::arrange(Date))
      } else {
        # For other stats, return NULL
        return(NULL)
      }
    }
    
    return(NULL)
  }
  
  # Helper function to create plots
  create_pp_goal_plot <- function(goal_num) {
    df <- filter_goal_data(goal_num)
    if (is.null(df)) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No data available") +
               theme_void())
    }
    
    goal_type <- input[[paste0("pp_goal", goal_num, "_type")]]
    
    # Chart-view routing
    chart_view <- input[[paste0("pp_goal", goal_num, "_chart_view")]]
    if (goal_type == "Execution") {
      stat <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      if (!is.null(chart_view) && chart_view == "Heatmap" && !is.null(stat) && stat != "") {
        return(create_execution_heatmap(df, stat))
      } else if (!is.null(chart_view) && chart_view == "Pitch Map") {
        return(create_execution_pitch_map(df))
      }
    } else if (goal_type == "Stuff" && !is.null(chart_view)) {
      if (chart_view == "Pitch Map") {
        return(create_execution_pitch_map(df))
      } else if (chart_view == "Movement Plot") {
        return(create_pp_movement_plot(df, goal_num))
      }
    }
    
    # For all other cases, create trend chart
    metric_data <- calculate_metric(df, goal_num)
    if (is.null(metric_data) || nrow(metric_data) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No metric data available") +
               theme_void())
    }
    
    # Determine y-axis label
    y_label <- "Value"
    if (goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      if (category == "Velocity") {
        y_label <- "Velocity (mph)"
      } else if (category == "Movement") {
        movement_types <- input[[paste0("pp_goal", goal_num, "_movement_type")]]
        if (length(movement_types) == 1) {
          y_label <- paste(movement_types[1], "(inches)")
        } else {
          y_label <- "Movement Magnitude (inches)"
        }
      }
    } else if (goal_type == "Execution") {
      stat <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      y_label <- stat
    }
    
    # Get target information
    target_direction <- input[[paste0("pp_goal", goal_num, "_target_direction")]]
    target_value <- input[[paste0("pp_goal", goal_num, "_target_value")]]
    
    # Extract numeric value from target_value if it exists
    target_numeric <- NULL
    if (!is.null(target_value) && !is.null(target_direction) && 
        target_value != "" && target_direction != "") {
      # Extract numeric part from target_value (remove %, mph, etc.)
      target_clean <- gsub("[^0-9.-]", "", target_value)
      if (nzchar(target_clean)) {
        target_numeric <- as.numeric(target_clean)
      }
    }
    
    # Evenly spaced dates on x-axis (treat each date as a step)
    metric_data <- metric_data %>%
      dplyr::arrange(Date)
    unique_dates <- sort(unique(metric_data$Date))
    date_map <- setNames(seq_along(unique_dates), as.character(unique_dates))
    metric_data <- metric_data %>%
      dplyr::mutate(date_idx = date_map[as.character(Date)])
    
    # Create base plot with Live/Bullpen color coding
    p <- ggplot(metric_data, aes(x = date_idx, y = value, color = SessionType)) +
      geom_point(size = 2) +
      geom_line(aes(group = SessionType), size = 1) +
      scale_color_manual(values = c("Bullpen" = "black", "Live" = "red")) +
      scale_x_continuous(
        breaks = seq_along(unique_dates),
        labels = format(unique_dates, "%m/%d"),
        expand = expansion(mult = c(0.05, 0.05))
      )
    
    # Add target line if target is set and numeric
    if (!is.null(target_numeric) && is.finite(target_numeric)) {
      p <- p + geom_hline(yintercept = target_numeric, 
                          color = "black", 
                          linetype = "dashed", 
                          alpha = 0.6, 
                          size = 1.2)
    }
    
    # Determine chart title based on goal configuration
    chart_title <- "Goal Trend"
    if (goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      if (!is.null(category) && category != "") {
        if (category == "Velocity") {
          pitch <- input[[paste0("pp_goal", goal_num, "_velocity_pitch")]]
          if (!is.null(pitch) && pitch != "") {
            chart_title <- paste(pitch, "Velocity")
          } else {
            chart_title <- "Velocity"
          }
        } else if (category == "Movement") {
          pitch <- input[[paste0("pp_goal", goal_num, "_movement_pitch")]]
          movement <- input[[paste0("pp_goal", goal_num, "_movement_type")]]
          if (!is.null(pitch) && pitch != "" && !is.null(movement) && length(movement) > 0) {
            chart_title <- paste(pitch, paste(movement, collapse = " & "))
          } else {
            chart_title <- "Movement"
          }
        }
      }
    } else if (goal_type == "Execution") {
      stat <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      if (!is.null(stat) && stat != "") {
        chart_title <- stat
      } else {
        chart_title <- "Execution"
      }
    }
    
    p <- p + labs(
      title = chart_title,
      x = "Date",
      y = y_label,
      color = "Session Type"
    )
    
    dark_on <- isTRUE(input$dark_mode)
    p <- p +
      theme_minimal() +
      transparent_bg_theme +
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        panel.grid.minor = if (dark_on) element_blank() else NULL,
        panel.grid.major = if (dark_on) element_line(color = "gray40", linewidth = 0.3) else NULL
      )
    
    return(p)
  }
  
  # Helper function to create data tables
  create_pp_goal_table <- function(goal_num) {
    metric_data <- calculate_metric(filter_goal_data(goal_num), goal_num)
    if (is.null(metric_data) || nrow(metric_data) == 0) {
      return(data.frame(Date = character(0), Value = character(0)))
    }
    
    # Get the goal type and determine column name
    goal_type <- input[[paste0("pp_goal", goal_num, "_type")]]
    column_name <- "Value"
    
    if (goal_type == "Stuff") {
      category <- input[[paste0("pp_goal", goal_num, "_stuff_category")]]
      if (category == "Velocity") {
        column_name <- "Velocity"
      } else if (category == "Movement") {
        movement_types <- input[[paste0("pp_goal", goal_num, "_movement_type")]]
        if (length(movement_types) > 1) {
          column_name <- "Movement"
        } else if ("IVB" %in% movement_types) {
          column_name <- "IVB"
        } else if ("HB" %in% movement_types) {
          column_name <- "HB"
        }
      }
    } else if (goal_type == "Execution") {
      category <- input[[paste0("pp_goal", goal_num, "_execution_stat")]]
      if (category == "FPS%") {
        column_name <- "FPS%"
      } else if (category == "Strike%") {
        column_name <- "Strike%"
      } else if (category == "InZone%") {
        column_name <- "InZone%"
      } else if (category == "Comp%") {
        column_name <- "Comp%"
      } else if (category == "Whiff%") {
        column_name <- "Whiff%"
      } else if (category == "CSW%") {
        column_name <- "CSW%"
      } else if (category == "E+A%") {
        column_name <- "E+A%"
      } else if (category == "K%") {
        column_name <- "K%"
      } else if (category == "BB%") {
        column_name <- "BB%"
      } else if (category == "QP+") {
        column_name <- "QP+"
      } else if (category == "Ctrl+") {
        column_name <- "Ctrl+"
      }
    }
    
    # Create table with date and formatted value
    table_data <- metric_data %>%
      dplyr::mutate(
        formatted_value = case_when(
          SessionType == "Bullpen" ~ paste0(value, " (B)"),
          SessionType == "Live" ~ paste0(value, " (L)"),
          TRUE ~ as.character(value)
        ),
        Date = format(Date, "%m/%d")
      ) %>%
      dplyr::select(Date, formatted_value) %>%
      dplyr::arrange(desc(as.Date(paste0("2025/", Date), format = "%Y/%m/%d")))
    
    # Set column names
    colnames(table_data) <- c("Date", column_name)
    
    return(table_data)
  }
  
  # Goal plot renders (girafe)
  output$pp_goal1_plot <- ggiraph::renderGirafe({
    p <- create_pp_goal_plot(1)
    if (inherits(p, "girafe")) return(p)
    if (inherits(p, "ggplot")) return(girafe_transparent(ggobj = p, options = list(ggiraph::opts_sizing(rescale = TRUE))))
    NULL
  })
  
  output$pp_goal2_plot <- ggiraph::renderGirafe({
    p <- create_pp_goal_plot(2)
    if (inherits(p, "girafe")) return(p)
    if (inherits(p, "ggplot")) return(girafe_transparent(ggobj = p, options = list(ggiraph::opts_sizing(rescale = TRUE))))
    NULL
  })
  
  output$pp_goal3_plot <- ggiraph::renderGirafe({
    p <- create_pp_goal_plot(3)
    if (inherits(p, "girafe")) return(p)
    if (inherits(p, "ggplot")) return(girafe_transparent(ggobj = p, options = list(ggiraph::opts_sizing(rescale = TRUE))))
    NULL
  })
  
  # Goal table renders
  output$pp_goal1_table <- DT::renderDataTable({
    table_data <- create_pp_goal_table(1)
    if (nrow(table_data) == 0) return(table_data)
    
    dt <- DT::datatable(
      table_data,
      options = list(
        pageLength = 5,
        searching = FALSE,
        info = FALSE,
        lengthChange = FALSE,
        ordering = FALSE,
        columnDefs = list(list(className = 'dt-center', targets = '_all'))
      ), 
      rownames = FALSE
    )
    
    # Apply color formatting if data exists
    if (ncol(table_data) >= 2) {
      column_name <- colnames(table_data)[2]
      bullpen_values <- table_data[[column_name]][grepl("\\(B\\)", table_data[[column_name]])]
      live_values <- table_data[[column_name]][grepl("\\(L\\)", table_data[[column_name]])]
      
      if (length(bullpen_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(bullpen_values, rep("black", length(bullpen_values)))
        )
      }
      
      if (length(live_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(live_values, rep("red", length(live_values)))
        )
      }
    }
    
    return(dt)
  })
  
  output$pp_goal2_table <- DT::renderDataTable({
    table_data <- create_pp_goal_table(2)
    if (nrow(table_data) == 0) return(table_data)
    
    dt <- DT::datatable(
      table_data,
      options = list(
        pageLength = 5,
        searching = FALSE,
        info = FALSE,
        lengthChange = FALSE,
        ordering = FALSE,
        columnDefs = list(list(className = 'dt-center', targets = '_all'))
      ), 
      rownames = FALSE
    )
    
    # Apply color formatting if data exists
    if (ncol(table_data) >= 2) {
      column_name <- colnames(table_data)[2]
      bullpen_values <- table_data[[column_name]][grepl("\\(B\\)", table_data[[column_name]])]
      live_values <- table_data[[column_name]][grepl("\\(L\\)", table_data[[column_name]])]
      
      if (length(bullpen_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(bullpen_values, rep("black", length(bullpen_values)))
        )
      }
      
      if (length(live_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(live_values, rep("red", length(live_values)))
        )
      }
    }
    
    return(dt)
  })
  
  output$pp_goal3_table <- DT::renderDataTable({
    table_data <- create_pp_goal_table(3)
    if (nrow(table_data) == 0) return(table_data)
    
    dt <- DT::datatable(
      table_data,
      options = list(
        pageLength = 5,
        searching = FALSE,
        info = FALSE,
        lengthChange = FALSE,
        ordering = FALSE,
        columnDefs = list(list(className = 'dt-center', targets = '_all'))
      ), 
      rownames = FALSE
    )
    
    # Apply color formatting if data exists
    if (ncol(table_data) >= 2) {
      column_name <- colnames(table_data)[2]
      bullpen_values <- table_data[[column_name]][grepl("\\(B\\)", table_data[[column_name]])]
      live_values <- table_data[[column_name]][grepl("\\(L\\)", table_data[[column_name]])]
      
      if (length(bullpen_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(bullpen_values, rep("black", length(bullpen_values)))
        )
      }
      
      if (length(live_values) > 0) {
        dt <- dt %>% DT::formatStyle(
          column_name,
          color = DT::styleEqual(live_values, rep("red", length(live_values)))
        )
      }
    }
    
    return(dt)
  })
  
  # ============== END PLAYER PLANS SERVER LOGIC ==============
  
  
  # ---- Stuff+ Calculator (uses original compute_stuff_simple) ----
  # HB_adj display helper (hand-agnostic: arm-side positive)
  hb_adj_text <- function(hand, hb) {
    if (is.null(hand) || is.null(hb) || is.na(hand) || is.na(hb)) return("")
    adj <- if (hand == "Left") hb else -hb
    sprintf("%.1f", adj)
  }
  
  # Build a tiny df and call existing compute_stuff_simple() exactly as elsewhere
  stuff_calc_df <- function(pitch, hand, velo, ivb, hb, rh, level, base_type, base_vel, base_ivb, base_hb) {
    df <- data.frame(
      TaggedPitchType    = as.character(pitch),
      PitcherThrows      = as.character(hand),
      RelSpeed           = as.numeric(velo),
      InducedVertBreak   = as.numeric(ivb),
      HorzBreak          = as.numeric(hb),
      RelHeight          = as.numeric(rh),
      stringsAsFactors   = FALSE
    )
    # If off-speed, include a base FB/SI row so your function can derive context
    if (!(pitch %in% c("Fastball","Sinker"))) {
      df <- rbind(df, data.frame(
        TaggedPitchType    = as.character(base_type),
        PitcherThrows      = as.character(hand),
        RelSpeed           = as.numeric(base_vel),
        InducedVertBreak   = as.numeric(base_ivb),
        HorzBreak          = as.numeric(base_hb),
        RelHeight          = as.numeric(rh),
        stringsAsFactors   = FALSE
      ))
    }
    base_for <- if (pitch %in% c("Fastball","Sinker")) pitch else base_type
    out <- tryCatch({
      compute_stuff_simple(df, base_type = base_for, level = level)
    }, error = function(e) {
      df$`Stuff+` <- NA_real_
      df
    })
    as.numeric(out$`Stuff+`[1])
  }
  
  # Pitch A
  output$calc1_stuff <- renderText({
    val <- stuff_calc_df(
      input$calc1_pitch, input$calc1_hand, input$calc1_vel, input$calc1_ivb, input$calc1_hb,
      input$calc1_relheight, input$calc1_level,
      if (!isTruthy(input$calc1_base_type)) "Fastball" else input$calc1_base_type,
      if (!isTruthy(input$calc1_base_vel)) input$calc1_vel else input$calc1_base_vel,
      if (!isTruthy(input$calc1_base_ivb)) input$calc1_ivb else input$calc1_base_ivb,
      if (!isTruthy(input$calc1_base_hb))  input$calc1_hb  else input$calc1_base_hb
    )
    ifelse(is.finite(val), sprintf("Stuff+: %.1f", val), "Stuff+: —")
  })
  output$calc1_hb_adj <- renderText(hb_adj_text(input$calc1_hand, input$calc1_hb))
  
  # Pitch B
  output$calc2_stuff <- renderText({
    val <- stuff_calc_df(
      input$calc2_pitch, input$calc2_hand, input$calc2_vel, input$calc2_ivb, input$calc2_hb,
      input$calc2_relheight, input$calc2_level,
      if (!isTruthy(input$calc2_base_type)) "Fastball" else input$calc2_base_type,
      if (!isTruthy(input$calc2_base_vel)) input$calc2_vel else input$calc2_base_vel,
      if (!isTruthy(input$calc2_base_ivb)) input$calc2_ivb else input$calc2_base_ivb,
      if (!isTruthy(input$calc2_base_hb))  input$calc2_hb  else input$calc2_base_hb
    )
    ifelse(is.finite(val), sprintf("Stuff+: %.1f", val), "Stuff+: —")
  })
  output$calc2_hb_adj <- renderText(hb_adj_text(input$calc2_hand, input$calc2_hb))
  
  # ===== QP LOCATIONS SERVER LOGIC =====
  
  # Helper function to get pitcher handedness
  get_pitcher_handedness <- reactive({
    tryCatch({
      if (is.null(input$pitcher) || input$pitcher == "All") {
        # If "All" is selected, use the hand filter if it's not "All"
        if (!is.null(input$hand) && input$hand != "All") {
          return(input$hand)
        } else {
          return(NULL)  # No handedness available
        }
      } else {
        # Get the specific pitcher's handedness from the data
        df <- filtered_data()
        if (is.null(df) || nrow(df) == 0) return(NULL)
        
        pitcher_data <- df %>% 
          dplyr::filter(Pitcher == input$pitcher) %>%
          dplyr::slice(1)
        
        if (nrow(pitcher_data) > 0) {
          hand <- as.character(pitcher_data$PitcherThrows[1])
          if (!is.na(hand) && hand %in% c("Left", "Right")) {
            return(hand)
          }
        }
        
        # Fallback to hand filter if specific pitcher handedness not found
        if (!is.null(input$hand) && input$hand != "All") {
          return(input$hand)
        } else {
          return(NULL)
        }
      }
    }, error = function(e) {
      return(NULL)
    })
  })
  
  # Helper function to check if QP Locations should be shown
  should_show_qp_locations <- reactive({
    tryCatch({
      pitcher_hand <- get_pitcher_handedness()
      batter_hand <- input$batterSide
      
      # Need both pitcher and batter handedness to be non-"All"
      !is.null(pitcher_hand) && 
        !is.null(batter_hand) && 
        batter_hand != "All"
    }, error = function(e) {
      return(FALSE)
    })
  })
  
  # QP Locations message and content
  output$qpLocationsMessage <- renderUI({
    if (!should_show_qp_locations()) {
      div(style = "text-align: center; padding: 100px 20px; color: #999;",
          h4("QP+ Locations requires handedness selection"),
          p("Please select both pitcher handedness and batter handedness to view QP+ location charts."),
          if (is.null(get_pitcher_handedness())) {
            p("→ Pitcher handedness: Select a specific pitcher or set 'Pitcher Hand' filter")
          },
          if (is.null(input$batterSide) || input$batterSide == "All") {
            p("→ Batter handedness: Set 'Batter Hand' filter to 'Left' or 'Right'")
          }
      )
    } else {
      # Show the main content when conditions are met
      div(
        div(style = "margin-bottom: 20px;",
            h4("Behind Counts", style = "text-align: center; font-weight: bold;"),
            ggiraph::girafeOutput("qpLocationsBehind", height = "350px")
        ),
        div(style = "margin-bottom: 20px;",
            h4("Even Counts", style = "text-align: center; font-weight: bold;"),
            ggiraph::girafeOutput("qpLocationsEven", height = "350px")
        ),
        div(style = "margin-bottom: 20px;",
            h4("Ahead Counts", style = "text-align: center; font-weight: bold;"),
            ggiraph::girafeOutput("qpLocationsAhead", height = "350px")
        )
      )
    }
  })
  
  # CSS for QP Locations tooltips
  tooltip_css <- "color:#fff !important;font-weight:600;padding:6px;border-radius:8px;text-shadow:0 1px 1px rgba(0,0,0,.4);"
  
  # QP Locations Behind plot
  output$qpLocationsBehind <- ggiraph::renderGirafe({
    tryCatch({
      if (!should_show_qp_locations()) return(NULL)
      
      df <- filtered_data()
      if (!nrow(df)) return(NULL)
      
      pitcher_hand <- get_pitcher_handedness()
      batter_hand <- input$batterSide
      
      p <- create_qp_locations_plot(df, "Behind", pitcher_hand, batter_hand)
      
      girafe_transparent(
        ggobj = p,
        width_svg = 12, height_svg = 4,
        options = list(
          ggiraph::opts_hover_inv(css = "opacity:0.1;"),
          ggiraph::opts_hover(css = "stroke-width:2;"),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css,
                                opacity = 0.9
          )
        )
      )
    }, error = function(e) {
      message("Error in qpLocationsBehind: ", e$message)
      return(NULL)
    })
  })
  
  # QP Locations Even plot
  output$qpLocationsEven <- ggiraph::renderGirafe({
    tryCatch({
      if (!should_show_qp_locations()) return(NULL)
      
      df <- filtered_data()
      if (!nrow(df)) return(NULL)
      
      pitcher_hand <- get_pitcher_handedness()
      batter_hand <- input$batterSide
      
      p <- create_qp_locations_plot(df, "Even", pitcher_hand, batter_hand)
      
      girafe_transparent(
        ggobj = p,
        width_svg = 12, height_svg = 4,
        options = list(
          ggiraph::opts_hover_inv(css = "opacity:0.1;"),
          ggiraph::opts_hover(css = "stroke-width:2;"),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css,
                                opacity = 0.9
          )
        )
      )
    }, error = function(e) {
      message("Error in qpLocationsEven: ", e$message)
      return(NULL)
    })
  })
  
  # QP Locations Ahead plot
  output$qpLocationsAhead <- ggiraph::renderGirafe({
    tryCatch({
      if (!should_show_qp_locations()) return(NULL)
      
      df <- filtered_data()
      if (!nrow(df)) return(NULL)
      
      pitcher_hand <- get_pitcher_handedness()
      batter_hand <- input$batterSide
      
      p <- create_qp_locations_plot(df, "Ahead", pitcher_hand, batter_hand)
      
      girafe_transparent(
        ggobj = p,
        width_svg = 12, height_svg = 4,
        options = list(
          ggiraph::opts_hover_inv(css = "opacity:0.1;"),
          ggiraph::opts_hover(css = "stroke-width:2;"),
          ggiraph::opts_tooltip(use_fill = TRUE, use_stroke = TRUE, css = tooltip_css,
                                opacity = 0.9
          )
        )
      )
    }, error = function(e) {
      message("Error in qpLocationsAhead: ", e$message)
      return(NULL)
    })
  })
  
  # QP Locations Pitch Type Color Legend
  output$qpPitchTypeColors <- renderUI({
    tryCatch({
      if (!should_show_qp_locations()) {
        return(div(style = "font-size: 12px; color: #999;", "Select data to see pitch types"))
      }
      
      df <- filtered_data()
      if (!nrow(df)) {
        return(div(style = "font-size: 12px; color: #999;", "No data available"))
      }
      
      # Get unique pitch types in the current data
      pitch_types <- sort(unique(df$TaggedPitchType))
      pitch_types <- pitch_types[!is.na(pitch_types)]
      
      if (length(pitch_types) == 0) {
        return(div(style = "font-size: 12px; color: #999;", "No pitch types found"))
      }
      
      # Create legend entries for each pitch type with its color
      legend_items <- lapply(pitch_types, function(pt) {
        color <- all_colors[[as.character(pt)]]
        if (is.null(color)) color <- "gray"
        
        div(style = "margin-bottom: 5px;",
            span(style = paste0("display: inline-block; width: 12px; height: 12px; background-color: ", color, "; border-radius: 50%; margin-right: 8px;")),
            pt
        )
      })
      
      div(style = "font-size: 12px;", legend_items)
      
    }, error = function(e) {
      div(style = "font-size: 12px; color: #999;", "Error loading pitch types")
    })
  })
  
  # Custom Reports module
  custom_reports_server("creports")
}
# ---------- Run ----------
shinyApp(ui=ui, server=server)# app.R
# Shiny pitching report with per-player privacy + admin view + customized Stuff+ metric per pitch type
